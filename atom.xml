<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qiuly&#39;s blog!</title>
  
  <subtitle>A weak OIer from HN-YZ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qiulyblog.github.io/"/>
  <updated>2019-05-22T05:17:06.450Z</updated>
  <id>http://qiulyblog.github.io/</id>
  
  <author>
    <name>Qiuly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【题解】 [HNOI2011]卡农  组合数学+DP  luoguP3214</title>
    <link href="http://qiulyblog.github.io/2019/05/22/%5B%E9%A2%98%E8%A7%A3%5DluoguP3214/"/>
    <id>http://qiulyblog.github.io/2019/05/22/[题解]luoguP3214/</id>
    <published>2019-05-21T16:00:00.000Z</published>
    <updated>2019-05-22T05:17:06.450Z</updated>
    
    <content type="html"><![CDATA[<p>什么同种音乐简直是个逗比，最后直接除上 $m!$ 即可。</p><p>现在我们需要算出选出 $m$ 的片段的方案数，考虑 $\rm{DP}$ ，设 $dp_i$ 表示前 $i​$ 个片段已经确定，且满足下列要求：</p><ul><li>这 $i$ 个片段中没有空集</li><li>这 $i$ 个片段互不相同</li><li>这 $i$ 个片段中所有的音符的出现次数全部都要是偶数次</li></ul><a id="more"></a><p>现在考虑如何从 $dp_{i-1}$ 转移到 $dp_i$ 。</p><p>首先看第三个要求，不难发现在知道前 $i-1$ 个片段的情况下，$i$ 的音符集合一定是确定的—— $i$ 的音符集合一定是前 $i-1$ 个片段中出现次数为奇数的音符。也就是说 $i$ 的集合是随着前 $i-1$ 个片段变换的，已知选择前 $i-1$ 个片段的方案数为 $A_{2^n-1}^{i-1}$ ，那么 $i$ 的方案数也自然是 $A_{2^n-1}^{i-1}$  。(注意该统计方案保证前 $i-1$ 个片段互不相同)</p><p>但是 $i$ 可能是空集，那么这个方案就不成立，方案不成立的个数当然是前 $i-1$ 个片段自由搭配<strong>且合法</strong>的情况数，那么自然就是 $dp_{i-1}$ ，为什么要计算和法的呢，因为首先计算了的方案数显然是满足第三个要求的，也就是说我们要去掉的也只能是满足第三个要求的不合法方案数，那么自然就是 $dp_{i-1}$ 个了。</p><p>最后考虑不满足第二种情况的方案数，首先我们令一个片段 $j$ 和 $i$ 一样(在前 $i-1$ 个片段中最多一个和 $i$ 一样)，这个那么这样子我们将这两个片段都去掉的时候全局的方案数就是 $dp_{i-2}$ 了，因为剩下的一定是合法的。显然 $j$ 可以是前 $i-1$ 个片段中的任意一个，并且重复的音乐集的种类数为 $2^n-1-(i-2)$ ，为什么这么说呢，显然 $2^n-1$ 是非空集的音乐集方案数，$i-2$ 就是说剩下的 $i-2$ 个片段不重复，并且 $i,j$ 也不能与之重复，那么可供 $i,j$ 选择的就剩下 $2^n-1-(i-2)$ 个音乐集了。</p><p>也就是说，我们用 $A_{2^n-1}^{i-1}$ 减去这些不合法的方案后剩下的就是 $dp_i$ 了：</p><script type="math/tex; mode=display">dp_i=A_{2^n-1}^{i-1}-dp_{i-1}-(dp_{i-2}\times(i-1)\times(2^n-1-(i-2)))</script><p>最后的答案就是 $dp_m$ 。</p><p>关于初始化的问题，首先 $dp_0=0$ ，那么选一个片段呢可以吗？其实不行，因为音符没有重复偶数次，所以一定是全都不合法的，又不允许空集的存在，也就是说 $dp_1=0$ 。用上面的式子从 $dp_2$ 推起即可。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 100000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll dp[N],A[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow</span><span class="params">(ll x,ll y,ll res=<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%p) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x%p;</span><br><span class="line">    <span class="keyword">return</span> res%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    ll mul=<span class="built_in">pow</span>(<span class="number">2</span>,n)<span class="number">-1</span>;mul=(mul%p+p)%p;</span><br><span class="line">    A[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        A[i]=<span class="number">1l</span>l*A[i<span class="number">-1</span>]*(mul-i+<span class="number">1</span>)%p;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>,dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        dp[i]=A[i<span class="number">-1</span>]%p;</span><br><span class="line">        dp[i]=(dp[i]-dp[i<span class="number">-1</span>]+p)%p;</span><br><span class="line">        dp[i]=(dp[i]<span class="number">-1l</span>l*dp[i<span class="number">-2</span>]*(i<span class="number">-1</span>)%p*(mul-(i<span class="number">-2</span>))%p+p)%p;</span><br><span class="line">        dp[i]=(dp[i]%p+p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    ll fac=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;++i) fac=<span class="number">1l</span>l*fac*i%p;</span><br><span class="line">    ll inv=<span class="built_in">pow</span>(fac,p<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[m]*inv%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么同种音乐简直是个逗比，最后直接除上 $m!$ 即可。&lt;/p&gt;
&lt;p&gt;现在我们需要算出选出 $m$ 的片段的方案数，考虑 $\rm{DP}$ ，设 $dp_i$ 表示前 $i​$ 个片段已经确定，且满足下列要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这 $i$ 个片段中没有空集&lt;/li&gt;
&lt;li&gt;这 $i$ 个片段互不相同&lt;/li&gt;
&lt;li&gt;这 $i$ 个片段中所有的音符的出现次数全部都要是偶数次&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 Lunar New Year and Red Envelopes  DP  luoguCF1106E</title>
    <link href="http://qiulyblog.github.io/2019/05/22/%5B%E9%A2%98%E8%A7%A3%5DluoguCF1106E/"/>
    <id>http://qiulyblog.github.io/2019/05/22/[题解]luoguCF1106E/</id>
    <published>2019-05-21T16:00:00.000Z</published>
    <updated>2019-05-22T05:35:51.097Z</updated>
    
    <content type="html"><![CDATA[<p>很简单的可以想到，设 $f_{i,j}$ 表示到第 $i$ 时刻已经干扰了 $j$ 次时的最少拿到钱数。然后每一次转移的时候只要看第 $i$ 时刻是否干扰即可，然后如果不干扰的话就算一下这一时刻拿到的红包的钱。</p><p>对于第 $i$ 时刻拿到的红包的钱数我们需要预处理，开一个优先队列，按照题意重载运算符，然后按照时刻走一遍即可。</p><a id="more"></a><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2e2</span>+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">ll f[N][M];</span><br><span class="line"><span class="keyword">int</span> n,m,k,nxt[N],val[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,t,d,w,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> w==b.w?b.d&gt;d:b.w&gt;w;&#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x,Node y)</span> </span>&#123;<span class="keyword">return</span> x.s&lt;y.s;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(m),IN(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">        IN(a[i].s),IN(a[i].t),IN(a[i].d),IN(a[i].w),a[i].id=i;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+k,cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;=k&amp;&amp;a[cnt].s&lt;=i) q.push(a[cnt++]);</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) nxt[i]=i+<span class="number">1</span>,val[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node now=q.top();</span><br><span class="line">            <span class="keyword">if</span>(now.t&lt;i) &#123;--i,q.pop();<span class="keyword">continue</span>;&#125;</span><br><span class="line">            nxt[i]=now.d+<span class="number">1</span>,val[i]=now.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">127</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;++j)</span><br><span class="line">        f[i+<span class="number">1</span>][j+<span class="number">1</span>]=min(f[i+<span class="number">1</span>][j+<span class="number">1</span>],f[i][j]),</span><br><span class="line">        f[nxt[i]][j]=min(f[nxt[i]][j],f[i][j]+val[i]);</span><br><span class="line">    ll ans=<span class="number">1e18</span>+<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) ans=min(ans,f[n+<span class="number">1</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很简单的可以想到，设 $f_{i,j}$ 表示到第 $i$ 时刻已经干扰了 $j$ 次时的最少拿到钱数。然后每一次转移的时候只要看第 $i$ 时刻是否干扰即可，然后如果不干扰的话就算一下这一时刻拿到的红包的钱。&lt;/p&gt;
&lt;p&gt;对于第 $i$ 时刻拿到的红包的钱数我们需要预处理，开一个优先队列，按照题意重载运算符，然后按照时刻走一遍即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【数论】 扩展中国剩余定理</title>
    <link href="http://qiulyblog.github.io/2019/05/17/%5B%E6%95%B0%E8%AE%BA%5D%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    <id>http://qiulyblog.github.io/2019/05/17/[数论]扩展中国剩余定理/</id>
    <published>2019-05-16T16:00:00.000Z</published>
    <updated>2019-05-17T12:16:01.688Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="在此输入你的密码以便阅读全文" />    <label for="pass">在此输入你的密码以便阅读全文</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本文为加密文章，阅读本文需要输入密码。
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="数论" scheme="http://qiulyblog.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="中国剩余定理" scheme="http://qiulyblog.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
      <category term="扩展中国剩余定理" scheme="http://qiulyblog.github.io/tags/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SDOI2010]古代猪文  组合数学  luoguP2480</title>
    <link href="http://qiulyblog.github.io/2019/05/17/%5B%E9%A2%98%E8%A7%A3%5DluoguP2480/"/>
    <id>http://qiulyblog.github.io/2019/05/17/[题解]luoguP2480/</id>
    <published>2019-05-16T16:00:00.000Z</published>
    <updated>2019-05-17T02:15:44.949Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门：<a href="https://www.luogu.org/problemnew/show/P2480" target="_blank" rel="noopener">传送门戳我</a></p><p>很显然题目需要我们求出 $G^{\sum_{d|n}C_n^d} \ mod\ P$ ( $P=999911659$ ) 。我们知道费马小定理有一个推论：$a^{x}\equiv a^{x \ mod\ (P-1)} \ (mod \ P)$ (需要满足 $P$ 是质数) ，题目中的 $P$ 正好是质数，那么我们可以将上式变换一下：</p><script type="math/tex; mode=display">G^{\sum_{d|n}C_n^d} \ mod\ P=G^{\sum_{d|n}C_n^d \ mod\ (P-1)} \ mod\ P​</script><a id="more"></a><p>现在我们需要快速求出 $\sum_{d|n}C_n^d \ mod\ (P-1)$ ，看样子可以 $lucas$ 直接求组合数，但是模数太大了不方便。分解质因数后发现 $999911658=2\times 3\times 4679\times 35617$ ，对四个模数求出其对应的答案，然后因为四个模数互质，最后 $crt$ 合并答案即可。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 999911658</span></span><br><span class="line"></span><br><span class="line">ll n,g,fac[<span class="number">35617</span>+<span class="number">7</span>];</span><br><span class="line">ll m[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4679</span>,<span class="number">35617</span>&#125;,a[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> math &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">pow</span><span class="params">(ll x,ll y,ll p)</span> </span>&#123;</span><br><span class="line">        ll res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%p) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1l</span>l*res*x%p; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n,ll m,ll p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ((fac[n]*<span class="built_in">pow</span>(fac[m],p<span class="number">-2</span>,p))%p*<span class="built_in">pow</span>(fac[n-m],p<span class="number">-2</span>,p)%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">lucas</span><span class="params">(ll n,ll m,ll p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> C(n%p,m%p,p)*lucas(n/p,m/p,p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll&amp;x,ll&amp;y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b) &#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">        ll gcd=exgcd(b,a%b,x,y),tmp=x;</span><br><span class="line">        x=y,y=tmp-(a/b)*y;<span class="keyword">return</span> gcd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">CRT</span><span class="params">(ll*m,ll*a,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ll res=<span class="number">0</span>,lcm=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i) lcm=lcm*m[i];</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            ll num=lcm/m[i],x,y,gcd=exgcd(num,m[i],x,y);</span><br><span class="line">            x=(x%m[i]+m[i])%m[i];</span><br><span class="line">            res=(res+a[i]*x*num)%lcm;</span><br><span class="line">        &#125;<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> math;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;g);</span><br><span class="line">    <span class="keyword">if</span>(!(g%(mod+<span class="number">1</span>))) &#123;<span class="built_in">puts</span>(<span class="string">"0"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">35617</span>;++i) fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;++k) &#123;</span><br><span class="line">        ll p=m[k],res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i*i&lt;=n;++i) <span class="keyword">if</span>(!(n%i)) &#123;</span><br><span class="line">            ll x=i,y=n/i;<span class="keyword">if</span>(x==y) y=<span class="number">0</span>;</span><br><span class="line">            res=(res+lucas(n,x,p)%p)%p;</span><br><span class="line">            <span class="keyword">if</span>(y) res=(res+lucas(n,y,p)%p)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        a[k]=res;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=CRT(m,a,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="built_in">pow</span>(g,ans,mod+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目传送门：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2480&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门戳我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很显然题目需要我们求出 $G^{\sum_{d|n}C_n^d} \ mod\ P$ ( $P=999911659$ ) 。我们知道费马小定理有一个推论：$a^{x}\equiv a^{x \ mod\ (P-1)} \ (mod \ P)$ (需要满足 $P$ 是质数) ，题目中的 $P$ 正好是质数，那么我们可以将上式变换一下：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;G^{\sum_{d|n}C_n^d} \ mod\ P=G^{\sum_{d|n}C_n^d \ mod\ (P-1)} \ mod\ P​&lt;/script&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="中国剩余定理" scheme="http://qiulyblog.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SDOI2009]学校食堂 状压DP luoguP2157</title>
    <link href="http://qiulyblog.github.io/2019/05/17/%5B%E9%A2%98%E8%A7%A3%5DluoguP2157/"/>
    <id>http://qiulyblog.github.io/2019/05/17/[题解]luoguP2157/</id>
    <published>2019-05-16T16:00:00.000Z</published>
    <updated>2019-05-17T02:03:04.397Z</updated>
    
    <content type="html"><![CDATA[<p>观察发现 $\texttt{B}​$ 及其的小，可以想到对于第 $i​$ 个人，状压自己以及自己后面 $7​$ 个人的打饭状态即可。</p><p>设 $dp_{i,j}$ 表示打饭到第 $i$ 个人，第 $i$ 个人以及其后面 $7$ 人的打饭状态为 $j$ 的时候的最短时间。转移的时候看在当前状态 $j$ 下有那些人没有打饭，然后给其打饭转移即可(显然还有忍耐度的限制)。</p><a id="more"></a><p>但是经过打饭操作我们无法得出这道菜的时间——因为我们不清楚上一个打饭的是谁。这个时候再记一维状态即可。</p><p>设 $dp_{i,j,k}$ 表示( $i,j$ 的意义与上面相同)，上一次打饭的人的编号就是 $i+k$ (注意 $k$ 的取值为 $-8$ 至 $7$ ，所以实际实现中我们需要将 $k$ 加上 $8$ 后再记入数组) 。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,t[N],b[N],dp[N][M+<span class="number">2</span>][<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmin</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x=min(x,y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmax</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x=max(x,y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(t[i]),IN(b[i]);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">127</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">int</span> inf=dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">7</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">-8</span>;k&lt;=<span class="number">7</span>;++k) <span class="keyword">if</span>(dp[i][j][k+<span class="number">8</span>]!=inf) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&amp;<span class="number">1</span>) cmin(dp[i+<span class="number">1</span>][j&gt;&gt;<span class="number">1</span>][k+<span class="number">7</span>],dp[i][j][k+<span class="number">8</span>]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> max_pos=inf;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;=<span class="number">7</span>;++h) <span class="keyword">if</span>(!((j&gt;&gt;h)&amp;<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i+h&gt;max_pos) <span class="keyword">break</span>;</span><br><span class="line">                    cmin(max_pos,i+h+b[i+h]);</span><br><span class="line">                    cmin(dp[i][j|(<span class="number">1</span>&lt;&lt;h)][h+<span class="number">8</span>],dp[i][j][k+<span class="number">8</span>]+(i+k?t[i+h]^t[i+k]:<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">8</span>;++i) cmin(ans,dp[n+<span class="number">1</span>][<span class="number">0</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观察发现 $\texttt{B}​$ 及其的小，可以想到对于第 $i​$ 个人，状压自己以及自己后面 $7​$ 个人的打饭状态即可。&lt;/p&gt;
&lt;p&gt;设 $dp_{i,j}$ 表示打饭到第 $i$ 个人，第 $i$ 个人以及其后面 $7$ 人的打饭状态为 $j$ 的时候的最短时间。转移的时候看在当前状态 $j$ 下有那些人没有打饭，然后给其打饭转移即可(显然还有忍耐度的限制)。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状压DP" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [九省联考2018]林克卡特树  树形DP+wqs二分优化  loj2478</title>
    <link href="http://qiulyblog.github.io/2019/05/12/%5B%E9%A2%98%E8%A7%A3%5Dloj2478/"/>
    <id>http://qiulyblog.github.io/2019/05/12/[题解]loj2478/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-05-12T08:54:08.118Z</updated>
    
    <content type="html"><![CDATA[<p>毒瘤传送门：<a href="https://loj.ac/problem/2478" target="_blank" rel="noopener">戳我戳我</a></p><p>仔细观察会发现该题需要从树上拿出 $k+1$ 条互不相交的链，求这些链的节点的权值总和的最大值。那么我们选出这些链后就可以用 $k$ 条边将其连起来了，这样就满足了题意。</p><a id="more"></a><p>用 $f_{i,j}$ 表示 $i$ 的子树中选出了 $j$ 个链的最大值，但是会发现转移很难办，枚举一个 $i$ 的儿子 $v$ 的时候，我们不好算出 $v$ 对 $i$ 上的链做出的贡献。</p><p>那么我们新增加一个状态，设 $f_{0/1/2,i,j}$ 为我们的状态，$i,j$ 的意思和上面一样，其中 $0/1/2$ 分别表示——<strong>$0$ : $i$ 不属于子树中 $j$ 条链中的任意一条，$1$ : $i$ 属于 $j$ 条链中其中一条，$2$ : $i$ 属于 $j$ 条链中的其中两条</strong> 。</p><p>那么我们枚举一个儿子 $v$ ，现在我们需要转移的对象就是 $u$ (上面的 $i$ ) ，那么我们注意来考虑：</p><p>我们转移的时候枚举一个 $i$ 表示当前的链数，然后枚举 $j$ 表示 $v$ 子树中的链数，那么之前 $u$ 子树中的链数显然就是 $i-j$ 了。</p><p>令 $num_{v,j}=\max(f_{0,v,j},f_{1,v,j},f_{2,v,j})$ .</p><ul><li><p>计算 $v$ 对 $f_{0,u,i}$ 的贡献</p><ul><li><p>因为该状态必须满足 $u$ 不能属于任意一条链，所有我们理所当然也不能连上 $u\rightarrow v$ 这条边。那么也就是说 $v$ 中发生什么事情都跟 $u$ 没有任何关系了，因为要统计最大，我们直接将 $num$ 统计进去即可。</p></li><li><p>转移：</p><script type="math/tex; mode=display">f_{0,u,i}=\max_v\max_j \{f_{0,u,i-j}+num_{v,j}\}</script></li></ul></li><li><p>计算 $v$ 对 $f_{1,u,i}$ 的贡献</p><ul><li><p>考虑两种情况，第一种，这一条和 $u$ 有关的链是连着别的子树的，那么也就肯定不会连上 $u\rightarrow v$ 这条边，按照上面的转移即可。</p></li><li><p>第一种转移：</p><script type="math/tex; mode=display">f_{1,u,i}=\max_v\max_j \{f_{1,u,i-j}+num_{v,j}\}​</script></li><li><p>第二种情况就是这一条链是和 $v$ 相连接的，那么这个时候 $v$ 的状态只能是 $0,1$ ，原因很显然，链不能香蕉(最好吃了🍌) ，那么对于 $v$ 状态是 $0$ 的情况，这样一连接后就会新出现一条链了，记得算上边权：</p></li><li><p>转移 $0$ 情况：</p><script type="math/tex; mode=display">f_{1,u,i}=\max_v\max_j\{f_{0,u,i-j}+f_{0,v,j-1}+w\}​</script><p>$f_{0,u,i-j}$ 不解释，$f_{0,v,j-1}$ 这里为什么要 $j-1$ 呢？因为很显然当前局面只有 $i-1$ 条链，上面讲了连接后会多出来一条，那么 $i-1+1$ 就正好用来转移 $i$ 了。最后的 $w$ 即为当前转移带来的贡献。</p></li><li><p>$v$ 的状态是 $1$ 的时候和上面差不多，但是因为连接 $u,v$ 后 $u$ 属于了原来就存在的一条链，也就是说没有新增链，那么就没必要 $j-1$ 了。</p></li><li><p>转移 $1$ 的情况：</p><script type="math/tex; mode=display">f_{1,u,i}=\max_v\max_j\{f_{0,u,i-1}+f_{1,v,j}+w\}</script></li></ul></li><li><p>计算 $v$ 对 $f_{2,u,i}$ 的贡献</p><ul><li><p>首先如果这两条链连接别的子树了，那么 $v$ 就没有限制了，转移同上：</p></li><li><p>转移：</p><script type="math/tex; mode=display">f_{2,u,i}=\max_v\max_j \{f_{2,u,i-j}+num_{v,j}\}</script></li><li><p>接下来的就很好办了，因为连接 $u,v$ 最多是一条链，也就是说我们不可能将两条链都放到 $v$ 下来。先考虑 $v$ 状态为 $0$ 的情况，因为连接后 $v$ 属于了 $u$ 原来所在的链(没有新增链)，那么直接算贡献：</p></li><li><p>转移：</p><script type="math/tex; mode=display">f_{2,u,i}=\max_v\max_j\{f_{1,u,i-j}+f_{0,v,j}+w\}</script></li><li><p>然后考虑 $v$ 状态为 $1$ 的情况，这个时候连接 $u,v$ 会使得 $v$ 原来所在的链和 $u$ 原来所在的链合并为一条链，那么这里的和上面的 $j-1$ 不同，这里因为是少了一条链所有要变成 $j+1$ 。</p></li><li><p>转移：</p><script type="math/tex; mode=display">f_{2,u,i}=\max_v\max_j\{f_{1,u,i-j}+f_{1,v,j+1}+w\}</script></li></ul></li></ul><p>所有的转移式都得到了，我们来考虑初始化，首先因为是取最大值，我们需要全部初始化为一个很小的负数。然后对于 $f_{0,u,0}$ 这样的状态的值很显然是 $0$ 。</p><p>其他的没了，注意这样的 $\rm{DP}$ 复杂度只能让我们最多拿到 $60$ 分。</p><h3 id="Code-60-pts-："><a href="#Code-60-pts-：" class="headerlink" title="Code (60 $pts$ ) ："></a>Code (60 $pts$ ) ：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,sz[N],head[N],cnt;</span><br><span class="line">ll dp[<span class="number">3</span>][N][<span class="number">110</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to,val;&#125; G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[v],u,w&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][u][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">/*初始化*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e=head[u];e;e=G[e].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[e].to,w=G[e].val;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u),sz[u]+=sz[v];</span><br><span class="line">        <span class="comment">/*利用sz数组优化，同样是O(nk^2)的代码，其他的只能拿到30</span></span><br><span class="line"><span class="comment">        ~40，但是这个优化过后是妥妥的60分*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=min(sz[u],k);i;--i) &#123;</span><br><span class="line">            <span class="comment">/*计算v下面没有链的情况，计算初始状态带来的贡献*/</span></span><br><span class="line">            dp[<span class="number">2</span>][u][i]=max(dp[<span class="number">2</span>][u][i],dp[<span class="number">1</span>][u][i]+w);</span><br><span class="line">            dp[<span class="number">2</span>][u][i]=max(dp[<span class="number">2</span>][u][i],dp[<span class="number">1</span>][u][i]+dp[<span class="number">1</span>][v][<span class="number">1</span>]+w);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=min(sz[v],i);j;--j) &#123;</span><br><span class="line">                <span class="comment">/*计算出num*/</span></span><br><span class="line">                ll num=max(dp[<span class="number">0</span>][v][j],max(dp[<span class="number">1</span>][v][j],dp[<span class="number">2</span>][v][j]));</span><br><span class="line">                <span class="comment">/*下面的7个式子就是上文讲的转移了*/</span></span><br><span class="line">                dp[<span class="number">0</span>][u][i]=max(dp[<span class="number">0</span>][u][i],dp[<span class="number">0</span>][u][i-j]+num);</span><br><span class="line"></span><br><span class="line">                dp[<span class="number">1</span>][u][i]=max(dp[<span class="number">1</span>][u][i],dp[<span class="number">1</span>][u][i-j]+num);</span><br><span class="line">                dp[<span class="number">1</span>][u][i]=max(dp[<span class="number">1</span>][u][i],dp[<span class="number">0</span>][u][i-j]+dp[<span class="number">1</span>][v][j]+w);</span><br><span class="line">                dp[<span class="number">1</span>][u][i]=max(dp[<span class="number">1</span>][u][i],dp[<span class="number">0</span>][u][i-j]+dp[<span class="number">0</span>][v][j<span class="number">-1</span>]+w);</span><br><span class="line"></span><br><span class="line">                dp[<span class="number">2</span>][u][i]=max(dp[<span class="number">2</span>][u][i],dp[<span class="number">2</span>][u][i-j]+num);</span><br><span class="line">                dp[<span class="number">2</span>][u][i]=max(dp[<span class="number">2</span>][u][i],dp[<span class="number">1</span>][u][i-j]+dp[<span class="number">0</span>][v][j]+w);</span><br><span class="line">                dp[<span class="number">2</span>][u][i]=max(dp[<span class="number">2</span>][u][i],dp[<span class="number">1</span>][u][i-j]+dp[<span class="number">1</span>][v][j+<span class="number">1</span>]+w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*也是一种特殊情况，可以直接放到上面去的(v下没有链)*/</span></span><br><span class="line">            dp[<span class="number">1</span>][u][i]=max(dp[<span class="number">1</span>][u][i],dp[<span class="number">0</span>][u][i<span class="number">-1</span>]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!sz[u]) dp[<span class="number">0</span>][u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    ++sz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,v;IN(x),IN(y),IN(v),add(x,y,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span>(dp));<span class="comment">/*极小值*/</span></span><br><span class="line">    ++k;dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,max(dp[<span class="number">0</span>][<span class="number">1</span>][k],max(dp[<span class="number">1</span>][<span class="number">1</span>][k],dp[<span class="number">2</span>][<span class="number">1</span>][k])));</span><br><span class="line">    <span class="comment">/*输出最优👆*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>如果打出了表，你会发现对于单调递增的 $k$ ，关于其的最优解所形成的一定是一个上凸的函数，感性理解的话就是说 $k$ 小的时候我们可以选更多的更大的边，但是随着 $k$ 增大，这些边不够了，我们只能选更小的或者是拆掉一些边(将一条链断成两条增加链数) ，这样子答案就好慢慢变小。</p><p>因为是上凸函数，我们可以使用 $\rm{DP}$ 凸优化，带权二分/$wqs$二分套路优化一下就可以过了。</p><p>注意二分边界！还有就是需要注意一个点也可以成为一条链的情况！</p><h3 id="Code-100-pts"><a href="#Code-100-pts" class="headerlink" title="Code (100 $pts$ )"></a>Code (100 $pts$ )</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e18</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> &#123;</span></span><br><span class="line">    ll x;<span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> date&amp;var) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x==var.x?y&gt;var.y:x&lt;var.x;&#125;</span><br><span class="line">    date <span class="keyword">operator</span> + (<span class="keyword">const</span> date&amp;var) &#123;<span class="keyword">return</span> (date)&#123;x+var.x,y+var.y&#125;;&#125;</span><br><span class="line">    date <span class="keyword">operator</span> + (<span class="keyword">const</span> ll&amp;var) &#123;<span class="keyword">return</span> (date)&#123;x+var,y&#125;;&#125;</span><br><span class="line">&#125;dp[<span class="number">3</span>][N];</span><br><span class="line"><span class="function">ll <span class="title">number</span><span class="params">(date var)</span> </span>&#123;<span class="keyword">return</span> var.x;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to,val;&#125; G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[v],u,w&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(ll add,<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][u]=(date)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    dp[<span class="number">1</span>][u]=(date)&#123;-inf,<span class="number">0</span>&#125;,</span><br><span class="line">    dp[<span class="number">2</span>][u]=(date)&#123;add,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e=head[u];e;e=G[e].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[e].to;</span><br><span class="line">        ll w=G[e].val;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        check(add,v,u);</span><br><span class="line">        date num=max(dp[<span class="number">0</span>][v],max(dp[<span class="number">1</span>][v],dp[<span class="number">2</span>][v]));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">2</span>][u]=max(dp[<span class="number">2</span>][u],dp[<span class="number">2</span>][u]+num);</span><br><span class="line">        dp[<span class="number">2</span>][u]=max(dp[<span class="number">2</span>][u],dp[<span class="number">1</span>][u]+(date)&#123;w,<span class="number">0</span>&#125;+max(dp[<span class="number">0</span>][v],dp[<span class="number">1</span>][v]+(date)&#123;-add,<span class="number">-1</span>&#125;));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>][u]=max(dp[<span class="number">1</span>][u],dp[<span class="number">1</span>][u]+num);</span><br><span class="line">        dp[<span class="number">1</span>][u]=max(dp[<span class="number">1</span>][u],dp[<span class="number">0</span>][u]+(date)&#123;w,<span class="number">0</span>&#125;+max(dp[<span class="number">1</span>][v],dp[<span class="number">0</span>][v]+(date)&#123;add,<span class="number">1</span>&#125;));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][u]=dp[<span class="number">0</span>][u]+num;</span><br><span class="line">    &#125;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">wqs</span><span class="params">(ll sum)</span> </span>&#123;</span><br><span class="line">    ll l=-sum,r=sum,mid;</span><br><span class="line">    date now;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,check(mid,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        now=max(dp[<span class="number">0</span>][<span class="number">1</span>],max(dp[<span class="number">1</span>][<span class="number">1</span>],dp[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">if</span>(!(now.y^k)) &#123;l=r=mid;<span class="keyword">break</span>;&#125;</span><br><span class="line">        now.y&lt;k?l=mid:r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mid=l;check(mid,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    now=max(dp[<span class="number">0</span>][<span class="number">1</span>],max(dp[<span class="number">1</span>][<span class="number">1</span>],dp[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> now.x-mid*k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("lct2.in","r",stdin);</span></span><br><span class="line">    <span class="comment">// freopen("P4383.out","w",stdout);</span></span><br><span class="line">    IN(n),IN(k);++k;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,v;IN(x),IN(y),IN(v);</span><br><span class="line">        add(x,y,v),sum+=<span class="built_in">abs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,wqs(sum));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毒瘤传送门：&lt;a href=&quot;https://loj.ac/problem/2478&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳我戳我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仔细观察会发现该题需要从树上拿出 $k+1$ 条互不相交的链，求这些链的节点的权值总和的最大值。那么我们选出这些链后就可以用 $k$ 条边将其连起来了，这样就满足了题意。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="树形DP" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="wqs二分/带权二分" scheme="http://qiulyblog.github.io/tags/wqs%E4%BA%8C%E5%88%86-%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [ZJOI2010]基站选址  线段树优化DP  luoguP2065</title>
    <link href="http://qiulyblog.github.io/2019/05/09/%5B%E9%A2%98%E8%A7%A3%5DluoguP2605/"/>
    <id>http://qiulyblog.github.io/2019/05/09/[题解]luoguP2605/</id>
    <published>2019-05-08T16:00:00.000Z</published>
    <updated>2019-05-09T14:43:08.149Z</updated>
    
    <content type="html"><![CDATA[<p>这题居然只有 $luogu$ 有……无法水多倍经验了（逃。</p><p>朴素的 $\rm{DP}$ 很简单，设 $f_{i,j}$ 表示前 $i$ 个村庄建了 $j$ 个基站的花费最小值，注意因为是<strong>前 $i$ 个</strong>，所有完全无视掉后面的所有村庄了。转移的话直接枚举一个 $k$ ，从 $f_{k,j-1}$ 转移过来即可，加上的代价就是中间村庄产生的补偿费用。</p><a id="more"></a><p>那么这样的复杂度就是 $O(n^2k)$ [<del>爆炸</del>] ，我们需要做到的就是如何快速计算中间村庄的补偿，那么外围的 $\rm{DP}$ 复杂度其实是 $O(nk)$ 的，如果中间的补偿可以快速算出那么就可以过掉了。</p><p>我们对于每一个村庄 $i$ ，用二分计算出最左边可以覆盖到其的村庄 $st_i$ 和最右边可以覆盖到其的村庄 $ed_i$ ，那么我们从 $i$ 到 $i+1$ 的时候，所有 $ed$ 值为 $i$ 的点都将失去右边的依靠，这个时候对于 $i+1$ 的最优转移点 $k$ ，有对于一个失去”右边依靠”的村庄 $j$ ，如果 $k$ 的范围在 $[1,st_j-1]$ 之间的话那么就要给 $j$ 补偿了。</p><p>于是我们考虑用线段树优化，对于这样一个村庄 $j$ ，我们在 $[1,st_j-1]$ 区间集体加上 $w_j$ ，表示决策点如果落在那个区间就要多付出 $w_j$ 的费用。</p><p>线段树的每个位置维护的就是 $f_k+$ $i$ 和 $k$ 中间村庄的补偿费用，因为我们每一次的答案就是整个区间的 $\min$ 值了，只是随着 $i$ 的变化线段树维护的值也应当做出变化，所以就会向上面那样更新。</p><p>不过有个问题，有个情况没有考虑道：第 $n$ 个村庄不建基站的情况，对于一个小于 $n$ 的 $i$ ，$f_i$ 管不了 $n$ ，那么 $f_n$ 也仅仅表示 $n$ 建站的情况。</p><p>所以我们需要在 $n+1$ 的位置上建一个辅助基站，当然 $c_{n+1}=0$ ，这样子就很好计算 <q>第 $n$ 个村庄不建站时全局的花费了</q> 。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">1e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span>&#123;</span><span class="keyword">int</span> nxt,to;&#125; G[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;G[++cnt]=(link)&#123;head[u],v&#125;;head[u]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,d[N],c[N],s[N],w[N],f[N],st[N],ed[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segment_Tree &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) ((x)&lt;&lt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) ((x)&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">int</span> val[N&lt;&lt;<span class="number">2</span>],tag[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        val[ls(x)]+=tag[x],tag[ls(x)]+=tag[x];</span><br><span class="line">        val[rs(x)]+=tag[x],tag[rs(x)]+=tag[x];</span><br><span class="line">        tag[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        tag[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r) &#123;val[x]=f[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">        build(ls(x),l,mid),build(rs(x),mid+<span class="number">1</span>,r);</span><br><span class="line">        val[x]=min(val[ls(x)],val[rs(x)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==l&amp;&amp;r==R) &#123;val[x]+=v,tag[x]+=v;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(tag[x]) pushdown(x,l,r);</span><br><span class="line">        <span class="keyword">if</span>(R&lt;=mid) change(ls(x),l,mid,L,R,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) change(rs(x),mid+<span class="number">1</span>,r,L,R,v);</span><br><span class="line">        <span class="keyword">else</span> change(ls(x),l,mid,L,mid,v),change(rs(x),mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,R,v);</span><br><span class="line">        val[x]=min(val[ls(x)],val[rs(x)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==l&amp;&amp;r==R) <span class="keyword">return</span> val[x];</span><br><span class="line">        <span class="keyword">if</span>(tag[x]) pushdown(x,l,r);</span><br><span class="line">        <span class="keyword">if</span>(R&lt;=mid) <span class="keyword">return</span> query(ls(x),l,mid,L,R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) <span class="keyword">return</span> query(rs(x),mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min(query(ls(x),l,mid,L,mid),query(rs(x),mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,R));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Segment_Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) IN(d[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(s[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(w[i]);</span><br><span class="line">    ++n;w[n]=d[n]=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        st[i]=lower_bound(d+<span class="number">1</span>,d+<span class="number">1</span>+n,d[i]-s[i])-d;</span><br><span class="line">        ed[i]=lower_bound(d+<span class="number">1</span>,d+<span class="number">1</span>+n,d[i]+s[i])-d;</span><br><span class="line">        <span class="keyword">if</span>(d[ed[i]]&gt;d[i]+s[i]) ed[i]--;add(ed[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) &#123;</span><br><span class="line">                f[j]=res+c[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> e=head[j];e;e=G[e].nxt)</span><br><span class="line">                    res+=w[G[e].to];</span><br><span class="line">            &#125;ans=f[n];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) &#123;</span><br><span class="line">                f[j]=(j&gt;i<span class="number">-1</span>?query(<span class="number">1</span>,<span class="number">1</span>,n,i<span class="number">-1</span>,j<span class="number">-1</span>):<span class="number">0</span>)+c[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> e=head[j],v;e;e=G[e].nxt)</span><br><span class="line">                    <span class="keyword">if</span>(st[v=G[e].to]&gt;<span class="number">1</span>) change(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,st[v]<span class="number">-1</span>,w[v]); </span><br><span class="line">            &#125;ans=min(ans,f[n]);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这题居然只有 $luogu$ 有……无法水多倍经验了（逃。&lt;/p&gt;
&lt;p&gt;朴素的 $\rm{DP}$ 很简单，设 $f_{i,j}$ 表示前 $i$ 个村庄建了 $j$ 个基站的花费最小值，注意因为是&lt;strong&gt;前 $i$ 个&lt;/strong&gt;，所有完全无视掉后面的所有村庄了。转移的话直接枚举一个 $k$ ，从 $f_{k,j-1}$ 转移过来即可，加上的代价就是中间村庄产生的补偿费用。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="线段树" scheme="http://qiulyblog.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 最长上升子序列  状压DP  bzoj3591</title>
    <link href="http://qiulyblog.github.io/2019/05/08/%5B%E9%A2%98%E8%A7%A3%5Dbzoj3591/"/>
    <id>http://qiulyblog.github.io/2019/05/08/[题解]bzoj3591/</id>
    <published>2019-05-07T16:00:00.000Z</published>
    <updated>2019-05-08T08:09:02.467Z</updated>
    
    <content type="html"><![CDATA[<p>这题脑洞很大——你需要状压 $\rm{LTS}$ 数组，而且是三进制状压。复杂度很高……大约是 $O(n3^n)$ 左右，当然实际复杂度会小于这个，$1000^+ms$ 是可以通过的。</p><p>对于每一个数字，分别记录其三种状态：该数字没有进过 $\rm{LTS}$ 数组记为 $0$ ，该数字在 $\rm{LTS}$ 数组中记为 $1$ ，该数字进过 $\rm{LTS}$ 数组，结果又出来了记为 $2$ 。</p><a id="more"></a><p>设 $f_i$ 表示 $1$ 到 $n$ 所有数字的状态为 $i$ 时的方案数，接下来考虑转移，首先对于这个 $i$ 状态我们还原其 $\rm{LTS}$ 数组，也就是当前位置上为 $1$ 的那些数字。接着我们枚举所有位置上为 $0$ 的数字，并考虑将其插入当前的 $\rm{LTS}$ 当中。替换掉一个状态为 $1$ 的数。</p><p>我们就选定这个要被替换的状态为 $1$ 的数为当前 $\rm{LTS}$ 中第一个大于当前要加入的数的数，那么这样替换后 $\rm{LTS}$ 依然满足其性质。</p><p>维护一个指针扫一遍就好，碰到需要换的数就将其标记为 $2$ ，然后将当前需要加入的数变成 $1$ 即可。</p><p>需要注意的是，我们这里的”加入”并不是只的在原数组中加入，也就是说跟排列什么的几乎扯不上关系，比如说当前序列为 $1,2,3,4,5$ ，$\rm{LTS}$ 数组为 $1,3,4$ ，我们在这里将 $3$ 丢掉，然后加入 $2$ ，其实是不变的。</p><p>当所有数字都被考虑过的时候就可以直接统计答案了，普通的 $\rm{LTS}$ 也是所有数字都要考虑一回的。</p><p>在做 $\rm{DP}$ 转移的时候我们顺带满足一下题面给出的那些数的递增即可，那么可以保证所有被统计的状态都带有题面要求的 $\rm{LTS}$ 。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,ans,arr[N],pos[N],mul[N];</span><br><span class="line"><span class="keyword">int</span> hep[N],var[N],dp[<span class="number">14348907</span>+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"3591.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"3591.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    IN(n),IN(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) </span><br><span class="line">        IN(arr[i]),--arr[i],pos[arr[i]]=i;</span><br><span class="line">    mul[<span class="number">0</span>]=dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) mul[i]=mul[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mul[n];++i) <span class="keyword">if</span>(dp[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> state=i,top=<span class="number">0</span>,num=<span class="number">0</span>,per=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line">            var[j]=state%<span class="number">3</span>,state/=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(var[j]) ++num;</span><br><span class="line">            <span class="keyword">if</span>(var[j]==<span class="number">1</span>) hep[top++]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num==n) &#123;ans+=dp[i];<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(var[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos[j]&amp;&amp;!var[arr[pos[j]<span class="number">-1</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(hep[per]&lt;j&amp;&amp;per&lt;top) ++per;</span><br><span class="line">            <span class="keyword">if</span>(per&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line">            state=i+mul[j];</span><br><span class="line">            <span class="keyword">if</span>(per&lt;top) state+=mul[hep[per]];</span><br><span class="line">            dp[state]+=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这题脑洞很大——你需要状压 $\rm{LTS}$ 数组，而且是三进制状压。复杂度很高……大约是 $O(n3^n)$ 左右，当然实际复杂度会小于这个，$1000^+ms$ 是可以通过的。&lt;/p&gt;
&lt;p&gt;对于每一个数字，分别记录其三种状态：该数字没有进过 $\rm{LTS}$ 数组记为 $0$ ，该数字在 $\rm{LTS}$ 数组中记为 $1$ ，该数字进过 $\rm{LTS}$ 数组，结果又出来了记为 $2$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状压DP" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>DP进阶必刷题单</title>
    <link href="http://qiulyblog.github.io/2019/05/07/DP%E8%BF%9B%E9%98%B6%E5%BF%85%E5%88%B7%E9%A2%98%E5%8D%95/"/>
    <id>http://qiulyblog.github.io/2019/05/07/DP进阶必刷题单/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-15T02:12:35.886Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="在此输入你的密码以便阅读全文" />    <label for="pass">在此输入你的密码以便阅读全文</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本文为加密文章，阅读本文需要输入密码。
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题单" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2009]双递增序列  线性DP  luoguP4728</title>
    <link href="http://qiulyblog.github.io/2019/05/07/%5B%E9%A2%98%E8%A7%A3%5DluoguP4728/"/>
    <id>http://qiulyblog.github.io/2019/05/07/[题解]luoguP4728/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-07T02:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示<strong>第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立</strong> ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。</p><a id="more"></a><p>考虑设 $dp_{i,j}$ 表示第一个序列的最终位置为 $i-1$ 且长度为 $j$ 时第二个序列的最终位置的最小值。枚举当前数字 $i$ ，然后分两种情况进行转移——将 $a_i$ 放到第一个序列末尾 $\texttt{and}$ 将 $a_i$ 放到第二个序列末尾。</p><p>放到第一个序列末尾很好想：因为当前第一个序列的结尾处就是 $a_{i-1}$ ，比较一下大小直接转移就好了：</p><script type="math/tex; mode=display">dp_{i,j}=min(dp_{i,j},dp_{i-1,j-1}) \ \ \ (a_i>a_{i-1})</script><p>因为第二个序列的末尾没变，所有直接转移就好。</p><p>接下来考虑将第 $i$ 个数放到第二个序列末尾的情况，其实第一个序列和第二个序列没区别，当然除了名字上有一个字的差异，假设第 $i-1$ 个数是第二个序列末尾，当前第一个序列的长度为 $j-1$ ，那么第二个序列的长度因该就是 $(i-1)-(j-1)$ 了，因为我们假设了第 $i-1$ 个数是第二个序列末尾，那么 $dp_{i-1,i-j}$ 又可以被解释为<strong>第二个序列的末尾为 $i-1$ 个数且第二个序列的长度为 $i-j$ 的时候第一个序列的末尾的最小值</strong> ，如果这个最小值小于 $a_i$ ，说明 $a_i$ 可以接到第一个序列前面，那么这个时候第二个序列的末尾为 $a_{i-1}$ ，显然又有转移：</p><script type="math/tex; mode=display">dp_{i,j}=min(dp_{i,j},a_{i-1}) \ \ \ (a_i>dp_{i-1,i-j})</script><p>开始的时候我们将 $dp$ 数组赋成极大值，然后最后判断一下 $dp_{n,n/2}$ 这个状态变小没有就好。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;IN(n);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    a[<span class="number">0</span>]=f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i&amp;&amp;j&lt;=n/<span class="number">2</span>;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i<span class="number">-1</span>]) f[i][j]=min(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;f[i<span class="number">-1</span>][i-j]) f[i][j]=min(f[i][j],a[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> f[n][n/<span class="number">2</span>]&lt;<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">puts</span>(solve()?<span class="string">"Yes!"</span>:<span class="string">"No!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这道题的确很绕……=。=</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示&lt;strong&gt;第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立&lt;/strong&gt; ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HEOI2013]SAO  组合数学+树形DP  luoguP4099</title>
    <link href="http://qiulyblog.github.io/2019/05/06/%5B%E9%A2%98%E8%A7%A3%5DluoguP4099/"/>
    <id>http://qiulyblog.github.io/2019/05/06/[题解]luoguP4099/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-05-06T10:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：<a href="https://www.luogu.org/problemnew/show/P4099" target="_blank" rel="noopener">转送门😄</a> 。</p><p>我们先不考虑边的权值(&lt;与&gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&lt;,&gt;) ，我们分类讨论即可。</p><p>首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢<a id="more"></a>，对于一个 $u$ 的儿子 $v$ ，我们虽然知道 $u$ 和 $v$ 的攻克的前后关系，但是合并答案貌似并不好合并。这个时候我们增加一维 $j$ ，$f_{u,j}$ 表示 $u$ 的子树的所有合法拓扑序中 $u$ 在第 $j$ 位上的总状态数。</p><p>也就是说，对于一个必须在 $u$ 前面攻克的关卡 $v$ ，我们考虑枚举一个 $j$ ，$v$ 子树中 $j$ 个结点在合并 $u,v$ 后放到 $u$ 前面，另外 $sz_v-j$ 个放到 $u$ 后面，然后枚举一个 $k$ ，表示当前的 $v$ 排在 $v$ 子树的拓扑序中的第 $k$ 位，只有 $k\leq j$ 的时候 $v$ 才可以转移 $u$ ，因为这个时候 $v$ 在 $u$ 前面。</p><p>现在再来考虑$“$ $j$ 个结点放在 $u$ 前面 $”$ 的方案数和$“$ $sz_v-j$ 个结点放在 $u$ 后面的方案数$”$，这个显然可以用组合数算，合并 $v$ 的子树后，$u$ 的排名从 $i$ 变成了 $i+j$ ，也就是说我们需要将 $j$ 个乱序插入到 $u$ 前面 $i+j-1$ 个数中，方案数显然为 $C_{i+j-1}^{j}$ ，那么现在总节点数显然为 $sz_u+sz_v$ (现在 $sz_u$ 和 $sz_v$ 还没有并在一起) ，$u$ 后面理所当然有 $sz_u+sz_v-i-j$ 个位置，将 $sz_v-j$ 个数插进去的方案数显然为 $C_{sz_u+sz_v-i-j}^{sz_v-j}$ 个，这两个数再乘上 $f_{u,i}$ 和 $f_{v,k}$ 就好了，这一次合并后 $u$ 的位置显然到了 $i+j$ ，所以 $f_{u,i+j}$ 显然要加上这一组贡献。</p><p>经整理后的转移方程如下：</p><script type="math/tex; mode=display">pls(f_{u,i+j},f_{u,i}\cdot f_{v,k}\cdot C_{i+j-1}^{j}\cdot C_{sz_u+sz_v-i-j}^{sz_v-j})</script><p>代码就是这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span> to sz[u]</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span> to sz[v]</span><br><span class="line">        <span class="keyword">for</span> k=<span class="number">1</span> to j</span><br><span class="line">            pls(f[u][i+j],f[u][i]*f[v][k]*C[i+j<span class="number">-1</span>][j]*C[sz[u]+sz[v]-i-j][sz[v]-j])</span><br></pre></td></tr></table></figure><p>这是 $n^3$ 的，过不去。考虑前缀和优化，几下 $f_v$ 的前缀和，最后的一层循环就可以直接丢掉了。</p><p>这个就是 $v$ 要在 $u$ 前面的情况，$u$ 在 $v$ 前面的情况和这个差不多，不过转移的时候 $j$ 就要从 $0$ 开始了，因为那个时候 $u$ 前面是可以不多放任何东西的，还有就是 $u$ 在 $v$ 前面的时候注意 $k\geq j$ 时才可以转移 !</p><p>最后的答案就是 $\sum\limits_{i=1}^{n} f_{1,i}$ 啦。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to,val;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> C[N][N],f[N][N],pre[N][N],suf[N][N],sz[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[v],u,w^<span class="number">1</span>&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;=mod)x-=mod;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[u]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=head[u];l;l=G[l].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[l].to,w=G[l].val;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u);</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">if</span>(w) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=sz[v];++j)</span><br><span class="line">                    pls(g[i+j],<span class="number">1l</span>l*f[u][i]*pre[v][j]%mod*C[i+j<span class="number">-1</span>][j]%mod</span><br><span class="line">                    *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=sz[v];++j)</span><br><span class="line">                    pls(g[i+j],<span class="number">1l</span>l*f[u][i]*suf[v][j+<span class="number">1</span>]%mod*C[i+j<span class="number">-1</span>][j]%mod</span><br><span class="line">                    *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="built_in">memcpy</span>(f[u],g,<span class="keyword">sizeof</span>(g));</span><br><span class="line">    &#125;</span><br><span class="line">    pre[u][<span class="number">0</span>]=suf[u][sz[u]+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i) pre[u][i]=(pre[u][i<span class="number">-1</span>]+f[u][i])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sz[u];i&gt;=<span class="number">1</span>;--i) suf[u][i]=(suf[u][i+<span class="number">1</span>]+f[u][i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head)),cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> n;IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;<span class="keyword">char</span> sign;</span><br><span class="line">        IN(u),sign=getchar(),IN(v);</span><br><span class="line">        add(u+<span class="number">1</span>,v+<span class="number">1</span>,sign==<span class="string">'&lt;'</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) pls(ans,f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*预处理组合数*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N<span class="number">-2</span>;++i) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N<span class="number">-2</span>;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人会问，如果 $u$ 的儿子 $v$ 下面的边全都是 $&gt;$ ，并且 $u$ 连向 $v$ 的边也是 $&gt;$ ，那么这个时候 $v$ 以及其子树的所有点都必须在 $u$ 前面完成，在转移的时候为什么可以 $“$ 提出 $j$ 个结点放到 $u$ 前面 $”$ 呢？</p><p>其实想想就可以明白，在向上统计答案的时候对于一个 $v$ 的儿子 $a$ ，我们只统计了合并后 $a$ 在 $v$ 前面的情况，同样在 $u$ 统计 $v$ 时也只是统计了合并后 $v$ 在 $u$ 前面的情况，所有我们也只是统计了 $“$ $a$ 在 $v$ 前面且 $v$ 在 $u$ 前面 $”$ 的情况，所有被统计的情况一定是合法的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4099&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转送门😄&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;我们先不考虑边的权值(&amp;lt;与&amp;gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&amp;lt;,&amp;gt;) ，我们分类讨论即可。&lt;/p&gt;
&lt;p&gt;首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="树形DP" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】  [HAOI2018]苹果树  组合数学  loj2526</title>
    <link href="http://qiulyblog.github.io/2019/05/05/%5B%E9%A2%98%E8%A7%A3%5Dloj2526/"/>
    <id>http://qiulyblog.github.io/2019/05/05/[题解]loj2526/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-06T05:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的题目，可爱的传送门：<a href="https://loj.ac/problem/2526" target="_blank" rel="noopener">戳这呢=￣ω￣=</a></p><p>刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。</p><p>我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。</p><a id="more"></a><p>易知节点数为 $n$ 的二叉树的总形态数为 $n!$ ，而且 $i$ 子树下的所有节点的编号一定要大于 $i$ ，我们考虑”先将 $i$ 子树构造出来再填入节点”的过程，子树的形态数显然为 $j!$ ，然后我们只能选剩下的 $n-i$ 个节点(编号要比 $i$ 大) ，填入剩下的 $j-1$ 个位置( $i$ 占了一个位置) ，显然这样的方案数为 $C_{n-i}^{j-1}$ 。</p><p>这样的一个 $i$ ，其子树大小为 $j$ ，那么它可以做出多少贡献呢？考虑 $fa_i \Rightarrow i$ 这条边会经过多少次，显然是 $j\cdot(n-j)$ 次( $j$ 为子树节点个数，$n-j$ 为上面的节点个数) ，也就是说这样的方案可以造成 $j\cdot (n-j)$ 的贡献。</p><p>那么现在 $i$ 的子树得到确定了，我们将 $i$ 以及其子树看做一个点，我们考虑 $1$ 到 $i$ 这些节点，它们可以以任意形态组成一棵树，方案数是 $i!$ 。</p><p>接着我们需要将剩下的 $n-j-(i-1)$ 个节点挂到树上去。对于第 $i$ 个挂到树上的点，它有 $i$ 个位置可以挂。但是因为 $i$ 一定要占一个位置，所以这个节点只有 $i-1$ 个位置可以挂了，第二个多出来的节点就有 $i$ 个位置可以挂……第 $k$ 个显然有 $i-2+k$ 个位置可以挂。也就是说这些点挂上去的总方案数为 $\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 。</p><p>将上面的乘起来就是这一组 $i,j$ 对答案造成的贡献了：</p><script type="math/tex; mode=display">j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)</script><p>$\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 比较不好计算，但是简单的变化后发现这个是和 $(n-j-1)!/(i-2)!$ 等价的，我们带进原式子。</p><script type="math/tex; mode=display">j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot(n-j-1)!/(i-2)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i\cdot (i-1)\cdot(n-j-1)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot i\cdot (i-1)\cdot (n-j)!</script><p>这样就很好算了，我们预处理组合数和阶乘，上面的式子 $O(1)$ 算~</p><p>代码很短。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,ans,fac[N],C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x+=y;x%=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(p);</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;++j)</span><br><span class="line">            pls(ans,(ll)fac[j]*fac[n-j]%p*C[n-i][j<span class="number">-1</span>]%p*(i*(i<span class="number">-1</span>))%p*j%p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有趣的题目，可爱的传送门：&lt;a href=&quot;https://loj.ac/problem/2526&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳这呢=￣ω￣=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。&lt;/p&gt;
&lt;p&gt;我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [六省联考2017]分手是祝愿  概率DP  loj2145</title>
    <link href="http://qiulyblog.github.io/2019/05/05/%5B%E9%A2%98%E8%A7%A3%5Dloj2145/"/>
    <id>http://qiulyblog.github.io/2019/05/05/[题解]loj2145/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-05T02:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>概率神仙题的传送门：<a href="https://loj.ac/problem/2145" target="_blank" rel="noopener"><del>别戳偏了</del></a></p><p>设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程：</p><script type="math/tex; mode=display">f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})</script><p>因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。</p><a id="more"></a><script type="math/tex; mode=display">f_i=\frac{i}{n}+1\cdot (1+f_i+f_{i+1})-\frac{i}{n}\cdot (1+f_i+f_{i+1})\\\\f_i=\frac{i}{n}+1+f_i+f_{i+1}-\frac{i}{n}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\f_i=1+f_i+f_{i+1}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\\frac{i}{n}f_i=1+f_{i+1}-\frac{i}{n}f_{i+1}\\\\f_i=\frac{1+f_{i+1}-\frac{i}{n}f_{i+1}}{\frac{i}{n}}\\\\f_i=\frac{n\cdot(1+f_{i+1})-i\cdot f_{i+1}}{i}\\\\f_i=\frac{n+(n-i)\cdot f_{i+1}}{i}\\\\f_i=1+\frac{(n-i)\cdot (f_{i+1}+1)}{i}</script><p>预处理逆元就可以直接计算了，记得最后乘上 $n!$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,step,a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,f[N],inv[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    inv[<span class="number">0</span>]=<span class="number">0</span>,inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) inv[i]=(<span class="keyword">long</span> <span class="keyword">long</span>)(p-p/i)*inv[p%i]%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i) g[j].push_back(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) <span class="keyword">if</span>(a[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[i].size();++j) a[g[i][j]]^=<span class="number">1</span>;</span><br><span class="line">        ++step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(step&lt;=k) ans=step;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">1</span>;--i) f[i]=(<span class="number">1l</span>l+(<span class="number">1l</span>l*n-i)*(f[i+<span class="number">1</span>]+<span class="number">1</span>)*inv[i])%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&gt;k;--i) ans=(ans+f[i])%p;</span><br><span class="line">        ans=(ans+k)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans=(<span class="number">1l</span>l*i*ans)%p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;概率神仙题的传送门：&lt;a href=&quot;https://loj.ac/problem/2145&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;del&gt;别戳偏了&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})&lt;/script&gt;&lt;p&gt;因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SCOI2014]方伯伯的玉米田  树状数组优化DP  luoguP3287</title>
    <link href="http://qiulyblog.github.io/2019/05/04/%5B%E9%A2%98%E8%A7%A3%5DluoguP3287/"/>
    <id>http://qiulyblog.github.io/2019/05/04/[题解]luoguP3287/</id>
    <published>2019-05-03T16:00:00.000Z</published>
    <updated>2019-05-05T02:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>以后不要被这种傻逼题给蒙骗了。传送门：<a href="https://www.luogu.org/problemnew/show/P3287" target="_blank" rel="noopener">方伯伯的传送门=。=</a></p><p>首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。</p><p>设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程：</p><a id="more"></a><script type="math/tex; mode=display">f_{i,j}=\max\{f_{k,l}+1\} \ \ (k<i,l\leq j,h_i+j\geq h_k+l)</script><p>可能有人会问为什么 $l\leq j$ ，很显然就是上面的道理，越大的 $i$ 一定拔高次数是单调不减的。</p><p>发现上面的转移其实是 $O(n^2k^2)$ 的，万恶的出题人不会给这个复杂度一丁点分……这个时候用树状数组优化转移，发现上面有三个限制条件，我们正着枚举 $i$ ，就已经满足第一个条件了，因为这个时候树状数组中的都是小于 $i$ 的 $k$ 。然后将每个点按照 $(j+1,h_i+j)$ 放到平面上，然后树状数组统计答案即可。</p><p>树状数组维护的是 $\max$  ，不是和。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],n,k,mx;</span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line">    <span class="keyword">int</span> c[N][<span class="number">5009</span>+K];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">const</span> <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;=mx+k;x+=(x&amp;-x))<span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&lt;=k+<span class="number">1</span>;i+=(i&amp;-i))</span><br><span class="line">                c[x][i]=max(c[x][i],v); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x;x-=(x&amp;-x))<span class="keyword">for</span>(<span class="keyword">int</span> i=y;i;i-=(i&amp;-i))</span><br><span class="line">                ans=max(ans,c[x][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> BIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),mx=max(mx,a[i]);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k;~j;--j) &#123;</span><br><span class="line">            <span class="keyword">int</span> res=query(a[i]+j,j+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            ans=max(ans,res),update(a[i]+j,j+<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以后不要被这种傻逼题给蒙骗了。传送门：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3287&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;方伯伯的传送门=。=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。&lt;/p&gt;
&lt;p&gt;设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="树状数组" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="二维树状数组" scheme="http://qiulyblog.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SHOI2014]概率充电器  概率DP  loj2192</title>
    <link href="http://qiulyblog.github.io/2019/05/02/%5B%E9%A2%98%E8%A7%A3%5Dloj2192/"/>
    <id>http://qiulyblog.github.io/2019/05/02/[题解]loj2192/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-05T02:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>传送门在这：<a href="https://loj.ac/problem/2192" target="_blank" rel="noopener">我是传送门$QwQ$</a></p><p>其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。</p><p>因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。</p><a id="more"></a><p>枚举每一个儿子，对于这个儿子只有两种情况：该儿子没有通上电，该儿子通上电了且传送失败。两种情况的概率都很好算。我们可以列出转移方程：</p><script type="math/tex; mode=display">f_u=(1-q_u)\cdot \prod (f_v+(1-f_v)\cdot(1-G_i.p))</script><p>其中 $(1-q_u)$ 显然为该点本身不通电的概率，然后枚举儿子 $v$ ，$f_v$ 就是该儿子本来就没有通上电的概率，$(1-f_v)\cdot(1-G_i.p)$ 就是通上电的传送失败(注：$G_i.p$ 是当前连接 $u,v$ 的边的通电概率) 。</p><p>那么如何计算父亲传来的电呢？设 $g_i$ 表示点 $i$ 的父亲没有向点 $i$ 通电的概率。计算一下父节点不通电的概率，注意不要计算上该儿子的贡献，不然会乱。计算完不通电的概率后分上面两种情况讨论即可。</p><script type="math/tex; mode=display">res=g_u\cdot f_v / (f_v+(1-f_v)\cdot(1-G_i.p))\\\\g_v=res+(1-res)\cdot(1-G_i.p)</script><p>两边 $dfs$ 就可以搞定。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans,f[N],g[N],q[N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,n,tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to;<span class="keyword">double</span> p;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> p)</span> </span>&#123;G[++cnt]=(Edge)&#123;head[x],y,p&#125;,head[x]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[u]=<span class="number">1</span>-q[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>((v=G[i].to)!=fa)</span><br><span class="line">            dfs1(v,u),f[u]*=(f[v]+(<span class="number">1</span>-f[v])*(<span class="number">1</span>-G[i].p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>((v=G[i].to)!=fa) &#123;</span><br><span class="line">            <span class="keyword">double</span> res=g[u]*f[u]/(f[v]+(<span class="number">1</span>-f[v])*(<span class="number">1</span>-G[i].p));</span><br><span class="line">            g[v]=res+(<span class="number">1</span>-res)*(<span class="number">1</span>-G[i].p);dfs2(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,p;IN(x),IN(y),IN(p);</span><br><span class="line">        add(x,y,p/<span class="number">100.0</span>),add(y,x,p/<span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) IN(x),q[i]=x/<span class="number">100.0</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1.0</span>,dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans+=<span class="number">1</span>-f[i]*g[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门在这：&lt;a href=&quot;https://loj.ac/problem/2192&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我是传送门$QwQ$&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。&lt;/p&gt;
&lt;p&gt;因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2015]寿司晚宴  状压DP  loj2131</title>
    <link href="http://qiulyblog.github.io/2019/05/01/%5B%E9%A2%98%E8%A7%A3%5Dloj2131/"/>
    <id>http://qiulyblog.github.io/2019/05/01/[题解]loj2131/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-05T01:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。</p><p>设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mul=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,s[N];ll p,f[<span class="number">2</span>][mul][mul];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(ll&amp;x,ll&amp;y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;p)x-=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">// freopen("1.out","w",stdout);</span></span><br><span class="line">    IN(n),IN(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;++j)</span><br><span class="line">            <span class="keyword">if</span>(!(i%pri[j])) s[i]|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now=i&amp;<span class="number">1</span>,lst=!now;</span><br><span class="line">        <span class="built_in">memcpy</span>(f[now],f[lst],<span class="keyword">sizeof</span>(f[lst]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;mul;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;mul;++s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[lst][s1][s2]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;s[i])) pls(f[now][s1|s[i]][s2],f[lst][s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;s[i])) pls(f[now][s1][s2|s[i]],f[lst][s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;mul;++s1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;mul;++s2) pls(ans,f[n&amp;<span class="number">1</span>][s1][s2]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以知道 $n\leq 500$ 的时候，每一个数最多带上一个大于等于 $23$ 的质因子。我们首先将所有的寿司分为两类：带了大于等于 $23$ 的质因子的和没带的。</p><p>没带的显然可以向上面那样转移。那么带了的呢？这个显然不能压缩吧。</p><p>我们考虑将带了同样的大于等于 $23$ 的质因子的分成一组，这一组要不小 $\rm{G}$ 吃小 $\rm{W}$ 不吃，要不小 $\rm{W}$ 吃小 $G$ 不吃。分别讨论即可。</p><p>设 $f1[s1][s2]$ 表示这一组是小 $\rm{G}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。同理，设 $f2[s1][s2]$ 表示这一组是小 $\rm{W}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。分别转移就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i) &#123; <span class="comment">/*枚举这些寿司*/</span></span><br><span class="line">    <span class="keyword">if</span>(a[i].t!=a[i<span class="number">-1</span>].t) <span class="comment">/*大质因子不同了*/</span></span><br><span class="line">        <span class="built_in">memcpy</span>(f1,f,<span class="keyword">sizeof</span>(f)),<span class="built_in">memcpy</span>(f2,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">        <span class="comment">/*倒着枚举所以没用滚动数组*/</span></span><br><span class="line">        <span class="comment">/*所谓的分别转移*/</span></span><br><span class="line">        <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]);</span><br><span class="line">        <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这一组结束了，需要合并答案*/</span></span><br><span class="line">    <span class="keyword">if</span>(a[i].t!=a[i+<span class="number">1</span>].t||i==n)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2)</span><br><span class="line">            <span class="comment">/*因为f1[s1][s2]和f2[s1][s2]都重复算了一遍原来的</span></span><br><span class="line"><span class="comment">            f[s1][s2]，所以减掉后再取膜*/</span></span><br><span class="line">            f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">ll p,f[M][M],f1[M][M],f2[M][M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> t,s;&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span> </span>&#123;<span class="keyword">return</span> a.t&lt;b.t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(ll&amp;x,ll&amp;y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;=p)x%=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;IN(n),IN(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        a[i].t=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;++j)<span class="keyword">if</span>(!(i%pri[j])) &#123;</span><br><span class="line">            a[i].s|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>),a[i].t/=pri[j];</span><br><span class="line">            <span class="keyword">while</span>(!(a[i].t%pri[j])) a[i].t/=pri[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    sort(a+<span class="number">2</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[pos].t==<span class="number">1</span>) ++pos;--pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=pos;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f[s1|a[i].s][s2],f[s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f[s1][s2|a[i].s],f[s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].t!=a[i<span class="number">-1</span>].t)</span><br><span class="line">            <span class="built_in">memcpy</span>(f1,f,<span class="keyword">sizeof</span>(f)),<span class="built_in">memcpy</span>(f2,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i].t!=a[i+<span class="number">1</span>].t||i==n)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2)</span><br><span class="line">                f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2) pls(ans,f[s1][s2]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans+p)%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。&lt;/p&gt;
&lt;p&gt;设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状态压缩" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [JSOI2016]灯塔  决策单调性&amp;DP  loj2074</title>
    <link href="http://qiulyblog.github.io/2019/04/30/%5B%E9%A2%98%E8%A7%A3%5Dloj2047/"/>
    <id>http://qiulyblog.github.io/2019/04/30/[题解]loj2047/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2019-05-05T01:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：<a href="https://loj.ac/problem/2074" target="_blank" rel="noopener">在这呢o(￣︶￣)o</a></p><p>刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了：</p><script type="math/tex; mode=display">h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}</script><p>设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续：</p><a id="more"></a><script type="math/tex; mode=display">f_i=\max\{ h_j +\sqrt{|i−j|}\}-h_i</script><p>发现绝对值很烦人，将绝对值拆开。</p><script type="math/tex; mode=display">f_i=\max(\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\},\max\limits_{j=i}^{n}\{h_j +\sqrt{j-i}\})-h_i</script><p>原序列翻转一下就可以直接计算后面的式子，也就是说我们只需要考虑第一个：</p><script type="math/tex; mode=display">f_i=\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\}-h_i</script><p>假设对于 $i$ 来说 $j$ 是最优的决策，那么如果存在一个小于 $j$ 的 $k$ ，是否在转移一个大于 $i$ 的 $l$ 会更优呢？显然不会，可以知道 $i-k$ 显然是大于 $i-j$ 的，而且根号是增长的越来越慢的。所以如果在 $i$ 时 $k$ 就没有 $j$ 优了，那么在以后所以大于 $i$ 的 $l$ 转移时 $k$ 也不可能比 $j$ 优。</p><p>也就是说上面的式子满足决策单调性，那么我们可以 $O(n\log n)$ 愉快求出了。</p><p>这里说明两个方法：</p><ul><li><strong>1.</strong> 单调队列维护三元组，三元组包含 $v$ (决策点 $v$) ，$l$ (决策点 $v$ 作为最优决策点的最左端点) ，$r$ (决策点 $v$ 作为最优决策点的最右端点) ，每一次排除掉最右端点小于 $i$ 的元素(因为该元素已经没用了) ，插入队列的时候去掉完全劣于 $i$ 的，然后对于折中的二分即可。(具体参见诗人小 $\rm{G}$ 的题解) 。</li><li><strong>2.</strong> 分治计算答案。设 $slove(al,ar,vl,vr)$ 表示在原数组 $al$ 到 $ar$ 这段区间的最优决策点位于 $vl$ 到 $vr$ 区间。我们每一次找到 $al$ 到 $ar$ 的中间点，也就是 $mid$ ，然后在 $vl$ 到 $vr$ 寻找最优的决策点更新 $f_{mid}$ ( $\rm{DP}$ 数组)，设这个最优点为 $g$ 。因为满足决策单调性，$al$ 到 $mid-1$ 的所有点的最优决策点一定在 $vl$ 到 $g$ 之间，右边 $mid+1$ 到 $ar$ 的也同理，就这么分治下去即可。</li></ul><p>实际运用中分治的效率不如三元组，但是代码却好写得多，很短，并且调试难度也大大降低，所以最终我选择了分治……分治的具体细节看代码。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;ll a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> f1[N],f2[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f1</span><span class="params">(<span class="keyword">int</span> al,<span class="keyword">int</span> ar,<span class="keyword">int</span> vl,<span class="keyword">int</span> vr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(al&gt;ar) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(al+ar)&gt;&gt;<span class="number">1</span>,g=<span class="number">0</span>;</span><br><span class="line">    f1[mid]=a[mid];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vl;i&lt;=min(vr,mid);++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> calc=a[i]+<span class="built_in">sqrt</span>(<span class="keyword">double</span>(mid-i));</span><br><span class="line">        <span class="keyword">if</span>(calc&gt;f1[mid]) f1[mid]=calc,g=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mid;f1[mid]-=a[mid];</span><br><span class="line">    solve_f1(al,mid<span class="number">-1</span>,vl,g),solve_f1(mid+<span class="number">1</span>,ar,g,vr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f2</span><span class="params">(<span class="keyword">int</span> al,<span class="keyword">int</span> ar,<span class="keyword">int</span> vl,<span class="keyword">int</span> vr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(al&gt;ar) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(al+ar)&gt;&gt;<span class="number">1</span>,g=<span class="number">0</span>;</span><br><span class="line">    f2[mid]=a[mid];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vr;i&gt;=max(vl,mid);--i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> calc=a[i]+<span class="built_in">sqrt</span>(<span class="keyword">double</span>(i-mid));</span><br><span class="line">        <span class="keyword">if</span>(calc&gt;f2[mid]) f2[mid]=calc,g=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mid;f2[mid]-=a[mid];</span><br><span class="line">    solve_f2(al,mid<span class="number">-1</span>,vl,g),solve_f2(mid+<span class="number">1</span>,ar,g,vr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    solve_f1(<span class="number">1</span>,n,<span class="number">1</span>,n),solve_f2(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line">    <span class="comment">/*最终没有翻转序列，而是选择做两遍分治*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ll)<span class="built_in">ceil</span>(max(f1[i],f2[i])));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：&lt;a href=&quot;https://loj.ac/problem/2074&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在这呢o(￣︶￣)o&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}&lt;/script&gt;&lt;p&gt;设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
      <category term="分治" scheme="http://qiulyblog.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2016]国王饮水记  斜率优化DP  loj2087</title>
    <link href="http://qiulyblog.github.io/2019/04/29/%5B%E9%A2%98%E8%A7%A3%5Dloj2087/"/>
    <id>http://qiulyblog.github.io/2019/04/29/[题解]loj2087/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-29T13:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>可爱的题目传送门：<a href="https://loj.ac/problem/2087" target="_blank" rel="noopener">戳我戳我·(<em>╹▽╹</em>)·</a></p><p>说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧……</p><ul><li><strong>1.</strong> 初始水位小于 $h_1$ 的没有用。</li></ul><p>这很显然。</p><a id="more"></a><ul><li><strong>2.</strong> 如果 $n\leq k$ ，那么只需要将所以大于 $h_1$ 的跟 $1$ 城市连就好了。</li></ul><p>每次连接的城市数越少贡献越大，那么每个逐一连一次一定是最优方案。</p><ul><li><strong>3.</strong> 每次操作必然跟 $1$ 城市有关系。</li></ul><p>不然没贡献。</p><ul><li><strong>4.</strong> 除了 $1$ 号城市，其他每个城市最多连一次。</li></ul><p>因为连过一次的城市的水位已经和 $1$ 城市一样了，简单点说肯定就是废了。</p><ul><li><strong>5.</strong> 每次连的所有城市中最小的 $h_i$ 必然大于上一次链接的最大的 $h_i$ 。</li></ul><p>这很显然，不然不满足最优方案。</p><ul><li><strong>6.</strong> 将所以城市按水位排序后，每次选择的必然是连续一段区间。</li></ul><p>和上一个差不多。</p><ul><li><strong>7.</strong> 每次选择的区间必然和上一次的选择区间接触。</li></ul><p>这很显然。</p><ul><li><strong>8.</strong> 每次选择的区间的长度必定单调不增。</li></ul><p>满足最优，都说了每次连接的城市越少贡献越大。</p><hr><p>那么显然就变成了一个区间问题了，我们需要将这个区间分成若干块。</p><p>设 $f_{i,j}$ 表示排序后前 $i$ 个城市联通了 $j$ 次后 $1$ 号城市的最大水位高度。那么转移直接枚举一个 $k$ ，在新的一次连接中连接了 $k+1$ 到 $i$ 这些城市。转移方程显然：</p><script type="math/tex; mode=display">f_{i,j}=\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1}</script><p>*注：$s_i$ 为前缀和。</p><p>上式的复杂度为 $O(n^2k)$  ，肯定爆炸。但是这个是可以<strong>斜率优化</strong>的：</p><script type="math/tex; mode=display">\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1} =\frac{s_i-(s_k-f_{k,j-1})}{i-(k-1)}\Rightarrow \frac{Y(i)-Y(k)}{X(i)-X(k)}</script><p>然后通过第 $8$ 条性质可以得知 $\texttt{DP}$ 是有<strong>决策单调性</strong>的，故复杂度为 $O(nk)$ 。因为恶心的高精度小数的运算还需要 $O(p)$ 的复杂度，所以最终总时间复杂度为 $O(nkp)$ 。</p><p>我们发现 $k$ 有 $10^9$ ，所以复杂度带 $k$ 的一定假掉了。</p><p>那么观察第 $2$ 条性质会发现，如果 $k$ 大于 $n$ 了直接将 $k$ 设为 $n$ 就好了。也就是说复杂度应该为 $O(n^2p)$ ，这样就是 $86$ 分，通过数据来看会发现这个倾向于大众分，一车厢的人都是这个分数。</p><p>那么如果想要 $\texttt{AC}$ 的话需要最后一条很迷的性质：</p><ul><li><strong>9.</strong> 因为 $h$ 各不同，选择的区间最多只有 $14$ 个区间长度大于 $1$ ，其他的区间均等于 $1$ 。</li></ul><p>很迷，准确的说这样的区间是 $O(\log\frac{nh}{\min_i\{h_i-h_{i-1}\}})$ 个。</p><p>证明不会……但是这里写了证明(唯一的且很迷的证明)：<a href="https://github.com/qiulyblog/image/blob/master/[NOI2016]%E5%9B%BD%E7%8E%8B%E9%A5%AE%E6%B0%B4%E8%AE%B0%E9%A2%98%E8%A7%A3.pdf?raw=true" target="_blank" rel="noopener">哈哈我是传送门O(∩_∩)O</a></p><p>那么就丢代码了，实际上是需要高精小数的，这里先给出一个除去高精小数板子的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">8e3</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Decimal ans;</span><br><span class="line"><span class="keyword">int</span> n,k,p,lim,h[N],s[N],pre[N][<span class="number">16</span>],tot;</span><br><span class="line"><span class="keyword">int</span> q[N],head,tail;</span><br><span class="line"><span class="keyword">double</span> f[N][<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span><span class="keyword">double</span> x,y;&#125;t[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(point a,point b)</span> </span>&#123;<span class="keyword">return</span> (a.y-b.y)/(a.x-b.x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Decimal <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!j) <span class="keyword">return</span> h[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> (solve(pre[i][j],j<span class="number">-1</span>)+s[i]-s[pre[i][j]])/(i-pre[i][j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;k,&amp;p,&amp;h[tot=<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;h[i]);</span><br><span class="line">        <span class="keyword">if</span>(h[i]&gt;h[<span class="number">1</span>]) h[++tot]=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    n=tot;sort(&amp;h[<span class="number">1</span>],&amp;h[n+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i][<span class="number">0</span>]=h[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]=s[i<span class="number">-1</span>]+h[i];</span><br><span class="line">    k=min(k,n),lim=min(k,<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lim;++j) &#123;</span><br><span class="line">        q[head=tail=<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t[i]=(point)&#123;i<span class="number">-1</span>,s[i]-f[i][j<span class="number">-1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            point now=(point)&#123;i,s[i]&#125;;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(now,t[q[head]])&lt;slope(now,t[q[head+<span class="number">1</span>]])) ++head;</span><br><span class="line">            f[i][j]=(f[q[head]][j<span class="number">-1</span>]+s[i]-s[q[head]])/(i-q[head]+<span class="number">1</span>);</span><br><span class="line">            pre[i][j]=q[head];</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(t[q[tail]],t[q[tail<span class="number">-1</span>]])&gt;slope(t[q[tail]],t[i])) --tail;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=n-k+lim,pos;</span><br><span class="line">    <span class="keyword">double</span> mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i) </span><br><span class="line">        <span class="keyword">if</span>(f[m][i]&gt;mx) mx=f[m][i],pos=i;</span><br><span class="line">    ans=solve(m,pos);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=n;++i) ans=(ans+h[i])/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans.to_string(p&lt;&lt;<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么高精度小数板子的下载链接就贴这了：<a href="https://loj.ac/problem/2087/download/additional_file" target="_blank" rel="noopener">$loj$ 的下载地址传送们(～￣▽￣)～</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可爱的题目传送门：&lt;a href=&quot;https://loj.ac/problem/2087&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳我戳我·(&lt;em&gt;╹▽╹&lt;/em&gt;)·&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1.&lt;/strong&gt; 初始水位小于 $h_1$ 的没有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这很显然。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2015]亚瑟王  概率DP  loj2112</title>
    <link href="http://qiulyblog.github.io/2019/04/28/%5B%E9%A2%98%E8%A7%A3%5Dloj2112/"/>
    <id>http://qiulyblog.github.io/2019/04/28/[题解]loj2112/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-29T13:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现 <a href="https://loj.ac" target="_blank" rel="noopener">$loj$</a> 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。</p><p>顺便贴一下题目传送门：<a href="https://loj.ac/problem/2112" target="_blank" rel="noopener">$loj$的传送门就戳我啦(～￣▽￣)～</a></p><p>概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。</p><a id="more"></a><p>第一种情况：$j$ 轮中都没有打出第 $i+1$ 张牌，由于一轮中不打出第 $i+1$ 张牌的概率为 $1-p_i$ ，那么 $j$ 轮都不打出该牌的概率显然为 $(1-p_i)^j$ 。转移方程显然：</p><script type="math/tex; mode=display">f_{i+1,j}+=f_{i,j}\cdot (1-p_i)^j​</script><p>因为 $f_{i+1,j}$ 可能从多方向转移过来，所以是 $+=$ 。</p><p>第二种情况：$j$ 轮中至少有一轮打出了第 $i+1$ 张牌，概率显然为 $1-(1-p_i)^j$ ，转移也就很显然了：</p><script type="math/tex; mode=display">f_{i+1,j-1}+=f_{i,j}\cdot （1-(1-p_i)^j）</script><p>如果我们打出了第 $i+1$ 张牌，那么肯定是要计算贡献的，这个时候直接用这个概率算贡献就好了。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,r,d[N];</span><br><span class="line"><span class="keyword">double</span> f[N][N],p[N],pw[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>,&amp;p[i],&amp;d[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            pw[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=r;++j) pw[i][j]=pw[i][j<span class="number">-1</span>]*(<span class="number">1</span>-p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][r]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=r;++j) &#123;</span><br><span class="line">                f[i+<span class="number">1</span>][j]+=f[i][j]*pw[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j) &#123;</span><br><span class="line">                    <span class="keyword">double</span> calc=f[i][j]*(<span class="number">1</span>-pw[i+<span class="number">1</span>][j]);</span><br><span class="line">                    f[i+<span class="number">1</span>][j<span class="number">-1</span>]+=calc,ans+=calc*d[i+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现 &lt;a href=&quot;https://loj.ac&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$loj$&lt;/a&gt; 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。&lt;/p&gt;
&lt;p&gt;顺便贴一下题目传送门：&lt;a href=&quot;https://loj.ac/problem/2112&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$loj$的传送门就戳我啦(～￣▽￣)～&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 小谈斜率优化</title>
    <link href="http://qiulyblog.github.io/2019/04/28/%5B%E7%AE%97%E6%B3%95%5D%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://qiulyblog.github.io/2019/04/28/[算法]斜率优化/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-05-07T06:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="在此输入你的密码以便阅读全文" />    <label for="pass">在此输入你的密码以便阅读全文</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本文为加密文章，阅读本文需要输入密码。
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="算法" scheme="http://qiulyblog.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
