<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qiuly&#39;s blog!</title>
  
  <subtitle>A weak OIer from HN-YZ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qiulyblog.github.io/"/>
  <updated>2019-05-12T08:54:08.118Z</updated>
  <id>http://qiulyblog.github.io/</id>
  
  <author>
    <name>Qiuly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【题解】 [九省联考2018]林克卡特树  树形DP+wqs二分优化  loj2478</title>
    <link href="http://qiulyblog.github.io/2019/05/12/%5B%E9%A2%98%E8%A7%A3%5Dloj2478/"/>
    <id>http://qiulyblog.github.io/2019/05/12/[题解]loj2478/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-05-12T08:54:08.118Z</updated>
    
    <content type="html"><![CDATA[<p>毒瘤传送门：<a href="https://loj.ac/problem/2478" target="_blank" rel="noopener">戳我戳我</a></p><p>仔细观察会发现该题需要从树上拿出 $k+1$ 条互不相交的链，求这些链的节点的权值总和的最大值。那么我们选出这些链后就可以用 $k$ 条边将其连起来了，这样就满足了题意。</p><a id="more"></a><p>用 $f_{i,j}$ 表示 $i$ 的子树中选出了 $j$ 个链的最大值，但是会发现转移很难办，枚举一个 $i$ 的儿子 $v$ 的时候，我们不好算出 $v$ 对 $i$ 上的链做出的贡献。</p><p>那么我们新增加一个状态，设 $f_{0/1/2,i,j}$ 为我们的状态，$i,j$ 的意思和上面一样，其中 $0/1/2$ 分别表示——<strong>$0$ : $i$ 不属于子树中 $j$ 条链中的任意一条，$1$ : $i$ 属于 $j$ 条链中其中一条，$2$ : $i$ 属于 $j$ 条链中的其中两条</strong> 。</p><p>那么我们枚举一个儿子 $v$ ，现在我们需要转移的对象就是 $u$ (上面的 $i$ ) ，那么我们注意来考虑：</p><p>我们转移的时候枚举一个 $i$ 表示当前的链数，然后枚举 $j$ 表示 $v$ 子树中的链数，那么之前 $u$ 子树中的链数显然就是 $i-j$ 了。</p><p>令 $num_{v,j}=\max(f_{0,v,j},f_{1,v,j},f_{2,v,j})$ .</p><ul><li><p>计算 $v$ 对 $f_{0,u,i}$ 的贡献</p><ul><li><p>因为该状态必须满足 $u$ 不能属于任意一条链，所有我们理所当然也不能连上 $u\rightarrow v$ 这条边。那么也就是说 $v$ 中发生什么事情都跟 $u$ 没有任何关系了，因为要统计最大，我们直接将 $num$ 统计进去即可。</p></li><li><p>转移：</p><script type="math/tex; mode=display">f_{0,u,i}=\max_v\max_j \{f_{0,u,i-j}+num_{v,j}\}</script></li></ul></li><li><p>计算 $v$ 对 $f_{1,u,i}$ 的贡献</p><ul><li><p>考虑两种情况，第一种，这一条和 $u$ 有关的链是连着别的子树的，那么也就肯定不会连上 $u\rightarrow v$ 这条边，按照上面的转移即可。</p></li><li><p>第一种转移：</p><script type="math/tex; mode=display">f_{1,u,i}=\max_v\max_j \{f_{1,u,i-j}+num_{v,j}\}​</script></li><li><p>第二种情况就是这一条链是和 $v$ 相连接的，那么这个时候 $v$ 的状态只能是 $0,1$ ，原因很显然，链不能香蕉(最好吃了🍌) ，那么对于 $v$ 状态是 $0$ 的情况，这样一连接后就会新出现一条链了，记得算上边权：</p></li><li><p>转移 $0$ 情况：</p><script type="math/tex; mode=display">f_{1,u,i}=\max_v\max_j\{f_{0,u,i-j}+f_{0,v,j-1}+w\}​</script><p>$f_{0,u,i-j}$ 不解释，$f_{0,v,j-1}$ 这里为什么要 $j-1$ 呢？因为很显然当前局面只有 $i-1$ 条链，上面讲了连接后会多出来一条，那么 $i-1+1$ 就正好用来转移 $i$ 了。最后的 $w$ 即为当前转移带来的贡献。</p></li><li><p>$v$ 的状态是 $1$ 的时候和上面差不多，但是因为连接 $u,v$ 后 $u$ 属于了原来就存在的一条链，也就是说没有新增链，那么就没必要 $j-1$ 了。</p></li><li><p>转移 $1$ 的情况：</p><script type="math/tex; mode=display">f_{1,u,i}=\max_v\max_j\{f_{0,u,i-1}+f_{1,v,j}+w\}</script></li></ul></li><li><p>计算 $v$ 对 $f_{2,u,i}$ 的贡献</p><ul><li><p>首先如果这两条链连接别的子树了，那么 $v$ 就没有限制了，转移同上：</p></li><li><p>转移：</p><script type="math/tex; mode=display">f_{2,u,i}=\max_v\max_j \{f_{2,u,i-j}+num_{v,j}\}</script></li><li><p>接下来的就很好办了，因为连接 $u,v$ 最多是一条链，也就是说我们不可能将两条链都放到 $v$ 下来。先考虑 $v$ 状态为 $0$ 的情况，因为连接后 $v$ 属于了 $u$ 原来所在的链(没有新增链)，那么直接算贡献：</p></li><li><p>转移：</p><script type="math/tex; mode=display">f_{2,u,i}=\max_v\max_j\{f_{1,u,i-j}+f_{0,v,j}+w\}</script></li><li><p>然后考虑 $v$ 状态为 $1$ 的情况，这个时候连接 $u,v$ 会使得 $v$ 原来所在的链和 $u$ 原来所在的链合并为一条链，那么这里的和上面的 $j-1$ 不同，这里因为是少了一条链所有要变成 $j+1$ 。</p></li><li><p>转移：</p><script type="math/tex; mode=display">f_{2,u,i}=\max_v\max_j\{f_{1,u,i-j}+f_{1,v,j+1}+w\}</script></li></ul></li></ul><p>所有的转移式都得到了，我们来考虑初始化，首先因为是取最大值，我们需要全部初始化为一个很小的负数。然后对于 $f_{0,u,0}$ 这样的状态的值很显然是 $0$ 。</p><p>其他的没了，注意这样的 $\rm{DP}$ 复杂度只能让我们最多拿到 $60$ 分。</p><h3 id="Code-60-pts-："><a href="#Code-60-pts-：" class="headerlink" title="Code (60 $pts$ ) ："></a>Code (60 $pts$ ) ：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,sz[N],head[N],cnt;</span><br><span class="line">ll dp[<span class="number">3</span>][N][<span class="number">110</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to,val;&#125; G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[v],u,w&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][u][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">/*初始化*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e=head[u];e;e=G[e].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[e].to,w=G[e].val;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u),sz[u]+=sz[v];</span><br><span class="line">        <span class="comment">/*利用sz数组优化，同样是O(nk^2)的代码，其他的只能拿到30</span></span><br><span class="line"><span class="comment">        ~40，但是这个优化过后是妥妥的60分*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=min(sz[u],k);i;--i) &#123;</span><br><span class="line">            <span class="comment">/*计算v下面没有链的情况，计算初始状态带来的贡献*/</span></span><br><span class="line">            dp[<span class="number">2</span>][u][i]=max(dp[<span class="number">2</span>][u][i],dp[<span class="number">1</span>][u][i]+w);</span><br><span class="line">            dp[<span class="number">2</span>][u][i]=max(dp[<span class="number">2</span>][u][i],dp[<span class="number">1</span>][u][i]+dp[<span class="number">1</span>][v][<span class="number">1</span>]+w);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=min(sz[v],i);j;--j) &#123;</span><br><span class="line">                <span class="comment">/*计算出num*/</span></span><br><span class="line">                ll num=max(dp[<span class="number">0</span>][v][j],max(dp[<span class="number">1</span>][v][j],dp[<span class="number">2</span>][v][j]));</span><br><span class="line">                <span class="comment">/*下面的7个式子就是上文讲的转移了*/</span></span><br><span class="line">                dp[<span class="number">0</span>][u][i]=max(dp[<span class="number">0</span>][u][i],dp[<span class="number">0</span>][u][i-j]+num);</span><br><span class="line"></span><br><span class="line">                dp[<span class="number">1</span>][u][i]=max(dp[<span class="number">1</span>][u][i],dp[<span class="number">1</span>][u][i-j]+num);</span><br><span class="line">                dp[<span class="number">1</span>][u][i]=max(dp[<span class="number">1</span>][u][i],dp[<span class="number">0</span>][u][i-j]+dp[<span class="number">1</span>][v][j]+w);</span><br><span class="line">                dp[<span class="number">1</span>][u][i]=max(dp[<span class="number">1</span>][u][i],dp[<span class="number">0</span>][u][i-j]+dp[<span class="number">0</span>][v][j<span class="number">-1</span>]+w);</span><br><span class="line"></span><br><span class="line">                dp[<span class="number">2</span>][u][i]=max(dp[<span class="number">2</span>][u][i],dp[<span class="number">2</span>][u][i-j]+num);</span><br><span class="line">                dp[<span class="number">2</span>][u][i]=max(dp[<span class="number">2</span>][u][i],dp[<span class="number">1</span>][u][i-j]+dp[<span class="number">0</span>][v][j]+w);</span><br><span class="line">                dp[<span class="number">2</span>][u][i]=max(dp[<span class="number">2</span>][u][i],dp[<span class="number">1</span>][u][i-j]+dp[<span class="number">1</span>][v][j+<span class="number">1</span>]+w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*也是一种特殊情况，可以直接放到上面去的(v下没有链)*/</span></span><br><span class="line">            dp[<span class="number">1</span>][u][i]=max(dp[<span class="number">1</span>][u][i],dp[<span class="number">0</span>][u][i<span class="number">-1</span>]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!sz[u]) dp[<span class="number">0</span>][u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    ++sz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,v;IN(x),IN(y),IN(v),add(x,y,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span>(dp));<span class="comment">/*极小值*/</span></span><br><span class="line">    ++k;dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,max(dp[<span class="number">0</span>][<span class="number">1</span>][k],max(dp[<span class="number">1</span>][<span class="number">1</span>][k],dp[<span class="number">2</span>][<span class="number">1</span>][k])));</span><br><span class="line">    <span class="comment">/*输出最优👆*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>如果打出了表，你会发现对于单调递增的 $k$ ，关于其的最优解所形成的一定是一个上凸的函数，感性理解的话就是说 $k$ 小的时候我们可以选更多的更大的边，但是随着 $k$ 增大，这些边不够了，我们只能选更小的或者是拆掉一些边(将一条链断成两条增加链数) ，这样子答案就好慢慢变小。</p><p>因为是上凸函数，我们可以使用 $\rm{DP}$ 凸优化，带权二分/$wqs$二分套路优化一下就可以过了。</p><p>注意二分边界！还有就是需要注意一个点也可以成为一条链的情况！</p><h3 id="Code-100-pts"><a href="#Code-100-pts" class="headerlink" title="Code (100 $pts$ )"></a>Code (100 $pts$ )</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e18</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> &#123;</span></span><br><span class="line">    ll x;<span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> date&amp;var) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x==var.x?y&gt;var.y:x&lt;var.x;&#125;</span><br><span class="line">    date <span class="keyword">operator</span> + (<span class="keyword">const</span> date&amp;var) &#123;<span class="keyword">return</span> (date)&#123;x+var.x,y+var.y&#125;;&#125;</span><br><span class="line">    date <span class="keyword">operator</span> + (<span class="keyword">const</span> ll&amp;var) &#123;<span class="keyword">return</span> (date)&#123;x+var,y&#125;;&#125;</span><br><span class="line">&#125;dp[<span class="number">3</span>][N];</span><br><span class="line"><span class="function">ll <span class="title">number</span><span class="params">(date var)</span> </span>&#123;<span class="keyword">return</span> var.x;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to,val;&#125; G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[v],u,w&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(ll add,<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][u]=(date)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    dp[<span class="number">1</span>][u]=(date)&#123;-inf,<span class="number">0</span>&#125;,</span><br><span class="line">    dp[<span class="number">2</span>][u]=(date)&#123;add,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e=head[u];e;e=G[e].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[e].to;</span><br><span class="line">        ll w=G[e].val;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        check(add,v,u);</span><br><span class="line">        date num=max(dp[<span class="number">0</span>][v],max(dp[<span class="number">1</span>][v],dp[<span class="number">2</span>][v]));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">2</span>][u]=max(dp[<span class="number">2</span>][u],dp[<span class="number">2</span>][u]+num);</span><br><span class="line">        dp[<span class="number">2</span>][u]=max(dp[<span class="number">2</span>][u],dp[<span class="number">1</span>][u]+(date)&#123;w,<span class="number">0</span>&#125;+max(dp[<span class="number">0</span>][v],dp[<span class="number">1</span>][v]+(date)&#123;-add,<span class="number">-1</span>&#125;));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>][u]=max(dp[<span class="number">1</span>][u],dp[<span class="number">1</span>][u]+num);</span><br><span class="line">        dp[<span class="number">1</span>][u]=max(dp[<span class="number">1</span>][u],dp[<span class="number">0</span>][u]+(date)&#123;w,<span class="number">0</span>&#125;+max(dp[<span class="number">1</span>][v],dp[<span class="number">0</span>][v]+(date)&#123;add,<span class="number">1</span>&#125;));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][u]=dp[<span class="number">0</span>][u]+num;</span><br><span class="line">    &#125;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">wqs</span><span class="params">(ll sum)</span> </span>&#123;</span><br><span class="line">    ll l=-sum,r=sum,mid;</span><br><span class="line">    date now;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,check(mid,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        now=max(dp[<span class="number">0</span>][<span class="number">1</span>],max(dp[<span class="number">1</span>][<span class="number">1</span>],dp[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">if</span>(!(now.y^k)) &#123;l=r=mid;<span class="keyword">break</span>;&#125;</span><br><span class="line">        now.y&lt;k?l=mid:r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mid=l;check(mid,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    now=max(dp[<span class="number">0</span>][<span class="number">1</span>],max(dp[<span class="number">1</span>][<span class="number">1</span>],dp[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> now.x-mid*k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("lct2.in","r",stdin);</span></span><br><span class="line">    <span class="comment">// freopen("P4383.out","w",stdout);</span></span><br><span class="line">    IN(n),IN(k);++k;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,v;IN(x),IN(y),IN(v);</span><br><span class="line">        add(x,y,v),sum+=<span class="built_in">abs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,wqs(sum));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毒瘤传送门：&lt;a href=&quot;https://loj.ac/problem/2478&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳我戳我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仔细观察会发现该题需要从树上拿出 $k+1$ 条互不相交的链，求这些链的节点的权值总和的最大值。那么我们选出这些链后就可以用 $k$ 条边将其连起来了，这样就满足了题意。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="树形DP" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="wqs二分/带权二分" scheme="http://qiulyblog.github.io/tags/wqs%E4%BA%8C%E5%88%86-%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [ZJOI2010]基站选址  线段树优化DP  luoguP2065</title>
    <link href="http://qiulyblog.github.io/2019/05/09/%5B%E9%A2%98%E8%A7%A3%5DluoguP2605/"/>
    <id>http://qiulyblog.github.io/2019/05/09/[题解]luoguP2605/</id>
    <published>2019-05-08T16:00:00.000Z</published>
    <updated>2019-05-09T14:43:08.149Z</updated>
    
    <content type="html"><![CDATA[<p>这题居然只有 $luogu$ 有……无法水多倍经验了（逃。</p><p>朴素的 $\rm{DP}$ 很简单，设 $f_{i,j}$ 表示前 $i$ 个村庄建了 $j$ 个基站的花费最小值，注意因为是<strong>前 $i$ 个</strong>，所有完全无视掉后面的所有村庄了。转移的话直接枚举一个 $k$ ，从 $f_{k,j-1}$ 转移过来即可，加上的代价就是中间村庄产生的补偿费用。</p><a id="more"></a><p>那么这样的复杂度就是 $O(n^2k)$ [<del>爆炸</del>] ，我们需要做到的就是如何快速计算中间村庄的补偿，那么外围的 $\rm{DP}$ 复杂度其实是 $O(nk)$ 的，如果中间的补偿可以快速算出那么就可以过掉了。</p><p>我们对于每一个村庄 $i$ ，用二分计算出最左边可以覆盖到其的村庄 $st_i$ 和最右边可以覆盖到其的村庄 $ed_i$ ，那么我们从 $i$ 到 $i+1$ 的时候，所有 $ed$ 值为 $i$ 的点都将失去右边的依靠，这个时候对于 $i+1$ 的最优转移点 $k$ ，有对于一个失去”右边依靠”的村庄 $j$ ，如果 $k$ 的范围在 $[1,st_j-1]$ 之间的话那么就要给 $j$ 补偿了。</p><p>于是我们考虑用线段树优化，对于这样一个村庄 $j$ ，我们在 $[1,st_j-1]$ 区间集体加上 $w_j$ ，表示决策点如果落在那个区间就要多付出 $w_j$ 的费用。</p><p>线段树的每个位置维护的就是 $f_k+$ $i$ 和 $k$ 中间村庄的补偿费用，因为我们每一次的答案就是整个区间的 $\min$ 值了，只是随着 $i$ 的变化线段树维护的值也应当做出变化，所以就会向上面那样更新。</p><p>不过有个问题，有个情况没有考虑道：第 $n$ 个村庄不建基站的情况，对于一个小于 $n$ 的 $i$ ，$f_i$ 管不了 $n$ ，那么 $f_n$ 也仅仅表示 $n$ 建站的情况。</p><p>所以我们需要在 $n+1$ 的位置上建一个辅助基站，当然 $c_{n+1}=0$ ，这样子就很好计算 <q>第 $n$ 个村庄不建站时全局的花费了</q> 。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">1e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span>&#123;</span><span class="keyword">int</span> nxt,to;&#125; G[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;G[++cnt]=(link)&#123;head[u],v&#125;;head[u]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,d[N],c[N],s[N],w[N],f[N],st[N],ed[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segment_Tree &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) ((x)&lt;&lt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) ((x)&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">int</span> val[N&lt;&lt;<span class="number">2</span>],tag[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        val[ls(x)]+=tag[x],tag[ls(x)]+=tag[x];</span><br><span class="line">        val[rs(x)]+=tag[x],tag[rs(x)]+=tag[x];</span><br><span class="line">        tag[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        tag[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r) &#123;val[x]=f[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">        build(ls(x),l,mid),build(rs(x),mid+<span class="number">1</span>,r);</span><br><span class="line">        val[x]=min(val[ls(x)],val[rs(x)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==l&amp;&amp;r==R) &#123;val[x]+=v,tag[x]+=v;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(tag[x]) pushdown(x,l,r);</span><br><span class="line">        <span class="keyword">if</span>(R&lt;=mid) change(ls(x),l,mid,L,R,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) change(rs(x),mid+<span class="number">1</span>,r,L,R,v);</span><br><span class="line">        <span class="keyword">else</span> change(ls(x),l,mid,L,mid,v),change(rs(x),mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,R,v);</span><br><span class="line">        val[x]=min(val[ls(x)],val[rs(x)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==l&amp;&amp;r==R) <span class="keyword">return</span> val[x];</span><br><span class="line">        <span class="keyword">if</span>(tag[x]) pushdown(x,l,r);</span><br><span class="line">        <span class="keyword">if</span>(R&lt;=mid) <span class="keyword">return</span> query(ls(x),l,mid,L,R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) <span class="keyword">return</span> query(rs(x),mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min(query(ls(x),l,mid,L,mid),query(rs(x),mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,R));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Segment_Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) IN(d[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(s[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(w[i]);</span><br><span class="line">    ++n;w[n]=d[n]=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        st[i]=lower_bound(d+<span class="number">1</span>,d+<span class="number">1</span>+n,d[i]-s[i])-d;</span><br><span class="line">        ed[i]=lower_bound(d+<span class="number">1</span>,d+<span class="number">1</span>+n,d[i]+s[i])-d;</span><br><span class="line">        <span class="keyword">if</span>(d[ed[i]]&gt;d[i]+s[i]) ed[i]--;add(ed[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) &#123;</span><br><span class="line">                f[j]=res+c[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> e=head[j];e;e=G[e].nxt)</span><br><span class="line">                    res+=w[G[e].to];</span><br><span class="line">            &#125;ans=f[n];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) &#123;</span><br><span class="line">                f[j]=(j&gt;i<span class="number">-1</span>?query(<span class="number">1</span>,<span class="number">1</span>,n,i<span class="number">-1</span>,j<span class="number">-1</span>):<span class="number">0</span>)+c[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> e=head[j],v;e;e=G[e].nxt)</span><br><span class="line">                    <span class="keyword">if</span>(st[v=G[e].to]&gt;<span class="number">1</span>) change(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,st[v]<span class="number">-1</span>,w[v]); </span><br><span class="line">            &#125;ans=min(ans,f[n]);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这题居然只有 $luogu$ 有……无法水多倍经验了（逃。&lt;/p&gt;
&lt;p&gt;朴素的 $\rm{DP}$ 很简单，设 $f_{i,j}$ 表示前 $i$ 个村庄建了 $j$ 个基站的花费最小值，注意因为是&lt;strong&gt;前 $i$ 个&lt;/strong&gt;，所有完全无视掉后面的所有村庄了。转移的话直接枚举一个 $k$ ，从 $f_{k,j-1}$ 转移过来即可，加上的代价就是中间村庄产生的补偿费用。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="线段树" scheme="http://qiulyblog.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 最长上升子序列  状压DP  bzoj3591</title>
    <link href="http://qiulyblog.github.io/2019/05/08/%5B%E9%A2%98%E8%A7%A3%5Dbzoj3591/"/>
    <id>http://qiulyblog.github.io/2019/05/08/[题解]bzoj3591/</id>
    <published>2019-05-07T16:00:00.000Z</published>
    <updated>2019-05-08T08:09:02.467Z</updated>
    
    <content type="html"><![CDATA[<p>这题脑洞很大——你需要状压 $\rm{LTS}$ 数组，而且是三进制状压。复杂度很高……大约是 $O(n3^n)$ 左右，当然实际复杂度会小于这个，$1000^+ms$ 是可以通过的。</p><p>对于每一个数字，分别记录其三种状态：该数字没有进过 $\rm{LTS}$ 数组记为 $0$ ，该数字在 $\rm{LTS}$ 数组中记为 $1$ ，该数字进过 $\rm{LTS}$ 数组，结果又出来了记为 $2$ 。</p><a id="more"></a><p>设 $f_i$ 表示 $1$ 到 $n$ 所有数字的状态为 $i$ 时的方案数，接下来考虑转移，首先对于这个 $i$ 状态我们还原其 $\rm{LTS}$ 数组，也就是当前位置上为 $1$ 的那些数字。接着我们枚举所有位置上为 $0$ 的数字，并考虑将其插入当前的 $\rm{LTS}$ 当中。替换掉一个状态为 $1$ 的数。</p><p>我们就选定这个要被替换的状态为 $1$ 的数为当前 $\rm{LTS}$ 中第一个大于当前要加入的数的数，那么这样替换后 $\rm{LTS}$ 依然满足其性质。</p><p>维护一个指针扫一遍就好，碰到需要换的数就将其标记为 $2$ ，然后将当前需要加入的数变成 $1$ 即可。</p><p>需要注意的是，我们这里的”加入”并不是只的在原数组中加入，也就是说跟排列什么的几乎扯不上关系，比如说当前序列为 $1,2,3,4,5$ ，$\rm{LTS}$ 数组为 $1,3,4$ ，我们在这里将 $3$ 丢掉，然后加入 $2$ ，其实是不变的。</p><p>当所有数字都被考虑过的时候就可以直接统计答案了，普通的 $\rm{LTS}$ 也是所有数字都要考虑一回的。</p><p>在做 $\rm{DP}$ 转移的时候我们顺带满足一下题面给出的那些数的递增即可，那么可以保证所有被统计的状态都带有题面要求的 $\rm{LTS}$ 。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,ans,arr[N],pos[N],mul[N];</span><br><span class="line"><span class="keyword">int</span> hep[N],var[N],dp[<span class="number">14348907</span>+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"3591.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"3591.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    IN(n),IN(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) </span><br><span class="line">        IN(arr[i]),--arr[i],pos[arr[i]]=i;</span><br><span class="line">    mul[<span class="number">0</span>]=dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) mul[i]=mul[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mul[n];++i) <span class="keyword">if</span>(dp[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> state=i,top=<span class="number">0</span>,num=<span class="number">0</span>,per=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line">            var[j]=state%<span class="number">3</span>,state/=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(var[j]) ++num;</span><br><span class="line">            <span class="keyword">if</span>(var[j]==<span class="number">1</span>) hep[top++]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num==n) &#123;ans+=dp[i];<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(var[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos[j]&amp;&amp;!var[arr[pos[j]<span class="number">-1</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(hep[per]&lt;j&amp;&amp;per&lt;top) ++per;</span><br><span class="line">            <span class="keyword">if</span>(per&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line">            state=i+mul[j];</span><br><span class="line">            <span class="keyword">if</span>(per&lt;top) state+=mul[hep[per]];</span><br><span class="line">            dp[state]+=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这题脑洞很大——你需要状压 $\rm{LTS}$ 数组，而且是三进制状压。复杂度很高……大约是 $O(n3^n)$ 左右，当然实际复杂度会小于这个，$1000^+ms$ 是可以通过的。&lt;/p&gt;
&lt;p&gt;对于每一个数字，分别记录其三种状态：该数字没有进过 $\rm{LTS}$ 数组记为 $0$ ，该数字在 $\rm{LTS}$ 数组中记为 $1$ ，该数字进过 $\rm{LTS}$ 数组，结果又出来了记为 $2$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状压DP" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>DP进阶必刷题单</title>
    <link href="http://qiulyblog.github.io/2019/05/07/DP%E8%BF%9B%E9%98%B6%E5%BF%85%E5%88%B7%E9%A2%98%E5%8D%95/"/>
    <id>http://qiulyblog.github.io/2019/05/07/DP进阶必刷题单/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-12T07:42:19.466Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="在此输入你的密码以便阅读全文" />    <label for="pass">在此输入你的密码以便阅读全文</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本文为加密文章，阅读本文需要输入密码。
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题单" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2009]双递增序列  线性DP  luoguP4728</title>
    <link href="http://qiulyblog.github.io/2019/05/07/%5B%E9%A2%98%E8%A7%A3%5DluoguP4728/"/>
    <id>http://qiulyblog.github.io/2019/05/07/[题解]luoguP4728/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-07T02:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示<strong>第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立</strong> ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。</p><a id="more"></a><p>考虑设 $dp_{i,j}$ 表示第一个序列的最终位置为 $i-1$ 且长度为 $j$ 时第二个序列的最终位置的最小值。枚举当前数字 $i$ ，然后分两种情况进行转移——将 $a_i$ 放到第一个序列末尾 $\texttt{and}$ 将 $a_i$ 放到第二个序列末尾。</p><p>放到第一个序列末尾很好想：因为当前第一个序列的结尾处就是 $a_{i-1}$ ，比较一下大小直接转移就好了：</p><script type="math/tex; mode=display">dp_{i,j}=min(dp_{i,j},dp_{i-1,j-1}) \ \ \ (a_i>a_{i-1})</script><p>因为第二个序列的末尾没变，所有直接转移就好。</p><p>接下来考虑将第 $i$ 个数放到第二个序列末尾的情况，其实第一个序列和第二个序列没区别，当然除了名字上有一个字的差异，假设第 $i-1$ 个数是第二个序列末尾，当前第一个序列的长度为 $j-1$ ，那么第二个序列的长度因该就是 $(i-1)-(j-1)$ 了，因为我们假设了第 $i-1$ 个数是第二个序列末尾，那么 $dp_{i-1,i-j}$ 又可以被解释为<strong>第二个序列的末尾为 $i-1$ 个数且第二个序列的长度为 $i-j$ 的时候第一个序列的末尾的最小值</strong> ，如果这个最小值小于 $a_i$ ，说明 $a_i$ 可以接到第一个序列前面，那么这个时候第二个序列的末尾为 $a_{i-1}$ ，显然又有转移：</p><script type="math/tex; mode=display">dp_{i,j}=min(dp_{i,j},a_{i-1}) \ \ \ (a_i>dp_{i-1,i-j})</script><p>开始的时候我们将 $dp$ 数组赋成极大值，然后最后判断一下 $dp_{n,n/2}$ 这个状态变小没有就好。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;IN(n);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    a[<span class="number">0</span>]=f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i&amp;&amp;j&lt;=n/<span class="number">2</span>;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i<span class="number">-1</span>]) f[i][j]=min(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;f[i<span class="number">-1</span>][i-j]) f[i][j]=min(f[i][j],a[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> f[n][n/<span class="number">2</span>]&lt;<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">puts</span>(solve()?<span class="string">"Yes!"</span>:<span class="string">"No!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这道题的确很绕……=。=</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示&lt;strong&gt;第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立&lt;/strong&gt; ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HEOI2013]SAO  组合数学+树形DP  luoguP4099</title>
    <link href="http://qiulyblog.github.io/2019/05/06/%5B%E9%A2%98%E8%A7%A3%5DluoguP4099/"/>
    <id>http://qiulyblog.github.io/2019/05/06/[题解]luoguP4099/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-05-06T10:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：<a href="https://www.luogu.org/problemnew/show/P4099" target="_blank" rel="noopener">转送门😄</a> 。</p><p>我们先不考虑边的权值(&lt;与&gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&lt;,&gt;) ，我们分类讨论即可。</p><p>首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢<a id="more"></a>，对于一个 $u$ 的儿子 $v$ ，我们虽然知道 $u$ 和 $v$ 的攻克的前后关系，但是合并答案貌似并不好合并。这个时候我们增加一维 $j$ ，$f_{u,j}$ 表示 $u$ 的子树的所有合法拓扑序中 $u$ 在第 $j$ 位上的总状态数。</p><p>也就是说，对于一个必须在 $u$ 前面攻克的关卡 $v$ ，我们考虑枚举一个 $j$ ，$v$ 子树中 $j$ 个结点在合并 $u,v$ 后放到 $u$ 前面，另外 $sz_v-j$ 个放到 $u$ 后面，然后枚举一个 $k$ ，表示当前的 $v$ 排在 $v$ 子树的拓扑序中的第 $k$ 位，只有 $k\leq j$ 的时候 $v$ 才可以转移 $u$ ，因为这个时候 $v$ 在 $u$ 前面。</p><p>现在再来考虑$“$ $j$ 个结点放在 $u$ 前面 $”$ 的方案数和$“$ $sz_v-j$ 个结点放在 $u$ 后面的方案数$”$，这个显然可以用组合数算，合并 $v$ 的子树后，$u$ 的排名从 $i$ 变成了 $i+j$ ，也就是说我们需要将 $j$ 个乱序插入到 $u$ 前面 $i+j-1$ 个数中，方案数显然为 $C_{i+j-1}^{j}$ ，那么现在总节点数显然为 $sz_u+sz_v$ (现在 $sz_u$ 和 $sz_v$ 还没有并在一起) ，$u$ 后面理所当然有 $sz_u+sz_v-i-j$ 个位置，将 $sz_v-j$ 个数插进去的方案数显然为 $C_{sz_u+sz_v-i-j}^{sz_v-j}$ 个，这两个数再乘上 $f_{u,i}$ 和 $f_{v,k}$ 就好了，这一次合并后 $u$ 的位置显然到了 $i+j$ ，所以 $f_{u,i+j}$ 显然要加上这一组贡献。</p><p>经整理后的转移方程如下：</p><script type="math/tex; mode=display">pls(f_{u,i+j},f_{u,i}\cdot f_{v,k}\cdot C_{i+j-1}^{j}\cdot C_{sz_u+sz_v-i-j}^{sz_v-j})</script><p>代码就是这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span> to sz[u]</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span> to sz[v]</span><br><span class="line">        <span class="keyword">for</span> k=<span class="number">1</span> to j</span><br><span class="line">            pls(f[u][i+j],f[u][i]*f[v][k]*C[i+j<span class="number">-1</span>][j]*C[sz[u]+sz[v]-i-j][sz[v]-j])</span><br></pre></td></tr></table></figure><p>这是 $n^3$ 的，过不去。考虑前缀和优化，几下 $f_v$ 的前缀和，最后的一层循环就可以直接丢掉了。</p><p>这个就是 $v$ 要在 $u$ 前面的情况，$u$ 在 $v$ 前面的情况和这个差不多，不过转移的时候 $j$ 就要从 $0$ 开始了，因为那个时候 $u$ 前面是可以不多放任何东西的，还有就是 $u$ 在 $v$ 前面的时候注意 $k\geq j$ 时才可以转移 !</p><p>最后的答案就是 $\sum\limits_{i=1}^{n} f_{1,i}$ 啦。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to,val;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> C[N][N],f[N][N],pre[N][N],suf[N][N],sz[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[v],u,w^<span class="number">1</span>&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;=mod)x-=mod;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[u]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=head[u];l;l=G[l].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[l].to,w=G[l].val;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u);</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">if</span>(w) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=sz[v];++j)</span><br><span class="line">                    pls(g[i+j],<span class="number">1l</span>l*f[u][i]*pre[v][j]%mod*C[i+j<span class="number">-1</span>][j]%mod</span><br><span class="line">                    *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=sz[v];++j)</span><br><span class="line">                    pls(g[i+j],<span class="number">1l</span>l*f[u][i]*suf[v][j+<span class="number">1</span>]%mod*C[i+j<span class="number">-1</span>][j]%mod</span><br><span class="line">                    *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="built_in">memcpy</span>(f[u],g,<span class="keyword">sizeof</span>(g));</span><br><span class="line">    &#125;</span><br><span class="line">    pre[u][<span class="number">0</span>]=suf[u][sz[u]+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i) pre[u][i]=(pre[u][i<span class="number">-1</span>]+f[u][i])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sz[u];i&gt;=<span class="number">1</span>;--i) suf[u][i]=(suf[u][i+<span class="number">1</span>]+f[u][i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head)),cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> n;IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;<span class="keyword">char</span> sign;</span><br><span class="line">        IN(u),sign=getchar(),IN(v);</span><br><span class="line">        add(u+<span class="number">1</span>,v+<span class="number">1</span>,sign==<span class="string">'&lt;'</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) pls(ans,f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*预处理组合数*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N<span class="number">-2</span>;++i) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N<span class="number">-2</span>;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人会问，如果 $u$ 的儿子 $v$ 下面的边全都是 $&gt;$ ，并且 $u$ 连向 $v$ 的边也是 $&gt;$ ，那么这个时候 $v$ 以及其子树的所有点都必须在 $u$ 前面完成，在转移的时候为什么可以 $“$ 提出 $j$ 个结点放到 $u$ 前面 $”$ 呢？</p><p>其实想想就可以明白，在向上统计答案的时候对于一个 $v$ 的儿子 $a$ ，我们只统计了合并后 $a$ 在 $v$ 前面的情况，同样在 $u$ 统计 $v$ 时也只是统计了合并后 $v$ 在 $u$ 前面的情况，所有我们也只是统计了 $“$ $a$ 在 $v$ 前面且 $v$ 在 $u$ 前面 $”$ 的情况，所有被统计的情况一定是合法的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4099&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转送门😄&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;我们先不考虑边的权值(&amp;lt;与&amp;gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&amp;lt;,&amp;gt;) ，我们分类讨论即可。&lt;/p&gt;
&lt;p&gt;首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="树形DP" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】  [HAOI2018]苹果树  组合数学  loj2526</title>
    <link href="http://qiulyblog.github.io/2019/05/05/%5B%E9%A2%98%E8%A7%A3%5Dloj2526/"/>
    <id>http://qiulyblog.github.io/2019/05/05/[题解]loj2526/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-06T05:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的题目，可爱的传送门：<a href="https://loj.ac/problem/2526" target="_blank" rel="noopener">戳这呢=￣ω￣=</a></p><p>刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。</p><p>我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。</p><a id="more"></a><p>易知节点数为 $n$ 的二叉树的总形态数为 $n!$ ，而且 $i$ 子树下的所有节点的编号一定要大于 $i$ ，我们考虑”先将 $i$ 子树构造出来再填入节点”的过程，子树的形态数显然为 $j!$ ，然后我们只能选剩下的 $n-i$ 个节点(编号要比 $i$ 大) ，填入剩下的 $j-1$ 个位置( $i$ 占了一个位置) ，显然这样的方案数为 $C_{n-i}^{j-1}$ 。</p><p>这样的一个 $i$ ，其子树大小为 $j$ ，那么它可以做出多少贡献呢？考虑 $fa_i \Rightarrow i$ 这条边会经过多少次，显然是 $j\cdot(n-j)$ 次( $j$ 为子树节点个数，$n-j$ 为上面的节点个数) ，也就是说这样的方案可以造成 $j\cdot (n-j)$ 的贡献。</p><p>那么现在 $i$ 的子树得到确定了，我们将 $i$ 以及其子树看做一个点，我们考虑 $1$ 到 $i$ 这些节点，它们可以以任意形态组成一棵树，方案数是 $i!$ 。</p><p>接着我们需要将剩下的 $n-j-(i-1)$ 个节点挂到树上去。对于第 $i$ 个挂到树上的点，它有 $i$ 个位置可以挂。但是因为 $i$ 一定要占一个位置，所以这个节点只有 $i-1$ 个位置可以挂了，第二个多出来的节点就有 $i$ 个位置可以挂……第 $k$ 个显然有 $i-2+k$ 个位置可以挂。也就是说这些点挂上去的总方案数为 $\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 。</p><p>将上面的乘起来就是这一组 $i,j$ 对答案造成的贡献了：</p><script type="math/tex; mode=display">j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)</script><p>$\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 比较不好计算，但是简单的变化后发现这个是和 $(n-j-1)!/(i-2)!$ 等价的，我们带进原式子。</p><script type="math/tex; mode=display">j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot(n-j-1)!/(i-2)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i\cdot (i-1)\cdot(n-j-1)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot i\cdot (i-1)\cdot (n-j)!</script><p>这样就很好算了，我们预处理组合数和阶乘，上面的式子 $O(1)$ 算~</p><p>代码很短。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,ans,fac[N],C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x+=y;x%=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(p);</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;++j)</span><br><span class="line">            pls(ans,(ll)fac[j]*fac[n-j]%p*C[n-i][j<span class="number">-1</span>]%p*(i*(i<span class="number">-1</span>))%p*j%p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有趣的题目，可爱的传送门：&lt;a href=&quot;https://loj.ac/problem/2526&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳这呢=￣ω￣=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。&lt;/p&gt;
&lt;p&gt;我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [六省联考2017]分手是祝愿  概率DP  loj2145</title>
    <link href="http://qiulyblog.github.io/2019/05/05/%5B%E9%A2%98%E8%A7%A3%5Dloj2145/"/>
    <id>http://qiulyblog.github.io/2019/05/05/[题解]loj2145/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-05T02:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>概率神仙题的传送门：<a href="https://loj.ac/problem/2145" target="_blank" rel="noopener"><del>别戳偏了</del></a></p><p>设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程：</p><script type="math/tex; mode=display">f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})</script><p>因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。</p><a id="more"></a><script type="math/tex; mode=display">f_i=\frac{i}{n}+1\cdot (1+f_i+f_{i+1})-\frac{i}{n}\cdot (1+f_i+f_{i+1})\\\\f_i=\frac{i}{n}+1+f_i+f_{i+1}-\frac{i}{n}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\f_i=1+f_i+f_{i+1}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\\frac{i}{n}f_i=1+f_{i+1}-\frac{i}{n}f_{i+1}\\\\f_i=\frac{1+f_{i+1}-\frac{i}{n}f_{i+1}}{\frac{i}{n}}\\\\f_i=\frac{n\cdot(1+f_{i+1})-i\cdot f_{i+1}}{i}\\\\f_i=\frac{n+(n-i)\cdot f_{i+1}}{i}\\\\f_i=1+\frac{(n-i)\cdot (f_{i+1}+1)}{i}</script><p>预处理逆元就可以直接计算了，记得最后乘上 $n!$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,step,a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,f[N],inv[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    inv[<span class="number">0</span>]=<span class="number">0</span>,inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) inv[i]=(<span class="keyword">long</span> <span class="keyword">long</span>)(p-p/i)*inv[p%i]%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i) g[j].push_back(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) <span class="keyword">if</span>(a[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[i].size();++j) a[g[i][j]]^=<span class="number">1</span>;</span><br><span class="line">        ++step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(step&lt;=k) ans=step;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">1</span>;--i) f[i]=(<span class="number">1l</span>l+(<span class="number">1l</span>l*n-i)*(f[i+<span class="number">1</span>]+<span class="number">1</span>)*inv[i])%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&gt;k;--i) ans=(ans+f[i])%p;</span><br><span class="line">        ans=(ans+k)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans=(<span class="number">1l</span>l*i*ans)%p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;概率神仙题的传送门：&lt;a href=&quot;https://loj.ac/problem/2145&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;del&gt;别戳偏了&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})&lt;/script&gt;&lt;p&gt;因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SCOI2014]方伯伯的玉米田  树状数组优化DP  luoguP3287</title>
    <link href="http://qiulyblog.github.io/2019/05/04/%5B%E9%A2%98%E8%A7%A3%5DluoguP3287/"/>
    <id>http://qiulyblog.github.io/2019/05/04/[题解]luoguP3287/</id>
    <published>2019-05-03T16:00:00.000Z</published>
    <updated>2019-05-05T02:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>以后不要被这种傻逼题给蒙骗了。传送门：<a href="https://www.luogu.org/problemnew/show/P3287" target="_blank" rel="noopener">方伯伯的传送门=。=</a></p><p>首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。</p><p>设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程：</p><a id="more"></a><script type="math/tex; mode=display">f_{i,j}=\max\{f_{k,l}+1\} \ \ (k<i,l\leq j,h_i+j\geq h_k+l)</script><p>可能有人会问为什么 $l\leq j$ ，很显然就是上面的道理，越大的 $i$ 一定拔高次数是单调不减的。</p><p>发现上面的转移其实是 $O(n^2k^2)$ 的，万恶的出题人不会给这个复杂度一丁点分……这个时候用树状数组优化转移，发现上面有三个限制条件，我们正着枚举 $i$ ，就已经满足第一个条件了，因为这个时候树状数组中的都是小于 $i$ 的 $k$ 。然后将每个点按照 $(j+1,h_i+j)$ 放到平面上，然后树状数组统计答案即可。</p><p>树状数组维护的是 $\max$  ，不是和。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],n,k,mx;</span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line">    <span class="keyword">int</span> c[N][<span class="number">5009</span>+K];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">const</span> <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;=mx+k;x+=(x&amp;-x))<span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&lt;=k+<span class="number">1</span>;i+=(i&amp;-i))</span><br><span class="line">                c[x][i]=max(c[x][i],v); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x;x-=(x&amp;-x))<span class="keyword">for</span>(<span class="keyword">int</span> i=y;i;i-=(i&amp;-i))</span><br><span class="line">                ans=max(ans,c[x][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> BIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),mx=max(mx,a[i]);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k;~j;--j) &#123;</span><br><span class="line">            <span class="keyword">int</span> res=query(a[i]+j,j+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            ans=max(ans,res),update(a[i]+j,j+<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以后不要被这种傻逼题给蒙骗了。传送门：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3287&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;方伯伯的传送门=。=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。&lt;/p&gt;
&lt;p&gt;设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="树状数组" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="二维树状数组" scheme="http://qiulyblog.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SHOI2014]概率充电器  概率DP  loj2192</title>
    <link href="http://qiulyblog.github.io/2019/05/02/%5B%E9%A2%98%E8%A7%A3%5Dloj2192/"/>
    <id>http://qiulyblog.github.io/2019/05/02/[题解]loj2192/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-05T02:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>传送门在这：<a href="https://loj.ac/problem/2192" target="_blank" rel="noopener">我是传送门$QwQ$</a></p><p>其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。</p><p>因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。</p><a id="more"></a><p>枚举每一个儿子，对于这个儿子只有两种情况：该儿子没有通上电，该儿子通上电了且传送失败。两种情况的概率都很好算。我们可以列出转移方程：</p><script type="math/tex; mode=display">f_u=(1-q_u)\cdot \prod (f_v+(1-f_v)\cdot(1-G_i.p))</script><p>其中 $(1-q_u)$ 显然为该点本身不通电的概率，然后枚举儿子 $v$ ，$f_v$ 就是该儿子本来就没有通上电的概率，$(1-f_v)\cdot(1-G_i.p)$ 就是通上电的传送失败(注：$G_i.p$ 是当前连接 $u,v$ 的边的通电概率) 。</p><p>那么如何计算父亲传来的电呢？设 $g_i$ 表示点 $i$ 的父亲没有向点 $i$ 通电的概率。计算一下父节点不通电的概率，注意不要计算上该儿子的贡献，不然会乱。计算完不通电的概率后分上面两种情况讨论即可。</p><script type="math/tex; mode=display">res=g_u\cdot f_v / (f_v+(1-f_v)\cdot(1-G_i.p))\\\\g_v=res+(1-res)\cdot(1-G_i.p)</script><p>两边 $dfs$ 就可以搞定。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans,f[N],g[N],q[N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,n,tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to;<span class="keyword">double</span> p;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> p)</span> </span>&#123;G[++cnt]=(Edge)&#123;head[x],y,p&#125;,head[x]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[u]=<span class="number">1</span>-q[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>((v=G[i].to)!=fa)</span><br><span class="line">            dfs1(v,u),f[u]*=(f[v]+(<span class="number">1</span>-f[v])*(<span class="number">1</span>-G[i].p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>((v=G[i].to)!=fa) &#123;</span><br><span class="line">            <span class="keyword">double</span> res=g[u]*f[u]/(f[v]+(<span class="number">1</span>-f[v])*(<span class="number">1</span>-G[i].p));</span><br><span class="line">            g[v]=res+(<span class="number">1</span>-res)*(<span class="number">1</span>-G[i].p);dfs2(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,p;IN(x),IN(y),IN(p);</span><br><span class="line">        add(x,y,p/<span class="number">100.0</span>),add(y,x,p/<span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) IN(x),q[i]=x/<span class="number">100.0</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1.0</span>,dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans+=<span class="number">1</span>-f[i]*g[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门在这：&lt;a href=&quot;https://loj.ac/problem/2192&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我是传送门$QwQ$&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。&lt;/p&gt;
&lt;p&gt;因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2015]寿司晚宴  状压DP  loj2131</title>
    <link href="http://qiulyblog.github.io/2019/05/01/%5B%E9%A2%98%E8%A7%A3%5Dloj2131/"/>
    <id>http://qiulyblog.github.io/2019/05/01/[题解]loj2131/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-05T01:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。</p><p>设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mul=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,s[N];ll p,f[<span class="number">2</span>][mul][mul];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(ll&amp;x,ll&amp;y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;p)x-=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">// freopen("1.out","w",stdout);</span></span><br><span class="line">    IN(n),IN(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;++j)</span><br><span class="line">            <span class="keyword">if</span>(!(i%pri[j])) s[i]|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now=i&amp;<span class="number">1</span>,lst=!now;</span><br><span class="line">        <span class="built_in">memcpy</span>(f[now],f[lst],<span class="keyword">sizeof</span>(f[lst]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;mul;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;mul;++s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[lst][s1][s2]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;s[i])) pls(f[now][s1|s[i]][s2],f[lst][s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;s[i])) pls(f[now][s1][s2|s[i]],f[lst][s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;mul;++s1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;mul;++s2) pls(ans,f[n&amp;<span class="number">1</span>][s1][s2]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以知道 $n\leq 500$ 的时候，每一个数最多带上一个大于等于 $23$ 的质因子。我们首先将所有的寿司分为两类：带了大于等于 $23$ 的质因子的和没带的。</p><p>没带的显然可以向上面那样转移。那么带了的呢？这个显然不能压缩吧。</p><p>我们考虑将带了同样的大于等于 $23$ 的质因子的分成一组，这一组要不小 $\rm{G}$ 吃小 $\rm{W}$ 不吃，要不小 $\rm{W}$ 吃小 $G$ 不吃。分别讨论即可。</p><p>设 $f1[s1][s2]$ 表示这一组是小 $\rm{G}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。同理，设 $f2[s1][s2]$ 表示这一组是小 $\rm{W}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。分别转移就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i) &#123; <span class="comment">/*枚举这些寿司*/</span></span><br><span class="line">    <span class="keyword">if</span>(a[i].t!=a[i<span class="number">-1</span>].t) <span class="comment">/*大质因子不同了*/</span></span><br><span class="line">        <span class="built_in">memcpy</span>(f1,f,<span class="keyword">sizeof</span>(f)),<span class="built_in">memcpy</span>(f2,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">        <span class="comment">/*倒着枚举所以没用滚动数组*/</span></span><br><span class="line">        <span class="comment">/*所谓的分别转移*/</span></span><br><span class="line">        <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]);</span><br><span class="line">        <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这一组结束了，需要合并答案*/</span></span><br><span class="line">    <span class="keyword">if</span>(a[i].t!=a[i+<span class="number">1</span>].t||i==n)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2)</span><br><span class="line">            <span class="comment">/*因为f1[s1][s2]和f2[s1][s2]都重复算了一遍原来的</span></span><br><span class="line"><span class="comment">            f[s1][s2]，所以减掉后再取膜*/</span></span><br><span class="line">            f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">ll p,f[M][M],f1[M][M],f2[M][M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> t,s;&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span> </span>&#123;<span class="keyword">return</span> a.t&lt;b.t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(ll&amp;x,ll&amp;y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;=p)x%=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;IN(n),IN(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        a[i].t=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;++j)<span class="keyword">if</span>(!(i%pri[j])) &#123;</span><br><span class="line">            a[i].s|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>),a[i].t/=pri[j];</span><br><span class="line">            <span class="keyword">while</span>(!(a[i].t%pri[j])) a[i].t/=pri[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    sort(a+<span class="number">2</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[pos].t==<span class="number">1</span>) ++pos;--pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=pos;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f[s1|a[i].s][s2],f[s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f[s1][s2|a[i].s],f[s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].t!=a[i<span class="number">-1</span>].t)</span><br><span class="line">            <span class="built_in">memcpy</span>(f1,f,<span class="keyword">sizeof</span>(f)),<span class="built_in">memcpy</span>(f2,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i].t!=a[i+<span class="number">1</span>].t||i==n)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2)</span><br><span class="line">                f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2) pls(ans,f[s1][s2]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans+p)%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。&lt;/p&gt;
&lt;p&gt;设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状态压缩" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [JSOI2016]灯塔  决策单调性&amp;DP  loj2074</title>
    <link href="http://qiulyblog.github.io/2019/04/30/%5B%E9%A2%98%E8%A7%A3%5Dloj2047/"/>
    <id>http://qiulyblog.github.io/2019/04/30/[题解]loj2047/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2019-05-05T01:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：<a href="https://loj.ac/problem/2074" target="_blank" rel="noopener">在这呢o(￣︶￣)o</a></p><p>刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了：</p><script type="math/tex; mode=display">h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}</script><p>设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续：</p><a id="more"></a><script type="math/tex; mode=display">f_i=\max\{ h_j +\sqrt{|i−j|}\}-h_i</script><p>发现绝对值很烦人，将绝对值拆开。</p><script type="math/tex; mode=display">f_i=\max(\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\},\max\limits_{j=i}^{n}\{h_j +\sqrt{j-i}\})-h_i</script><p>原序列翻转一下就可以直接计算后面的式子，也就是说我们只需要考虑第一个：</p><script type="math/tex; mode=display">f_i=\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\}-h_i</script><p>假设对于 $i$ 来说 $j$ 是最优的决策，那么如果存在一个小于 $j$ 的 $k$ ，是否在转移一个大于 $i$ 的 $l$ 会更优呢？显然不会，可以知道 $i-k$ 显然是大于 $i-j$ 的，而且根号是增长的越来越慢的。所以如果在 $i$ 时 $k$ 就没有 $j$ 优了，那么在以后所以大于 $i$ 的 $l$ 转移时 $k$ 也不可能比 $j$ 优。</p><p>也就是说上面的式子满足决策单调性，那么我们可以 $O(n\log n)$ 愉快求出了。</p><p>这里说明两个方法：</p><ul><li><strong>1.</strong> 单调队列维护三元组，三元组包含 $v$ (决策点 $v$) ，$l$ (决策点 $v$ 作为最优决策点的最左端点) ，$r$ (决策点 $v$ 作为最优决策点的最右端点) ，每一次排除掉最右端点小于 $i$ 的元素(因为该元素已经没用了) ，插入队列的时候去掉完全劣于 $i$ 的，然后对于折中的二分即可。(具体参见诗人小 $\rm{G}$ 的题解) 。</li><li><strong>2.</strong> 分治计算答案。设 $slove(al,ar,vl,vr)$ 表示在原数组 $al$ 到 $ar$ 这段区间的最优决策点位于 $vl$ 到 $vr$ 区间。我们每一次找到 $al$ 到 $ar$ 的中间点，也就是 $mid$ ，然后在 $vl$ 到 $vr$ 寻找最优的决策点更新 $f_{mid}$ ( $\rm{DP}$ 数组)，设这个最优点为 $g$ 。因为满足决策单调性，$al$ 到 $mid-1$ 的所有点的最优决策点一定在 $vl$ 到 $g$ 之间，右边 $mid+1$ 到 $ar$ 的也同理，就这么分治下去即可。</li></ul><p>实际运用中分治的效率不如三元组，但是代码却好写得多，很短，并且调试难度也大大降低，所以最终我选择了分治……分治的具体细节看代码。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;ll a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> f1[N],f2[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f1</span><span class="params">(<span class="keyword">int</span> al,<span class="keyword">int</span> ar,<span class="keyword">int</span> vl,<span class="keyword">int</span> vr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(al&gt;ar) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(al+ar)&gt;&gt;<span class="number">1</span>,g=<span class="number">0</span>;</span><br><span class="line">    f1[mid]=a[mid];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vl;i&lt;=min(vr,mid);++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> calc=a[i]+<span class="built_in">sqrt</span>(<span class="keyword">double</span>(mid-i));</span><br><span class="line">        <span class="keyword">if</span>(calc&gt;f1[mid]) f1[mid]=calc,g=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mid;f1[mid]-=a[mid];</span><br><span class="line">    solve_f1(al,mid<span class="number">-1</span>,vl,g),solve_f1(mid+<span class="number">1</span>,ar,g,vr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f2</span><span class="params">(<span class="keyword">int</span> al,<span class="keyword">int</span> ar,<span class="keyword">int</span> vl,<span class="keyword">int</span> vr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(al&gt;ar) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(al+ar)&gt;&gt;<span class="number">1</span>,g=<span class="number">0</span>;</span><br><span class="line">    f2[mid]=a[mid];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vr;i&gt;=max(vl,mid);--i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> calc=a[i]+<span class="built_in">sqrt</span>(<span class="keyword">double</span>(i-mid));</span><br><span class="line">        <span class="keyword">if</span>(calc&gt;f2[mid]) f2[mid]=calc,g=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mid;f2[mid]-=a[mid];</span><br><span class="line">    solve_f2(al,mid<span class="number">-1</span>,vl,g),solve_f2(mid+<span class="number">1</span>,ar,g,vr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    solve_f1(<span class="number">1</span>,n,<span class="number">1</span>,n),solve_f2(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line">    <span class="comment">/*最终没有翻转序列，而是选择做两遍分治*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ll)<span class="built_in">ceil</span>(max(f1[i],f2[i])));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：&lt;a href=&quot;https://loj.ac/problem/2074&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在这呢o(￣︶￣)o&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}&lt;/script&gt;&lt;p&gt;设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
      <category term="分治" scheme="http://qiulyblog.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2016]国王饮水记  斜率优化DP  loj2087</title>
    <link href="http://qiulyblog.github.io/2019/04/29/%5B%E9%A2%98%E8%A7%A3%5Dloj2087/"/>
    <id>http://qiulyblog.github.io/2019/04/29/[题解]loj2087/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-29T13:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>可爱的题目传送门：<a href="https://loj.ac/problem/2087" target="_blank" rel="noopener">戳我戳我·(<em>╹▽╹</em>)·</a></p><p>说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧……</p><ul><li><strong>1.</strong> 初始水位小于 $h_1$ 的没有用。</li></ul><p>这很显然。</p><a id="more"></a><ul><li><strong>2.</strong> 如果 $n\leq k$ ，那么只需要将所以大于 $h_1$ 的跟 $1$ 城市连就好了。</li></ul><p>每次连接的城市数越少贡献越大，那么每个逐一连一次一定是最优方案。</p><ul><li><strong>3.</strong> 每次操作必然跟 $1$ 城市有关系。</li></ul><p>不然没贡献。</p><ul><li><strong>4.</strong> 除了 $1$ 号城市，其他每个城市最多连一次。</li></ul><p>因为连过一次的城市的水位已经和 $1$ 城市一样了，简单点说肯定就是废了。</p><ul><li><strong>5.</strong> 每次连的所有城市中最小的 $h_i$ 必然大于上一次链接的最大的 $h_i$ 。</li></ul><p>这很显然，不然不满足最优方案。</p><ul><li><strong>6.</strong> 将所以城市按水位排序后，每次选择的必然是连续一段区间。</li></ul><p>和上一个差不多。</p><ul><li><strong>7.</strong> 每次选择的区间必然和上一次的选择区间接触。</li></ul><p>这很显然。</p><ul><li><strong>8.</strong> 每次选择的区间的长度必定单调不增。</li></ul><p>满足最优，都说了每次连接的城市越少贡献越大。</p><hr><p>那么显然就变成了一个区间问题了，我们需要将这个区间分成若干块。</p><p>设 $f_{i,j}$ 表示排序后前 $i$ 个城市联通了 $j$ 次后 $1$ 号城市的最大水位高度。那么转移直接枚举一个 $k$ ，在新的一次连接中连接了 $k+1$ 到 $i$ 这些城市。转移方程显然：</p><script type="math/tex; mode=display">f_{i,j}=\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1}</script><p>*注：$s_i$ 为前缀和。</p><p>上式的复杂度为 $O(n^2k)$  ，肯定爆炸。但是这个是可以<strong>斜率优化</strong>的：</p><script type="math/tex; mode=display">\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1} =\frac{s_i-(s_k-f_{k,j-1})}{i-(k-1)}\Rightarrow \frac{Y(i)-Y(k)}{X(i)-X(k)}</script><p>然后通过第 $8$ 条性质可以得知 $\texttt{DP}$ 是有<strong>决策单调性</strong>的，故复杂度为 $O(nk)$ 。因为恶心的高精度小数的运算还需要 $O(p)$ 的复杂度，所以最终总时间复杂度为 $O(nkp)$ 。</p><p>我们发现 $k$ 有 $10^9$ ，所以复杂度带 $k$ 的一定假掉了。</p><p>那么观察第 $2$ 条性质会发现，如果 $k$ 大于 $n$ 了直接将 $k$ 设为 $n$ 就好了。也就是说复杂度应该为 $O(n^2p)$ ，这样就是 $86$ 分，通过数据来看会发现这个倾向于大众分，一车厢的人都是这个分数。</p><p>那么如果想要 $\texttt{AC}$ 的话需要最后一条很迷的性质：</p><ul><li><strong>9.</strong> 因为 $h$ 各不同，选择的区间最多只有 $14$ 个区间长度大于 $1$ ，其他的区间均等于 $1$ 。</li></ul><p>很迷，准确的说这样的区间是 $O(\log\frac{nh}{\min_i\{h_i-h_{i-1}\}})$ 个。</p><p>证明不会……但是这里写了证明(唯一的且很迷的证明)：<a href="https://github.com/qiulyblog/image/blob/master/[NOI2016]%E5%9B%BD%E7%8E%8B%E9%A5%AE%E6%B0%B4%E8%AE%B0%E9%A2%98%E8%A7%A3.pdf?raw=true" target="_blank" rel="noopener">哈哈我是传送门O(∩_∩)O</a></p><p>那么就丢代码了，实际上是需要高精小数的，这里先给出一个除去高精小数板子的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">8e3</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Decimal ans;</span><br><span class="line"><span class="keyword">int</span> n,k,p,lim,h[N],s[N],pre[N][<span class="number">16</span>],tot;</span><br><span class="line"><span class="keyword">int</span> q[N],head,tail;</span><br><span class="line"><span class="keyword">double</span> f[N][<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span><span class="keyword">double</span> x,y;&#125;t[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(point a,point b)</span> </span>&#123;<span class="keyword">return</span> (a.y-b.y)/(a.x-b.x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Decimal <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!j) <span class="keyword">return</span> h[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> (solve(pre[i][j],j<span class="number">-1</span>)+s[i]-s[pre[i][j]])/(i-pre[i][j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;k,&amp;p,&amp;h[tot=<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;h[i]);</span><br><span class="line">        <span class="keyword">if</span>(h[i]&gt;h[<span class="number">1</span>]) h[++tot]=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    n=tot;sort(&amp;h[<span class="number">1</span>],&amp;h[n+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i][<span class="number">0</span>]=h[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]=s[i<span class="number">-1</span>]+h[i];</span><br><span class="line">    k=min(k,n),lim=min(k,<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lim;++j) &#123;</span><br><span class="line">        q[head=tail=<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t[i]=(point)&#123;i<span class="number">-1</span>,s[i]-f[i][j<span class="number">-1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            point now=(point)&#123;i,s[i]&#125;;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(now,t[q[head]])&lt;slope(now,t[q[head+<span class="number">1</span>]])) ++head;</span><br><span class="line">            f[i][j]=(f[q[head]][j<span class="number">-1</span>]+s[i]-s[q[head]])/(i-q[head]+<span class="number">1</span>);</span><br><span class="line">            pre[i][j]=q[head];</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(t[q[tail]],t[q[tail<span class="number">-1</span>]])&gt;slope(t[q[tail]],t[i])) --tail;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=n-k+lim,pos;</span><br><span class="line">    <span class="keyword">double</span> mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i) </span><br><span class="line">        <span class="keyword">if</span>(f[m][i]&gt;mx) mx=f[m][i],pos=i;</span><br><span class="line">    ans=solve(m,pos);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=n;++i) ans=(ans+h[i])/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans.to_string(p&lt;&lt;<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么高精度小数板子的下载链接就贴这了：<a href="https://loj.ac/problem/2087/download/additional_file" target="_blank" rel="noopener">$loj$ 的下载地址传送们(～￣▽￣)～</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可爱的题目传送门：&lt;a href=&quot;https://loj.ac/problem/2087&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳我戳我·(&lt;em&gt;╹▽╹&lt;/em&gt;)·&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1.&lt;/strong&gt; 初始水位小于 $h_1$ 的没有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这很显然。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 小谈斜率优化</title>
    <link href="http://qiulyblog.github.io/2019/04/28/%5B%E7%AE%97%E6%B3%95%5D%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://qiulyblog.github.io/2019/04/28/[算法]斜率优化/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-05-07T06:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="在此输入你的密码以便阅读全文" />    <label for="pass">在此输入你的密码以便阅读全文</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本文为加密文章，阅读本文需要输入密码。
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="算法" scheme="http://qiulyblog.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2015]亚瑟王  概率DP  loj2112</title>
    <link href="http://qiulyblog.github.io/2019/04/28/%5B%E9%A2%98%E8%A7%A3%5Dloj2112/"/>
    <id>http://qiulyblog.github.io/2019/04/28/[题解]loj2112/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-29T13:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现 <a href="https://loj.ac" target="_blank" rel="noopener">$loj$</a> 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。</p><p>顺便贴一下题目传送门：<a href="https://loj.ac/problem/2112" target="_blank" rel="noopener">$loj$的传送门就戳我啦(～￣▽￣)～</a></p><p>概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。</p><a id="more"></a><p>第一种情况：$j$ 轮中都没有打出第 $i+1$ 张牌，由于一轮中不打出第 $i+1$ 张牌的概率为 $1-p_i$ ，那么 $j$ 轮都不打出该牌的概率显然为 $(1-p_i)^j$ 。转移方程显然：</p><script type="math/tex; mode=display">f_{i+1,j}+=f_{i,j}\cdot (1-p_i)^j​</script><p>因为 $f_{i+1,j}$ 可能从多方向转移过来，所以是 $+=$ 。</p><p>第二种情况：$j$ 轮中至少有一轮打出了第 $i+1$ 张牌，概率显然为 $1-(1-p_i)^j$ ，转移也就很显然了：</p><script type="math/tex; mode=display">f_{i+1,j-1}+=f_{i,j}\cdot （1-(1-p_i)^j）</script><p>如果我们打出了第 $i+1$ 张牌，那么肯定是要计算贡献的，这个时候直接用这个概率算贡献就好了。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,r,d[N];</span><br><span class="line"><span class="keyword">double</span> f[N][N],p[N],pw[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>,&amp;p[i],&amp;d[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            pw[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=r;++j) pw[i][j]=pw[i][j<span class="number">-1</span>]*(<span class="number">1</span>-p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][r]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=r;++j) &#123;</span><br><span class="line">                f[i+<span class="number">1</span>][j]+=f[i][j]*pw[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j) &#123;</span><br><span class="line">                    <span class="keyword">double</span> calc=f[i][j]*(<span class="number">1</span>-pw[i+<span class="number">1</span>][j]);</span><br><span class="line">                    f[i+<span class="number">1</span>][j<span class="number">-1</span>]+=calc,ans+=calc*d[i+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现 &lt;a href=&quot;https://loj.ac&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$loj$&lt;/a&gt; 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。&lt;/p&gt;
&lt;p&gt;顺便贴一下题目传送门：&lt;a href=&quot;https://loj.ac/problem/2112&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$loj$的传送门就戳我啦(～￣▽￣)～&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [CEOI2017]Building Bridges 斜率优化DP loj2483</title>
    <link href="http://qiulyblog.github.io/2019/04/27/%5B%E9%A2%98%E8%A7%A3%5Dloj2483/"/>
    <id>http://qiulyblog.github.io/2019/04/27/[题解]loj2483/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-04-29T13:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>愉快的推式子吧(ﾉ≧∀≦)ﾉ！</p><p>设 $f_i$ 表示前 $i$ 根柱子完工后的最小代价。枚举一个小于 $i$ 的 $j$ ，表示为从 $j$ 向 $i$ 连了一座桥，中间的柱子当然全部推掉，计算一下就好：</p><script type="math/tex; mode=display">f_i=\min\{f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\}</script><p>*其中 $s$ 为 $w$ 的前缀和。</p><a id="more"></a><script type="math/tex; mode=display">f_i=f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\\\\f_i=f_j+s_{i-1}-s_j+h_i^2+h_j^2-2h_ih_j\\\\f_j+s_{i-1}-s_j+h_i^2+h_j^2=2h_ih_j+f_i</script><p>于是最终式子变成了 $y=kx+b$ 的形式，斜率优化！</p><p>但是……注意这个式子的 $k$ 不是单调递增的，并且 $x$ 也不是单调递增的！那么我们不能用朴素做法了，也不能用二分……难道用 $Splay$ ？(码量巨大) 。</p><p>不，用 $CDQ$ 分治。</p><p>对于一个 $i$ ，可能可以对 $i$ 做出贡献的只有所有小于 $i$ 的 $j$ 。为了保证 $x$ 单调我们先大力将原来的数组按照 $x$ 从小到大排个序，然后 $CDQ$ 的时候分左右两边，左边的所有元素在初始数组的位置都小于右边的左右元素，也就是说我们直接用左边元素对右边元素做出贡献。</p><p>同时这里也保证了左右两边的 $x$ 一定是单调上增的。</p><p>我们使用单调队列，扫一遍左边的元素，留下能做贡献的点(下凸壳上的点)，这时候左边的所有元素可以保证 $x$ 和斜率都是单调上增的。</p><p>右边呢？因为直线的斜率是 $2x$ ，而右边的 $x$ 也是单调上增的，所以我们可以愉快的做朴素的单调队列了。</p><p>$CDQ$ 分治部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;<span class="comment">/*一个点的时候直接计算y值*/</span></span><br><span class="line">        a[l].y=f[a[l].id]-s[a[l].id]+S(a[l].x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(a[i].id&lt;=mid) b[c1++]=a[i]; <span class="comment">/*编号小的左边去*/</span></span><br><span class="line">        <span class="keyword">else</span> b[c2++]=a[i]; <span class="comment">/*编号大些的右边去*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    CDQ(l,mid); <span class="comment">/*计算出左边所有元素的 f*/</span></span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i) &#123; <span class="comment">/*处理出左边所有元素组成的下凸壳*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail<span class="number">-1</span>],q[tail])&gt;slope(q[tail],i)) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;++i) &#123; <span class="comment">/*计算左边元素对右边元素产生的贡献*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*a[i].x) ++head; <span class="comment">/*维护队列*/</span></span><br><span class="line">        <span class="keyword">int</span> x=a[i].id,y=a[q[head]].id;</span><br><span class="line">        f[x]=min(f[x],f[y]+s[x<span class="number">-1</span>]-s[y]+S(a[i].x-a[q[head]].x));</span><br><span class="line">        <span class="comment">/*可能计算多次所以要取min*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i)  <span class="comment">/*还原a数组至初始状态*/</span></span><br><span class="line">        <span class="keyword">if</span>(c2&gt;r||(c1&lt;=mid&amp;&amp;a[c1].x&lt;a[c2].x)) b[i]=a[c1++];</span><br><span class="line">        <span class="keyword">else</span> b[i]=a[c2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数中</span></span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp),CDQ(<span class="number">1</span>,n); <span class="comment">/*排序后CDQ开始*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]); <span class="comment">/*输出*/</span></span><br></pre></td></tr></table></figure><p>最后因为存在 $0$ ，在计算斜率的时候需要特判一下。还需要注意一下 $long\ long$ 的问题，记得将 $f$ 数组初始化。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e18</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span><span class="keyword">int</span> x,id;ll y;&#125;a[N],b[N];</span><br><span class="line">ll s[N],w[N],f[N];<span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point x,point y)</span> </span>&#123;<span class="keyword">return</span> x.x&lt;y.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i].x==a[j].x) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[i].y&lt;a[j].y?inf:-inf;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="keyword">double</span>(a[i].y-a[j].y)/<span class="keyword">double</span>(a[i].x-a[j].x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;a[l].y=f[a[l].id]-s[a[l].id]+S(a[l].x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(a[i].id&lt;=mid) b[c1++]=a[i];</span><br><span class="line">        <span class="keyword">else</span> b[c2++]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    CDQ(l,mid);</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail<span class="number">-1</span>],q[tail])&gt;slope(q[tail],i)) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*a[i].x) ++head;</span><br><span class="line">        <span class="keyword">int</span> x=a[i].id,y=a[q[head]].id;</span><br><span class="line">        f[x]=min(f[x],f[y]+s[x<span class="number">-1</span>]-s[y]+S(a[i].x-a[q[head]].x));</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(c2&gt;r||(c1&lt;=mid&amp;&amp;a[c1].x&lt;a[c2].x)) b[i]=a[c1++];</span><br><span class="line">        <span class="keyword">else</span> b[i]=a[c2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        IN(a[i].x),a[i].id=i,f[i]=inf;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(w[i]),s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp),CDQ(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;愉快的推式子吧(ﾉ≧∀≦)ﾉ！&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示前 $i$ 根柱子完工后的最小代价。枚举一个小于 $i$ 的 $j$ ，表示为从 $j$ 向 $i$ 连了一座桥，中间的柱子当然全部推掉，计算一下就好：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\min\{f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\}&lt;/script&gt;&lt;p&gt;*其中 $s$ 为 $w$ 的前缀和。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2008]玩具装箱TOY  斜率优化DP  luoguP3195</title>
    <link href="http://qiulyblog.github.io/2019/04/24/%5B%E9%A2%98%E8%A7%A3%5DluoguP3195/"/>
    <id>http://qiulyblog.github.io/2019/04/24/[题解]luoguP3195/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-28T05:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>差不多搞懂了斜率优化吧……说实话网上的文章都写得很迷，还好找到了一个不错的文章：<a href="https://www.cnblogs.com/yangsongyi/p/9630227.html" target="_blank" rel="noopener">转送门戳我(￣▽￣)~*</a> 。(为什么突然发现这道题和诗人小G很像呢) </p><p>这个 $\texttt{DP}$ 方程谁都会设：设 $f_i$ 表示前 $i$ 个玩具的最小费用，转移显然如下：</p><script type="math/tex; mode=display">f_i=\min\limits_{j=1}^{i-1}\{f_j+(sum_i-sum_j+i-j-l)^2\}</script><p>(其中 $sum$ 是前缀和)。这个复杂度是 $O(n^2)$ 的，过不去……</p><a id="more"></a><p>继续推式子：</p><script type="math/tex; mode=display">f_i=\min\limits_{j=1}^{i-1}\{f_j+[(sum_i+i)-(sum_j+j)-l]^2\}</script><p>设 $s_i=sum_i+i$ ，我们假设 $j$ 为最优决策，将 $\min$ 去掉。</p><script type="math/tex; mode=display">f_i=f_j+(s_i-s_j-l)^2\\f_i=f_j+s_i^2+(s_j+l)^2-2\cdot s_i\cdot(s_j+l)\\f_j+s_i^2+(s_j+l)^2=2\cdot s_i\cdot(s_j+l)+f_i​</script><p>于是上面的式子变成了 $y=kx+b$ 的形式，其中 $y=f_j+s_i^2+(s_j+l)^2$ ，$k=2\cdot s_i$ ，$x=s_j+l$ ，$b=f_i$ 。</p><p>然后将 $x,y$ 两个值作为点 $(x,y)$ 放到平面上即可，因为最终答案是取 $min$ ，所以我们需要维护的是下凸壳。有一点需要注意的是，我们算斜率的时候可以将每个点的常数项或者只和 $i$ 有关的项去掉，因为算斜率是相减的，减的时候这些项同样也没了。</p><p>上面的 $x$ 中的 $l$ 是常数项于是可以省略，$y$ 中的 $s_i^2$ 只和 $i$ 有关，于是也省略掉。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,l,head,tail;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N],s[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> s[i];&#125;<span class="comment">/*每个点的x坐标*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]+S(s[i]+l);&#125;<span class="comment">/*每个点的y坐标*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> (Y(j)-Y(i))/(X(j)-X(i));&#125;<span class="comment">/*算斜率*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;s[i]),s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]+=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*s[i]) ++head;</span><br><span class="line">        f[i]=f[q[head]]+S(s[i]-s[q[head]]-l<span class="number">-1</span>);<span class="comment">/*转移*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail],i)&lt;slope(q[tail],q[tail<span class="number">-1</span>])) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来解释一些问题。</p><h3 id="1-为什么要维护下凸壳"><a href="#1-为什么要维护下凸壳" class="headerlink" title="1.为什么要维护下凸壳"></a>1.为什么要维护下凸壳</h3><p>因为我们的 $\texttt{DP}$ 方程是在取 $\min$ ，如果是 $\max$ 的话则维护上凸壳。而且维护下凸壳显然是让 $f_i$ 更小。</p><p>以上面为例，我们用 $y=kx+b​$ 的直线从下面网上扫，注意这条直线的斜率就是 $k​$ 。很显然如果我们从下往上这样扫越往上扫 $b​$ 越大(不明白的画画图)，但是我们的目的是使得 $b​$ 最小( $b​$ 就是 $f_i​$ ) 。下凸壳包含了最下面的所有点，显然不是下凸壳上的点一定不能成为最优的。</p><h3 id="2-维护队列的过程是什么鬼操作"><a href="#2-维护队列的过程是什么鬼操作" class="headerlink" title="2.维护队列的过程是什么鬼操作"></a>2.维护队列的过程是什么鬼操作</h3><p>首先第一个过程，也就是下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*s[i]) ++head;</span><br></pre></td></tr></table></figure><p>上面讲了我们需要使得 $b​$ 最小，那么最优的决策点在直线从下往上扫的过程中肯定是最先扫到的，因为那样可以保证 $f_i​$ 最小。假设最优的点为 $i​$ ，上一个点为 $j​$ ，下一个点为 $k​$ ，那么 $i​$ 一定保证 $j​$ 到 $i​$ 的斜率小于直线斜率并且 $i​$ 到 $k​$ 的斜率大于直线斜率。</p><p>然后我们会发现对于单调上增的需要更新的 $i​$ ，其直线的斜率 $k​$ 一定是单调上增的，因为前缀和是单调上增的。</p><p>所以对于斜率已经不满足要求的点直接踢出队就好了。</p><p>然后康康出队的过程。如果在纸上画画会发现，如果满足 <code>slope(q[tail],i)&lt;slope(q[tail],q[tail-1])</code> ，那么说明 $q[tail]$ 已经不再下凸壳中了！没错吧？那么这个时候 $q[tail]$ 永远也不可能成为最优的转移点了，直接丢掉即可。</p><hr><p>最后有一些斜率优化的套路总结(自己总结出来的)：</p><ul><li>$\texttt{DP}$ 方程取 $\min$ 就维护下凸壳，取 $\max$ 就维护上凸壳</li><li>$y=kx+b​$ 中的 $k​$ 一定要是常量或者是完全是 $i​$ 的量(例如 $s_i,2\cdot g_i^2​$ 等)，$b​$ 一定是你需要转移的对象(就是 $f_i​$ )，$x​$ 和 $y​$ 两个值一定要包含和 $j​$ 有关的值，要随 $j​$ 的变化而变化。</li><li>提炼出来的 $x,y$ 放到坐标系上之前记得去掉没用的值。</li></ul><p>差不多就这些吧，也不知道是不是完全正确，至少这个套路还是过了几道题目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;差不多搞懂了斜率优化吧……说实话网上的文章都写得很迷，还好找到了一个不错的文章：&lt;a href=&quot;https://www.cnblogs.com/yangsongyi/p/9630227.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转送门戳我(￣▽￣)~*&lt;/a&gt; 。(为什么突然发现这道题和诗人小G很像呢) &lt;/p&gt;
&lt;p&gt;这个 $\texttt{DP}$ 方程谁都会设：设 $f_i$ 表示前 $i$ 个玩具的最小费用，转移显然如下：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\min\limits_{j=1}^{i-1}\{f_j+(sum_i-sum_j+i-j-l)^2\}&lt;/script&gt;&lt;p&gt;(其中 $sum$ 是前缀和)。这个复杂度是 $O(n^2)$ 的，过不去……&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [APIO2010]特别行动队  斜率优化DP  luoguP3628</title>
    <link href="http://qiulyblog.github.io/2019/04/24/%5B%E9%A2%98%E8%A7%A3%5DluoguP3628/"/>
    <id>http://qiulyblog.github.io/2019/04/24/[题解]luoguP3628/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-28T05:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>依旧是斜率优化的套路。</p><p>设 $f_i$ 表示前 $i$ 个士兵的最大贡献，转移显然是枚举一个 $j$ ，将 $j+1$ 到 $i$ 这些士兵组成特别行动队算贡献：</p><script type="math/tex; mode=display">f_i=\max\{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c\}​</script><p>其中 $s_i$ 为战斗力的前缀和。这个方程是 $O(n^2)$ 的，需要优化。发现这个转移式貌似不满足单调队列优化的条件，于是将中间的式子拆开看看可不可以斜率优化。</p><a id="more"></a><script type="math/tex; mode=display">f_i=\max\{f_j+a(s_i^2+s_j^2-2s_is_j)+b\cdot s_i-b\cdot s_j+c\}\\f_i=\max\{f_j+a\cdot s_i^2+a\cdot s_j^2-2a\cdot s_is_j)+b\cdot s_i-b\cdot s_j+c\}\\f_i=f_j+a\cdot s_i^2+a\cdot s_j^2-2a\cdot s_is_j+b\cdot s_i-b\cdot s_j+c\\f_j+a\cdot s_i^2+a\cdot s_j^2+b\cdot s_i-b\cdot s_j+c=2a\cdot s_i\cdot s_j +f_i​</script><p>诶，是 $y=kx+b$ 的形式，而且满足斜率优化的条件诶。继续将 $x,y$ 找出来放到坐标系上( $x=s_j$,$y=f_j+a\cdot s_j^2-b\cdot s_j$) 。</p><p>因为是 $\max​$ ，所以用单调队列维护一下上凸壳然后转移即可，复杂度 $O(n)​$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,head,tail;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[N],f[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> s[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]+<span class="number">1l</span>l*S(s[i])*a<span class="number">-1l</span>l*s[i]*b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> (Y(j)-Y(i))/(X(j)-X(i));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    f[i]=f[j]+<span class="number">1l</span>l*S(s[i]-s[j])*a+<span class="number">1l</span>l*(s[i]-s[j])*b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(a),IN(b),IN(c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(s[i]),s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&gt;<span class="number">2</span>*a*s[i]) ++head;</span><br><span class="line">        calc(i,q[head]);</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail],i)&gt;slope(q[tail],q[tail<span class="number">-1</span>])) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依旧是斜率优化的套路。&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示前 $i$ 个士兵的最大贡献，转移显然是枚举一个 $j$ ，将 $j+1$ 到 $i$ 这些士兵组成特别行动队算贡献：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\max\{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c\}​&lt;/script&gt;&lt;p&gt;其中 $s_i$ 为战斗力的前缀和。这个方程是 $O(n^2)$ 的，需要优化。发现这个转移式貌似不满足单调队列优化的条件，于是将中间的式子拆开看看可不可以斜率优化。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SCOI2008]奖励关  状压DP  luoguP2473</title>
    <link href="http://qiulyblog.github.io/2019/04/23/%5B%E9%A2%98%E8%A7%A3%5DluoguP2473/"/>
    <id>http://qiulyblog.github.io/2019/04/23/[题解]luoguP2473/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-04-24T07:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现数据范围很小，并且涉及到”集合”，很容易可以想到用状压 $\texttt{DP}$ 。</p><p>设 $f[i][j]$ 表示已经抛出了 $i$ 次宝物，获得的宝物集合为 $j$ 时的最优分值。那么转移的时候枚举每一个宝物，分两种情况即可——选当前宝物或者不选。注意选当前宝物的前提是必须满足前提，按照最优情况选取即可。注意最后将所有的宝物的贡献加上后还需要$/n$ ，因为题目要求的是”平均”。</p><a id="more"></a><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">101</span>][<span class="number">65540</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">18</span>],d[<span class="number">18</span>],v[<span class="number">18</span>],N,K;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;++i) p[i]=<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;K,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(x) &#123;d[i]|=p[x];<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=K;i;--i) <span class="comment">/*倒着枚举会好些*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=p[N+<span class="number">1</span>]<span class="number">-1</span>;++j) &#123;</span><br><span class="line">            <span class="comment">/*上面两重循环枚举状态*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;++k)<span class="comment">/*枚举所有宝物并计算贡献*/</span></span><br><span class="line">                <span class="keyword">if</span>((d[k]&amp;j)==d[k]) <span class="comment">/*可以选取当前宝物*/</span></span><br><span class="line">                    f[i][j]+=max(f[i+<span class="number">1</span>][j],f[i+<span class="number">1</span>][j|p[k]]+v[k]);</span><br><span class="line">                    <span class="comment">/*按照最优选取*/</span></span><br><span class="line">                <span class="keyword">else</span> f[i][j]+=f[i+<span class="number">1</span>][j]; <span class="comment">/*不能选取直接转移*/</span></span><br><span class="line">            f[i][j]/=N;<span class="comment">/*所谓"平均"*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,f[<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">/*最终答案*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现数据范围很小，并且涉及到”集合”，很容易可以想到用状压 $\texttt{DP}$ 。&lt;/p&gt;
&lt;p&gt;设 $f[i][j]$ 表示已经抛出了 $i$ 次宝物，获得的宝物集合为 $j$ 时的最优分值。那么转移的时候枚举每一个宝物，分两种情况即可——选当前宝物或者不选。注意选当前宝物的前提是必须满足前提，按照最优情况选取即可。注意最后将所有的宝物的贡献加上后还需要$/n$ ，因为题目要求的是”平均”。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状压DP" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2011]Noi嘉年华  决策单调性优化DP  luoguP1973</title>
    <link href="http://qiulyblog.github.io/2019/04/22/%5B%E9%A2%98%E8%A7%A3%5DluoguP1973/"/>
    <id>http://qiulyblog.github.io/2019/04/22/[题解]luoguP1973/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-23T00:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题一共有两问，第一问瞎搞 $\texttt{DP}$ ，第二问如果直接 $\texttt{DP}$ 的话复杂度是 $O(n^4)$ 的过不去，这个时候需要用到决策单调性优化复杂度就可以降低至 $O(n^3)$ ，这样就过了。我们先来讨论一下第一问的做法。</p><p>时间的范围太大了，我们需要离散化一下。离散化后时间就控制在 $0$ 到 $2n$ 的范围内了。</p><p>首先可以发现最终的答案一定就是一段一段时间，每一段时间内的活动都是在同一个会场举行。我们可以预处理一个 $tot_{l,r}$ 表示完全在时间 $l,r$ 之内的活动有多少个。计算直接暴力，预处理的复杂度为 $O(n^3)$ 。</p><a id="more"></a><p>然后设一个 $pre_{i,j}​$ 表示 <strong>$1​$ 到 $i​$ 的时间一个会场的活动数为 $j​$ 时另一个会场的最大活动数</strong>。那么转移的话我们枚举一个时间 $k​$ ，然后考虑 $k​$ 到 $i​$ 这段时间中的所有活动分配给哪个会场即可。可以得到转移方程：</p><script type="math/tex; mode=display">pre_{i,j}=\max\limits_{k=1}^{i}\{pre_{k,j}+tot_{k,i},pre_{k,j-tot_{k,i}}\}​</script><p>这里我们 $pre$ 方程的定义中”一个会场”就是一号会场，”另一个会场”就是二号会场$。pre_{k,j}+tot_{k,i}$ 就是将 $k$ 到 $i$ 这段时间中所有活动都分配给了二号会场，$pre_{k,j-tot_{k,i}}$ 很显然就是分配给了一号会场。计算时枚举 $i,j,k$ ，复杂度是 $O(n^3)$ 。(其实准确的复杂度带个常数，因为 $i$ 枚举的是时间，而时间最大是 $2n$ 的) 。</p><p>我们设离散化后时间总长为 $m$ ，那么答案显然为 $\max\limits_{i=1}^m\{\min(pre_{m,i},i)\}$ 。接下来我们解决第二问。</p><p>我们的 $tot_{l,r}$ 统计的就是完全在时间 $l,r$ 的区间有多少个。那么对于第 $i$ 个活动，设该活动的起始时间与终止时间分别为 $s_i,t_i$ ，那么我们再考虑一对 $x,y \ \ (x\leq s_i,t_i\leq y)$ ，那么如果我们将答案计算上 $tot_{x,y}$ ，那么也就选择了第 $i$ 个活动了。</p><p>我们设 $f_{i,j}$ 表示一号会场强制选择 $i$ 到 $j$ 时间中的所有活动时的最优答案。(注意这里的最优答案就是两个会场中活动少的一方的最大值，我们只是考虑在一号会场<strong>强制选择</strong> $i$ 到 $j​$ 中的所有活动的情况下考虑最优的全局答案) 。</p><p>继续看向一号会场，假设在 $i$ 前面的时间中一号会场已经合法举办了 $x$ 场活动，在 $j$ 后面的时间中也合法举办了 $y$ 场活动。那么我们枚举 $i,j,x,y$ 也可以得到二号会场的活动数：$i$ 前面的时间种有 $pre_{i,x}$ 场活动，$j$ 后面的时间中有……诶这里用 $pre$ 貌似不是很好表示诶，于是我们新定义一个 $suf$ ，$suf_{i,j}$ 表示 <strong>$i$ 到 $m$ 的时间一个会场的活动数为 $j$ 时另一个会场的最大活动数</strong>，$suf$ 的状态转移方程和 $pre$ 的同理。</p><p>枚举 $i,j,x,y$ 后就可以得到两个会场的活动个数，那么就可以直接算答案了：</p><script type="math/tex; mode=display">f_{i,j}=\max\limits_{x=1}^{m}\max\limits_{y=1}^{m}\{\min(x+tot_{i,j}+y,pre_{i,x}+suf_{j,y})\}​</script><p>但是这样子的复杂度是 $O(n^4)​$ 的，过不了。</p><p>不过，我们会发现，<strong>对于单调递增的 $x$ ，对应的最优的 $y$ 一定是单调递减的</strong> 。为什么呢？首先对于一个单调递增的 $i$ ，$pre_{?_i},suf_{?_i}$ 一定是单调递减的( $?$ 为任意数) 。那么如果对于单调递增的 $x$ ，$pre_{i,x}$ 一定是单调递减的，这个时候如果 $y$ 单调递增也就意味着 $suf_{j,y}$ 会单调递减，那么 $x+tot_{i,j}+y$ 和 $pre_{i,x}+suf_{j,y}$ 将会越拉越大，对于答案显然是不利的。反过来，如果 $y$ 是单调递减的，那么就会相对比较均衡。(感性理解理解……)</p><p>那么我们就不需要枚举 $y$ 了，只需要扫一扫就好了，最终计算 $f$ 的时间复杂度为 $O(n^3)$ 。</p><p>最终统计答案的时候，对于一个活动 $i$ ，我们的答案显然为 $\max\limits_{x=1}^{s_i}\max\limits_{y=t_i}^{m}f_{x,y}$ 。必须满足 $x\leq s_i,t_i\leq y$ ，因为这样就会满足一定会选择第 $i$ 个活动。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,j,k) for((i)=(j);(i)&lt;=(k);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(i,j,k) for((i)=(j);(i)&gt;=(k);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e2</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,i,j,k,l,r,s[N],t[N],b[N];</span><br><span class="line"><span class="keyword">int</span> tot[N][N],pre[N][N],suf[N][N],f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> min(x+tot[l][r]+y,pre[l][x]+suf[r][y]);&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=IN();</span><br><span class="line">    F(i,<span class="number">1</span>,n) b[++m]=s[i]=IN(),b[++m]=t[i]=IN()+s[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+m),</span><br><span class="line">    m=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+m)-b<span class="number">-1</span>;<span class="comment">/*离散化去重*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        s[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,s[i])-b;</span><br><span class="line">        t[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,t[i])-b;</span><br><span class="line">        F(l,<span class="number">1</span>,s[i]) R(r,m,t[i]) ++tot[l][r];<span class="comment">/*计算出tot*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    F(i,<span class="number">1</span>,m) F(j,<span class="number">1</span>,n) pre[i][j]=suf[i][j]=-inf;<span class="comment">/*初始化*/</span> </span><br><span class="line">    <span class="comment">/*----------计算出pre和suf----------*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,m) F(j,<span class="number">0</span>,tot[<span class="number">1</span>][i]) F(k,<span class="number">1</span>,i) &#123;</span><br><span class="line">        pre[i][j]=max(pre[i][j],pre[k][j]+tot[k][i]);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=tot[k][i]) pre[i][j]=max(pre[i][j],pre[k][j-tot[k][i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    R(i,m,<span class="number">1</span>) F(j,<span class="number">0</span>,tot[i][m]) F(k,i,m) &#123;</span><br><span class="line">        suf[i][j]=max(suf[i][j],suf[k][j]+tot[i][k]);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=tot[i][k]) suf[i][j]=max(suf[i][j],suf[k][j-tot[i][k]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*计算f*/</span></span><br><span class="line">    F(l,<span class="number">1</span>,m) F(r,l+<span class="number">1</span>,m) <span class="keyword">for</span>(<span class="keyword">int</span> y=n,x=<span class="number">0</span>;x&lt;=n;++x) &#123;<span class="comment">/*y当做指针扫一遍*/</span></span><br><span class="line">        <span class="keyword">int</span> old_calc=calc(x,y),new_calc;</span><br><span class="line">        <span class="keyword">while</span>(y&amp;&amp;old_calc&lt;=(new_calc=calc(x,y<span class="number">-1</span>))) --y,old_calc=new_calc;</span><br><span class="line">        f[l][r]=max(f[l][r],calc(x,y));<span class="comment">/*转移*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*输出答案*/</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    F(i,<span class="number">1</span>,n) ans=max(ans,min(pre[m][i],i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">/*第一问*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        F(l,<span class="number">1</span>,s[i]) R(r,m,t[i]) ans=max(ans,f[l][r]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">/*第二问*/</span></span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题一共有两问，第一问瞎搞 $\texttt{DP}$ ，第二问如果直接 $\texttt{DP}$ 的话复杂度是 $O(n^4)$ 的过不去，这个时候需要用到决策单调性优化复杂度就可以降低至 $O(n^3)$ ，这样就过了。我们先来讨论一下第一问的做法。&lt;/p&gt;
&lt;p&gt;时间的范围太大了，我们需要离散化一下。离散化后时间就控制在 $0$ 到 $2n$ 的范围内了。&lt;/p&gt;
&lt;p&gt;首先可以发现最终的答案一定就是一段一段时间，每一段时间内的活动都是在同一个会场举行。我们可以预处理一个 $tot_{l,r}$ 表示完全在时间 $l,r$ 之内的活动有多少个。计算直接暴力，预处理的复杂度为 $O(n^3)$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
</feed>
