<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qiuly&#39;s blog!</title>
  
  <subtitle>A weak OIer from HN-YZ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qiulyblog.github.io/"/>
  <updated>2019-05-07T02:42:18.017Z</updated>
  <id>http://qiulyblog.github.io/</id>
  
  <author>
    <name>Qiuly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【题解】 [HNOI2009]双递增序列  线性DP  luoguP4728</title>
    <link href="http://qiulyblog.github.io/2019/05/07/%5B%E9%A2%98%E8%A7%A3%5DluoguP4728/"/>
    <id>http://qiulyblog.github.io/2019/05/07/[题解]luoguP4728/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-07T02:42:18.017Z</updated>
    
    <content type="html"><![CDATA[<p>其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示<strong>第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立</strong> ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。</p><a id="more"></a><p>考虑设 $dp_{i,j}$ 表示第一个序列的最终位置为 $i-1$ 且长度为 $j$ 时第二个序列的最终位置的最小值。枚举当前数字 $i$ ，然后分两种情况进行转移——将 $a_i$ 放到第一个序列末尾 $\texttt{and}$ 将 $a_i$ 放到第二个序列末尾。</p><p>放到第一个序列末尾很好想：因为当前第一个序列的结尾处就是 $a_{i-1}$ ，比较一下大小直接转移就好了：</p><script type="math/tex; mode=display">dp_{i,j}=min(dp_{i,j},dp_{i-1,j-1}) \ \ \ (a_i>a_{i-1})</script><p>因为第二个序列的末尾没变，所有直接转移就好。</p><p>接下来考虑将第 $i$ 个数放到第二个序列末尾的情况，其实第一个序列和第二个序列没区别，当然除了名字上有一个字的差异，假设第 $i-1$ 个数是第二个序列末尾，当前第一个序列的长度为 $j-1$ ，那么第二个序列的长度因该就是 $(i-1)-(j-1)$ 了，因为我们假设了第 $i-1$ 个数是第二个序列末尾，那么 $dp_{i-1,i-j}$ 又可以被解释为<strong>第二个序列的末尾为 $i-1$ 个数且第二个序列的长度为 $i-j$ 的时候第一个序列的末尾的最小值</strong> ，如果这个最小值小于 $a_i$ ，说明 $a_i$ 可以接到第一个序列前面，那么这个时候第二个序列的末尾为 $a_{i-1}$ ，显然又有转移：</p><script type="math/tex; mode=display">dp_{i,j}=min(dp_{i,j},a_{i-1}) \ \ \ (a_i>dp_{i-1,i-j})</script><p>开始的时候我们将 $dp$ 数组赋成极大值，然后最后判断一下 $dp_{n,n/2}$ 这个状态变小没有就好。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;IN(n);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    a[<span class="number">0</span>]=f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i&amp;&amp;j&lt;=n/<span class="number">2</span>;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i<span class="number">-1</span>]) f[i][j]=min(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;f[i<span class="number">-1</span>][i-j]) f[i][j]=min(f[i][j],a[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> f[n][n/<span class="number">2</span>]&lt;<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">puts</span>(solve()?<span class="string">"Yes!"</span>:<span class="string">"No!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这道题的确很绕……=。=</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示&lt;strong&gt;第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立&lt;/strong&gt; ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HEOI2013]SAO  组合数学+树形DP  luoguP4099</title>
    <link href="http://qiulyblog.github.io/2019/05/06/%5B%E9%A2%98%E8%A7%A3%5DluoguP4099/"/>
    <id>http://qiulyblog.github.io/2019/05/06/[题解]luoguP4099/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-05-06T10:07:38.445Z</updated>
    
    <content type="html"><![CDATA[<p>$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：<a href="https://www.luogu.org/problemnew/show/P4099" target="_blank" rel="noopener">转送门😄</a> 。</p><p>我们先不考虑边的权值(&lt;与&gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&lt;,&gt;) ，我们分类讨论即可。</p><p>首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢<a id="more"></a>，对于一个 $u$ 的儿子 $v$ ，我们虽然知道 $u$ 和 $v$ 的攻克的前后关系，但是合并答案貌似并不好合并。这个时候我们增加一维 $j$ ，$f_{u,j}$ 表示 $u$ 的子树的所有合法拓扑序中 $u$ 在第 $j$ 位上的总状态数。</p><p>也就是说，对于一个必须在 $u$ 前面攻克的关卡 $v$ ，我们考虑枚举一个 $j$ ，$v$ 子树中 $j$ 个结点在合并 $u,v$ 后放到 $u$ 前面，另外 $sz_v-j$ 个放到 $u$ 后面，然后枚举一个 $k$ ，表示当前的 $v$ 排在 $v$ 子树的拓扑序中的第 $k$ 位，只有 $k\leq j$ 的时候 $v$ 才可以转移 $u$ ，因为这个时候 $v$ 在 $u$ 前面。</p><p>现在再来考虑$“$ $j$ 个结点放在 $u$ 前面 $”$ 的方案数和$“$ $sz_v-j$ 个结点放在 $u$ 后面的方案数$”$，这个显然可以用组合数算，合并 $v$ 的子树后，$u$ 的排名从 $i$ 变成了 $i+j$ ，也就是说我们需要将 $j$ 个乱序插入到 $u$ 前面 $i+j-1$ 个数中，方案数显然为 $C_{i+j-1}^{j}$ ，那么现在总节点数显然为 $sz_u+sz_v$ (现在 $sz_u$ 和 $sz_v$ 还没有并在一起) ，$u$ 后面理所当然有 $sz_u+sz_v-i-j$ 个位置，将 $sz_v-j$ 个数插进去的方案数显然为 $C_{sz_u+sz_v-i-j}^{sz_v-j}$ 个，这两个数再乘上 $f_{u,i}$ 和 $f_{v,k}$ 就好了，这一次合并后 $u$ 的位置显然到了 $i+j$ ，所以 $f_{u,i+j}$ 显然要加上这一组贡献。</p><p>经整理后的转移方程如下：</p><script type="math/tex; mode=display">pls(f_{u,i+j},f_{u,i}\cdot f_{v,k}\cdot C_{i+j-1}^{j}\cdot C_{sz_u+sz_v-i-j}^{sz_v-j})</script><p>代码就是这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span> to sz[u]</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span> to sz[v]</span><br><span class="line">        <span class="keyword">for</span> k=<span class="number">1</span> to j</span><br><span class="line">            pls(f[u][i+j],f[u][i]*f[v][k]*C[i+j<span class="number">-1</span>][j]*C[sz[u]+sz[v]-i-j][sz[v]-j])</span><br></pre></td></tr></table></figure><p>这是 $n^3$ 的，过不去。考虑前缀和优化，几下 $f_v$ 的前缀和，最后的一层循环就可以直接丢掉了。</p><p>这个就是 $v$ 要在 $u$ 前面的情况，$u$ 在 $v$ 前面的情况和这个差不多，不过转移的时候 $j$ 就要从 $0$ 开始了，因为那个时候 $u$ 前面是可以不多放任何东西的，还有就是 $u$ 在 $v$ 前面的时候注意 $k\geq j$ 时才可以转移 !</p><p>最后的答案就是 $\sum\limits_{i=1}^{n} f_{1,i}$ 啦。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to,val;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> C[N][N],f[N][N],pre[N][N],suf[N][N],sz[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[v],u,w^<span class="number">1</span>&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;=mod)x-=mod;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[u]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=head[u];l;l=G[l].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[l].to,w=G[l].val;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u);</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">if</span>(w) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=sz[v];++j)</span><br><span class="line">                    pls(g[i+j],<span class="number">1l</span>l*f[u][i]*pre[v][j]%mod*C[i+j<span class="number">-1</span>][j]%mod</span><br><span class="line">                    *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=sz[v];++j)</span><br><span class="line">                    pls(g[i+j],<span class="number">1l</span>l*f[u][i]*suf[v][j+<span class="number">1</span>]%mod*C[i+j<span class="number">-1</span>][j]%mod</span><br><span class="line">                    *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="built_in">memcpy</span>(f[u],g,<span class="keyword">sizeof</span>(g));</span><br><span class="line">    &#125;</span><br><span class="line">    pre[u][<span class="number">0</span>]=suf[u][sz[u]+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i) pre[u][i]=(pre[u][i<span class="number">-1</span>]+f[u][i])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sz[u];i&gt;=<span class="number">1</span>;--i) suf[u][i]=(suf[u][i+<span class="number">1</span>]+f[u][i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head)),cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> n;IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;<span class="keyword">char</span> sign;</span><br><span class="line">        IN(u),sign=getchar(),IN(v);</span><br><span class="line">        add(u+<span class="number">1</span>,v+<span class="number">1</span>,sign==<span class="string">'&lt;'</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) pls(ans,f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*预处理组合数*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N<span class="number">-2</span>;++i) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N<span class="number">-2</span>;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人会问，如果 $u$ 的儿子 $v$ 下面的边全都是 $&gt;$ ，并且 $u$ 连向 $v$ 的边也是 $&gt;$ ，那么这个时候 $v$ 以及其子树的所有点都必须在 $u$ 前面完成，在转移的时候为什么可以 $“$ 提出 $j$ 个结点放到 $u$ 前面 $”$ 呢？</p><p>其实想想就可以明白，在向上统计答案的时候对于一个 $v$ 的儿子 $a$ ，我们只统计了合并后 $a$ 在 $v$ 前面的情况，同样在 $u$ 统计 $v$ 时也只是统计了合并后 $v$ 在 $u$ 前面的情况，所有我们也只是统计了 $“$ $a$ 在 $v$ 前面且 $v$ 在 $u$ 前面 $”$ 的情况，所有被统计的情况一定是合法的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4099&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转送门😄&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;我们先不考虑边的权值(&amp;lt;与&amp;gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&amp;lt;,&amp;gt;) ，我们分类讨论即可。&lt;/p&gt;
&lt;p&gt;首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="树形DP" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [六省联考2017]分手是祝愿  概率DP  loj2145</title>
    <link href="http://qiulyblog.github.io/2019/05/05/%5B%E9%A2%98%E8%A7%A3%5Dloj2145/"/>
    <id>http://qiulyblog.github.io/2019/05/05/[题解]loj2145/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-05T02:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>概率神仙题的传送门：<a href="https://loj.ac/problem/2145" target="_blank" rel="noopener"><del>别戳偏了</del></a></p><p>设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程：</p><script type="math/tex; mode=display">f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})</script><p>因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。</p><a id="more"></a><script type="math/tex; mode=display">f_i=\frac{i}{n}+1\cdot (1+f_i+f_{i+1})-\frac{i}{n}\cdot (1+f_i+f_{i+1})\\\\f_i=\frac{i}{n}+1+f_i+f_{i+1}-\frac{i}{n}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\f_i=1+f_i+f_{i+1}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\\frac{i}{n}f_i=1+f_{i+1}-\frac{i}{n}f_{i+1}\\\\f_i=\frac{1+f_{i+1}-\frac{i}{n}f_{i+1}}{\frac{i}{n}}\\\\f_i=\frac{n\cdot(1+f_{i+1})-i\cdot f_{i+1}}{i}\\\\f_i=\frac{n+(n-i)\cdot f_{i+1}}{i}\\\\f_i=1+\frac{(n-i)\cdot (f_{i+1}+1)}{i}</script><p>预处理逆元就可以直接计算了，记得最后乘上 $n!$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,step,a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,f[N],inv[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    inv[<span class="number">0</span>]=<span class="number">0</span>,inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) inv[i]=(<span class="keyword">long</span> <span class="keyword">long</span>)(p-p/i)*inv[p%i]%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i) g[j].push_back(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) <span class="keyword">if</span>(a[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[i].size();++j) a[g[i][j]]^=<span class="number">1</span>;</span><br><span class="line">        ++step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(step&lt;=k) ans=step;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">1</span>;--i) f[i]=(<span class="number">1l</span>l+(<span class="number">1l</span>l*n-i)*(f[i+<span class="number">1</span>]+<span class="number">1</span>)*inv[i])%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&gt;k;--i) ans=(ans+f[i])%p;</span><br><span class="line">        ans=(ans+k)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans=(<span class="number">1l</span>l*i*ans)%p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;概率神仙题的传送门：&lt;a href=&quot;https://loj.ac/problem/2145&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;del&gt;别戳偏了&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})&lt;/script&gt;&lt;p&gt;因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】  [HAOI2018]苹果树  组合数学  loj2526</title>
    <link href="http://qiulyblog.github.io/2019/05/05/%5B%E9%A2%98%E8%A7%A3%5Dloj2526/"/>
    <id>http://qiulyblog.github.io/2019/05/05/[题解]loj2526/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-06T05:23:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的题目，可爱的传送门：<a href="https://loj.ac/problem/2526" target="_blank" rel="noopener">戳这呢=￣ω￣=</a></p><p>刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。</p><p>我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。</p><a id="more"></a><p>易知节点数为 $n$ 的二叉树的总形态数为 $n!$ ，而且 $i$ 子树下的所有节点的编号一定要大于 $i$ ，我们考虑”先将 $i$ 子树构造出来再填入节点”的过程，子树的形态数显然为 $j!$ ，然后我们只能选剩下的 $n-i$ 个节点(编号要比 $i$ 大) ，填入剩下的 $j-1$ 个位置( $i$ 占了一个位置) ，显然这样的方案数为 $C_{n-i}^{j-1}$ 。</p><p>这样的一个 $i$ ，其子树大小为 $j$ ，那么它可以做出多少贡献呢？考虑 $fa_i \Rightarrow i$ 这条边会经过多少次，显然是 $j\cdot(n-j)$ 次( $j$ 为子树节点个数，$n-j$ 为上面的节点个数) ，也就是说这样的方案可以造成 $j\cdot (n-j)$ 的贡献。</p><p>那么现在 $i$ 的子树得到确定了，我们将 $i$ 以及其子树看做一个点，我们考虑 $1$ 到 $i$ 这些节点，它们可以以任意形态组成一棵树，方案数是 $i!$ 。</p><p>接着我们需要将剩下的 $n-j-(i-1)$ 个节点挂到树上去。对于第 $i$ 个挂到树上的点，它有 $i$ 个位置可以挂。但是因为 $i$ 一定要占一个位置，所以这个节点只有 $i-1$ 个位置可以挂了，第二个多出来的节点就有 $i$ 个位置可以挂……第 $k$ 个显然有 $i-2+k$ 个位置可以挂。也就是说这些点挂上去的总方案数为 $\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 。</p><p>将上面的乘起来就是这一组 $i,j$ 对答案造成的贡献了：</p><script type="math/tex; mode=display">j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)</script><p>$\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 比较不好计算，但是简单的变化后发现这个是和 $(n-j-1)!/(i-2)!$ 等价的，我们带进原式子。</p><script type="math/tex; mode=display">j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot(n-j-1)!/(i-2)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i\cdot (i-1)\cdot(n-j-1)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot i\cdot (i-1)\cdot (n-j)!</script><p>这样就很好算了，我们预处理组合数和阶乘，上面的式子 $O(1)$ 算~</p><p>代码很短。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,ans,fac[N],C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x+=y;x%=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(p);</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;++j)</span><br><span class="line">            pls(ans,(ll)fac[j]*fac[n-j]%p*C[n-i][j<span class="number">-1</span>]%p*(i*(i<span class="number">-1</span>))%p*j%p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有趣的题目，可爱的传送门：&lt;a href=&quot;https://loj.ac/problem/2526&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳这呢=￣ω￣=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。&lt;/p&gt;
&lt;p&gt;我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SCOI2014]方伯伯的玉米田  树状数组优化DP  luoguP3287</title>
    <link href="http://qiulyblog.github.io/2019/05/04/%5B%E9%A2%98%E8%A7%A3%5DluoguP3287/"/>
    <id>http://qiulyblog.github.io/2019/05/04/[题解]luoguP3287/</id>
    <published>2019-05-03T16:00:00.000Z</published>
    <updated>2019-05-05T02:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>以后不要被这种傻逼题给蒙骗了。传送门：<a href="https://www.luogu.org/problemnew/show/P3287" target="_blank" rel="noopener">方伯伯的传送门=。=</a></p><p>首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。</p><p>设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程：</p><a id="more"></a><script type="math/tex; mode=display">f_{i,j}=\max\{f_{k,l}+1\} \ \ (k<i,l\leq j,h_i+j\geq h_k+l)</script><p>可能有人会问为什么 $l\leq j$ ，很显然就是上面的道理，越大的 $i$ 一定拔高次数是单调不减的。</p><p>发现上面的转移其实是 $O(n^2k^2)$ 的，万恶的出题人不会给这个复杂度一丁点分……这个时候用树状数组优化转移，发现上面有三个限制条件，我们正着枚举 $i$ ，就已经满足第一个条件了，因为这个时候树状数组中的都是小于 $i$ 的 $k$ 。然后将每个点按照 $(j+1,h_i+j)$ 放到平面上，然后树状数组统计答案即可。</p><p>树状数组维护的是 $\max$  ，不是和。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],n,k,mx;</span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line">    <span class="keyword">int</span> c[N][<span class="number">5009</span>+K];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">const</span> <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;=mx+k;x+=(x&amp;-x))<span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&lt;=k+<span class="number">1</span>;i+=(i&amp;-i))</span><br><span class="line">                c[x][i]=max(c[x][i],v); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x;x-=(x&amp;-x))<span class="keyword">for</span>(<span class="keyword">int</span> i=y;i;i-=(i&amp;-i))</span><br><span class="line">                ans=max(ans,c[x][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> BIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),mx=max(mx,a[i]);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k;~j;--j) &#123;</span><br><span class="line">            <span class="keyword">int</span> res=query(a[i]+j,j+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            ans=max(ans,res),update(a[i]+j,j+<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以后不要被这种傻逼题给蒙骗了。传送门：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3287&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;方伯伯的传送门=。=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。&lt;/p&gt;
&lt;p&gt;设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="树状数组" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="二维树状数组" scheme="http://qiulyblog.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SHOI2014]概率充电器  概率DP  loj2192</title>
    <link href="http://qiulyblog.github.io/2019/05/02/%5B%E9%A2%98%E8%A7%A3%5Dloj2192/"/>
    <id>http://qiulyblog.github.io/2019/05/02/[题解]loj2192/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-05T02:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>传送门在这：<a href="https://loj.ac/problem/2192" target="_blank" rel="noopener">我是传送门$QwQ$</a></p><p>其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。</p><p>因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。</p><a id="more"></a><p>枚举每一个儿子，对于这个儿子只有两种情况：该儿子没有通上电，该儿子通上电了且传送失败。两种情况的概率都很好算。我们可以列出转移方程：</p><script type="math/tex; mode=display">f_u=(1-q_u)\cdot \prod (f_v+(1-f_v)\cdot(1-G_i.p))</script><p>其中 $(1-q_u)$ 显然为该点本身不通电的概率，然后枚举儿子 $v$ ，$f_v$ 就是该儿子本来就没有通上电的概率，$(1-f_v)\cdot(1-G_i.p)$ 就是通上电的传送失败(注：$G_i.p$ 是当前连接 $u,v$ 的边的通电概率) 。</p><p>那么如何计算父亲传来的电呢？设 $g_i$ 表示点 $i$ 的父亲没有向点 $i$ 通电的概率。计算一下父节点不通电的概率，注意不要计算上该儿子的贡献，不然会乱。计算完不通电的概率后分上面两种情况讨论即可。</p><script type="math/tex; mode=display">res=g_u\cdot f_v / (f_v+(1-f_v)\cdot(1-G_i.p))\\\\g_v=res+(1-res)\cdot(1-G_i.p)</script><p>两边 $dfs$ 就可以搞定。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans,f[N],g[N],q[N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,n,tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to;<span class="keyword">double</span> p;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> p)</span> </span>&#123;G[++cnt]=(Edge)&#123;head[x],y,p&#125;,head[x]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[u]=<span class="number">1</span>-q[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>((v=G[i].to)!=fa)</span><br><span class="line">            dfs1(v,u),f[u]*=(f[v]+(<span class="number">1</span>-f[v])*(<span class="number">1</span>-G[i].p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>((v=G[i].to)!=fa) &#123;</span><br><span class="line">            <span class="keyword">double</span> res=g[u]*f[u]/(f[v]+(<span class="number">1</span>-f[v])*(<span class="number">1</span>-G[i].p));</span><br><span class="line">            g[v]=res+(<span class="number">1</span>-res)*(<span class="number">1</span>-G[i].p);dfs2(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,p;IN(x),IN(y),IN(p);</span><br><span class="line">        add(x,y,p/<span class="number">100.0</span>),add(y,x,p/<span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) IN(x),q[i]=x/<span class="number">100.0</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1.0</span>,dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans+=<span class="number">1</span>-f[i]*g[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门在这：&lt;a href=&quot;https://loj.ac/problem/2192&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我是传送门$QwQ$&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。&lt;/p&gt;
&lt;p&gt;因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2015]寿司晚宴  状压DP  loj2131</title>
    <link href="http://qiulyblog.github.io/2019/05/01/%5B%E9%A2%98%E8%A7%A3%5Dloj2131/"/>
    <id>http://qiulyblog.github.io/2019/05/01/[题解]loj2131/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-05T01:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。</p><p>设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mul=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,s[N];ll p,f[<span class="number">2</span>][mul][mul];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(ll&amp;x,ll&amp;y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;p)x-=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">// freopen("1.out","w",stdout);</span></span><br><span class="line">    IN(n),IN(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;++j)</span><br><span class="line">            <span class="keyword">if</span>(!(i%pri[j])) s[i]|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now=i&amp;<span class="number">1</span>,lst=!now;</span><br><span class="line">        <span class="built_in">memcpy</span>(f[now],f[lst],<span class="keyword">sizeof</span>(f[lst]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;mul;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;mul;++s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[lst][s1][s2]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;s[i])) pls(f[now][s1|s[i]][s2],f[lst][s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;s[i])) pls(f[now][s1][s2|s[i]],f[lst][s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;mul;++s1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;mul;++s2) pls(ans,f[n&amp;<span class="number">1</span>][s1][s2]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以知道 $n\leq 500$ 的时候，每一个数最多带上一个大于等于 $23$ 的质因子。我们首先将所有的寿司分为两类：带了大于等于 $23$ 的质因子的和没带的。</p><p>没带的显然可以向上面那样转移。那么带了的呢？这个显然不能压缩吧。</p><p>我们考虑将带了同样的大于等于 $23$ 的质因子的分成一组，这一组要不小 $\rm{G}$ 吃小 $\rm{W}$ 不吃，要不小 $\rm{W}$ 吃小 $G$ 不吃。分别讨论即可。</p><p>设 $f1[s1][s2]$ 表示这一组是小 $\rm{G}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。同理，设 $f2[s1][s2]$ 表示这一组是小 $\rm{W}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。分别转移就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i) &#123; <span class="comment">/*枚举这些寿司*/</span></span><br><span class="line">    <span class="keyword">if</span>(a[i].t!=a[i<span class="number">-1</span>].t) <span class="comment">/*大质因子不同了*/</span></span><br><span class="line">        <span class="built_in">memcpy</span>(f1,f,<span class="keyword">sizeof</span>(f)),<span class="built_in">memcpy</span>(f2,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">        <span class="comment">/*倒着枚举所以没用滚动数组*/</span></span><br><span class="line">        <span class="comment">/*所谓的分别转移*/</span></span><br><span class="line">        <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]);</span><br><span class="line">        <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这一组结束了，需要合并答案*/</span></span><br><span class="line">    <span class="keyword">if</span>(a[i].t!=a[i+<span class="number">1</span>].t||i==n)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2)</span><br><span class="line">            <span class="comment">/*因为f1[s1][s2]和f2[s1][s2]都重复算了一遍原来的</span></span><br><span class="line"><span class="comment">            f[s1][s2]，所以减掉后再取膜*/</span></span><br><span class="line">            f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">ll p,f[M][M],f1[M][M],f2[M][M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> t,s;&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span> </span>&#123;<span class="keyword">return</span> a.t&lt;b.t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(ll&amp;x,ll&amp;y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;=p)x%=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;IN(n),IN(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        a[i].t=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;++j)<span class="keyword">if</span>(!(i%pri[j])) &#123;</span><br><span class="line">            a[i].s|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>),a[i].t/=pri[j];</span><br><span class="line">            <span class="keyword">while</span>(!(a[i].t%pri[j])) a[i].t/=pri[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    sort(a+<span class="number">2</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[pos].t==<span class="number">1</span>) ++pos;--pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=pos;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f[s1|a[i].s][s2],f[s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f[s1][s2|a[i].s],f[s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].t!=a[i<span class="number">-1</span>].t)</span><br><span class="line">            <span class="built_in">memcpy</span>(f1,f,<span class="keyword">sizeof</span>(f)),<span class="built_in">memcpy</span>(f2,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i].t!=a[i+<span class="number">1</span>].t||i==n)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2)</span><br><span class="line">                f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2) pls(ans,f[s1][s2]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans+p)%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。&lt;/p&gt;
&lt;p&gt;设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状态压缩" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [JSOI2016]灯塔  决策单调性&amp;DP  loj2074</title>
    <link href="http://qiulyblog.github.io/2019/04/30/%5B%E9%A2%98%E8%A7%A3%5Dloj2047/"/>
    <id>http://qiulyblog.github.io/2019/04/30/[题解]loj2047/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2019-05-05T01:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：<a href="https://loj.ac/problem/2074" target="_blank" rel="noopener">在这呢o(￣︶￣)o</a></p><p>刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了：</p><script type="math/tex; mode=display">h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}</script><p>设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续：</p><a id="more"></a><script type="math/tex; mode=display">f_i=\max\{ h_j +\sqrt{|i−j|}\}-h_i</script><p>发现绝对值很烦人，将绝对值拆开。</p><script type="math/tex; mode=display">f_i=\max(\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\},\max\limits_{j=i}^{n}\{h_j +\sqrt{j-i}\})-h_i</script><p>原序列翻转一下就可以直接计算后面的式子，也就是说我们只需要考虑第一个：</p><script type="math/tex; mode=display">f_i=\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\}-h_i</script><p>假设对于 $i$ 来说 $j$ 是最优的决策，那么如果存在一个小于 $j$ 的 $k$ ，是否在转移一个大于 $i$ 的 $l$ 会更优呢？显然不会，可以知道 $i-k$ 显然是大于 $i-j$ 的，而且根号是增长的越来越慢的。所以如果在 $i$ 时 $k$ 就没有 $j$ 优了，那么在以后所以大于 $i$ 的 $l$ 转移时 $k$ 也不可能比 $j$ 优。</p><p>也就是说上面的式子满足决策单调性，那么我们可以 $O(n\log n)$ 愉快求出了。</p><p>这里说明两个方法：</p><ul><li><strong>1.</strong> 单调队列维护三元组，三元组包含 $v$ (决策点 $v$) ，$l$ (决策点 $v$ 作为最优决策点的最左端点) ，$r$ (决策点 $v$ 作为最优决策点的最右端点) ，每一次排除掉最右端点小于 $i$ 的元素(因为该元素已经没用了) ，插入队列的时候去掉完全劣于 $i$ 的，然后对于折中的二分即可。(具体参见诗人小 $\rm{G}$ 的题解) 。</li><li><strong>2.</strong> 分治计算答案。设 $slove(al,ar,vl,vr)$ 表示在原数组 $al$ 到 $ar$ 这段区间的最优决策点位于 $vl$ 到 $vr$ 区间。我们每一次找到 $al$ 到 $ar$ 的中间点，也就是 $mid$ ，然后在 $vl$ 到 $vr$ 寻找最优的决策点更新 $f_{mid}$ ( $\rm{DP}$ 数组)，设这个最优点为 $g$ 。因为满足决策单调性，$al$ 到 $mid-1$ 的所有点的最优决策点一定在 $vl$ 到 $g$ 之间，右边 $mid+1$ 到 $ar$ 的也同理，就这么分治下去即可。</li></ul><p>实际运用中分治的效率不如三元组，但是代码却好写得多，很短，并且调试难度也大大降低，所以最终我选择了分治……分治的具体细节看代码。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;ll a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> f1[N],f2[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f1</span><span class="params">(<span class="keyword">int</span> al,<span class="keyword">int</span> ar,<span class="keyword">int</span> vl,<span class="keyword">int</span> vr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(al&gt;ar) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(al+ar)&gt;&gt;<span class="number">1</span>,g=<span class="number">0</span>;</span><br><span class="line">    f1[mid]=a[mid];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vl;i&lt;=min(vr,mid);++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> calc=a[i]+<span class="built_in">sqrt</span>(<span class="keyword">double</span>(mid-i));</span><br><span class="line">        <span class="keyword">if</span>(calc&gt;f1[mid]) f1[mid]=calc,g=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mid;f1[mid]-=a[mid];</span><br><span class="line">    solve_f1(al,mid<span class="number">-1</span>,vl,g),solve_f1(mid+<span class="number">1</span>,ar,g,vr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f2</span><span class="params">(<span class="keyword">int</span> al,<span class="keyword">int</span> ar,<span class="keyword">int</span> vl,<span class="keyword">int</span> vr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(al&gt;ar) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(al+ar)&gt;&gt;<span class="number">1</span>,g=<span class="number">0</span>;</span><br><span class="line">    f2[mid]=a[mid];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vr;i&gt;=max(vl,mid);--i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> calc=a[i]+<span class="built_in">sqrt</span>(<span class="keyword">double</span>(i-mid));</span><br><span class="line">        <span class="keyword">if</span>(calc&gt;f2[mid]) f2[mid]=calc,g=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mid;f2[mid]-=a[mid];</span><br><span class="line">    solve_f2(al,mid<span class="number">-1</span>,vl,g),solve_f2(mid+<span class="number">1</span>,ar,g,vr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    solve_f1(<span class="number">1</span>,n,<span class="number">1</span>,n),solve_f2(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line">    <span class="comment">/*最终没有翻转序列，而是选择做两遍分治*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ll)<span class="built_in">ceil</span>(max(f1[i],f2[i])));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：&lt;a href=&quot;https://loj.ac/problem/2074&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在这呢o(￣︶￣)o&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}&lt;/script&gt;&lt;p&gt;设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
      <category term="分治" scheme="http://qiulyblog.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2016]国王饮水记  斜率优化DP  loj2087</title>
    <link href="http://qiulyblog.github.io/2019/04/29/%5B%E9%A2%98%E8%A7%A3%5Dloj2087/"/>
    <id>http://qiulyblog.github.io/2019/04/29/[题解]loj2087/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-29T13:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>可爱的题目传送门：<a href="https://loj.ac/problem/2087" target="_blank" rel="noopener">戳我戳我·(<em>╹▽╹</em>)·</a></p><p>说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧……</p><ul><li><strong>1.</strong> 初始水位小于 $h_1$ 的没有用。</li></ul><p>这很显然。</p><a id="more"></a><ul><li><strong>2.</strong> 如果 $n\leq k$ ，那么只需要将所以大于 $h_1$ 的跟 $1$ 城市连就好了。</li></ul><p>每次连接的城市数越少贡献越大，那么每个逐一连一次一定是最优方案。</p><ul><li><strong>3.</strong> 每次操作必然跟 $1$ 城市有关系。</li></ul><p>不然没贡献。</p><ul><li><strong>4.</strong> 除了 $1$ 号城市，其他每个城市最多连一次。</li></ul><p>因为连过一次的城市的水位已经和 $1$ 城市一样了，简单点说肯定就是废了。</p><ul><li><strong>5.</strong> 每次连的所有城市中最小的 $h_i$ 必然大于上一次链接的最大的 $h_i$ 。</li></ul><p>这很显然，不然不满足最优方案。</p><ul><li><strong>6.</strong> 将所以城市按水位排序后，每次选择的必然是连续一段区间。</li></ul><p>和上一个差不多。</p><ul><li><strong>7.</strong> 每次选择的区间必然和上一次的选择区间接触。</li></ul><p>这很显然。</p><ul><li><strong>8.</strong> 每次选择的区间的长度必定单调不增。</li></ul><p>满足最优，都说了每次连接的城市越少贡献越大。</p><hr><p>那么显然就变成了一个区间问题了，我们需要将这个区间分成若干块。</p><p>设 $f_{i,j}$ 表示排序后前 $i$ 个城市联通了 $j$ 次后 $1$ 号城市的最大水位高度。那么转移直接枚举一个 $k$ ，在新的一次连接中连接了 $k+1$ 到 $i$ 这些城市。转移方程显然：</p><script type="math/tex; mode=display">f_{i,j}=\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1}</script><p>*注：$s_i$ 为前缀和。</p><p>上式的复杂度为 $O(n^2k)$  ，肯定爆炸。但是这个是可以<strong>斜率优化</strong>的：</p><script type="math/tex; mode=display">\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1} =\frac{s_i-(s_k-f_{k,j-1})}{i-(k-1)}\Rightarrow \frac{Y(i)-Y(k)}{X(i)-X(k)}</script><p>然后通过第 $8$ 条性质可以得知 $\texttt{DP}$ 是有<strong>决策单调性</strong>的，故复杂度为 $O(nk)$ 。因为恶心的高精度小数的运算还需要 $O(p)$ 的复杂度，所以最终总时间复杂度为 $O(nkp)$ 。</p><p>我们发现 $k$ 有 $10^9$ ，所以复杂度带 $k$ 的一定假掉了。</p><p>那么观察第 $2$ 条性质会发现，如果 $k$ 大于 $n$ 了直接将 $k$ 设为 $n$ 就好了。也就是说复杂度应该为 $O(n^2p)$ ，这样就是 $86$ 分，通过数据来看会发现这个倾向于大众分，一车厢的人都是这个分数。</p><p>那么如果想要 $\texttt{AC}$ 的话需要最后一条很迷的性质：</p><ul><li><strong>9.</strong> 因为 $h$ 各不同，选择的区间最多只有 $14$ 个区间长度大于 $1$ ，其他的区间均等于 $1$ 。</li></ul><p>很迷，准确的说这样的区间是 $O(\log\frac{nh}{\min_i\{h_i-h_{i-1}\}})$ 个。</p><p>证明不会……但是这里写了证明(唯一的且很迷的证明)：<a href="https://github.com/qiulyblog/image/blob/master/[NOI2016]%E5%9B%BD%E7%8E%8B%E9%A5%AE%E6%B0%B4%E8%AE%B0%E9%A2%98%E8%A7%A3.pdf?raw=true" target="_blank" rel="noopener">哈哈我是传送门O(∩_∩)O</a></p><p>那么就丢代码了，实际上是需要高精小数的，这里先给出一个除去高精小数板子的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">8e3</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Decimal ans;</span><br><span class="line"><span class="keyword">int</span> n,k,p,lim,h[N],s[N],pre[N][<span class="number">16</span>],tot;</span><br><span class="line"><span class="keyword">int</span> q[N],head,tail;</span><br><span class="line"><span class="keyword">double</span> f[N][<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span><span class="keyword">double</span> x,y;&#125;t[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(point a,point b)</span> </span>&#123;<span class="keyword">return</span> (a.y-b.y)/(a.x-b.x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Decimal <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!j) <span class="keyword">return</span> h[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> (solve(pre[i][j],j<span class="number">-1</span>)+s[i]-s[pre[i][j]])/(i-pre[i][j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;k,&amp;p,&amp;h[tot=<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;h[i]);</span><br><span class="line">        <span class="keyword">if</span>(h[i]&gt;h[<span class="number">1</span>]) h[++tot]=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    n=tot;sort(&amp;h[<span class="number">1</span>],&amp;h[n+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i][<span class="number">0</span>]=h[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]=s[i<span class="number">-1</span>]+h[i];</span><br><span class="line">    k=min(k,n),lim=min(k,<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lim;++j) &#123;</span><br><span class="line">        q[head=tail=<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t[i]=(point)&#123;i<span class="number">-1</span>,s[i]-f[i][j<span class="number">-1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            point now=(point)&#123;i,s[i]&#125;;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(now,t[q[head]])&lt;slope(now,t[q[head+<span class="number">1</span>]])) ++head;</span><br><span class="line">            f[i][j]=(f[q[head]][j<span class="number">-1</span>]+s[i]-s[q[head]])/(i-q[head]+<span class="number">1</span>);</span><br><span class="line">            pre[i][j]=q[head];</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(t[q[tail]],t[q[tail<span class="number">-1</span>]])&gt;slope(t[q[tail]],t[i])) --tail;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=n-k+lim,pos;</span><br><span class="line">    <span class="keyword">double</span> mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i) </span><br><span class="line">        <span class="keyword">if</span>(f[m][i]&gt;mx) mx=f[m][i],pos=i;</span><br><span class="line">    ans=solve(m,pos);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=n;++i) ans=(ans+h[i])/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans.to_string(p&lt;&lt;<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么高精度小数板子的下载链接就贴这了：<a href="https://loj.ac/problem/2087/download/additional_file" target="_blank" rel="noopener">$loj$ 的下载地址传送们(～￣▽￣)～</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可爱的题目传送门：&lt;a href=&quot;https://loj.ac/problem/2087&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳我戳我·(&lt;em&gt;╹▽╹&lt;/em&gt;)·&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1.&lt;/strong&gt; 初始水位小于 $h_1$ 的没有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这很显然。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 小谈斜率优化</title>
    <link href="http://qiulyblog.github.io/2019/04/28/%5B%E7%AE%97%E6%B3%95%5D%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://qiulyblog.github.io/2019/04/28/[算法]斜率优化/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-05-06T05:42:53.964Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="再此输入你的密码以便阅读全文" />    <label for="pass">再此输入你的密码以便阅读全文</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本文为加密文章，阅读本文需要输入密码。
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="算法" scheme="http://qiulyblog.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2015]亚瑟王  概率DP  loj2112</title>
    <link href="http://qiulyblog.github.io/2019/04/28/%5B%E9%A2%98%E8%A7%A3%5Dloj2112/"/>
    <id>http://qiulyblog.github.io/2019/04/28/[题解]loj2112/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-29T13:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现 <a href="https://loj.ac" target="_blank" rel="noopener">$loj$</a> 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。</p><p>顺便贴一下题目传送门：<a href="https://loj.ac/problem/2112" target="_blank" rel="noopener">$loj$的传送门就戳我啦(～￣▽￣)～</a></p><p>概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。</p><a id="more"></a><p>第一种情况：$j$ 轮中都没有打出第 $i+1$ 张牌，由于一轮中不打出第 $i+1$ 张牌的概率为 $1-p_i$ ，那么 $j$ 轮都不打出该牌的概率显然为 $(1-p_i)^j$ 。转移方程显然：</p><script type="math/tex; mode=display">f_{i+1,j}+=f_{i,j}\cdot (1-p_i)^j​</script><p>因为 $f_{i+1,j}$ 可能从多方向转移过来，所以是 $+=$ 。</p><p>第二种情况：$j$ 轮中至少有一轮打出了第 $i+1$ 张牌，概率显然为 $1-(1-p_i)^j$ ，转移也就很显然了：</p><script type="math/tex; mode=display">f_{i+1,j-1}+=f_{i,j}\cdot （1-(1-p_i)^j）</script><p>如果我们打出了第 $i+1$ 张牌，那么肯定是要计算贡献的，这个时候直接用这个概率算贡献就好了。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,r,d[N];</span><br><span class="line"><span class="keyword">double</span> f[N][N],p[N],pw[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>,&amp;p[i],&amp;d[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            pw[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=r;++j) pw[i][j]=pw[i][j<span class="number">-1</span>]*(<span class="number">1</span>-p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][r]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=r;++j) &#123;</span><br><span class="line">                f[i+<span class="number">1</span>][j]+=f[i][j]*pw[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j) &#123;</span><br><span class="line">                    <span class="keyword">double</span> calc=f[i][j]*(<span class="number">1</span>-pw[i+<span class="number">1</span>][j]);</span><br><span class="line">                    f[i+<span class="number">1</span>][j<span class="number">-1</span>]+=calc,ans+=calc*d[i+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现 &lt;a href=&quot;https://loj.ac&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$loj$&lt;/a&gt; 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。&lt;/p&gt;
&lt;p&gt;顺便贴一下题目传送门：&lt;a href=&quot;https://loj.ac/problem/2112&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$loj$的传送门就戳我啦(～￣▽￣)～&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [CEOI2017]Building Bridges 斜率优化DP loj2483</title>
    <link href="http://qiulyblog.github.io/2019/04/27/%5B%E9%A2%98%E8%A7%A3%5Dloj2483/"/>
    <id>http://qiulyblog.github.io/2019/04/27/[题解]loj2483/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-04-29T13:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>愉快的推式子吧(ﾉ≧∀≦)ﾉ！</p><p>设 $f_i$ 表示前 $i$ 根柱子完工后的最小代价。枚举一个小于 $i$ 的 $j$ ，表示为从 $j$ 向 $i$ 连了一座桥，中间的柱子当然全部推掉，计算一下就好：</p><script type="math/tex; mode=display">f_i=\min\{f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\}</script><p>*其中 $s$ 为 $w$ 的前缀和。</p><a id="more"></a><script type="math/tex; mode=display">f_i=f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\\\\f_i=f_j+s_{i-1}-s_j+h_i^2+h_j^2-2h_ih_j\\\\f_j+s_{i-1}-s_j+h_i^2+h_j^2=2h_ih_j+f_i</script><p>于是最终式子变成了 $y=kx+b$ 的形式，斜率优化！</p><p>但是……注意这个式子的 $k$ 不是单调递增的，并且 $x$ 也不是单调递增的！那么我们不能用朴素做法了，也不能用二分……难道用 $Splay$ ？(码量巨大) 。</p><p>不，用 $CDQ$ 分治。</p><p>对于一个 $i$ ，可能可以对 $i$ 做出贡献的只有所有小于 $i$ 的 $j$ 。为了保证 $x$ 单调我们先大力将原来的数组按照 $x$ 从小到大排个序，然后 $CDQ$ 的时候分左右两边，左边的所有元素在初始数组的位置都小于右边的左右元素，也就是说我们直接用左边元素对右边元素做出贡献。</p><p>同时这里也保证了左右两边的 $x$ 一定是单调上增的。</p><p>我们使用单调队列，扫一遍左边的元素，留下能做贡献的点(下凸壳上的点)，这时候左边的所有元素可以保证 $x$ 和斜率都是单调上增的。</p><p>右边呢？因为直线的斜率是 $2x$ ，而右边的 $x$ 也是单调上增的，所以我们可以愉快的做朴素的单调队列了。</p><p>$CDQ$ 分治部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;<span class="comment">/*一个点的时候直接计算y值*/</span></span><br><span class="line">        a[l].y=f[a[l].id]-s[a[l].id]+S(a[l].x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(a[i].id&lt;=mid) b[c1++]=a[i]; <span class="comment">/*编号小的左边去*/</span></span><br><span class="line">        <span class="keyword">else</span> b[c2++]=a[i]; <span class="comment">/*编号大些的右边去*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    CDQ(l,mid); <span class="comment">/*计算出左边所有元素的 f*/</span></span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i) &#123; <span class="comment">/*处理出左边所有元素组成的下凸壳*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail<span class="number">-1</span>],q[tail])&gt;slope(q[tail],i)) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;++i) &#123; <span class="comment">/*计算左边元素对右边元素产生的贡献*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*a[i].x) ++head; <span class="comment">/*维护队列*/</span></span><br><span class="line">        <span class="keyword">int</span> x=a[i].id,y=a[q[head]].id;</span><br><span class="line">        f[x]=min(f[x],f[y]+s[x<span class="number">-1</span>]-s[y]+S(a[i].x-a[q[head]].x));</span><br><span class="line">        <span class="comment">/*可能计算多次所以要取min*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i)  <span class="comment">/*还原a数组至初始状态*/</span></span><br><span class="line">        <span class="keyword">if</span>(c2&gt;r||(c1&lt;=mid&amp;&amp;a[c1].x&lt;a[c2].x)) b[i]=a[c1++];</span><br><span class="line">        <span class="keyword">else</span> b[i]=a[c2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数中</span></span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp),CDQ(<span class="number">1</span>,n); <span class="comment">/*排序后CDQ开始*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]); <span class="comment">/*输出*/</span></span><br></pre></td></tr></table></figure><p>最后因为存在 $0$ ，在计算斜率的时候需要特判一下。还需要注意一下 $long\ long$ 的问题，记得将 $f$ 数组初始化。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e18</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span><span class="keyword">int</span> x,id;ll y;&#125;a[N],b[N];</span><br><span class="line">ll s[N],w[N],f[N];<span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point x,point y)</span> </span>&#123;<span class="keyword">return</span> x.x&lt;y.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i].x==a[j].x) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[i].y&lt;a[j].y?inf:-inf;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="keyword">double</span>(a[i].y-a[j].y)/<span class="keyword">double</span>(a[i].x-a[j].x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;a[l].y=f[a[l].id]-s[a[l].id]+S(a[l].x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(a[i].id&lt;=mid) b[c1++]=a[i];</span><br><span class="line">        <span class="keyword">else</span> b[c2++]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    CDQ(l,mid);</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail<span class="number">-1</span>],q[tail])&gt;slope(q[tail],i)) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*a[i].x) ++head;</span><br><span class="line">        <span class="keyword">int</span> x=a[i].id,y=a[q[head]].id;</span><br><span class="line">        f[x]=min(f[x],f[y]+s[x<span class="number">-1</span>]-s[y]+S(a[i].x-a[q[head]].x));</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(c2&gt;r||(c1&lt;=mid&amp;&amp;a[c1].x&lt;a[c2].x)) b[i]=a[c1++];</span><br><span class="line">        <span class="keyword">else</span> b[i]=a[c2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        IN(a[i].x),a[i].id=i,f[i]=inf;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(w[i]),s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp),CDQ(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;愉快的推式子吧(ﾉ≧∀≦)ﾉ！&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示前 $i$ 根柱子完工后的最小代价。枚举一个小于 $i$ 的 $j$ ，表示为从 $j$ 向 $i$ 连了一座桥，中间的柱子当然全部推掉，计算一下就好：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\min\{f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\}&lt;/script&gt;&lt;p&gt;*其中 $s$ 为 $w$ 的前缀和。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [APIO2010]特别行动队  斜率优化DP  luoguP3628</title>
    <link href="http://qiulyblog.github.io/2019/04/24/%5B%E9%A2%98%E8%A7%A3%5DluoguP3628/"/>
    <id>http://qiulyblog.github.io/2019/04/24/[题解]luoguP3628/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-28T05:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>依旧是斜率优化的套路。</p><p>设 $f_i$ 表示前 $i$ 个士兵的最大贡献，转移显然是枚举一个 $j$ ，将 $j+1$ 到 $i$ 这些士兵组成特别行动队算贡献：</p><script type="math/tex; mode=display">f_i=\max\{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c\}​</script><p>其中 $s_i$ 为战斗力的前缀和。这个方程是 $O(n^2)$ 的，需要优化。发现这个转移式貌似不满足单调队列优化的条件，于是将中间的式子拆开看看可不可以斜率优化。</p><a id="more"></a><script type="math/tex; mode=display">f_i=\max\{f_j+a(s_i^2+s_j^2-2s_is_j)+b\cdot s_i-b\cdot s_j+c\}\\f_i=\max\{f_j+a\cdot s_i^2+a\cdot s_j^2-2a\cdot s_is_j)+b\cdot s_i-b\cdot s_j+c\}\\f_i=f_j+a\cdot s_i^2+a\cdot s_j^2-2a\cdot s_is_j+b\cdot s_i-b\cdot s_j+c\\f_j+a\cdot s_i^2+a\cdot s_j^2+b\cdot s_i-b\cdot s_j+c=2a\cdot s_i\cdot s_j +f_i​</script><p>诶，是 $y=kx+b$ 的形式，而且满足斜率优化的条件诶。继续将 $x,y$ 找出来放到坐标系上( $x=s_j$,$y=f_j+a\cdot s_j^2-b\cdot s_j$) 。</p><p>因为是 $\max​$ ，所以用单调队列维护一下上凸壳然后转移即可，复杂度 $O(n)​$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,head,tail;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[N],f[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> s[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]+<span class="number">1l</span>l*S(s[i])*a<span class="number">-1l</span>l*s[i]*b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> (Y(j)-Y(i))/(X(j)-X(i));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    f[i]=f[j]+<span class="number">1l</span>l*S(s[i]-s[j])*a+<span class="number">1l</span>l*(s[i]-s[j])*b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(a),IN(b),IN(c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(s[i]),s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&gt;<span class="number">2</span>*a*s[i]) ++head;</span><br><span class="line">        calc(i,q[head]);</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail],i)&gt;slope(q[tail],q[tail<span class="number">-1</span>])) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依旧是斜率优化的套路。&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示前 $i$ 个士兵的最大贡献，转移显然是枚举一个 $j$ ，将 $j+1$ 到 $i$ 这些士兵组成特别行动队算贡献：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\max\{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c\}​&lt;/script&gt;&lt;p&gt;其中 $s_i$ 为战斗力的前缀和。这个方程是 $O(n^2)$ 的，需要优化。发现这个转移式貌似不满足单调队列优化的条件，于是将中间的式子拆开看看可不可以斜率优化。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2008]玩具装箱TOY  斜率优化DP  luoguP3195</title>
    <link href="http://qiulyblog.github.io/2019/04/24/%5B%E9%A2%98%E8%A7%A3%5DluoguP3195/"/>
    <id>http://qiulyblog.github.io/2019/04/24/[题解]luoguP3195/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-28T05:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>差不多搞懂了斜率优化吧……说实话网上的文章都写得很迷，还好找到了一个不错的文章：<a href="https://www.cnblogs.com/yangsongyi/p/9630227.html" target="_blank" rel="noopener">转送门戳我(￣▽￣)~*</a> 。(为什么突然发现这道题和诗人小G很像呢) </p><p>这个 $\texttt{DP}$ 方程谁都会设：设 $f_i$ 表示前 $i$ 个玩具的最小费用，转移显然如下：</p><script type="math/tex; mode=display">f_i=\min\limits_{j=1}^{i-1}\{f_j+(sum_i-sum_j+i-j-l)^2\}</script><p>(其中 $sum$ 是前缀和)。这个复杂度是 $O(n^2)$ 的，过不去……</p><a id="more"></a><p>继续推式子：</p><script type="math/tex; mode=display">f_i=\min\limits_{j=1}^{i-1}\{f_j+[(sum_i+i)-(sum_j+j)-l]^2\}</script><p>设 $s_i=sum_i+i$ ，我们假设 $j$ 为最优决策，将 $\min$ 去掉。</p><script type="math/tex; mode=display">f_i=f_j+(s_i-s_j-l)^2\\f_i=f_j+s_i^2+(s_j+l)^2-2\cdot s_i\cdot(s_j+l)\\f_j+s_i^2+(s_j+l)^2=2\cdot s_i\cdot(s_j+l)+f_i​</script><p>于是上面的式子变成了 $y=kx+b$ 的形式，其中 $y=f_j+s_i^2+(s_j+l)^2$ ，$k=2\cdot s_i$ ，$x=s_j+l$ ，$b=f_i$ 。</p><p>然后将 $x,y$ 两个值作为点 $(x,y)$ 放到平面上即可，因为最终答案是取 $min$ ，所以我们需要维护的是下凸壳。有一点需要注意的是，我们算斜率的时候可以将每个点的常数项或者只和 $i$ 有关的项去掉，因为算斜率是相减的，减的时候这些项同样也没了。</p><p>上面的 $x$ 中的 $l$ 是常数项于是可以省略，$y$ 中的 $s_i^2$ 只和 $i$ 有关，于是也省略掉。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,l,head,tail;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N],s[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> s[i];&#125;<span class="comment">/*每个点的x坐标*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]+S(s[i]+l);&#125;<span class="comment">/*每个点的y坐标*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> (Y(j)-Y(i))/(X(j)-X(i));&#125;<span class="comment">/*算斜率*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;s[i]),s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]+=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*s[i]) ++head;</span><br><span class="line">        f[i]=f[q[head]]+S(s[i]-s[q[head]]-l<span class="number">-1</span>);<span class="comment">/*转移*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail],i)&lt;slope(q[tail],q[tail<span class="number">-1</span>])) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来解释一些问题。</p><h3 id="1-为什么要维护下凸壳"><a href="#1-为什么要维护下凸壳" class="headerlink" title="1.为什么要维护下凸壳"></a>1.为什么要维护下凸壳</h3><p>因为我们的 $\texttt{DP}$ 方程是在取 $\min$ ，如果是 $\max$ 的话则维护上凸壳。而且维护下凸壳显然是让 $f_i$ 更小。</p><p>以上面为例，我们用 $y=kx+b​$ 的直线从下面网上扫，注意这条直线的斜率就是 $k​$ 。很显然如果我们从下往上这样扫越往上扫 $b​$ 越大(不明白的画画图)，但是我们的目的是使得 $b​$ 最小( $b​$ 就是 $f_i​$ ) 。下凸壳包含了最下面的所有点，显然不是下凸壳上的点一定不能成为最优的。</p><h3 id="2-维护队列的过程是什么鬼操作"><a href="#2-维护队列的过程是什么鬼操作" class="headerlink" title="2.维护队列的过程是什么鬼操作"></a>2.维护队列的过程是什么鬼操作</h3><p>首先第一个过程，也就是下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*s[i]) ++head;</span><br></pre></td></tr></table></figure><p>上面讲了我们需要使得 $b​$ 最小，那么最优的决策点在直线从下往上扫的过程中肯定是最先扫到的，因为那样可以保证 $f_i​$ 最小。假设最优的点为 $i​$ ，上一个点为 $j​$ ，下一个点为 $k​$ ，那么 $i​$ 一定保证 $j​$ 到 $i​$ 的斜率小于直线斜率并且 $i​$ 到 $k​$ 的斜率大于直线斜率。</p><p>然后我们会发现对于单调上增的需要更新的 $i​$ ，其直线的斜率 $k​$ 一定是单调上增的，因为前缀和是单调上增的。</p><p>所以对于斜率已经不满足要求的点直接踢出队就好了。</p><p>然后康康出队的过程。如果在纸上画画会发现，如果满足 <code>slope(q[tail],i)&lt;slope(q[tail],q[tail-1])</code> ，那么说明 $q[tail]$ 已经不再下凸壳中了！没错吧？那么这个时候 $q[tail]$ 永远也不可能成为最优的转移点了，直接丢掉即可。</p><hr><p>最后有一些斜率优化的套路总结(自己总结出来的)：</p><ul><li>$\texttt{DP}$ 方程取 $\min$ 就维护下凸壳，取 $\max$ 就维护上凸壳</li><li>$y=kx+b​$ 中的 $k​$ 一定要是常量或者是完全是 $i​$ 的量(例如 $s_i,2\cdot g_i^2​$ 等)，$b​$ 一定是你需要转移的对象(就是 $f_i​$ )，$x​$ 和 $y​$ 两个值一定要包含和 $j​$ 有关的值，要随 $j​$ 的变化而变化。</li><li>提炼出来的 $x,y$ 放到坐标系上之前记得去掉没用的值。</li></ul><p>差不多就这些吧，也不知道是不是完全正确，至少这个套路还是过了几道题目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;差不多搞懂了斜率优化吧……说实话网上的文章都写得很迷，还好找到了一个不错的文章：&lt;a href=&quot;https://www.cnblogs.com/yangsongyi/p/9630227.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转送门戳我(￣▽￣)~*&lt;/a&gt; 。(为什么突然发现这道题和诗人小G很像呢) &lt;/p&gt;
&lt;p&gt;这个 $\texttt{DP}$ 方程谁都会设：设 $f_i$ 表示前 $i$ 个玩具的最小费用，转移显然如下：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\min\limits_{j=1}^{i-1}\{f_j+(sum_i-sum_j+i-j-l)^2\}&lt;/script&gt;&lt;p&gt;(其中 $sum$ 是前缀和)。这个复杂度是 $O(n^2)$ 的，过不去……&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SCOI2008]奖励关  状压DP  luoguP2473</title>
    <link href="http://qiulyblog.github.io/2019/04/23/%5B%E9%A2%98%E8%A7%A3%5DluoguP2473/"/>
    <id>http://qiulyblog.github.io/2019/04/23/[题解]luoguP2473/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-04-24T07:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现数据范围很小，并且涉及到”集合”，很容易可以想到用状压 $\texttt{DP}$ 。</p><p>设 $f[i][j]$ 表示已经抛出了 $i$ 次宝物，获得的宝物集合为 $j$ 时的最优分值。那么转移的时候枚举每一个宝物，分两种情况即可——选当前宝物或者不选。注意选当前宝物的前提是必须满足前提，按照最优情况选取即可。注意最后将所有的宝物的贡献加上后还需要$/n$ ，因为题目要求的是”平均”。</p><a id="more"></a><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">101</span>][<span class="number">65540</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">18</span>],d[<span class="number">18</span>],v[<span class="number">18</span>],N,K;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;++i) p[i]=<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;K,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(x) &#123;d[i]|=p[x];<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=K;i;--i) <span class="comment">/*倒着枚举会好些*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=p[N+<span class="number">1</span>]<span class="number">-1</span>;++j) &#123;</span><br><span class="line">            <span class="comment">/*上面两重循环枚举状态*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;++k)<span class="comment">/*枚举所有宝物并计算贡献*/</span></span><br><span class="line">                <span class="keyword">if</span>((d[k]&amp;j)==d[k]) <span class="comment">/*可以选取当前宝物*/</span></span><br><span class="line">                    f[i][j]+=max(f[i+<span class="number">1</span>][j],f[i+<span class="number">1</span>][j|p[k]]+v[k]);</span><br><span class="line">                    <span class="comment">/*按照最优选取*/</span></span><br><span class="line">                <span class="keyword">else</span> f[i][j]+=f[i+<span class="number">1</span>][j]; <span class="comment">/*不能选取直接转移*/</span></span><br><span class="line">            f[i][j]/=N;<span class="comment">/*所谓"平均"*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,f[<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">/*最终答案*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现数据范围很小，并且涉及到”集合”，很容易可以想到用状压 $\texttt{DP}$ 。&lt;/p&gt;
&lt;p&gt;设 $f[i][j]$ 表示已经抛出了 $i$ 次宝物，获得的宝物集合为 $j$ 时的最优分值。那么转移的时候枚举每一个宝物，分两种情况即可——选当前宝物或者不选。注意选当前宝物的前提是必须满足前提，按照最优情况选取即可。注意最后将所有的宝物的贡献加上后还需要$/n$ ，因为题目要求的是”平均”。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状压DP" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2011]Noi嘉年华  决策单调性优化DP  luoguP1973</title>
    <link href="http://qiulyblog.github.io/2019/04/22/%5B%E9%A2%98%E8%A7%A3%5DluoguP1973/"/>
    <id>http://qiulyblog.github.io/2019/04/22/[题解]luoguP1973/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-23T00:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题一共有两问，第一问瞎搞 $\texttt{DP}$ ，第二问如果直接 $\texttt{DP}$ 的话复杂度是 $O(n^4)$ 的过不去，这个时候需要用到决策单调性优化复杂度就可以降低至 $O(n^3)$ ，这样就过了。我们先来讨论一下第一问的做法。</p><p>时间的范围太大了，我们需要离散化一下。离散化后时间就控制在 $0$ 到 $2n$ 的范围内了。</p><p>首先可以发现最终的答案一定就是一段一段时间，每一段时间内的活动都是在同一个会场举行。我们可以预处理一个 $tot_{l,r}$ 表示完全在时间 $l,r$ 之内的活动有多少个。计算直接暴力，预处理的复杂度为 $O(n^3)$ 。</p><a id="more"></a><p>然后设一个 $pre_{i,j}​$ 表示 <strong>$1​$ 到 $i​$ 的时间一个会场的活动数为 $j​$ 时另一个会场的最大活动数</strong>。那么转移的话我们枚举一个时间 $k​$ ，然后考虑 $k​$ 到 $i​$ 这段时间中的所有活动分配给哪个会场即可。可以得到转移方程：</p><script type="math/tex; mode=display">pre_{i,j}=\max\limits_{k=1}^{i}\{pre_{k,j}+tot_{k,i},pre_{k,j-tot_{k,i}}\}​</script><p>这里我们 $pre$ 方程的定义中”一个会场”就是一号会场，”另一个会场”就是二号会场$。pre_{k,j}+tot_{k,i}$ 就是将 $k$ 到 $i$ 这段时间中所有活动都分配给了二号会场，$pre_{k,j-tot_{k,i}}$ 很显然就是分配给了一号会场。计算时枚举 $i,j,k$ ，复杂度是 $O(n^3)$ 。(其实准确的复杂度带个常数，因为 $i$ 枚举的是时间，而时间最大是 $2n$ 的) 。</p><p>我们设离散化后时间总长为 $m$ ，那么答案显然为 $\max\limits_{i=1}^m\{\min(pre_{m,i},i)\}$ 。接下来我们解决第二问。</p><p>我们的 $tot_{l,r}$ 统计的就是完全在时间 $l,r$ 的区间有多少个。那么对于第 $i$ 个活动，设该活动的起始时间与终止时间分别为 $s_i,t_i$ ，那么我们再考虑一对 $x,y \ \ (x\leq s_i,t_i\leq y)$ ，那么如果我们将答案计算上 $tot_{x,y}$ ，那么也就选择了第 $i$ 个活动了。</p><p>我们设 $f_{i,j}$ 表示一号会场强制选择 $i$ 到 $j$ 时间中的所有活动时的最优答案。(注意这里的最优答案就是两个会场中活动少的一方的最大值，我们只是考虑在一号会场<strong>强制选择</strong> $i$ 到 $j​$ 中的所有活动的情况下考虑最优的全局答案) 。</p><p>继续看向一号会场，假设在 $i$ 前面的时间中一号会场已经合法举办了 $x$ 场活动，在 $j$ 后面的时间中也合法举办了 $y$ 场活动。那么我们枚举 $i,j,x,y$ 也可以得到二号会场的活动数：$i$ 前面的时间种有 $pre_{i,x}$ 场活动，$j$ 后面的时间中有……诶这里用 $pre$ 貌似不是很好表示诶，于是我们新定义一个 $suf$ ，$suf_{i,j}$ 表示 <strong>$i$ 到 $m$ 的时间一个会场的活动数为 $j$ 时另一个会场的最大活动数</strong>，$suf$ 的状态转移方程和 $pre$ 的同理。</p><p>枚举 $i,j,x,y$ 后就可以得到两个会场的活动个数，那么就可以直接算答案了：</p><script type="math/tex; mode=display">f_{i,j}=\max\limits_{x=1}^{m}\max\limits_{y=1}^{m}\{\min(x+tot_{i,j}+y,pre_{i,x}+suf_{j,y})\}​</script><p>但是这样子的复杂度是 $O(n^4)​$ 的，过不了。</p><p>不过，我们会发现，<strong>对于单调递增的 $x$ ，对应的最优的 $y$ 一定是单调递减的</strong> 。为什么呢？首先对于一个单调递增的 $i$ ，$pre_{?_i},suf_{?_i}$ 一定是单调递减的( $?$ 为任意数) 。那么如果对于单调递增的 $x$ ，$pre_{i,x}$ 一定是单调递减的，这个时候如果 $y$ 单调递增也就意味着 $suf_{j,y}$ 会单调递减，那么 $x+tot_{i,j}+y$ 和 $pre_{i,x}+suf_{j,y}$ 将会越拉越大，对于答案显然是不利的。反过来，如果 $y$ 是单调递减的，那么就会相对比较均衡。(感性理解理解……)</p><p>那么我们就不需要枚举 $y$ 了，只需要扫一扫就好了，最终计算 $f$ 的时间复杂度为 $O(n^3)$ 。</p><p>最终统计答案的时候，对于一个活动 $i$ ，我们的答案显然为 $\max\limits_{x=1}^{s_i}\max\limits_{y=t_i}^{m}f_{x,y}$ 。必须满足 $x\leq s_i,t_i\leq y$ ，因为这样就会满足一定会选择第 $i$ 个活动。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,j,k) for((i)=(j);(i)&lt;=(k);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(i,j,k) for((i)=(j);(i)&gt;=(k);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e2</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,i,j,k,l,r,s[N],t[N],b[N];</span><br><span class="line"><span class="keyword">int</span> tot[N][N],pre[N][N],suf[N][N],f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> min(x+tot[l][r]+y,pre[l][x]+suf[r][y]);&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=IN();</span><br><span class="line">    F(i,<span class="number">1</span>,n) b[++m]=s[i]=IN(),b[++m]=t[i]=IN()+s[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+m),</span><br><span class="line">    m=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+m)-b<span class="number">-1</span>;<span class="comment">/*离散化去重*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        s[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,s[i])-b;</span><br><span class="line">        t[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,t[i])-b;</span><br><span class="line">        F(l,<span class="number">1</span>,s[i]) R(r,m,t[i]) ++tot[l][r];<span class="comment">/*计算出tot*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    F(i,<span class="number">1</span>,m) F(j,<span class="number">1</span>,n) pre[i][j]=suf[i][j]=-inf;<span class="comment">/*初始化*/</span> </span><br><span class="line">    <span class="comment">/*----------计算出pre和suf----------*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,m) F(j,<span class="number">0</span>,tot[<span class="number">1</span>][i]) F(k,<span class="number">1</span>,i) &#123;</span><br><span class="line">        pre[i][j]=max(pre[i][j],pre[k][j]+tot[k][i]);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=tot[k][i]) pre[i][j]=max(pre[i][j],pre[k][j-tot[k][i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    R(i,m,<span class="number">1</span>) F(j,<span class="number">0</span>,tot[i][m]) F(k,i,m) &#123;</span><br><span class="line">        suf[i][j]=max(suf[i][j],suf[k][j]+tot[i][k]);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=tot[i][k]) suf[i][j]=max(suf[i][j],suf[k][j-tot[i][k]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*计算f*/</span></span><br><span class="line">    F(l,<span class="number">1</span>,m) F(r,l+<span class="number">1</span>,m) <span class="keyword">for</span>(<span class="keyword">int</span> y=n,x=<span class="number">0</span>;x&lt;=n;++x) &#123;<span class="comment">/*y当做指针扫一遍*/</span></span><br><span class="line">        <span class="keyword">int</span> old_calc=calc(x,y),new_calc;</span><br><span class="line">        <span class="keyword">while</span>(y&amp;&amp;old_calc&lt;=(new_calc=calc(x,y<span class="number">-1</span>))) --y,old_calc=new_calc;</span><br><span class="line">        f[l][r]=max(f[l][r],calc(x,y));<span class="comment">/*转移*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*输出答案*/</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    F(i,<span class="number">1</span>,n) ans=max(ans,min(pre[m][i],i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">/*第一问*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        F(l,<span class="number">1</span>,s[i]) R(r,m,t[i]) ans=max(ans,f[l][r]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">/*第二问*/</span></span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题一共有两问，第一问瞎搞 $\texttt{DP}$ ，第二问如果直接 $\texttt{DP}$ 的话复杂度是 $O(n^4)$ 的过不去，这个时候需要用到决策单调性优化复杂度就可以降低至 $O(n^3)$ ，这样就过了。我们先来讨论一下第一问的做法。&lt;/p&gt;
&lt;p&gt;时间的范围太大了，我们需要离散化一下。离散化后时间就控制在 $0$ 到 $2n$ 的范围内了。&lt;/p&gt;
&lt;p&gt;首先可以发现最终的答案一定就是一段一段时间，每一段时间内的活动都是在同一个会场举行。我们可以预处理一个 $tot_{l,r}$ 表示完全在时间 $l,r$ 之内的活动有多少个。计算直接暴力，预处理的复杂度为 $O(n^3)$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】【模板】动态DP  LCT+DP+矩阵  luoguP4751</title>
    <link href="http://qiulyblog.github.io/2019/04/19/%5B%E9%A2%98%E8%A7%A3%5DluoguP4751/"/>
    <id>http://qiulyblog.github.io/2019/04/19/[题解]luoguP4751/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T11:17:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>看懂了后发现 $\texttt{DDP}$ 其实不难呢……</p><p>其实主要思想就是将 $\texttt{DP}$ 转移式搞到矩阵上，然后如果是树形 $\texttt{DP}$ 的话就可以直接上树剖或者是 $LCT$ 进行维护，当然还可以用全局平衡二叉树(不费) 。如果只是线性的话可以直接用线段树等数据结构进行维护了。</p><p>注意这道模板树剖的复杂度是 $O(nlog^2n)$ ，而 $LCT$ 的复杂度为 $O(nlogn)$ ，于是窝选择了 $LCT$ ，跑的还挺快。</p><a id="more"></a><p>开始分析题目，如果没有”动态”限制的话就是一个裸的”没有上司的舞会”，解法显然是设 $f[u][0/1]​$ 表示 $u​$ 不选/选 的时候其子树的最大价值，转移显然为：</p><script type="math/tex; mode=display">f[u][0]=\sum \max(f[v][0],f[v][1])\\f[u][1]=val[u]+\sum f[v][0]</script><p>对于树中的一个节点 $u$ 的所有儿子中有个重儿子，其他的儿子就是轻儿子，我们将重儿子和轻儿子的贡献分开算。设一个 $g[u][0/1]$ ，其值为：</p><script type="math/tex; mode=display">g[u][0]=\sum\max(f[v][0],f[v][1])\\g[u][1]=val[u]+\sum f[v][0]</script><p>注意上式中的 $v$ 只的是轻儿子，然后 $f$ 的转移就变成了以下形式( $x$ 为重儿子)：</p><script type="math/tex; mode=display">f[u][0]=\max(f[x][0],f[x][1])+g[u][0]\\f[u][1]=g[u][1]+f[x][0]</script><p>其实这里的 $g$ 很好维护，我们在 $Access$ 的时候只要计算儿子变化时的贡献就好了。</p><p>接着我们构造出转移矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}g[u][0] & g[u][0]\\g[u][1] & -inf\end{bmatrix}\cdot\begin{bmatrix}f[x][0] \\f[x][1]\end{bmatrix}=\begin{bmatrix}f[u][0]\\f[u][1]\end{bmatrix}</script><p>这样子就可以直接更新了，对于每个节点我们只需要维护两个矩阵即可，一个就是上面乘法中的 $g$ 矩阵，一个就是上面乘法中的 $f$ 矩阵。</p><p>需要注意的是这是广义矩阵乘法，也就是说这个矩阵乘法的运算规则为：</p><script type="math/tex; mode=display">c[i][j]=max(c[i][j],a[i][k]+b[k][j])</script><p>很像 $floyd$ ，可以直接算了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span> &#123;</span><span class="keyword">int</span> c[<span class="number">2</span>][<span class="number">2</span>];matrix()&#123;c[<span class="number">0</span>][<span class="number">0</span>]=c[<span class="number">0</span>][<span class="number">1</span>]=c[<span class="number">1</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">1</span>]=-inf;&#125;&#125;;</span><br><span class="line">matrix <span class="keyword">operator</span> * (matrix&amp;a,matrix&amp;b) &#123;</span><br><span class="line">    matrix ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;++j)<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;++k)</span><br><span class="line">        ret.c[i][j]=max(ret.c[i][j],a.c[i][k]+b.c[k][j]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[N],dp[N][<span class="number">2</span>],head[N],nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;nxt[++cnt]=head[u],to[cnt]=v,head[u]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_cut_tree</span> &#123;</span></span><br><span class="line">    matrix f[N],g[N];</span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">2</span>],fa[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> !((ch[fa[x]][<span class="number">0</span>]==x)||(ch[fa[x]][<span class="number">1</span>]==x));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        f[x]=g[x];</span><br><span class="line">        <span class="keyword">if</span>(ch[x][<span class="number">0</span>]) f[x]=f[ch[x][<span class="number">0</span>]]*f[x];<span class="keyword">if</span>(ch[x][<span class="number">1</span>]) f[x]=f[x]*f[ch[x][<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y],k=ch[y][<span class="number">1</span>]==x,v=ch[x][!k];</span><br><span class="line">        <span class="keyword">if</span>(!isroot(y)) ch[z][ch[z][<span class="number">1</span>]==y]=x;ch[x][!k]=y,ch[y][k]=v;</span><br><span class="line">        <span class="keyword">if</span>(v) fa[v]=y;fa[y]=x,fa[x]=z;pushup(y);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!isroot(x)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isroot(fa[x]))</span><br><span class="line">                rotate((ch[fa[x]][<span class="number">0</span>]==x)^(ch[fa[fa[x]]][<span class="number">0</span>]==fa[x])?x:fa[x]);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;pushup(x);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;x=fa[y=x]) &#123;</span><br><span class="line">            Splay(x);</span><br><span class="line">            <span class="keyword">if</span>(ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">                g[x].c[<span class="number">0</span>][<span class="number">0</span>]+=max(f[ch[x][<span class="number">1</span>]].c[<span class="number">0</span>][<span class="number">0</span>],f[ch[x][<span class="number">1</span>]].c[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">                g[x].c[<span class="number">1</span>][<span class="number">0</span>]+=f[ch[x][<span class="number">1</span>]].c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y) &#123;</span><br><span class="line">                g[x].c[<span class="number">0</span>][<span class="number">0</span>]-=max(f[y].c[<span class="number">0</span>][<span class="number">0</span>],f[y].c[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">                g[x].c[<span class="number">1</span>][<span class="number">0</span>]-=f[y].c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            g[x].c[<span class="number">0</span>][<span class="number">1</span>]=g[x].c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            ch[x][<span class="number">1</span>]=y,pushup(x);</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        Access(x),Splay(x),g[x].c[<span class="number">1</span>][<span class="number">0</span>]-=v[x]-y;</span><br><span class="line">        pushup(x),v[x]=y;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        dp[u][<span class="number">1</span>]=v[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(v!=fa[u]) &#123;</span><br><span class="line">                fa[v]=u,build(v);</span><br><span class="line">                dp[u][<span class="number">0</span>]+=max(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]);</span><br><span class="line">                dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g[u].c[<span class="number">0</span>][<span class="number">0</span>]=g[u].c[<span class="number">0</span>][<span class="number">1</span>]=dp[u][<span class="number">0</span>];</span><br><span class="line">        g[u].c[<span class="number">1</span>][<span class="number">0</span>]=dp[u][<span class="number">1</span>];f[u]=g[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;IN(n),IN(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;++i)IN(u),IN(v),add(u,v),add(v,u);</span><br><span class="line">    T.build(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;IN(x),IN(y);</span><br><span class="line">        T.change(x,y),T.Splay(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(T.f[<span class="number">1</span>].c[<span class="number">0</span>][<span class="number">0</span>],T.f[<span class="number">1</span>].c[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看懂了后发现 $\texttt{DDP}$ 其实不难呢……&lt;/p&gt;
&lt;p&gt;其实主要思想就是将 $\texttt{DP}$ 转移式搞到矩阵上，然后如果是树形 $\texttt{DP}$ 的话就可以直接上树剖或者是 $LCT$ 进行维护，当然还可以用全局平衡二叉树(不费) 。如果只是线性的话可以直接用线段树等数据结构进行维护了。&lt;/p&gt;
&lt;p&gt;注意这道模板树剖的复杂度是 $O(nlog^2n)$ ，而 $LCT$ 的复杂度为 $O(nlogn)$ ，于是窝选择了 $LCT$ ，跑的还挺快。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LCT" scheme="http://qiulyblog.github.io/tags/LCT/"/>
    
      <category term="矩阵" scheme="http://qiulyblog.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [十二省联考2019]异或粽子  可持久化Trie树  luoguP5283</title>
    <link href="http://qiulyblog.github.io/2019/04/19/%5B%E9%A2%98%E8%A7%A3%5DluoguP5283/"/>
    <id>http://qiulyblog.github.io/2019/04/19/[题解]luoguP5283/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T11:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>要是我不是 $\texttt{HN}​$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……</p><p>[十二省联考2019]异或粽子，可持久化 $trie​$ 树的板子题，比最大异或和还要板子些。相信 $60​$ 分入门者都会做，那么 $100​$ 分的话我们上可持久化 $trie​$ 树维护前缀异或和，嗯没错就像主席树那样。然后对于每个节点的可持久化 $trie​$ 树我们将其当成区间右端点，然后在此位置上的 $trie​$ 树中贪心寻找左端点即可。</p><a id="more"></a><p>寻找前 $K$ 大区间的具体操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">    q.push(MKP(T.query(T.root[i],sum[i],qrank[i]=<span class="number">1</span>),i));</span><br><span class="line"><span class="comment">/*对于每一个右端点，找一个第一大(最优)的左端点放入优先队列*/</span></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(k--) &#123;</span><br><span class="line">    ll i=q.top().second;<span class="comment">/*取出当前最优元素*/</span></span><br><span class="line">    ans+=q.top().first;q.pop();</span><br><span class="line">    <span class="keyword">if</span>(qrank[i]!=i) q.push(MKP(T.query(T.root[i],sum[i],++qrank[i]),i));</span><br><span class="line">    <span class="comment">/*更新队列元素*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度大约是 $O(nlogn)​$ 级别。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKP make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll logN=<span class="number">33</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n,k,sum[N],qrank[N];</span><br><span class="line">priority_queue&lt;pair&lt;ll,ll&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    ll ch[N*logN][<span class="number">2</span>],sum[N*logN],root[N],tot;</span><br><span class="line">    <span class="function">ll <span class="title">newnode</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        ++tot,ch[tot][<span class="number">0</span>]=ch[x][<span class="number">0</span>],ch[tot][<span class="number">1</span>]=ch[x][<span class="number">1</span>];</span><br><span class="line">        sum[tot]=sum[x];<span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll&amp;rt,ll val)</span> </span>&#123;</span><br><span class="line">        rt=newnode(rt),++sum[rt];</span><br><span class="line">        ll now=rt;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">31</span>;~i;--i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> son=(val&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">            ch[now][son]=newnode(ch[now][son]);</span><br><span class="line">            now=ch[now][son],++sum[now];</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll now,ll val,ll k)</span> </span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">31</span>;~i;--i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> son=!((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=sum[ch[now][son]]) now=ch[now][son],ans|=(<span class="number">1u</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">else</span> k-=sum[ch[now][son]],now=ch[now][!son];</span><br><span class="line">        &#125;<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,x;i&lt;=n;++i) IN(x),sum[i]=sum[i<span class="number">-1</span>]^x;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i) T.root[i]=T.root[i<span class="number">-1</span>];</span><br><span class="line">        T.Insert(T.root[i],sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        q.push(MKP(T.query(T.root[i],sum[i],qrank[i]=<span class="number">1</span>),i));</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        ll i=q.top().second;</span><br><span class="line">        ans+=q.top().first;q.pop();</span><br><span class="line">        <span class="keyword">if</span>(qrank[i]!=i) q.push(MKP(T.query(T.root[i],sum[i],++qrank[i]),i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要是我不是 $\texttt{HN}​$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……&lt;/p&gt;
&lt;p&gt;[十二省联考2019]异或粽子，可持久化 $trie​$ 树的板子题，比最大异或和还要板子些。相信 $60​$ 分入门者都会做，那么 $100​$ 分的话我们上可持久化 $trie​$ 树维护前缀异或和，嗯没错就像主席树那样。然后对于每个节点的可持久化 $trie​$ 树我们将其当成区间右端点，然后在此位置上的 $trie​$ 树中贪心寻找左端点即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="可持久化Trie树" scheme="http://qiulyblog.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [十二省联考2019]春节十二响  堆+启发式合并  luoguP5290</title>
    <link href="http://qiulyblog.github.io/2019/04/19/%5B%E9%A2%98%E8%A7%A3%5DluoguP5290/"/>
    <id>http://qiulyblog.github.io/2019/04/19/[题解]luoguP5290/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T11:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>要是我不是 $\texttt{HN}$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……</p><p>[十二省联考2019]春节十二响，启发式合并裸题。对于树中的一个节点 $u$ ，从其子树中选择一段的方式显然只能是从 $u$ 的所有子树中各选出一个节点。于是我们每一个节点开一个堆，存的就是其子树中(包括自己)的所有段的内存。</p><p>然后从下往上启发式合并即可，复杂度大约是 $O(nlogn)$ 。</p><a id="more"></a><p>启发式合并的具体代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[x].size()&lt;q[y].size()) swap(q[x],q[y]);</span><br><span class="line">    <span class="keyword">while</span>(!q[y].empty()) &#123;</span><br><span class="line">        hep.push_back(max(q[x].top(),q[y].top()));</span><br><span class="line">        q[x].pop(),q[y].pop();</span><br><span class="line">        <span class="comment">/*贪心选取*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hep.size()) q[x].push(hep.back()),hep.pop_back();</span><br><span class="line">    <span class="comment">/*更新节点*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,sz=G[x].size();i&lt;sz;++i)</span><br><span class="line">        solve(G[x][i]),merge(x,G[x][i]);<span class="comment">/*将当前子树与之前枚举过的子树合并*/</span></span><br><span class="line">    q[x].push(s[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的总代码长度不超过 $40$ 行。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,f,s[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hep,G[N];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[x].size()&lt;q[y].size()) swap(q[x],q[y]);</span><br><span class="line">    <span class="keyword">while</span>(!q[y].empty()) &#123;</span><br><span class="line">        hep.push_back(max(q[x].top(),q[y].top()));</span><br><span class="line">        q[x].pop(),q[y].pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hep.size()) q[x].push(hep.back()),hep.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,sz=G[x].size();i&lt;sz;++i)</span><br><span class="line">        solve(G[x][i]),merge(x,G[x][i]);</span><br><span class="line">    q[x].push(s[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f),G[f].push_back(i);</span><br><span class="line">    solve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">1</span>].empty()) ans+=q[<span class="number">1</span>].top(),q[<span class="number">1</span>].pop();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要是我不是 $\texttt{HN}$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……&lt;/p&gt;
&lt;p&gt;[十二省联考2019]春节十二响，启发式合并裸题。对于树中的一个节点 $u$ ，从其子树中选择一段的方式显然只能是从 $u$ 的所有子树中各选出一个节点。于是我们每一个节点开一个堆，存的就是其子树中(包括自己)的所有段的内存。&lt;/p&gt;
&lt;p&gt;然后从下往上启发式合并即可，复杂度大约是 $O(nlogn)$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="堆" scheme="http://qiulyblog.github.io/tags/%E5%A0%86/"/>
    
      <category term="启发式合并" scheme="http://qiulyblog.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[HNOI2019]白兔之舞  单位根反演+MTT  luoguP5293</title>
    <link href="http://qiulyblog.github.io/2019/04/17/%5B%E9%A2%98%E8%A7%A3%5DluoguP5293/"/>
    <id>http://qiulyblog.github.io/2019/04/17/[题解]luoguP5293/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-18T01:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>单位根反演不会啊怎么搞 $FFT$ 吧，还是了解了单位根反演后才可以搞的好吧……居然有人吐槽我说我<strong>学了 $FFT​$ 但是不会运用？！</strong>，嘤嘤嘤打击有些大……</p><p>实际上所谓的单位根反演就是这个东西：</p><script type="math/tex; mode=display">\frac{1}{n}\sum_{i=0}^{n-1}(\omega_n^d)^i=[n|d]</script><a id="more"></a><p>回到题目，我们先考虑正解的简化版—— $n=1$ 的版本，我们先定义 $W=w[1][1]$ 。</p><p>现在对于每一个 $t$ 的答案显然为 $\sum_{i=0}^{L}[i\% k=t] W^i (^L_i)$</p><p>这个式子显然等于 $\sum_{i=0}^{L}[k|(i-t)] w^i (^L_i)$ 。会发现 $[k|(i-t)]$ 和上面单位根反演的 $[n|d]$ 一样，于是我们尝试将单位根反演的式子带进去。</p><script type="math/tex; mode=display">=\sum_{i=0}^{L}\frac{1}{k}\sum_{j=0}^{k-1}(\omega_k^{i-t})^j W^i \binom{L}{i}\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \omega_k^{ij} W^i \binom{L}{i}\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \binom{L}{i}(\omega_k^{j} W)^i\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \binom{L}{i}(\omega_k^{j} W)^i 1^{n-i}\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}(\omega_k^{j} W+1)^L</script><p>后面的 $(\omega_k^{j} W+1)^L$ 显然可以预处理，记为 $num_j$ 。</p><p>然后发现 $-tj=\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}$</p><script type="math/tex; mode=display">=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}}num_j\\\\=\frac{1}{k}\omega_k^{\binom{t}{2}}\sum_{j=0}^{k-1}num_j\omega_k^{\binom{j}{2}}\cdot\omega_k^{-\binom{t+j}{2}}</script><p>后面的式子可以用 $FFT$ 加速，但是值域太大这里需要用到 $MTT$ 。现在就有 $40$ 分了，接下来考虑 $n&gt;1$ 的情况。</p><p>我们建矩阵，然后会发现 $n&gt;1$ 仅会对 $num_j$ 的计算方式有变化。</p><p>我们定义一个 $begin$ 矩阵，该矩阵只有 $(0,x)$ 位置上有值且值为 $1$ ，也就是说这是白兔的起点。那么最后我们需要留下来的也就是矩阵的 $(0,y)$ ，因为只有在第二维为 $y$ 是才会计入答案。</p><p>嗯，差不多可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin.c[<span class="number">0</span>][x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) </span><br><span class="line">    num[i]=(begin*<span class="built_in">pow</span>(w*num[i]+I,n)).c[<span class="number">0</span>][y]%MOD;</span><br><span class="line"><span class="comment">/*w就是上文中的W，不过这里是矩阵*/</span></span><br><span class="line"><span class="comment">/*I是矩阵中的单位'1'*/</span></span><br></pre></td></tr></table></figure><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">65536</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);   </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,k,n,x,y,MOD,G,num[N],A[N&lt;&lt;<span class="number">2</span>],B[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> F(x,i,j) for((x)=(i);(x)&lt;=(j);++(x))</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">IN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;ll x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">matrix</span> &#123;</span><span class="keyword">int</span> c[<span class="number">3</span>][<span class="number">3</span>];matrix()&#123;<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));&#125;&#125;;</span><br><span class="line">    matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> matrix&amp;a,<span class="keyword">const</span> matrix&amp;b) &#123;</span><br><span class="line">        matrix ans;<span class="keyword">int</span> i,j;F(i,<span class="number">0</span>,<span class="number">2</span>)F(j,<span class="number">0</span>,<span class="number">2</span>) &#123;</span><br><span class="line">            ans.c[i][j]=a.c[i][j]+b.c[i][j];</span><br><span class="line">            <span class="keyword">if</span>(ans.c[i][j]&gt;=MOD) ans.c[i][j]-=MOD;</span><br><span class="line">        &#125;<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix&amp;a,<span class="keyword">const</span> matrix&amp;b) &#123;</span><br><span class="line">        matrix ans;<span class="keyword">int</span> i,j,k;F(i,<span class="number">0</span>,<span class="number">2</span>)F(j,<span class="number">0</span>,<span class="number">2</span>)F(k,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            ans.c[i][k]=(ans.c[i][k]+<span class="number">1l</span>l*a.c[i][j]*b.c[j][k])%MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix&amp;a,<span class="keyword">const</span> <span class="keyword">int</span>&amp;b) &#123;</span><br><span class="line">        matrix ans;<span class="keyword">int</span> i,j;F(i,<span class="number">0</span>,<span class="number">2</span>)F(j,<span class="number">0</span>,<span class="number">2</span>)ans.c[i][j]=<span class="number">1l</span>l*a.c[i][j]*b%MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span><span class="keyword">complex</span>(<span class="keyword">long</span> <span class="keyword">double</span> a=<span class="number">0</span>,<span class="keyword">long</span> <span class="keyword">double</span> b=<span class="number">0</span>)&#123;x=a,y=b;&#125;<span class="keyword">long</span> <span class="keyword">double</span> x,y;&#125;;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> + (<span class="keyword">complex</span> a,<span class="keyword">complex</span> b)&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(a.x+b.x,a.y+b.y);&#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> - (<span class="keyword">complex</span> a,<span class="keyword">complex</span> b)&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(a.x-b.x,a.y-b.y);&#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> * (<span class="keyword">complex</span> a,<span class="keyword">complex</span> b)&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;</span><br><span class="line">    matrix I;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%MOD) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1l</span>l*res*x%MOD;</span><br><span class="line">        <span class="keyword">return</span> res%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> matrix <span class="title">pow</span><span class="params">(matrix x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        matrix res=I;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MTT &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> BLOCK 32768</span></span><br><span class="line">    <span class="keyword">int</span> limit=<span class="number">1</span>,cnt=<span class="number">0</span>,filp[N&lt;&lt;<span class="number">2</span>],Ans[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">complex</span> A1[N&lt;&lt;<span class="number">2</span>],B1[N&lt;&lt;<span class="number">2</span>],A2[N&lt;&lt;<span class="number">2</span>],B2[N&lt;&lt;<span class="number">2</span>],X[N&lt;&lt;<span class="number">2</span>],omg[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fft</span><span class="params">(<span class="keyword">complex</span> *f,<span class="keyword">short</span> inv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)<span class="keyword">if</span>(i&lt;filp[i])<span class="built_in">std</span>::swap(f[i],f[filp[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;limit;p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">complex</span> *a=f;a!=f+limit;a+=(p&lt;&lt;<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;p;++l)&#123;</span><br><span class="line">                    <span class="keyword">complex</span> t=a[l+p]*omg[limit/(p&lt;&lt;<span class="number">1</span>)*l];</span><br><span class="line">                    a[l+p]=a[l]-t,a[l]=a[l]+t;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mtt</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(limit&lt;(k*<span class="number">3</span>+<span class="number">5</span>)) limit&lt;&lt;=<span class="number">1</span>,++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) filp[i]=(filp[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(cnt<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) A1[i].x=A[i]&amp;(BLOCK<span class="number">-1</span>),A2[i].x=A[i]&gt;&gt;<span class="number">15</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) B1[i].x=B[i]&amp;(BLOCK<span class="number">-1</span>),B2[i].x=B[i]&gt;&gt;<span class="number">15</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) omg[i]=(<span class="keyword">complex</span>)&#123;<span class="built_in">cos</span>(i*PI*<span class="number">2</span>/limit),<span class="built_in">sin</span>(i*PI*<span class="number">2</span>/limit)&#125;;</span><br><span class="line">        fft(A1,<span class="number">1</span>),fft(B1,<span class="number">1</span>);fft(A2,<span class="number">1</span>),fft(B2,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">            <span class="keyword">complex</span> a1=A1[i],a2=A2[i],b1=B1[i],b2=B2[i];</span><br><span class="line">            A1[i]=a1*b1,A2[i]=a2*b2,B1[i]=a1*b2,B2[i]=a2*b1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) omg[i]=(<span class="keyword">complex</span>)&#123;<span class="built_in">cos</span>(i*PI*<span class="number">2</span>/limit),-<span class="built_in">sin</span>(i*PI*<span class="number">2</span>/limit)&#125;;</span><br><span class="line">        fft(A1,<span class="number">-1</span>),fft(B1,<span class="number">-1</span>);fft(A2,<span class="number">-1</span>),fft(B2,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)</span><br><span class="line">            A1[i].x/=limit,A2[i].x/=limit,B1[i].x/=limit,B2[i].x/=limit;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)</span><br><span class="line">            Ans[i]=((ll)(A1[i].x+<span class="number">0.5</span>)%MOD+<span class="number">1073741824l</span>l*((ll)(A2[i].x+<span class="number">0.5</span>)%MOD)%MOD+</span><br><span class="line">            <span class="number">32768l</span>l*((ll)(B1[i].x+<span class="number">0.5</span>)%MOD)%MOD+<span class="number">32768l</span>l*((ll)(B2[i].x+<span class="number">0.5</span>)%MOD)%MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> MTT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> divisor[<span class="number">105</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_G</span><span class="params">()</span> </span>&#123;<span class="comment">/*获取原根*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,S=MOD<span class="number">-1</span>;i&lt;=S;++i) </span><br><span class="line">        <span class="keyword">if</span>(S%i==<span class="number">0</span>) &#123;divisor[++tot]=i;<span class="keyword">while</span>(!(S%i)) S/=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> g=<span class="number">2</span>;;++g) &#123;</span><br><span class="line">        <span class="keyword">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;++j) <span class="keyword">if</span>(<span class="built_in">pow</span>(g,(MOD<span class="number">-1</span>)/divisor[j])==<span class="number">1</span>) &#123;ok=<span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(ok) <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matrix w,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    I.c[<span class="number">0</span>][<span class="number">0</span>]=I.c[<span class="number">1</span>][<span class="number">1</span>]=I.c[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    m=IN(),k=IN(),n=IN(),x=IN(),y=IN(),MOD=IN();--x,--y;</span><br><span class="line">    <span class="comment">/*num其实就是上文中的单位根，这里预处理一下计算方便些*/</span></span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">1</span>,num[<span class="number">1</span>]=<span class="built_in">pow</span>(G=get_G(),(MOD<span class="number">-1</span>)/k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;k;++i) num[i]=<span class="number">1l</span>l*num[<span class="number">1</span>]*num[i<span class="number">-1</span>]%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) w.c[i][j]=IN();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);++i) A[i]=num[(k<span class="number">-1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>%k)%k];</span><br><span class="line">    s.c[<span class="number">0</span>][x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) B[i]=<span class="number">1l</span>l*num[<span class="number">1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>%k]*(s*<span class="built_in">pow</span>(w*num[i]+I,n)).c[<span class="number">0</span>][y]%MOD;</span><br><span class="line">    <span class="comment">/*计算后面两个多项式的值*/</span></span><br><span class="line">    reverse(B,B+k+<span class="number">1</span>),mtt(A,B);</span><br><span class="line">    <span class="keyword">int</span> invk=<span class="built_in">pow</span>(k,MOD<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="number">1l</span>l*Ans[i+k]*invk%MOD*num[<span class="number">1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>%k]%MOD);</span><br><span class="line">    <span class="comment">/*计算答案*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单位根反演不会啊怎么搞 $FFT$ 吧，还是了解了单位根反演后才可以搞的好吧……居然有人吐槽我说我&lt;strong&gt;学了 $FFT​$ 但是不会运用？！&lt;/strong&gt;，嘤嘤嘤打击有些大……&lt;/p&gt;
&lt;p&gt;实际上所谓的单位根反演就是这个东西：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{n}\sum_{i=0}^{n-1}(\omega_n^d)^i=[n|d]&lt;/script&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="FFT" scheme="http://qiulyblog.github.io/tags/FFT/"/>
    
      <category term="单位根反演" scheme="http://qiulyblog.github.io/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
      <category term="MTT" scheme="http://qiulyblog.github.io/tags/MTT/"/>
    
  </entry>
  
</feed>
