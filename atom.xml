<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qiuly&#39;s blog!</title>
  
  <subtitle>A weak OIer from HN-YZ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://monlights.github.io/"/>
  <updated>2019-04-12T09:57:17.534Z</updated>
  <id>http://monlights.github.io/</id>
  
  <author>
    <name>Qiuly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【题解】 [HNOI2019]多边形  组合数学  luoguP5288</title>
    <link href="http://monlights.github.io/2019/04/12/%5B%E9%A2%98%E8%A7%A3%5DluoguP5288/"/>
    <id>http://monlights.github.io/2019/04/12/[题解]luoguP5288/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-04-12T09:57:17.534Z</updated>
    
    <content type="html"><![CDATA[<p>$\texttt{HNOI2019}$ 终于改出来一道题目了……感谢 $JerryC$ 跟我一起讨论，不然我也看不懂题解。这题真的是 $\texttt{HNOI2019}$ 最可做的题啊，可想而知 $\texttt{HNOI2019}$ 有多么毒瘤了。</p><p>$orz yyb$ ，感谢 $yyb$ 大佬的题解。</p><p>这一题一共有两问，并且部分分也比较多，接下来我们一起来逐一攻破这些特殊条件。</p><a id="more"></a><h2 id="1-只有第一问且-m-0-的情况"><a href="#1-只有第一问且-m-0-的情况" class="headerlink" title="1.只有第一问且 $m=0$ 的情况"></a>1.只有第一问且 $m=0$ 的情况</h2><p>其实这个时候我们可以发现，最终的答案是要满足所有的点都连向 $n$ 。</p><p>对于每一次旋转操作，可以让 <strong>一个没有连向 $n$ 的点连向 $n$ </strong> ，并且一次旋转操作也最多可以使得一个没有连向 $n$ 的点连向 $n$ 。既然要求最少步数，我们考虑最优情况：<strong>每一次旋转都有一个新的点连向 $n$</strong> 。这个时候最终需要的最少步数显然就是 <strong>$n-1-$已经与 $n$ 连接了的点数</strong>，为什么 $-1$ ？因为最终需要连向 $n$ 的点不包括 $n$ 。(<strong>ps：这里指的已经与 $n$ 连接了的点数其实包括 $1$ 与 $n-1$</strong>) 。</p><p>至于代码实现的话，我们用个 $vector$ 来存连接的点，最后统计一下 $size$ 即可。</p><hr><h2 id="2-有两问且-m-0-的情况"><a href="#2-有两问且-m-0-的情况" class="headerlink" title="2.有两问且 $m=0$ 的情况"></a>2.有两问且 $m=0$ 的情况</h2><p>初始局面的第一问我们已经解决了，现在我们来看看怎么解决初始局面的第二问。</p><p>假设当前与 $n$ 连接了的点的集合为 $S=\{a_1,a_2,\cdots ,a_s\}$  ，这个时候我们将 $1$ 到 $n$ 分成若干个区间：$[1,a_1],[a_1,a_2],\cdots,[a_{s-1},a_s],[a_s,n-1]$ ，我们会发现，<strong>每一次旋转操作的四个点一定属于同一个区间</strong> 。<strong>在最终状态，每一个区间中的所有的点都是连向 $n$ 的。</strong></p><p>那么我们考虑计算每一个区间的<strong>操作序列</strong>，我们设 $[a_i,a_{i+1}]$ 区间的操作序列长度为 $sz(a_i)$ 。注意这个操作序列指的就是一个区间从初始状态到最终状态的所有旋转操作组成的序列。</p><p>我们现在考虑方案数，假设我们知道了 $sz(a_i),sz(a_{i+1})$ ，也就是区间 $[a_i,a_{i+1}]$ 和区间 $[a_{i+1},a_{i+2}]$ 的操作序列的长度。那么使得这两个区间都到达最终状态的方案数显然为 $C_{sz(a_i)+sz(a_{i+1})}^{sz(a_i)}$，当然也是 $C_{sz(a_i)+sz(a_{i+1})}^{sz(a_{i+1})}$ 。</p><p>这下子计算就变得简单多了，但是我们怎么求出<strong>使得单个区间变为最终状态的方案数</strong>以及<strong>当个区间的操作序列长度</strong>呢？这个时候我们可以将每一个区间 $[a_i,a_{i+1}]$ 建成一棵二叉树，每一次将 $[a_i,a_{i+1}]$ 拆成 $[a_i,p],[p,a_{i+1}]$ ，在树中这两个子区间就是 $[a_i,a_{i+1}]$ 的两个儿子。</p><p>这下子使得 $[a_i,a_{i+1}]$ 变为最终状态的方案数显然可以从其树中的两个儿子得出了，计算的方法和上面同理。</p><p>至于这个 $p$ ，假设当前区间为 $l,r$ ，我们可以选择 <strong>第一个比 $l+1$ 大且与 $r$ 连了边的点</strong> ，那么这个时候可以理解为 <strong>拆掉 $p,r$ 这条边，然后连起来 $p,n$ 这条边</strong> ，于是 $l,p$ 可以作为一个区间了，$p,r$ 也可以作为一个区间了。</p><p>为什么一定要选择<strong>第一个比 $l+1$ 大且与 $r$ 连了边的点</strong>呢？我们考虑两个点 $a$ 和 $b$ ，其中 $a$ 就是<strong>第一个比 $l+1$ 大且与 $r$ 连了边的点</strong>，$b$ 则是一个<strong>小于 $r$ 大于 $a$ 并且和 $r$ 连了边的点</strong> 。如果这个时候选择将 $b,r$ 断开连接 $b,n$ 的话，线段 $a,r$ 和线段 $b,n$ <strong>显然会交叉</strong> ，那么就不合法了。所以我们选择第一个比 $l+1$ 大且与 $r$ 连了边的点，这样至少是合法的。当然如果这个点大于 $r$ 了就没办法了。</p><p>代码的话一个 $dfs$ 可以搞定。</p><hr><h2 id="3-m-gt-0-且只有第一问的情况"><a href="#3-m-gt-0-且只有第一问的情况" class="headerlink" title="3.$m&gt;0$ 且只有第一问的情况"></a>3.$m&gt;0$ 且只有第一问的情况</h2><p>首先我们会发现，第一问的答案其实就是我们的树的结点个数。</p><p>然后考虑这个旋转操作，现在有 $a&lt;b&lt;c&lt;d​$ ，我们需要求出的就是 $(a,c)​$ 旋转对第一问带来的变化。</p><p>既然 $a,c$ 是连了边的，那么在树中也一定有一个节点代表 $[a,c]$ 区间，我们先在树中找到这个节点，然后再分两种情况来讨论。</p><h3 id="一-该节点在树中有父节点"><a href="#一-该节点在树中有父节点" class="headerlink" title="一.该节点在树中有父节点"></a>一.该节点在树中有父节点</h3><p>我们将图画出来：</p><p><img src="/2019/04/12/[题解]luoguP5288/A.png" alt=""></p><p>（左边的是原来的，右边的是经过了 $(a,c)$ 旋转的）</p><p>可以发现，旋转之后我们损失了 $(a,c)$ 节点，但是多了个 $(b,d)$ 节点，我们的节点数实际上是没有变的。也就是说我们第一问的答案没有变。</p><h3 id="二-该节点在树中没有父节点"><a href="#二-该节点在树中没有父节点" class="headerlink" title="二.该节点在树中没有父节点"></a>二.该节点在树中没有父节点</h3><p>这个时候 $a,c$ 肯定都是已经连向了 $n$ 的，不然不可能没有父节点。那么这个时候 $d$ 要不是 $n$ 要不是其他区间的点了。上文已经讲了，旋转操作只可能在一个区间内进行，也就是说 $d$ 只能等于 $n$ 。</p><p>那么 $d=n$ 的话树会怎么变换呢？很显然，$(a,c)$ 会消失，剩下的就是 $(a,b)$ 和 $(b,c)$ 。这个时候是少了一个点的，那么第一问的答案就要减一了。</p><p>如果从多边形的角度理解的话，会发现多了一个连接了 $n$ 的点，那么第一问的答案自然就少了一。</p><p>这个代码实现就不讲了。</p><hr><h2 id="4-m-gt-0-且两问都有的情况"><a href="#4-m-gt-0-且两问都有的情况" class="headerlink" title="4.$m&gt;0$ 且两问都有的情况"></a>4.$m&gt;0$ 且两问都有的情况</h2><p>解决了这个情况我们就胜利了。</p><p>也就是说现在我们需要解决 $m&gt;0$ 时第二问怎么变化。</p><p>按照上面的来就行了。</p><h3 id="一-该节点在树中有父节点-1"><a href="#一-该节点在树中有父节点-1" class="headerlink" title="一.该节点在树中有父节点"></a>一.该节点在树中有父节点</h3><p>按照上面的图，我们可以先将这些节点的贡献去掉。然后再加上新的贡献即可。</p><h3 id="二-该节点在树中没有父节点-1"><a href="#二-该节点在树中没有父节点-1" class="headerlink" title="二.该节点在树中没有父节点"></a>二.该节点在树中没有父节点</h3><p>我们直接去掉 $(a,c)$ 的贡献，然后加上 $(a,b),(b,c)$ 的贡献即可。</p><p>这一部分可以参照代码了。</p><hr><p>综上，我们解决了所有的问题，接下来贴出代码 $QwQ$ 。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W,n,Ans1,Ans2=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="comment">/*G[i]表示与i相连接的点的集合*/</span></span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="comment">/*这个是为了方便快速找到代表(a,c)节点所用的map*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i) </span><br><span class="line">        G[i].push_back(i+<span class="number">1</span>),G[i].push_back(i<span class="number">-1</span>);</span><br><span class="line">    G[<span class="number">1</span>].push_back(n),G[<span class="number">1</span>].push_back(<span class="number">2</span>);</span><br><span class="line">    G[n].push_back(n<span class="number">-1</span>),G[n].push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) sort(G[i].begin(),G[i].end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[N&lt;&lt;<span class="number">1</span>],fct[N&lt;&lt;<span class="number">1</span>],fci[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">/*分别对应逆元，阶乘，逆元的阶乘。主要用于计算组合数*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l*fct[n]*fci[m]%MOD*fci[n-m]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Inv_C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l*fci[n]*fct[m]%MOD*fct[n-m]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;<span class="keyword">return</span> C(n+m,n);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Inv_calc</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;<span class="keyword">return</span> Inv_C(n+m,n);&#125;</span><br><span class="line"><span class="comment">/*上面的组合数不再赘述......*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[N],fa[N&lt;&lt;<span class="number">1</span>],sz[N&lt;&lt;<span class="number">1</span>],ch[N&lt;&lt;<span class="number">1</span>][<span class="number">2</span>],tot;</span><br><span class="line"><span class="comment">/*root[i]就是S集合中的区间ai,ai+1在树中的节点的编号*/</span></span><br><span class="line"><span class="comment">/*fa表示父节点，sz表示节点子树大小，ch表示节点的左右儿子*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> f,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-l&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    x=++tot,sz[x]=<span class="number">1</span>,fa[x]=f;</span><br><span class="line">    <span class="keyword">int</span> p=lower_bound(G[r].begin(),G[r].end(),l+<span class="number">1</span>)-G[r].begin();</span><br><span class="line">    <span class="comment">/*找到这个p*/</span></span><br><span class="line">    p=G[r][p],vis[make_pair(l,r)]=x;</span><br><span class="line">    <span class="comment">/*找到p在原多边形中对应的点，并记录l,r在树中的点的编号*/</span></span><br><span class="line">    dfs(ch[x][<span class="number">0</span>],x,l,p),dfs(ch[x][<span class="number">1</span>],x,p,r);<span class="comment">/*向下计算子树*/</span></span><br><span class="line">    sz[x]+=sz[ch[x][<span class="number">0</span>]]+sz[ch[x][<span class="number">1</span>]];<span class="comment">/*统计子树大小*/</span></span><br><span class="line">    Ans2=<span class="number">1l</span>l*Ans2*calc(sz[ch[x][<span class="number">0</span>]],sz[ch[x][<span class="number">1</span>]])%MOD;<span class="comment">/*计算贡献*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(W),IN(n);</span><br><span class="line">    inv[<span class="number">0</span>]=inv[<span class="number">1</span>]=fct[<span class="number">0</span>]=fci[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n+n;++i) inv[i]=<span class="number">1l</span>l*(MOD-MOD/i)*inv[MOD%i]%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+n;++i) fct[i]=<span class="number">1l</span>l*fct[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+n;++i) fci[i]=<span class="number">1l</span>l*fci[i<span class="number">-1</span>]*inv[i]%MOD;</span><br><span class="line">    <span class="comment">/*以上为初始化逆元，阶乘，逆元的阶乘*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-3</span>;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;IN(x),IN(y);</span><br><span class="line">        G[x].push_back(y),G[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(),Ans1=n<span class="number">-1</span>-G[n].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len=G[n].size();i&lt;len<span class="number">-1</span>;++i) </span><br><span class="line">        dfs(root[i],<span class="number">0</span>,G[n][i],G[n][i+<span class="number">1</span>]);<span class="comment">/*计算每个区间ai,ai+1的树*/</span></span><br><span class="line">    <span class="keyword">int</span> Size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len=G[n].size();i&lt;len<span class="number">-1</span>;++i) </span><br><span class="line">        Ans2=<span class="number">1l</span>l*Ans2*calc(Size,sz[root[i]])%MOD,Size+=sz[root[i]];</span><br><span class="line">    <span class="comment">/*统计答案*/</span></span><br><span class="line">    <span class="keyword">if</span>(!W) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans1);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Ans1,Ans2);</span><br><span class="line">    <span class="keyword">int</span> q;IN(q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;IN(a),IN(b);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) a^=b^=a^=b;</span><br><span class="line">        <span class="keyword">int</span> x=vis[make_pair(a,b)];<span class="comment">/*找到在原树中a,b所代表的节点*/</span></span><br><span class="line">        <span class="keyword">if</span>(!W) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans1-(fa[x]?<span class="number">0</span>:<span class="number">1</span>));<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nowans1=Ans2;</span><br><span class="line">            <span class="keyword">if</span>(fa[x]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y=fa[x],k=ch[y][<span class="number">1</span>]==x;</span><br><span class="line">                nowans1=<span class="number">1l</span>l*nowans1*Inv_calc(sz[ch[x][<span class="number">0</span>]],sz[ch[x][<span class="number">1</span>]])%MOD;</span><br><span class="line">                nowans1=<span class="number">1l</span>l*nowans1*Inv_calc(sz[ch[y][<span class="number">0</span>]],sz[ch[y][<span class="number">1</span>]])%MOD;</span><br><span class="line">                nowans1=<span class="number">1l</span>l*nowans1*calc(sz[ch[x][!k]],sz[ch[y][!k]])%MOD;</span><br><span class="line">                nowans1=<span class="number">1l</span>l*nowans1*calc(<span class="number">1</span>+sz[ch[y][!k]]+sz[ch[x][!k]],sz[ch[x][k]])%MOD;</span><br><span class="line">                <span class="comment">/*除掉贡献与增加贡献*/</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nowans1=<span class="number">1l</span>l*nowans1*Inv_calc(sz[ch[x][<span class="number">0</span>]],sz[ch[x][<span class="number">1</span>]])%MOD;</span><br><span class="line">                nowans1=<span class="number">1l</span>l*nowans1*Inv_calc(Size-sz[x],sz[x])%MOD;</span><br><span class="line">                nowans1=<span class="number">1l</span>l*nowans1*calc(Size-sz[x],sz[ch[x][<span class="number">0</span>]])%MOD;</span><br><span class="line">                nowans1=<span class="number">1l</span>l*nowans1*calc(Size-sz[x]+sz[ch[x][<span class="number">0</span>]],sz[ch[x][<span class="number">1</span>]])%MOD;</span><br><span class="line">                <span class="comment">/*除掉贡献与增加贡献*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Ans1-(fa[x]?<span class="number">0</span>:<span class="number">1</span>),nowans1);<span class="comment">/*输出答案*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$\texttt{HNOI2019}$ 终于改出来一道题目了……感谢 $JerryC$ 跟我一起讨论，不然我也看不懂题解。这题真的是 $\texttt{HNOI2019}$ 最可做的题啊，可想而知 $\texttt{HNOI2019}$ 有多么毒瘤了。&lt;/p&gt;
&lt;p&gt;$orz yyb$ ，感谢 $yyb$ 大佬的题解。&lt;/p&gt;
&lt;p&gt;这一题一共有两问，并且部分分也比较多，接下来我们一起来逐一攻破这些特殊条件。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://monlights.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 不同子串个数  后缀数组.SA  luoguP2408</title>
    <link href="http://monlights.github.io/2019/04/10/%5B%E9%A2%98%E8%A7%A3%5DluoguP2408/"/>
    <id>http://monlights.github.io/2019/04/10/[题解]luoguP2408/</id>
    <published>2019-04-09T16:00:00.000Z</published>
    <updated>2019-04-10T07:28:32.822Z</updated>
    
    <content type="html"><![CDATA[<p>后缀数组。</p><p>假设我们现在已经求出了 $height$ 数组，我们发现，对两个后缀，其重复了的字串的个数就是 $height$ 数组所记录的数。我们举个例子：</p><blockquote><p>后缀$sa[i-1]$: $aaabbdbs$<br>后缀$sa[i]$ : $aabbdbs$</p></blockquote><a id="more"></a><p>会发现，最前面的”$aa$”是两个串都有的，”$aa$”中包含的”$a$”也是两个串都有的，这样子就有两个重复的了，可以发现这个重复个数正好是 $height[i]$ 的值。</p><p>但是后面还是有重复的啊？没关系，因为我们有所有的后缀，所以整个串中所有的重复的串都会被统计进来。所以这下子我们可以很容易的求出整个串中重复的串的个数了，就是 $\sum_{i=1}^{n}height[i]$ 。</p><p>子串的个数显然是 $\frac{n(n+1)}{2}$ ，这两项相减就是我们需要的答案了，记得开 $longlong$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Suffix_array &#123;</span><br><span class="line">    <span class="keyword">char</span> s[N];</span><br><span class="line">    <span class="keyword">int</span> sa[N],x[N],y[N],hep[N],height[N],n,m;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) hep[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ++hep[x[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) hep[i]+=hep[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) sa[hep[x[y[i]]]--]=y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pre_sa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) x[i]=s[i],y[i]=i;</span><br><span class="line">        m=<span class="number">129</span>;Sort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">1</span>,p=<span class="number">0</span>;m=p,p&lt;n;w&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">            p=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=w;++i) y[++p]=n-w+i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(sa[i]&gt;w) y[++p]=sa[i]-w;</span><br><span class="line">            Sort(),swap(x,y),x[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">                x[sa[i]]=(y[sa[i]]==y[sa[i<span class="number">-1</span>]]&amp;&amp;y[sa[i]+w]==y[sa[i<span class="number">-1</span>]+w])?p:++p;</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">Pre_height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) x[sa[i]]=i;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            k-=k&gt;<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j=sa[x[i]<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">while</span>(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) ++k;</span><br><span class="line">            height[x[i]]=k,res+=k;</span><br><span class="line">        &#125;<span class="keyword">return</span> res;<span class="comment">//直接返回height数组的和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Suffix_array;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">    Pre_sa();</span><br><span class="line">    ll ans=<span class="number">1l</span>l*n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    ans-=Pre_height();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;后缀数组。&lt;/p&gt;
&lt;p&gt;假设我们现在已经求出了 $height$ 数组，我们发现，对两个后缀，其重复了的字串的个数就是 $height$ 数组所记录的数。我们举个例子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后缀$sa[i-1]$: $aaabbdbs$&lt;br&gt;后缀$sa[i]$ : $aabbdbs$&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="后缀数组.SA" scheme="http://monlights.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-SA/"/>
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[SDOI2017]数字表格  莫比乌斯反演  luoguP3704</title>
    <link href="http://monlights.github.io/2019/04/10/%5B%E9%A2%98%E8%A7%A3%5DluoguP3704/"/>
    <id>http://monlights.github.io/2019/04/10/[题解]luoguP3704/</id>
    <published>2019-04-09T16:00:00.000Z</published>
    <updated>2019-04-10T14:10:32.098Z</updated>
    
    <content type="html"><![CDATA[<p>我们设 $n \leq m​$ ，然后开始推式子，我们将 $gcd(i,j)​$ 的值作为 “$d​$” 提出来：</p><script type="math/tex; mode=display">\prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}if(gcd(i,j)=d) f[d]</script><script type="math/tex; mode=display">=\prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}if(gcd(i,j)=d) f[d]</script><script type="math/tex; mode=display">=\prod_{d=1}^{n}\prod_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\prod_{j=1}^{ \lfloor\frac{m}{d}\rfloor }if(gcd(i,j)=1) f[d]</script><script type="math/tex; mode=display">=\prod_{d=1}^{n} f[d]^{\sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]}</script><a id="more"></a><p>$\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]​$ 是个熟悉的式子，我们从这个式子继续开刀：</p><script type="math/tex; mode=display">\sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{ \lfloor\frac{m}{d}\rfloor }[gcd(i,j)=1]​</script><script type="math/tex; mode=display">=\sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{ \lfloor\frac{m}{d}\rfloor }\sum_{x|gcd(i,j)} \mu(x)​</script><script type="math/tex; mode=display">=\sum_{x=1}^{n}\mu(x)\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor​</script><p>于是原来的式子变成了：</p><script type="math/tex; mode=display">\prod_{d=1}^{n} f[d]^{\sum_{x=1}^{n}\mu(x)\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor}​</script><p>设 $T=dx$ ，并将 $T$ 提出来枚举：</p><script type="math/tex; mode=display">\prod_{d=1}^{n} f[d]^{\sum_{x=1}^{n}\mu(x)\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor}​</script><script type="math/tex; mode=display">=\prod_{T=1}^{n}\prod_{d|T} f[d]^{\mu( \lfloor\frac{T}{d}\rfloor )\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor}</script><script type="math/tex; mode=display">=\prod_{T=1}^{n}(\prod_{d|T} f[d]^{\mu( \lfloor\frac{T}{d}\rfloor )})^{\lfloor\frac{n}{T}{\rfloor\lfloor\frac{m}{T}\rfloor}}</script><p>这个样子多好啊，我们可以将可爱的 $(\prod_{d|T} f[d]^{\mu( \lfloor\frac{T}{d}\rfloor )})$ 预处理，也就是枚举每一个 $d$ ，然后将可以整除 $d$ 的每一个 $T$ 都算上 $d$ 带来的贡献即可。最后的时候可以整除分块。最终的时间复杂度为 $O(\sqrt{n})$ ，当然不算上预处理时候的复杂度，如果加上预处理的复杂度，最终的复杂度应该为 $O(N(log\ N+log\ mod)+T(\sqrt{n} \  log\ mod))$ ，$log\ mod$ 就是算逆元的复杂度。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> mui[N+<span class="number">15</span>],inv[N+<span class="number">15</span>],fib[N+<span class="number">15</span>],sum[N+<span class="number">15</span>],prime[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%MOD) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1l</span>l*res*x%MOD;</span><br><span class="line">    <span class="keyword">return</span> res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fib[<span class="number">1</span>]=inv[<span class="number">1</span>]=sum[<span class="number">0</span>]=sum[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="literal">true</span>,mui[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;++i) &#123;</span><br><span class="line">        fib[i]=(fib[i<span class="number">-1</span>]+fib[i<span class="number">-2</span>])%MOD;</span><br><span class="line">        inv[i]=<span class="built_in">pow</span>(fib[i],MOD<span class="number">-2</span>),sum[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[++cnt]=i,mui[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;++j) &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j])) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> mui[i*prime[j]]=-mui[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;=N;++d) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!mui[d]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> T=d;T&lt;=N;T+=d) </span><br><span class="line">            sum[T]=<span class="number">1l</span>l*sum[T]*(mui[d]==<span class="number">1</span>?fib[T/d]:inv[T/d])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;++i) sum[i]=<span class="number">1l</span>l*sum[i]*sum[i<span class="number">-1</span>]%MOD;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pre(),IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        IN(n),IN(m);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;m) swap(n,m);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>,res,num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">            r=min(n/(n/l),m/(m/l));</span><br><span class="line">            num=<span class="number">1l</span>l*(n/l)*(m/l)%(MOD<span class="number">-1</span>);</span><br><span class="line">            res=<span class="number">1l</span>l*sum[r]*<span class="built_in">pow</span>(sum[l<span class="number">-1</span>],MOD<span class="number">-2</span>)%MOD;</span><br><span class="line">            ans=<span class="number">1l</span>l*ans*<span class="built_in">pow</span>(res,num)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(ans+MOD)%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们设 $n \leq m​$ ，然后开始推式子，我们将 $gcd(i,j)​$ 的值作为 “$d​$” 提出来：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}if(gcd(i,j)=d) f[d]&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;=\prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}if(gcd(i,j)=d) f[d]&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;=\prod_{d=1}^{n}\prod_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\prod_{j=1}^{ \lfloor\frac{m}{d}\rfloor }if(gcd(i,j)=1) f[d]&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;=\prod_{d=1}^{n} f[d]^{\sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]}&lt;/script&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="莫比乌斯反演" scheme="http://monlights.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>【游记】  HNOI2019酱油记</title>
    <link href="http://monlights.github.io/2019/04/08/%5B%E6%B8%B8%E8%AE%B0%5DHNOI2019/"/>
    <id>http://monlights.github.io/2019/04/08/[游记]HNOI2019/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-10T02:01:08.549Z</updated>
    
    <content type="html"><![CDATA[<p>嘤嘤嘤嘤虽然还是六年级不至于退役但鸭梨还是好大好大。</p><p>这一次 $\texttt{HNOI2019}$ 仅仅是去走过场，$\texttt{HNOI2020}$ 才是真正需要重视的，于是鸭梨又小了许多，却还是不希望分数太难看。算了比完了再说吧。($2019.4.4 $$\ Qiuly$记)</p><p>给自己立个小目标——试着在 $\texttt{HNOI2019}$ 踩 $20\%$ 的人。 </p><a id="more"></a><hr><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day   -2"></a>Day   -2</h1><p>上午考试，下午改题，<del>晚上颓废</del></p><p>上午考的不是很好，本来估计又 $150$ 的结果第三题全炸变成了 $85$ ……</p><p>晚上和 $JerryC​$ 一起颓废，后来有些虚了于是不玩了，去 $\texttt{HNFMSOJ}​$ 上将喵星球上的点名过掉了，实际上是看了题解的所以还是有些虚。然后九点的时候 $JerryC​$ 问窝最小路径覆盖问题怎么做，讨论了一番，<del>然后感觉又没那么虚了。</del></p><hr><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day   -1"></a>Day   -1</h1><p>上午考试，下午不想改题。</p><p>上午的考试不想写总结了，因为没有改出来一道题。上午的题目确实没有昨天的好做看到第二题是比较裸的 $AC​$ 自动机于是做掉了<del>(结果最后只有 $80​$ 分？！)</del> ，众所周知 $AC​$ 自动机是很好打的，我打完就没事干了，于是去高一机房看 $JerryC​$ 秒题去了。</p><p>中午和 $JerryC​$ 和史哥一起吃饭，但是出去的时候已经完了，出不了校门了。于是去小卖部吃泡面，味道海星。</p><p>下午回来先休息，$2​$ 点钟开始，然后看到洛谷智推有个永无乡于是切掉了。期间高二的年级组长(貌似是？)和高二机房的常规班上的班主任来了，说是来鼓励大家，给大家带来的许多吃的。当然没有窝的份于是窝继续做窝的永无乡，哎感觉我从头到尾就是个客人。</p><p>嗯打完了永无乡后将线段树合并的代码发给史哥了，因为史哥中午曾问窝线段树合并肿么打。</p><p>然后写 $\texttt{HNOI2019}​$ 游记(就是现在这篇)。</p><p>写完游记没事干了，然后去切掉了最小路径覆盖问题。这个时候差不多要吃晚饭于是跟着 $JerryC,CYjian,Yasar​$ 一起吃的晚饭。他们是住的什么托管，感觉……那个晚饭还是不吃为好。</p><p>结果最后回机房的时候也没有碰过一点吃的东西，于是 $JerryC$ 给了窝一包巧克力充充饥，好久没有这么一大包巧克力了，一口大满足美滋滋。</p><p>晚上无聊，不敢颓，于是康康板子，康康别人的博客，然后整理了一下自己的博客，差不多就回家了。</p><hr><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day   0"></a>Day   0</h1><p>清明节是不可能有假期的，今天还是要来机房，没有睡成懒觉……</p><p>嗯但是今天不考试，于是上午继续康康板子，不是很想打，只是看了一遍之前的代码：</p><blockquote><p>$\texttt{AC}$自动机，$\texttt{SAM}$，$\texttt{SA}$，$\texttt{FFT}$，$\texttt{NTT}$，$\texttt{MTT}$，$\texttt{Splay}$，$\texttt{LCT}$，树剖，杜教筛，莫比乌斯反演，$\texttt{CDQ}$分治，$\texttt{K-D Tree}$</p></blockquote><p>当然树套树是不可能看的，这辈子也不会复习的……光是码量就可以吓到我了。</p><p>$JerryC$ 说昨天他去康了 $\texttt{ICPC2019}$ 直播，但是窝没看<del>因为窝不知道有这个比赛</del>因为窝不能颓。</p><p>不想干活，跟熠宝聊了一下天，吃饭去了。</p><p>下午回来休息，然后快三点的时候看了下书，很讨厌这种恶心的感觉，希望 $\texttt{HNOI2019}$ 赶快比完，不然心里一直有鸭梨，并且已经厌烦这种恶心的感觉了，心里不是滋味。</p><p>看《进阶指南》，然后看了看 $DP$，看了看开车旅行想打但是不敢打，发现链表的次小不理解……于是也就没有打了。</p><p>不知道晚上要干些什么……于是玩了玩就睡觉了。</p><hr><h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><blockquote><p>辣鸡几何，毁我青春！</p></blockquote><p>早上在车上吃的面包，到了理工碰到了 $CYjian$ ，然后一大群 $yl,cj$ 的，几乎没有看到 $yz$ 的，差不多一刻钟以后才有 $yz$ 的陆陆续续赶来。</p><p>进入考场，嘿嘿两边的都是 $yz$ 的。解压题目，读了一遍。</p><p><strong>(#`O′)怎么没有一道数据结构啊这是什么题啊！</strong></p><p>不急不急咱慢慢来，发现第一题不可做，第三题也不可做，第二题貌似可以骗分。于是开始肝第二题，$20$ 分比较简单，一个 $kmp$ 就够了，于是打打打，然而……</p><p><strong>发现自己忘记了 $kmp$ !</strong></p><p>$mmp$，只好自己开始 $\texttt{YY}$ $kmp$ 了， 好几个都被自己 $hack$ 掉了……难道今天要爆零？虽然才六年级机会很多但是爆零的滋味不好受啊。于是打了个很虚的暴力查找，复杂度大概是……$O(n^3)$ ？我去这不<strong>T</strong>飞才怪，然后发现 $x\leq300$ ，嗯？我们一次最多加上 $300$ 个字符，那么……直接算多出来的这些贡献然后加上不久好了嘛，自己怎么这么$sb$呢。</p><p>嗯敲完了一遍过样例，然后不想拍了，第三题依旧感觉不可做，先康康第一题。</p><p>嗯，第一题的 $20​$ 可以暴力枚举点对，然后……</p><p><strong>角度怎么算啊喂，欺负窝是小学森是吧？！</strong></p><p>好吧然后想了想，距离相等的话很好算，关键是角度。我们对于这个角，将角的位置放到原点上，然后将其中另一个点放在 $y$ 轴上，剩下的一个点判断一下，如果跟 $y$ 轴上的点同号的话说明是锐角，不然就是钝角，当然直角的情况特判就好了。</p><p>嗯打完了，过了样例。</p><p>不过……发现我的程序对于”三点一线”的情况也算进去了，这样子显然构不成一条鱼啊。于是加了个特判，再测一遍手造数据，对了。然后又想了想，发现……如果是斜着的三点一线没有判！然后搞个斜率判了一判，应该可以吧……不过说实话第一题窝特别虚。(最后为了发泄，判斜率的函数名是”$check _ fuck$”……) 。</p><p>嗯第一题没什么做了，第三题又做不出，于是花费最后的一个半小时再康康第二题。翻到题面，发现，这道题是……<strong>可持久化后缀自动机？！</strong>，又逗小学森是吧……算了不会打。不过看了看 $30$ 分的部分分发现很像主席树，啪啪啪敲了个主席树，然后一直 $\texttt{WA}$ 到了最后 $15$ 分钟……</p><p>算了算了不打了，索性把主席树全删了，然后检查文件名，康康有没有打错。最后带着发泄的心理将第三题输出样例，觉得不够，然后剩下的全部输出 $rand()$ ……第一题也如法炮制，将拿不到分的点全部输出 $rand()$ …… $Ctrl+s$ 保存，然后编译一波。全部都好了，然后正准备休息一下，讲台上的监考老师却突然大声喊道:”下考了！同学们请离开自己的座位！”</p><p>出去以后发现今天的题目确实挺难，听说 $boshi$ 只有 $100$ 分，$kb$ 只有 $125$ ，其他的都没有到达 $100$ 分的……然后跑去跟 $JerryC$ 闲聊，发现第三题的 $30$ 分可以直接记忆化，顿时失去智商 $QwQ$ 。</p><p>回家吃饭，然后只有正式选手的成绩出来了，发现很多人都挂了……自己也有些虚。</p><p>没多想什么，睡觉。</p><hr><h1 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h1><blockquote><p>辣鸡图论，毁我青春！</p></blockquote><p>早上到了理工大，跟 $wjj$ 毒奶今天三道数据结构，他不信，又奶到今天有图论题，<del>疑似泄题</del> 。</p><p>进考场，到机位，开机子，然后敲 $main​$ 。正敲着快读，监考老师却在台上大声嚷嚷道：”不许敲，敲就算作弊！”，我去这是搞什么啊，敲配置都不让，于是放慢了敲的节奏。$jbj​$ 进来听到了这一句话，小声骂了一句鬼监考(此处省略粗口)，然后大声的打键盘(是打不是敲…..)，监考满怀恨意的瞪了一眼 $jbj​$ 就走了(真想吐槽这个监考)。</p><p>打开题目，读了一遍，我去今天哪有什么数据结构题啊。刚开始看到第三题”序列”以为是一道数据结构，结果发现也挺毒瘤的。</p><p>做题顺序 $\texttt{T3-&gt;T2-&gt;T1}$ 。</p><p>看看 $\texttt{T3}$ 的数据范围，还有小数？小学森要气哭了。没关系有整数部分呢，貌似可以 $\texttt{DP}$，也就是用 $f[i][j]$ 表示第 $B_i$ 的值为 $j$ 时的最小差值，转移很显然。这样……貌似自己拿到这 $10$ 分了吧。</p><p>$\texttt{T2}$ 开始直接上爆搜打表找规律，设 $f[i][j]$ 为<strong>当前$L$的值为$i$，$n=1$ ，白兔跳的长度为 $j$ 时的不同路径数</strong>。爆搜一下子就打出来了，观察前十个，写在纸上，发现……</p><p><strong>这是个广义杨辉三角！</strong></p><p>普通杨辉三角：$c[i][1]​$=$c[i][i]​$=$1​$,$c[i][j]​$=$c[i​$-$1][j]​$+$c[i​$-$1][j​$-$1]​$</p><p>广义杨辉三角：只满足 $c[i][j]$=$c[i$-$1][j]$+$c[i$-$1][j$-$1]$。这道题中的广义杨辉三角就是：$c[i][1]$=$i,$$c[i][i]$=$1$,$c[i][j]$=$c[i$-$1][j]$+$c[i$-$1][j$-$1]$</p><p>嗯实际上知道这个就不难拿到前 $40$ 分了吧……<strong>但是我不会 $Lucas$ !</strong></p><p>于是这题做不成了，看第一题吧。</p><p>$\texttt{T1}$ 发现有些有趣，可以搞出一个双向广搜的写法，但是自己貌似 $hack$ 掉了这个解法，于是没分……</p><p><strong>于是今天最高只有 $10$ 分！</strong></p><p>感觉今天的题目完全不可做啊，甚至比昨天的还毒瘤许多。$\texttt{T3}$ 有树套树的嫌疑？算了算了不管了，出考场舒服多了，走了走了回家了。</p><p><strong>(出题人你给我过来，我保证不捶死你！)</strong></p><hr><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>成绩出来了。的确踩了 $20\%$ 以上的人。</p><p>发现自己估分很不准确……</p><p>小学生真好，<del>上个期末考试考好了，妈妈再也不用担心被常规虐了</del> ，于是在家里休息休息，准备给自己可爱的博客搞一个小域名：$qiuly.ml$ ，免费的。不过最后没搞成，$DNSpod$ 检测，除了 <strong>HTTP</strong> 异常，其他均为正常，不过就是因为这个异常导致这个域名计划失效了嘤嘤嘤。</p><p>这段时间用的是家里的电脑，果然笔记本还是容易发烫的……而且不知道为什么我的微软笔记本很容易发烫，主板说烫就烫起来了……不过真的好用，这个屏幕分辨率真的清晰<del>(陈独秀同志请您坐下，不要秀自己的笔记本了……)</del>。</p><p>这次，$\texttt{HNOI2019}$ 才是真正结束了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘤嘤嘤嘤虽然还是六年级不至于退役但鸭梨还是好大好大。&lt;/p&gt;
&lt;p&gt;这一次 $\texttt{HNOI2019}$ 仅仅是去走过场，$\texttt{HNOI2020}$ 才是真正需要重视的，于是鸭梨又小了许多，却还是不希望分数太难看。算了比完了再说吧。($2019.4.4 $$\ Qiuly$记)&lt;/p&gt;
&lt;p&gt;给自己立个小目标——试着在 $\texttt{HNOI2019}$ 踩 $20\%$ 的人。 &lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="游记" scheme="http://monlights.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【题解】  [HNOI2012]永无乡  线段树+启发式合并  luoguP3224</title>
    <link href="http://monlights.github.io/2019/04/04/%5B%E9%A2%98%E8%A7%A3%5DluoguP3224/"/>
    <id>http://monlights.github.io/2019/04/04/[题解]luoguP3224/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-04-04T08:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>实际上可以用平衡树做的但是不喜欢平衡树。</p><p>还是喜欢可爱的线段树，于是打了一发线段树合并。很久没有这样子的做题感觉了，真是美妙，思路清晰，交上去一遍过(窝不会告诉泥萌窝第一次交的时候忘关文件=。=)。</p><a id="more"></a><p>我们对于每一个点维护一个权值线段树，然后用并查集维护点与点之间的联通关系。对于一个连通块，该连通块的所有结点信息都保留在该连通块的 $root$ 上。</p><p>这样子我们合并两个岛的时候 $x,y$ ，可以直接将 $x$ 所在连通块的 $root$ (简称 $fx$ ) 和  $y$ 所在连通块的 $root$ (简称 $fy$ ) 合并起来，也就是将 $fy$ 的线段树并到 $fx$ 上去。这样子 $fx$ 就维护了这两个连通块的信息了，最后我们按照并查集的套路将 $fy$ 的父亲设为 $fx$ 即可。</p><p>询问就是基础操作，权值线段树就像主席树那样询问即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=N*<span class="number">650</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree</span> &#123;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line">    <span class="keyword">int</span> cnt,rt[N],val[Max],lc[Max],rc[Max];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        val[x]=val[lc[x]]+val[rc[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x) x=++cnt;</span><br><span class="line">        <span class="keyword">if</span>(l==r) &#123;++val[x];<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid) update(lc[x],l,mid,pos);</span><br><span class="line">        <span class="keyword">else</span> update(rc[x],mid+<span class="number">1</span>,r,pos);</span><br><span class="line">        pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> th=val[lc[x]];</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=th) query(lc[x],l,mid,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(rc[x],mid+<span class="number">1</span>,r,k-th);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">        <span class="keyword">if</span>(l==r) &#123;val[x]+=val[y];<span class="keyword">return</span> x;&#125;</span><br><span class="line">        lc[x]=merge(lc[x],lc[y],l,mid),</span><br><span class="line">        rc[x]=merge(rc[x],rc[y],mid+<span class="number">1</span>,r);</span><br><span class="line">        pushup(x);<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N],pos[N],n,m,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=find(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i)</span><br><span class="line">        fa[i]=i,IN(x),pos[x]=i,T.update(T.rt[i],<span class="number">1</span>,n,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;IN(u),IN(v);</span><br><span class="line">        <span class="keyword">int</span> fu=find(u),fv=find(v);</span><br><span class="line">        <span class="keyword">if</span>(fu!=fv) T.merge(T.rt[fu],T.rt[fv],<span class="number">1</span>,n),fa[fv]=fu;</span><br><span class="line">    &#125;</span><br><span class="line">    IN(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];<span class="keyword">int</span> x,y,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'B'</span>) &#123;</span><br><span class="line">            IN(x),IN(y);</span><br><span class="line">            <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">            <span class="keyword">if</span>(fx!=fy) T.merge(T.rt[fx],T.rt[fy],<span class="number">1</span>,n),fa[fy]=fx;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'Q'</span>) &#123;</span><br><span class="line">            IN(x),IN(k);</span><br><span class="line">            <span class="keyword">int</span> fx=find(x);</span><br><span class="line">            <span class="keyword">if</span>(T.val[T.rt[fx]]&lt;k) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,pos[T.query(T.rt[fx],<span class="number">1</span>,n,k)]);</span><br><span class="line">            <span class="comment">/*我们query到的是第K大的权值而非岛屿的编号*/</span></span><br><span class="line">            <span class="comment">/*于是加个pos数组就好了*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际上可以用平衡树做的但是不喜欢平衡树。&lt;/p&gt;
&lt;p&gt;还是喜欢可爱的线段树，于是打了一发线段树合并。很久没有这样子的做题感觉了，真是美妙，思路清晰，交上去一遍过(窝不会告诉泥萌窝第一次交的时候忘关文件=。=)。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="线段树" scheme="http://monlights.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="启发式合并" scheme="http://monlights.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【考试总结】  Test-2019.4.3  HNOI2019模拟</title>
    <link href="http://monlights.github.io/2019/04/03/%5B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%5Dtest20190403/"/>
    <id>http://monlights.github.io/2019/04/03/[考试总结]test20190403/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T09:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>三道题目，一眼出算法。</p><blockquote><p>第一道题目显然是后缀自动机，<br>第二道题目显然是莫比乌斯反演加上杜教筛。<br>第三道题目显然是网络流。</p></blockquote><p>然而考场上都没做出来……自闭了。</p><blockquote><p>真的，现在已经是傍晚了，大后天就是毒瘤的省选了……小学中现在正在举办运动会，班级群中一群人在那里一个劲的喊加油，但是，班上有人给我加油吗？除了几个好朋友之外……</p></blockquote><a id="more"></a><p><a href="https://github.com/monlights/image/blob/master/problem20190403.zip?raw=true" target="_blank" rel="noopener">题目压缩包戳我!!!<code>~\(≧▽≦)/~</code>(有时链接可能会崩，如果崩了的话请稍后尝试QwQ)</a></p><hr><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><blockquote><p>期望得分：40分<br>实际得分：40分<br>正解：后缀自动机(SAM)+FFT<br>窝的解法：哈希</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>嗯后缀自动机是会的但是感觉不好做。</p><p>于是弄了个哈希上去骗分，暴力枚举字串然后玄学哈希即可。</p><p>不会正解。。。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">666</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">100000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k,m,cnt,res[N*N],ans;</span><br><span class="line"><span class="keyword">char</span> s[N],c[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(step==k+<span class="number">1</span>&amp;&amp;sum==m) &#123;++ans;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(step==k+<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)</span><br><span class="line">        dfs(step+<span class="number">1</span>,sum+res[i]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"tele.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"tele.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    IN(k),IN(m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;++k) tot=(<span class="number">1l</span>l*tot*<span class="number">27</span>%MOD+s[k]-<span class="string">'a'</span>+<span class="number">1</span>)%MOD;</span><br><span class="line">            <span class="comment">/*大力玄学哈希+map判重*/</span></span><br><span class="line">            hash[tot]++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;++k) tot=(<span class="number">1l</span>l*tot*<span class="number">27</span>%MOD+s[k]-<span class="string">'a'</span>+<span class="number">1</span>)%MOD;</span><br><span class="line">            res[++cnt]=hash[tot];</span><br><span class="line">        &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*灵机一动这样写，那么k打于2的时候如果数据小可以多拿一些分*/</span></span><br><span class="line">    <span class="comment">/*实验证明这样布星*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><blockquote><p>期望得分：60分<br>实际得分：40分<br>正解：莫比乌斯反演+杜教筛<br>窝的解法：莫比乌斯反演</p></blockquote><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>考场上忘记了杜教筛，于是GG。</p><p>本来有六十分的……脑抽的窝，预处理 $\sum_{i=1}^{T}\lfloor\frac{T}{i}\rfloor$ 居然用 $O(n\sqrt{n})$ 来解决……实际上改两个字符就变成 $O(n)$ 的复杂度了，就有 $60$ 分了……</p><p>嗯然后筛 $\mu$ 的时候可以搞个杜教筛加速，这样子的话 $\mu$ 函数的前缀和就可以 $O(n^{\frac{2}{3}})$ 筛出。不过估计是标程质量不行，题目范围只有 $10^9$ ……杜教筛可以解决 $O(10^{11})$ 左右的问题……吧?</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;N+7&gt; vis;</span><br><span class="line"><span class="keyword">int</span> n,mui[N+<span class="number">7</span>],prime[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mui[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[++cnt]=i,mui[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;N;++j) &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j])) &#123;mui[i*prime[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> mui[i*prime[j]]=-mui[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) mui[i]+=mui[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(<span class="keyword">int</span> MX)</span> </span>&#123;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=MX;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">        r=MX/(MX/l);</span><br><span class="line">        sum=(sum+<span class="number">1l</span>l*(r-l+<span class="number">1</span>)*(MX/l)%MOD)%MOD;</span><br><span class="line">    &#125;<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; MU;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*杜教筛*/</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> mui[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(MU.count(x)) <span class="keyword">return</span> MU[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>,r;l&lt;=x;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">            r=x/(x/l);</span><br><span class="line">            s-=(r-l+<span class="number">1</span>)*Sum(x/l);</span><br><span class="line">        &#125;<span class="keyword">return</span> MU[x]=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"math.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"math.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    pre();</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">        r=n/(n/l);</span><br><span class="line">        ll num=S(n/l);</span><br><span class="line">        res=(res+<span class="number">1l</span>l*(Sum(r)-Sum(l<span class="number">-1</span>))*num*num%MOD+MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(res+MOD)%MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯实际这题窝觉得是一道莫反板子题，但是没做出来，看来杜教筛还是不会……</p><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><blockquote><p>期望得分：50分<br>实际得分：0分<br>正解：最小割<br>窝的解法：最小割+爆搜</p></blockquote><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>看完题目后，窝决定第一个看这道题。</p><p>哇，一眼网络流题目欸！</p><p>咦这题好像小$M$的作物欸，但是第二个操作又不对劲了……(实际上第二个操作就是文理分科那题，但是窝没做那题)。</p><p>嗯，需要花费的什么费用……费用流？！然后手画了一下图……自己模拟一下发现根本不好模拟，想着费用流板子也就 $10$ 分钟的事，于是打了个费用流照着窝之前的想法建一下边，跑一下后发现错了……</p><p>然后苦苦思索……转眼间 $30$ 分钟过去了。<del>发现时间过得比较快</del>，于是决定先将暴力 $30$ 打好再想……嗯爆搜一下救过了样例(不过窝的爆搜又打错了以至于窝没拿到分？！)</p><p>嗯这个时候感觉前 $30$ 分稳了，于是观察部分分，发现有 $\%20$ 的数据不包含第二个操作，直接上小$M$的作物发现自己忘了，没办法只好自己瞎 $YY$ 一通。最后的结果发现是最小割，然后拆点，拆成牛羊两个点，源点连牛点，边权自然是其收益，羊点同理。然后中间连一条边权为 $inf$ 的边，表示这个要不圈牛要不圈羊只能圈一个。</p><p>嗯，发现还挺有道理的。对于，对于限制的话我们只需要再限制的两个牛羊点之间连上一条边权为 $inf$ 的边即可。</p><p>一遍过样例，美滋滋地开始造数据拍，嗯第一次和爆搜拍得挺顺利 $500$ 组数据全过了。</p><p>没过瘾，再来一组，结果第二组 $500$ 数据，拍到三百多个就 $WA$ 了……</p><p>后面没有想出来，于是弃疗了。</p><p><strong>接下来讲一讲正解怎么做</strong></p><p>小$M$的作物自然不用讲，我们来讲讲文理分科怎么做。</p><p>对于本题的第二个操作，我们需要新建一个结点 $p​$ ，然后如果这个操作的 $a​$ 是 $0​$ 我们就从源点向其连一条边权为 $b​$ 的边，$a​$ 是 $1​$ 的情况同理。</p><p>然后呢，对于 $S$ 中的每个点，如果 $a$ 为 $0$ 则从 $p$ 向该点连边，$a$ 是 $1$ 的情况同理。</p><p>嗯，然后就是不需要拆点。然后就差不多了。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,a[N],b[N];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> s,t,head[N],dep[N],cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to,val;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">        G[++cnt]=(Edge)&#123;head[v],u,<span class="number">0</span>&#125;,head[v]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">        dep[s]=<span class="number">1</span>,q.push(s);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v=G[i].to;</span><br><span class="line">                <span class="keyword">if</span>(!dep[v]&amp;&amp;G[i].val&gt;<span class="number">0</span>) </span><br><span class="line">                    dep[v]=dep[u]+<span class="number">1</span>,q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span> dep[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">        <span class="keyword">int</span> used=<span class="number">0</span>,rlow;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=G[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>&amp;&amp;G[i].val&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                used+=(rlow=dfs(v,min(flow-used,G[i].val)));</span><br><span class="line">                G[i].val-=rlow,G[i^<span class="number">1</span>].val+=rlow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">if</span>(!used) dep[u]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> used;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Dinic;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"work.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"work.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    IN(n),IN(m),IN(k);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,nodetot=n+<span class="number">1</span>;s=<span class="number">0</span>,t=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]),sum+=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;IN(x),IN(y),IN(z);</span><br><span class="line">        add(x,y,z),add(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> size,x,y;</span><br><span class="line">        IN(size),IN(x),IN(y);</span><br><span class="line">        sum+=y,++nodetot;</span><br><span class="line">        x?add(nodetot,t,y):add(s,nodetot,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size;++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> c;IN(c);</span><br><span class="line">            x?add(c,nodetot,inf):add(nodetot,c,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=b[i]) add(s,i,a[i]-b[i]);</span><br><span class="line">        <span class="keyword">else</span> add(i,t,b[i]-a[i]),sum+=b[i]-a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) maxflow+=dfs(s,inf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum-maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三道题目，一眼出算法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一道题目显然是后缀自动机，&lt;br&gt;第二道题目显然是莫比乌斯反演加上杜教筛。&lt;br&gt;第三道题目显然是网络流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而考场上都没做出来……自闭了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;真的，现在已经是傍晚了，大后天就是毒瘤的省选了……小学中现在正在举办运动会，班级群中一群人在那里一个劲的喊加油，但是，班上有人给我加油吗？除了几个好朋友之外……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="考试总结" scheme="http://monlights.github.io/tags/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2005]维护数列  Splay  luoguP2042</title>
    <link href="http://monlights.github.io/2019/04/02/%5B%E9%A2%98%E8%A7%A3%5DluoguP2042/"/>
    <id>http://monlights.github.io/2019/04/02/[题解]luoguP2042/</id>
    <published>2019-04-01T16:00:00.000Z</published>
    <updated>2019-04-02T02:06:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>神奇的题目。</p><p>网上说什么做了这道题 $Splay$ 就差不多了，嗯对窝也这么觉得。于是终于码掉了。</p><p>主要涉及的操作还是提取区间，我们组需要将 $l-1$ 提取至 $root$ ， 然后将 $r+1$ 提取至 $l-1$ 的下方，最终询问的 $l,r$ 区间的 $Splay$ 就是 $r+1$ 的左孩子。</p><a id="more"></a><p>这个时候该输出的就输出，该打标记的就打标记就好了。</p><p>至于插入的话我们可以先将所有需要插入的结点 $build$ 成一棵树，然后直接挂到 $r+1$ 的左孩子即可。</p><p>但是毒瘤出题人卡空间，于是我们需要将删除的结点全部重新应用，就像垃圾回收那样，搞个栈就行了。</p><p>最后因为怕 $l-1$ 和 $r+1$ 出界我们还需要新增两个”哨兵结点”，这样子的话需要提取的结点都加上了 $1$ ，提取区间变动的两个节点就变成 $l$ 和 $r+2$ 了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5.5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> root,cnt;</span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">2</span>],sz[N],fa[N],val[N],tag[N],rev[N];</span><br><span class="line">    <span class="keyword">int</span> sum[N],lmax[N],rmax[N],smax[N];</span><br><span class="line">    <span class="keyword">int</span> date[N],trash[N],top;</span><br><span class="line"></span><br><span class="line">    Splay()&#123;root=cnt=top=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        ch[node][<span class="number">0</span>]=ch[node][<span class="number">0</span>]=sz[node]=fa[node]=val[node]=<span class="number">0</span>,</span><br><span class="line">        rev[node]=sum[node]=lmax[node]=rmax[node]=smax[node]=<span class="number">0</span>;</span><br><span class="line">        tag[node]=inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MKN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node;</span><br><span class="line">        node=top?trash[top--]:++cnt;</span><br><span class="line">        clear(node);<span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=ch[x][<span class="number">0</span>],r=ch[x][<span class="number">1</span>];</span><br><span class="line">        sz[x]=sz[l]+sz[r]+<span class="number">1</span>;</span><br><span class="line">        sum[x]=sum[l]+sum[r]+val[x];</span><br><span class="line">        lmax[x]=max(lmax[l],sum[l]+val[x]+lmax[r]);</span><br><span class="line">        rmax[x]=max(rmax[r],sum[r]+val[x]+rmax[l]);</span><br><span class="line">        smax[x]=max(rmax[l]+lmax[r]+val[x],max(smax[l],smax[r]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=ch[x][<span class="number">0</span>],r=ch[x][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(tag[x]!=inf) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l) val[l]=tag[l]=tag[x],sum[l]=tag[x]*sz[l];</span><br><span class="line">            <span class="keyword">if</span>(r) val[r]=tag[r]=tag[x],sum[r]=tag[x]*sz[r];</span><br><span class="line">            <span class="keyword">if</span>(tag[x]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(l) lmax[l]=rmax[l]=smax[l]=sum[l];</span><br><span class="line">                <span class="keyword">if</span>(r) lmax[r]=rmax[r]=smax[r]=sum[r];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tag[x]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(l) lmax[l]=rmax[l]=<span class="number">0</span>,smax[l]=tag[x];</span><br><span class="line">                <span class="keyword">if</span>(r) lmax[r]=rmax[r]=<span class="number">0</span>,smax[r]=tag[x];</span><br><span class="line">            &#125;</span><br><span class="line">            tag[x]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rev[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l) swap(ch[l][<span class="number">0</span>],ch[l][<span class="number">1</span>]),swap(lmax[l],rmax[l]),rev[l]^=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(r) swap(ch[r][<span class="number">0</span>],ch[r][<span class="number">1</span>]),swap(lmax[r],rmax[r]),rev[r]^=<span class="number">1</span>;</span><br><span class="line">            rev[x]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">        pushdown(y),pushdown(x);</span><br><span class="line">        <span class="keyword">int</span> k=chk(x),v=ch[x][k^<span class="number">1</span>];</span><br><span class="line">        ch[z][chk(y)]=x,fa[x]=z,ch[y][k]=v,fa[v]=y,</span><br><span class="line">        ch[x][k^<span class="number">1</span>]=y,fa[y]=x;pushup(y),pushup(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> gola=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(fa[x]!=gola) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[fa[x]]!=gola)</span><br><span class="line">                rotate(chk(x)^chk(fa[x])?x:fa[x]);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;<span class="keyword">if</span>(!gola) root=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=root;</span><br><span class="line">        <span class="keyword">while</span>(pos) &#123;</span><br><span class="line">            pushdown(pos);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=sz[ch[pos][<span class="number">0</span>]]) pos=ch[pos][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                x-=sz[ch[pos][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!x) <span class="keyword">return</span> pos;</span><br><span class="line">                pos=ch[pos][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x=MKN(),mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ch[x][<span class="number">0</span>]=build(l,mid<span class="number">-1</span>,x),ch[x][<span class="number">1</span>]=build(mid+<span class="number">1</span>,r,x);</span><br><span class="line">        val[x]=date[mid],fa[x]=f,pushup(x);</span><br><span class="line">        <span class="keyword">return</span> x;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trashcan_node</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">        trash[++top]=x,trashcan_node(ch[x][<span class="number">0</span>]),trashcan_node(ch[x][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span>&amp;l,<span class="keyword">int</span>&amp;r,<span class="keyword">int</span> pos,<span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">        l=kth(pos),r=kth(pos+tot+<span class="number">1</span>);splay(l),splay(r,l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work_insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos,tot,l,r;</span><br><span class="line">        IN(pos),IN(tot);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i) IN(date[i]);</span><br><span class="line">        split(l,r,pos+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        ch[r][<span class="number">0</span>]=build(<span class="number">1</span>,tot,r),pushup(r),pushup(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work_delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos,tot,l,r;</span><br><span class="line">        IN(pos),IN(tot),split(l,r,pos,tot);</span><br><span class="line">        trashcan_node(ch[r][<span class="number">0</span>]),ch[r][<span class="number">0</span>]=<span class="number">0</span>,pushup(r),pushup(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work_same</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos,tot,c,l,r;</span><br><span class="line">        IN(pos),IN(tot),IN(c),split(l,r,pos,tot);</span><br><span class="line">        <span class="keyword">int</span> p=ch[r][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(p) &#123;</span><br><span class="line">            val[p]=tag[p]=c,sum[p]=c*sz[p];</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="number">0</span>) lmax[p]=rmax[p]=smax[p]=sum[p];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&lt;<span class="number">0</span>) lmax[p]=rmax[p]=<span class="number">0</span>,smax[p]=c;</span><br><span class="line">        &#125;pushup(r),pushup(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work_rev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos,tot,l,r;</span><br><span class="line">        IN(pos),IN(tot),split(l,r,pos,tot);</span><br><span class="line">        <span class="keyword">if</span>(ch[r][<span class="number">0</span>]) &#123;</span><br><span class="line">            swap(ch[ch[r][<span class="number">0</span>]][<span class="number">0</span>],ch[ch[r][<span class="number">0</span>]][<span class="number">1</span>]);</span><br><span class="line">            swap(lmax[ch[r][<span class="number">0</span>]],rmax[ch[r][<span class="number">0</span>]]);</span><br><span class="line">            rev[ch[r][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line">        &#125;pushup(r),pushup(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos,tot,l,r;</span><br><span class="line">        IN(pos),IN(tot),split(l,r,pos,tot);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum[ch[r][<span class="number">0</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work_max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=kth(<span class="number">1</span>),r=kth(sz[root]);splay(l),splay(r,l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,smax[ch[r][<span class="number">0</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("testdata.in","r",stdin);</span></span><br><span class="line">    <span class="comment">// freopen("myout.out","w",stdout);</span></span><br><span class="line">    IN(n),IN(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(T.date[i+<span class="number">1</span>]);</span><br><span class="line">    T.smax[<span class="number">0</span>]=T.date[<span class="number">1</span>]=-inf,T.date[n+<span class="number">2</span>]=inf;</span><br><span class="line">    T.root=T.build(<span class="number">1</span>,n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'M'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">3</span>]==<span class="string">'E'</span>) T.work_same();</span><br><span class="line">            <span class="keyword">else</span> T.work_max();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'I'</span>) T.work_insert();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'D'</span>) T.work_delete();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'R'</span>) T.work_rev();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'G'</span>) T.work_sum();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎离 $HNOI2019$ 不远了，感觉多多更博增加 $RP$ …… $QwQ$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;神奇的题目。&lt;/p&gt;
&lt;p&gt;网上说什么做了这道题 $Splay$ 就差不多了，嗯对窝也这么觉得。于是终于码掉了。&lt;/p&gt;
&lt;p&gt;主要涉及的操作还是提取区间，我们组需要将 $l-1$ 提取至 $root$ ， 然后将 $r+1$ 提取至 $l-1$ 的下方，最终询问的 $l,r$ 区间的 $Splay$ 就是 $r+1$ 的左孩子。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="splay" scheme="http://monlights.github.io/tags/splay/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [Vani有约会]雨天的尾巴  线段树+启发式合并  luoguP4556</title>
    <link href="http://monlights.github.io/2019/04/02/%5B%E9%A2%98%E8%A7%A3%5DluoguP4556/"/>
    <id>http://monlights.github.io/2019/04/02/[题解]luoguP4556/</id>
    <published>2019-04-01T16:00:00.000Z</published>
    <updated>2019-04-02T07:57:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>毒瘤出题人，卡时间卡空间！</p><p>嗯，如果这一题不是在树上的话貌似可以直接权值线段树维护？不过到了树上的话难道可以权值线段树+树链剖分，表示不明白。于是尝试了一发线段树合并，但是我们的线段树是权值线段树。</p><a id="more"></a><p>我们的权值线段树是用来存原树中 $x$ 结点以及其子树中的每种救济粮的个数。</p><p>怎么个合并法呢，其实特别简单，两个线段树同时进行，发现到了一个节点的时候一个线段树有这个结点另一个没有这个节点，那么这个节点以及其下面的结点的信息都可以直接作为新线段树的这个节点的信息。</p><p>当然如果到了一个叶子节点，直接将两个线段树的这个位置的救济粮的个数加起来即可。</p><p>嗯，每个线段树再维护一个值存出现最多次数的救济粮是什么，这样就可以得到答案了。但是为了避免一些结点与其子树压根就没有救济粮的情况，我们需要判断一下这个节点与其子树是否有救济粮即可。</p><p>然后直接一遍 $dfs$ ，遍历 $u$ 的所有孩子然后拿 $u$ 的线段树依次去和 $u$ 的儿子的线段树合并。最终合并完的线段树存储的就是 $u$ 以及其子树的信息了。然后就可以获得答案了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LogN=<span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">6e6</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q,X[N],Y[N],Z[N],Ans[N],head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> nxt,to;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[u],v&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[v],u&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=--x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Lca &#123;</span><br><span class="line">    <span class="keyword">int</span> dep[N],fa[N][LogN+<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        fa[u][<span class="number">0</span>]=f,dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(G[i].to!=f) dfs(G[i].to,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=LogN;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            <span class="keyword">if</span>(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=LogN;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];</span><br><span class="line">        <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Lca;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line">    <span class="keyword">int</span> rt[N],lc[M],rc[M],d[M],t[M],tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[lc[x]]&gt;=d[rc[x]]) d[x]=d[lc[x]],t[x]=t[lc[x]];</span><br><span class="line">        <span class="keyword">else</span> d[x]=d[rc[x]],t[x]=t[rc[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x) x=++tot;</span><br><span class="line">        <span class="keyword">if</span>(l==r) &#123;d[x]+=val;t[x]=l;<span class="keyword">return</span> x;&#125;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid) lc[x]=update(lc[x],l,mid,pos,val);</span><br><span class="line">        <span class="keyword">else</span> rc[x]=update(rc[x],mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">        pushup(x);<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x) <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">if</span>(!y) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span>(l==r) &#123;d[x]+=d[y];t[x]=l;<span class="keyword">return</span> x;&#125;</span><br><span class="line">        lc[x]=merge(lc[x],lc[y],l,mid);</span><br><span class="line">        rc[x]=merge(rc[x],rc[y],mid+<span class="number">1</span>,r);</span><br><span class="line">        pushup(x);<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(G[i].to!=f) </span><br><span class="line">            calc(G[i].to,u),</span><br><span class="line">            T.rt[u]=T.merge(T.rt[u],T.rt[G[i].to],<span class="number">1</span>,m);</span><br><span class="line">    <span class="keyword">if</span>(T.d[T.rt[u]]) Ans[u]=T.t[T.rt[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)</span><br><span class="line">        IN(x),IN(y),add(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">        IN(X[i]),IN(Y[i]),IN(Z[i]),m=max(m,Z[i]);</span><br><span class="line">   <span class="comment">//权值线段树离线处理</span></span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> lca_xy=lca(X[i],Y[i]);</span><br><span class="line">        T.rt[X[i]]=T.update(T.rt[X[i]],<span class="number">1</span>,m,Z[i],<span class="number">1</span>);</span><br><span class="line">        T.rt[Y[i]]=T.update(T.rt[Y[i]],<span class="number">1</span>,m,Z[i],<span class="number">1</span>);</span><br><span class="line">        T.rt[lca_xy]=T.update(T.rt[lca_xy],<span class="number">1</span>,m,Z[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(fa[lca_xy][<span class="number">0</span>]) T.rt[fa[lca_xy][<span class="number">0</span>]]=T.update(T.rt[fa[lca_xy][<span class="number">0</span>]],<span class="number">1</span>,m,Z[i],<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    calc(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毒瘤出题人，卡时间卡空间！&lt;/p&gt;
&lt;p&gt;嗯，如果这一题不是在树上的话貌似可以直接权值线段树维护？不过到了树上的话难道可以权值线段树+树链剖分，表示不明白。于是尝试了一发线段树合并，但是我们的线段树是权值线段树。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="线段树" scheme="http://monlights.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="启发式合并" scheme="http://monlights.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 虚树入门</title>
    <link href="http://monlights.github.io/2019/04/01/%5B%E7%AE%97%E6%B3%95%5D%E8%99%9A%E6%A0%91/"/>
    <id>http://monlights.github.io/2019/04/01/[算法]虚树/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-04T08:31:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>虚树一般用于优化树形 $DP$ ，通常的关键词有”关键点”等。如果关键点的个数非常少，直接树形 $DP$ 无疑是处理了很多没有用的点，浪费时间。这个时候我们用虚树来优化，可以大大增加效率。</p><p>虚树的主要思想就是，只保留这些关键点以及这些关键点的 $lca$ ，那么虚树中的这些点都是有用的，直接在虚树上 $DP$ 就好了。</p><a id="more"></a><p>下面给出几个虚树的例子(其中红色的为关键点) ：</p><p><img src="/2019/04/01/[算法]虚树/A.png" alt=""></p><p><img src="/2019/04/01/[算法]虚树/B.png" alt=""></p><p><img src="/2019/04/01/[算法]虚树/C.png" alt=""></p><p>不过要注意的一点就是，如果我们一个一个去求 $lca$ ，那么复杂度就会变成 $O(k^2logn)$ (其中 $k$ 为关键点数) 。这个复杂度我们承受不了，我们需要一个更加高级的计算方式。</p><p>我们使用单调栈，单调的是结点 $dfn$ 时间戳。我们使用单调栈维护原点上的一条链。</p><p>假设，现在我们的单调栈维护的是原树中的这一条链(蓝色)：</p><p><img src="/2019/04/01/[算法]虚树/D.png" alt=""></p><p>然后这条链上的两个关键点(红色)显然已经被处理过了，我们下一个需要处理的将是这个点：</p><p><img src="/2019/04/01/[算法]虚树/E.png" alt=""></p><p>没错吧？按照时间戳排序后的顺序来依次处理这些关键点。</p><p>然后当前的栈顶显然是最下面的那个关键点，我们很简单的可以发现，当前要处理的关键点和栈顶点不在一条链上——这意味着我们需要退栈，换一条维护的链！</p><p>我们先求出栈顶点和当前要处理的关键点的 $lca$ ，也就是上面的那个关键点。显而易见，我们可以先从栈顶逐次弹出节点直到当前栈顶是 $lca$ ，然后将当前要处理的关键点入栈。</p><p>当然我们的虚树也是要连边的，对于那些要弹出的节点直接依次连边就好了。</p><p>所以当前维护的链变成了这样：</p><p><img src="/2019/04/01/[算法]虚树/F.png" alt=""></p><p>但是实际情况可能会糟糕一些。比如说栈顶点和当前要处理的关键点的 $lca$ 不在栈中，这个时候我们还需要将其加入栈中。</p><p>先举个例子吧，比方说我们需要对下面的树建造虚树：</p><p><img src="/2019/04/01/[算法]虚树/G.png" alt=""></p><ul><li>首先，输入数据给我们的关键点分别为：$5,7,10,8$</li><li>然后我们按照 $dfn$ 排个序，排完序后显然变为了：$7,8,5,10$</li><li>然后我们先将根节点($1$)入队。</li><li>第一个需要处理的关键点为 $7$ ，发现当前需要处理的关键点($7$)和栈顶结点($1$)的 $lca$ 为 $1$ ，也就说明了 $1,7$ 在同一条链上，直接将 $7$ 入栈即可。此时的栈为：$1,7$</li><li>然后看到下一个需要处理的关键点($8$) ，这个时候栈顶结点($7$)和当前需要处理的关键点($8$) 的 $lca$ 不是栈顶结点，这说明不在一条链上了，于是我们连边 ($4,7$) ，然后将 $4$ 和 $7$ 入栈。</li><li>为什么要将 $4$ 入栈呢？我们发现判断的时候栈顶$-1$的结点是 $1$ ，$1$ 的 $dfn$ 是大于 $4$ 的，这说明 $4$ 没出现过，我们的虚树要有所有关键点的 $lca$ ，于是将 $4$ 入栈。</li><li>接下来看到 $5​$ ，发现又不在一条链上了，这个时候我们还发现 $2​$ 也没有算过，所以我们连完 $(4,8),(2,4)​$ 两条边并弹出两个结点后我们还需要将 $2​$ 入栈，然后再将 $5​$ 入栈。</li><li>下一个点是 $10$ ，我们发现又不在一条链上了于是我们沿着 $2,5$ 退栈，发现 $lca(5,10)$ 就是 $1$ ，也就是弹出 $2,5$ 后的栈顶结点。既然在栈中发现了 $lca$ 我们就没必要将 $lca$ 入栈了。这个时候直接将 $10$ 入栈。</li><li>发现没有关键点了，我们逐次退栈，由于栈维护的结点是在同一条链上的，我们直接连边就好。 </li></ul><p>所以，最后我们建成的虚树如下：</p><p><img src="/2019/04/01/[算法]虚树/H.png" alt=""></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="comment">//建造虚树,k:关键点个数</span></span><br><span class="line">    sort(point+<span class="number">1</span>,point+<span class="number">1</span>+k,cmp);<span class="comment">//关键点按照时间戳排好序</span></span><br><span class="line">    <span class="built_in">stack</span>[top=<span class="number">1</span>]=<span class="number">1</span>,<span class="comment">//根节点入栈</span></span><br><span class="line">    G.cnt=<span class="number">0</span>,G.head[<span class="number">1</span>]=<span class="number">-1</span>;<span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">/*枚举每一个关键点，依次处理*/</span></span><br><span class="line">    <span class="comment">/*这里判断的原因是为了防止1重复计算*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i) <span class="keyword">if</span>(point[i]!=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*获取当前要处理的关键点与栈顶结点的lca*/</span></span><br><span class="line">        <span class="keyword">int</span> l=lca(<span class="built_in">stack</span>[top],point[i]);</span><br><span class="line">        <span class="comment">/*发现不在同一条链上了，需要换链*/</span></span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="built_in">stack</span>[top]) &#123;</span><br><span class="line">            <span class="keyword">while</span>(id[l]&lt;id[<span class="built_in">stack</span>[top<span class="number">-1</span>]]) &#123;<span class="comment">//弹出lca下面的结点</span></span><br><span class="line">                G.add(<span class="built_in">stack</span>[top<span class="number">-1</span>],<span class="built_in">stack</span>[top]);<span class="comment">//顺带连边</span></span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(id[l]&gt;id[<span class="built_in">stack</span>[top<span class="number">-1</span>]]) &#123;<span class="comment">//发现lca并没有访问过</span></span><br><span class="line">                G.head[l]=<span class="number">-1</span>;<span class="comment">//初始化</span></span><br><span class="line">                <span class="comment">/*丢掉依旧在lca下面的栈顶结点并将lca入栈*/</span></span><br><span class="line">                G.add(l,<span class="built_in">stack</span>[top]),<span class="built_in">stack</span>[top]=l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                G.add(l,<span class="built_in">stack</span>[top]),--top;<span class="comment">//直接入栈就好了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        G.head[point[i]]=<span class="number">-1</span>,<span class="built_in">stack</span>[++top]=point[i];<span class="comment">//将当前关键点入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;top;++i)<span class="comment">//对于最后栈中剩余的元素依次连边</span></span><br><span class="line">    G.add(<span class="built_in">stack</span>[i],<span class="built_in">stack</span>[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来一道例题吧。</p><h3 id="SDOI2011-消耗战"><a href="#SDOI2011-消耗战" class="headerlink" title="[SDOI2011]消耗战"></a>[SDOI2011]消耗战</h3><p><a href="https://monlights.github.io/2019/03/31/[%E9%A2%98%E8%A7%A3]luoguP2495/">题解戳我(≧ω≦)/！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚树一般用于优化树形 $DP$ ，通常的关键词有”关键点”等。如果关键点的个数非常少，直接树形 $DP$ 无疑是处理了很多没有用的点，浪费时间。这个时候我们用虚树来优化，可以大大增加效率。&lt;/p&gt;
&lt;p&gt;虚树的主要思想就是，只保留这些关键点以及这些关键点的 $lca$ ，那么虚树中的这些点都是有用的，直接在虚树上 $DP$ 就好了。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="算法" scheme="http://monlights.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="学习笔记" scheme="http://monlights.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="虚树" scheme="http://monlights.github.io/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SDOI2011]消耗战  虚树+树形DP  luoguP2495</title>
    <link href="http://monlights.github.io/2019/03/31/%5B%E9%A2%98%E8%A7%A3%5DluoguP2495/"/>
    <id>http://monlights.github.io/2019/03/31/[题解]luoguP2495/</id>
    <published>2019-03-30T16:00:00.000Z</published>
    <updated>2019-03-31T13:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>去 $Mina!$ 上了解了一波虚树，$\%\%\% XZY$ 学长太强辣！</p><p>这次总算明白了些虚树，然后 $XZY$ 大佬的例题就是消耗战。</p><p>于是看了过来。</p><a id="more"></a><p>首先，考虑普通的树形 $DP​$ ，设 $dp[u]​$ 表示<strong>在 $u​$ 为根的子树中满足目标所花费的最小代价</strong> ，那么转移方程也不是很难，我们枚举 $u​$ 的孩子 $v​$ 。如果 $v​$ 本身就是”能源丰富的岛屿”那么 $dp[u]+=G[i].val​$ ，其中 $G[i].val​$ 表示 $u​$ 到 $v​$ 的边的边权。为什么这样转移呢？因为 $v​$ 必须切断。</p><p>那么没有必要切断的岛屿呢？就分切/不切两种情况了：</p><script type="math/tex; mode=display">dp[u]+=min(G.val[i],dp[G.to[i]]);</script><p>这个也很好懂。</p><p>这个时候我们打完代码交一发发现只有 $40$ 分……往下看，可以看到 $n$ 到最后的顶尖数据有 $250000$ ……</p><p>但是我们可以观察到，$\sum k_i \leq 5*10^5$ ，发现总共的 $k$ 也不过这么大，这个时候我们可以用虚树来解决。</p><p>$Qiuly$ ：有关虚树的文章先咕一下蛤，最近有点忙。</p><p>建好虚树后直接用上面的转移方程做就得了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2.5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LogN=<span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch))<span class="keyword">if</span>(ch==<span class="string">'-'</span>)flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[N],nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],val[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));cnt=<span class="number">0</span>;&#125;</span><br><span class="line">    graph() &#123;init();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        nxt[cnt]=head[u],to[cnt]=v,val[cnt]=w,head[u]=cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,point[N],<span class="built_in">stack</span>[N],top;</span><br><span class="line">ll dp[N];<span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCA &#123;</span><br><span class="line">    <span class="keyword">int</span> dep[N],fa[N][LogN+<span class="number">3</span>],num[N][LogN+<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> id[N],dfn,Edge_Mx;</span><br><span class="line">    <span class="keyword">void</span> _Pre_Lca(<span class="keyword">int</span> u,<span class="keyword">int</span> f) &#123;</span><br><span class="line">        fa[u][<span class="number">0</span>]=f,dep[u]=dep[f]+<span class="number">1</span>,id[u]=++dfn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=LogN;++i) &#123;</span><br><span class="line">            fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            num[u][i]=min(num[u][i<span class="number">-1</span>],num[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=G.head[u];~i;i=G.nxt[i]) </span><br><span class="line">            <span class="keyword">if</span>(G.to[i]!=f)num[G.to[i]][<span class="number">0</span>]=G.val[i],_Pre_Lca(G.to[i],u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        Edge_Mx=inf;</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span>(dep[x]&lt;dep[y])swap(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=LogN;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            <span class="keyword">if</span>(dep[fa[x][i]]&gt;=dep[y])</span><br><span class="line">                Edge_Mx=min(Edge_Mx,num[x][i]),x=fa[x][i];</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=LogN;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            <span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">                Edge_Mx=min(Edge_Mx,min(num[x][i],num[y][i])),</span><br><span class="line">                x=fa[x][i],y=fa[y][i];</span><br><span class="line">        <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> LCA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> id[x]&lt;id[y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="comment">//DP过程</span></span><br><span class="line">    dp[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=G.head[u];~i;i=G.nxt[i]) &#123;</span><br><span class="line">        solve(G.to[i]);</span><br><span class="line">        <span class="keyword">if</span>(vis[G.to[i]])dp[u]+=G.val[i];</span><br><span class="line">        <span class="keyword">else</span> dp[u]+=min((ll)G.val[i],dp[G.to[i]]);</span><br><span class="line">    &#125;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="comment">//建立虚树</span></span><br><span class="line">    sort(point+<span class="number">1</span>,point+<span class="number">1</span>+k,cmp);</span><br><span class="line">    <span class="built_in">stack</span>[top=<span class="number">1</span>]=<span class="number">1</span>,G.cnt=<span class="number">0</span>,G.head[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i) <span class="keyword">if</span>(point[i]!=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> l=lca(<span class="built_in">stack</span>[top],point[i]);</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="built_in">stack</span>[top]) &#123;</span><br><span class="line">            <span class="keyword">while</span>(id[l]&lt;id[<span class="built_in">stack</span>[top<span class="number">-1</span>]]) &#123;</span><br><span class="line">                lca(<span class="built_in">stack</span>[top<span class="number">-1</span>],<span class="built_in">stack</span>[top]);</span><br><span class="line">                G.add(<span class="built_in">stack</span>[top<span class="number">-1</span>],<span class="built_in">stack</span>[top],Edge_Mx);</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(id[l]&gt;id[<span class="built_in">stack</span>[top<span class="number">-1</span>]]) &#123;</span><br><span class="line">                G.head[l]=<span class="number">-1</span>,lca(l,<span class="built_in">stack</span>[top]);</span><br><span class="line">                G.add(l,<span class="built_in">stack</span>[top],Edge_Mx),<span class="built_in">stack</span>[top]=l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> lca(l,<span class="built_in">stack</span>[top]),G.add(l,<span class="built_in">stack</span>[top],Edge_Mx),--top;</span><br><span class="line">        &#125;</span><br><span class="line">        G.head[point[i]]=<span class="number">-1</span>,<span class="built_in">stack</span>[++top]=point[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;top;++i)</span><br><span class="line">        lca(<span class="built_in">stack</span>[i],<span class="built_in">stack</span>[i+<span class="number">1</span>]),G.add(<span class="built_in">stack</span>[i],<span class="built_in">stack</span>[i+<span class="number">1</span>],Edge_Mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;IN(u),IN(v),IN(w);</span><br><span class="line">        G.add(u,v,w),G.add(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    _Pre_Lca(<span class="number">1</span>,<span class="number">0</span>),IN(m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k;IN(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)IN(point[i]),vis[point[i]]=<span class="literal">true</span>;</span><br><span class="line">        build(k);</span><br><span class="line">        solve(<span class="number">1</span>),<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)vis[point[i]]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去 $Mina!$ 上了解了一波虚树，$\%\%\% XZY$ 学长太强辣！&lt;/p&gt;
&lt;p&gt;这次总算明白了些虚树，然后 $XZY$ 大佬的例题就是消耗战。&lt;/p&gt;
&lt;p&gt;于是看了过来。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="虚树" scheme="http://monlights.github.io/tags/%E8%99%9A%E6%A0%91/"/>
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="树形DP" scheme="http://monlights.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HAOI2012]高速公路  线段树  luoguP2221</title>
    <link href="http://monlights.github.io/2019/03/31/%5B%E9%A2%98%E8%A7%A3%5DluoguP2221/"/>
    <id>http://monlights.github.io/2019/03/31/[题解]luoguP2221/</id>
    <published>2019-03-30T16:00:00.000Z</published>
    <updated>2019-03-31T11:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>$3$ 月份的最后一篇题解了呢……明天就属于 $4$ 月了，离省选不远了…$QwQ$…</p><p>发现窝真的很制杖，我们先来聊聊刚开始窝的想法。</p><p>我画了画图，然后发现，对于最后答案的分母(不是最简)，是这个序列中这些数的值(废话)，然后发现了每个点的出现次数，然后线段树维护求和。发现效率很低于是试图将出现次数般到二维平面上，然后曼哈顿距离转切比雪夫距离然后二维树状数组维护然后 $WA$ 了然后弃疗。</p><a id="more"></a><p><del>你可能认为窝很傻对吧？</del></p><p>嗯对窝是挺傻的。</p><p>正解是线段树，没猜错，<del>但是和什么二维树状数组有什么关系</del></p><p>我们考虑区间中的一个点 $i$ ，权值为 $v_i$ 。然后我们观察当前询问区间中有多少子区间包含了 $v_i$ ，这个个数就是点 $i$ 做出的贡献。现在我们来考虑怎么计算这个包含了 $i$ 的子区间个数。</p><p>可以发现，我们从 $i$ 向左扩展若干个点，然后又向右扩展若干个点，这样子一来就成了一个包含了 $i$ 子区间。这个就很好计算了，答案显然为 $(i-l)\times(r-i)$ 。然后还要算进没有向左/右扩展的情况，并且算上权值，最终 $i$ 造成的贡献显然为：</p><script type="math/tex; mode=display">v_i\times(i-l+1)\times (r-i+1)</script><p>那么我们将式子拆开可以得到：</p><script type="math/tex; mode=display">v_i\times [i\times (r-i+1)-l\times(r-i+1)+(r-i+1)]</script><script type="math/tex; mode=display">v_i\times [i\times r-i\times i+i-l\times r+l\times i-l+r-i+1]</script><script type="math/tex; mode=display">v_i\times [i(r+l)-i^2-lr-l+r+1]</script><script type="math/tex; mode=display">v_i i(r+l)-v_ii^2-v_ilr+v_i(r-l)+v_i</script><p>其中 $l,r$ 为当前询问区间，这个是可以直接算出的。我们发现我们需要维护的就是 $v_i\ ,\ v_ii\ ,\ v_ii^2$  三个值，用线段树维护即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch))<span class="keyword">if</span>(ch==<span class="string">'-'</span>)flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag)x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; _<span class="function">Tp <span class="title">gcd</span><span class="params">(_Tp x,_Tp y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y?gcd(y,x%y):x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LS(x) ((x)&lt;&lt;1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RS(x) ((x)&lt;&lt;1|1)</span></span><br><span class="line"></span><br><span class="line">    ll ans1,ans2,ans3;</span><br><span class="line">    ll sum1[N&lt;&lt;<span class="number">2</span>],sum2[N&lt;&lt;<span class="number">2</span>],sum3[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    ll tag[N&lt;&lt;<span class="number">2</span>],suq[N&lt;&lt;<span class="number">2</span>],rle[N&lt;&lt;<span class="number">2</span>],len[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll x,ll l,ll r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">            len[x]=<span class="number">1</span>,suq[x]=l,rle[x]=l*l;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        build(LS(x),l,mid),build(RS(x),mid+<span class="number">1</span>,r);</span><br><span class="line">        len[x]=len[LS(x)]+len[RS(x)];</span><br><span class="line">        suq[x]=suq[LS(x)]+suq[RS(x)],</span><br><span class="line">        rle[x]=rle[LS(x)]+rle[RS(x)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(ll x,ll l,ll r)</span> </span>&#123;</span><br><span class="line">        ll k=tag[x];tag[x]=<span class="number">0</span>;</span><br><span class="line">        sum1[LS(x)]+=len[LS(x)]*k,sum1[RS(x)]+=len[RS(x)]*k;</span><br><span class="line">        sum2[LS(x)]+=suq[LS(x)]*k,sum2[RS(x)]+=suq[RS(x)]*k;</span><br><span class="line">        sum3[LS(x)]+=rle[LS(x)]*k,sum3[RS(x)]+=rle[RS(x)]*k;</span><br><span class="line">        tag[LS(x)]+=k,tag[RS(x)]+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll x,ll l,ll r,ll L,ll R,ll v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;</span><br><span class="line">            tag[x]+=v;</span><br><span class="line">            sum1[x]+=len[x]*v;</span><br><span class="line">            sum2[x]+=suq[x]*v;</span><br><span class="line">            sum3[x]+=rle[x]*v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tag[x])pushdown(x,l,r);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)update(LS(x),l,mid,L,R,v);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)update(RS(x),mid+<span class="number">1</span>,r,L,R,v);</span><br><span class="line">        sum1[x]=sum1[LS(x)]+sum1[RS(x)];</span><br><span class="line">        sum2[x]=sum2[LS(x)]+sum2[RS(x)];</span><br><span class="line">        sum3[x]=sum3[LS(x)]+sum3[RS(x)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(ll x,ll l,ll r,ll L,ll R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;</span><br><span class="line">            ans1+=sum1[x],ans2+=sum2[x],ans3+=sum3[x];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tag[x])pushdown(x,l,r);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)query(LS(x),l,mid,L,R);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)query(RS(x),mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(m);</span><br><span class="line">    T.build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        ll l,r;IN(l),IN(r);--r;</span><br><span class="line">        ll v;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'C'</span>) IN(v),T.update(<span class="number">1</span>,<span class="number">1</span>,n,l,r,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'Q'</span>) &#123;</span><br><span class="line">            T.ans1=T.ans2=T.ans3=<span class="number">0</span>;</span><br><span class="line">            T.query(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">            ll res1=T.ans1,res2=T.ans2,res3=T.ans3;</span><br><span class="line">            ll ans=(r-l+<span class="number">1</span>-l*r)*res1+(r+l)*res2-res3;</span><br><span class="line">            ll len=(r-l+<span class="number">1</span>)*(r-l+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">            ll esw=gcd(ans,len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,ans/esw,len/esw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$3$ 月份的最后一篇题解了呢……明天就属于 $4$ 月了，离省选不远了…$QwQ$…&lt;/p&gt;
&lt;p&gt;发现窝真的很制杖，我们先来聊聊刚开始窝的想法。&lt;/p&gt;
&lt;p&gt;我画了画图，然后发现，对于最后答案的分母(不是最简)，是这个序列中这些数的值(废话)，然后发现了每个点的出现次数，然后线段树维护求和。发现效率很低于是试图将出现次数般到二维平面上，然后曼哈顿距离转切比雪夫距离然后二维树状数组维护然后 $WA$ 了然后弃疗。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="线段树" scheme="http://monlights.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】  [CQOI2011]动态逆序对  CDQ分治  luoguP3157</title>
    <link href="http://monlights.github.io/2019/03/30/%5B%E9%A2%98%E8%A7%A3%5DluoguP3157/"/>
    <id>http://monlights.github.io/2019/03/30/[题解]luoguP3157/</id>
    <published>2019-03-29T16:00:00.000Z</published>
    <updated>2019-03-30T07:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个可爱的 $CDQ$ ，我们将原始序列看成一个一个加入，然后后面的操作就是一个一个删除，这么一个一个操作我们都记下来，然后每个操作记一个 $id$ 表示它将为第几个时间点做出贡献。</p><p>当然对于原始序列的一个一个插入的操作这里的贡献是 $1$ ，删除操作的贡献自然是 $-1$ 。</p><a id="more"></a><p>每个时间点统计答案，最后输出前做一个前缀和然后依次输出就好了。</p><p>这是具体的框架，但是统计 $ans$ 数组具体怎么做呢？</p><p>可以知道对于一个位置 $i$ ，位置上的元素是 $a_i$ 。对于一个 $j$ 满足 $j\leq i$ ，并且 $a_i\leq a_j$ ，而且还要保证 $id_j\leq id_i$ ，那么 $j$ 就可以对 $i$ 做出贡献。这个就是在 $i$ 前面的元素可以做出的贡献。$i$ 后面的元素做出的贡献同理。</p><p>这就是一个很普通的三位偏序了，注意要开 $long\ long$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> flag=<span class="number">0</span>;<span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch))<span class="keyword">if</span>(ch==<span class="string">'-'</span>)flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt,pos[N],a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span><span class="keyword">int</span> r,v,d,id;&#125;Q[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a,Query b)</span> </span>&#123;<span class="keyword">return</span> a.d&lt;b.d;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;<span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x))C[x]+=v;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">int</span> res=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=lowbit(x))res+=C[x];<span class="keyword">return</span> res;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    CDQ(l,mid),CDQ(mid+<span class="number">1</span>,r);</span><br><span class="line">    sort(Q+l,Q+mid+<span class="number">1</span>,cmp),sort(Q+mid+<span class="number">1</span>,Q+r+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> j=l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=mid&amp;&amp;Q[j].d&lt;=Q[i].d) add(Q[j].v,Q[j].r),++j;</span><br><span class="line">        ans[Q[i].id]+=Q[i].r*(sum(n)-sum(Q[i].v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;j;++i) add(Q[i].v,-Q[i].r);</span><br><span class="line">    j=mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;mid;--i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=l&amp;&amp;Q[j].d&gt;=Q[i].d) add(Q[j].v,Q[j].r),--j;</span><br><span class="line">        ans[Q[i].id]+=Q[i].r*sum(Q[i].v<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;j;--i) add(Q[i].v,-Q[i].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IN(n),IN(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        IN(a[i]),pos[a[i]]=i,Q[++cnt]=(Query)&#123;<span class="number">1</span>,a[i],i,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;IN(x);</span><br><span class="line">        Q[++cnt]=(Query)&#123;<span class="number">-1</span>,x,pos[x],i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(<span class="number">1</span>,cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) ans[i]+=ans[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个可爱的 $CDQ$ ，我们将原始序列看成一个一个加入，然后后面的操作就是一个一个删除，这么一个一个操作我们都记下来，然后每个操作记一个 $id$ 表示它将为第几个时间点做出贡献。&lt;/p&gt;
&lt;p&gt;当然对于原始序列的一个一个插入的操作这里的贡献是 $1$ ，删除操作的贡献自然是 $-1$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CDQ分治" scheme="http://monlights.github.io/tags/CDQ%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【题解】  [AHOI2013]差异  后缀自动机.SAM  luoguP4248</title>
    <link href="http://monlights.github.io/2019/03/30/%5B%E9%A2%98%E8%A7%A3%5DluoguP4248/"/>
    <id>http://monlights.github.io/2019/03/30/[题解]luoguP4248/</id>
    <published>2019-03-29T16:00:00.000Z</published>
    <updated>2019-03-30T07:38:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始发现 $SA$ 很可做，不过当时没有看范围，心想美滋滋了这个就是 $SA$ 的板子，然后一看范围心就凉了。</p><p>不过可以用 $SAM$ ，我们知道，对于两个串，它们的最长公共子串就是它们在前缀树上的 $Lca$ 。这是显然的，不明白的同学可以康康 $Qiuly$ 酱之前写的 $SAM$ ，可以观察观察图片。</p><a id="more"></a><p>我们观察式子，发现  $\sum_{1\leq i&lt;j\leq n} len(T_i)+len(T_j)$ 是等于 $\frac{(n-1)\times n\times(n+1)}{2}$ 的，这个可以 $O(1)$ 算出。</p><p>那么 $2\times lcp(T_i,T_j)$ 怎么求呢？</p><p>那么对于一个结点 $x$ ，我们依次统计 $x$ 的儿子，并依次更新 $x$ 的 $size$ ，对于一个 $x$ 的儿子 $y$ ，枚举的时候它对答案的贡献显然是 $size[x]\times len[x]\times size[y]$ ，因为 $y$ 的子树中的任意一结点(包括 $y$ ) ，与 $x$ 之前枚举过的所有儿子的子树中的所有结点的 $Lca$ 都是 $x$ 。并且对于一个 $x$ ，它所造成的贡献就是 $Len[x]$ 。 </p><p>最后统计出来的答案再乘上 $2$ 就是后面那个式子啦<code>~\(≧▽≦)/~</code> 。</p><p>不过要注意一点，后缀自动机是会复制结点的，这些复制的结点不属于原串因此不能计算贡献。</p><p>然后就是代码的问题了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> last,cnt;</span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">26</span>],fa[N],len[N],sz[N],hep[N],tot[N];</span><br><span class="line">    SAM() &#123;last=cnt=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=last,np=++cnt;</span><br><span class="line">        last=np,len[np]=len[p]+<span class="number">1</span>,sz[np]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;!ch[p][c]) ch[p][c]=np,p=fa[p];</span><br><span class="line">        <span class="keyword">if</span>(!p)fa[np]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q=ch[p][c];</span><br><span class="line">            <span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>)fa[np]=q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nq=++cnt;len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nq],ch[q],<span class="keyword">sizeof</span>(ch[q]));</span><br><span class="line">                fa[nq]=fa[q],fa[q]=fa[np]=nq;</span><br><span class="line">                <span class="keyword">while</span>(p&amp;&amp;ch[p][c]==q) ch[p][c]=nq,p=fa[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i) hep[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i) hep[i]+=hep[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i) tot[hep[len[i]]--]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt;i&gt;=<span class="number">1</span>;--i) &#123;</span><br><span class="line">            <span class="keyword">int</span> node=tot[i];</span><br><span class="line">            res+=(ll)sz[fa[node]]*sz[node]*len[fa[node]];</span><br><span class="line">            sz[fa[node]]+=sz[node];</span><br><span class="line">        &#125;<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)T.ins(s[i]-<span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ll)(n<span class="number">-1</span>)*n*(n+<span class="number">1</span>)/<span class="number">2</span><span class="number">-2</span>*T.calc());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚开始发现 $SA$ 很可做，不过当时没有看范围，心想美滋滋了这个就是 $SA$ 的板子，然后一看范围心就凉了。&lt;/p&gt;
&lt;p&gt;不过可以用 $SAM$ ，我们知道，对于两个串，它们的最长公共子串就是它们在前缀树上的 $Lca$ 。这是显然的，不明白的同学可以康康 $Qiuly$ 酱之前写的 $SAM$ ，可以观察观察图片。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="后缀自动机.SAM" scheme="http://monlights.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SDOI2013]森林  主席树+启发式合并  luoguP3302</title>
    <link href="http://monlights.github.io/2019/03/29/%5B%E9%A2%98%E8%A7%A3%5DluoguP3302/"/>
    <id>http://monlights.github.io/2019/03/29/[题解]luoguP3302/</id>
    <published>2019-03-28T16:00:00.000Z</published>
    <updated>2019-03-30T07:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>初看题面，看到 $K$ 大我们可以想到主席树，但是连边却又符合 $LCT$ ，但是毕竟 $LCT$ 是不能支持 $K$ 大的，因为 $Splay$ 辅助树不是二叉查找树。</p><p>不过主席树我们可以大力启发式合并，合并的时候重建节点的倍增数组并且重新建立节点的权值线段树。这样子每个节点要被修改的期望次数为 $logn​$ 次，那么时间复杂度就是 $O(nlog^2n)​$ (貌似是的)，这足以让我们过这道题了。</p><a id="more"></a><h3 id="1-主席树如何上树"><a href="#1-主席树如何上树" class="headerlink" title="1.主席树如何上树"></a>1.主席树如何上树</h3><p>上树[手动滑稽]……</p><p>首先，对于节点 $u$ 的权值线段树，$ta$ 是由 $fa[u]$ 的权值线段树继承过来的，因为只是多了一个 $u$ ，所以主席树只是多增加了 $logn$ 个节点。</p><p>既然是从父亲节点继承过来的话，那么很显然我们可以在预处理倍增数组的时候顺便将主席树建好。</p><h4 id="Code-builld"><a href="#Code-builld" class="headerlink" title="Code-builld:"></a>Code-builld:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    update(root[u],root[f],<span class="number">1</span>,tmp,S(a[u]));</span><br><span class="line">    fa[u][<span class="number">0</span>]=f,dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(G[i].to!=f) dfs(G[i].to,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很容易理解，那么我们怎么暴力合并两颗树呢？</p><p>对于要合并的两颗树，我们选择将 $size$ 小的往 $size$ 大的并，对于给出的 $x,y$ ，我们先给 $x,y$ 连好边，然后将 $y$ 的权值线段树从 $x$ 更新，丢掉以前的。最后遍历 $y$ 的子树，更新其倍增数组和权值线段树即可。</p><p>至于 $size$ 的维护的话，我们可以找到 $x,y$ 所在的树的根。这个样子 $size$ 谁大谁小只需要判断 $x,y$ 所在的树的根的 $size$ 谁大谁小即可。我们在网下遍历 $y$ 的子树时每次都将$x$ 所在树的根的 $size$ 加一即可。</p><h4 id="Code-merge"><a href="#Code-merge" class="headerlink" title="Code-merge:"></a>Code-merge:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*rt:x所在树的根，u:当前需要重构的节点,刚进入函数的时候为y*/</span></span><br><span class="line">    <span class="comment">/*f:当前需要重构的节点的父节点，刚进入函数的时候为x*/</span></span><br><span class="line">    fa[u][<span class="number">0</span>]=f,dep[u]=dep[f]+<span class="number">1</span>;<span class="comment">//更新深度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">/*更新倍增数组*/</span></span><br><span class="line">    size[rt]++,<span class="comment">//更新size</span></span><br><span class="line">    sta[u]=f,<span class="comment">//记录父亲(不是倍增数组,这是用来查询所在树的根的)</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>;<span class="comment">//记录一下</span></span><br><span class="line">    update(root[u],root[f],<span class="number">1</span>,tmp,S(a[u]));<span class="comment">//重建</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>(G[i].to!=f) merge(rt,G[i].to,u);<span class="comment">//遍历子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后差不多了，至于 $sta$ 的话，因为要查询所在树的根，为了提高效率我们可以将其作为并查集的形式。</p><p>还有一点，对于 $vis$ 数组，实际上我们建树的时候就直接用 $merge$ 好了，$vis$ 只是用来判重而已，因为是森林，有很多树。所以说我们可以不用 $dfs$ 就将初始形态的树建好。</p><h4 id="Code-pre"><a href="#Code-pre" class="headerlink" title="Code-pre:"></a>Code-pre:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) &#123;merge(i,i,<span class="number">0</span>);sta[i]=i;&#125;</span><br></pre></td></tr></table></figure><p>最后需要注意的就是主席树的空间要开很大，差不多是 $nlog^2n$ ，因为有很多结点。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">8e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LogN=<span class="number">22</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> testcase,lastans,n,m,T,a[N],b[N],tmp,head[N],cnt;</span><br><span class="line"><span class="keyword">int</span> size[N],sta[N],vis[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> nxt,to;&#125;G[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+tmp,x)-b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=&#123;head[u],v&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=&#123;head[v],u&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segment_Tree &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line">    <span class="keyword">int</span> root[N],tot;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span><span class="keyword">int</span> l,r,v;&#125;t[N*<span class="number">601</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp;now,<span class="keyword">int</span> last,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        now=++tot,t[now]=t[last],t[now].v++;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid) update(t[now].l,t[last].l,l,mid,pos);</span><br><span class="line">        <span class="keyword">else</span> update(t[now].r,t[last].r,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> r1,<span class="keyword">int</span> r2,<span class="keyword">int</span> r3,<span class="keyword">int</span> r4,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> th=t[t[r1].l].v+t[t[r2].l].v-t[t[r3].l].v-t[t[r4].l].v;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=th) <span class="keyword">return</span> query(t[r1].l,t[r2].l,t[r3].l,t[r4].l,l,mid,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(t[r1].r,t[r2].r,t[r3].r,t[r4].r,mid+<span class="number">1</span>,r,k-th);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Segment_Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[N],fa[N][LogN+<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=LogN;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=LogN;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>]=f,dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    size[rt]++,</span><br><span class="line">    sta[u]=f,</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    update(root[u],root[f],<span class="number">1</span>,tmp,S(a[u]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>(G[i].to!=f) merge(rt,G[i].to,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">return</span> u==sta[u]?u:sta[u]=find(sta[u]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(testcase);</span><br><span class="line">    IN(n),IN(m),IN(T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        IN(a[i]),b[i]=a[i],sta[i]=i;</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(b[i]!=b[i<span class="number">-1</span>])b[++tmp]=b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;IN(x),IN(y);add(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;merge(i,i,<span class="number">0</span>);sta[i]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];<span class="keyword">int</span> x,y,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);IN(x),IN(y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'L'</span>) &#123;</span><br><span class="line">            x^=lastans,y^=lastans;</span><br><span class="line">            add(x,y);</span><br><span class="line">            <span class="keyword">int</span> a=find(x),b=find(y);</span><br><span class="line">            <span class="keyword">if</span>(size[a]&lt;size[b])swap(x,y),swap(a,b);</span><br><span class="line">            merge(a,y,x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            IN(k);</span><br><span class="line">            x^=lastans,y^=lastans,k^=lastans;</span><br><span class="line">            <span class="keyword">int</span> lca_xy=lca(x,y);</span><br><span class="line">            lastans=b[query(root[x],root[y],</span><br><span class="line">                            root[lca_xy],root[fa[lca_xy][<span class="number">0</span>]],<span class="number">1</span>,tmp,k)];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lastans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初看题面，看到 $K$ 大我们可以想到主席树，但是连边却又符合 $LCT$ ，但是毕竟 $LCT$ 是不能支持 $K$ 大的，因为 $Splay$ 辅助树不是二叉查找树。&lt;/p&gt;
&lt;p&gt;不过主席树我们可以大力启发式合并，合并的时候重建节点的倍增数组并且重新建立节点的权值线段树。这样子每个节点要被修改的期望次数为 $logn​$ 次，那么时间复杂度就是 $O(nlog^2n)​$ (貌似是的)，这足以让我们过这道题了。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="启发式合并" scheme="http://monlights.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
      <category term="主席树" scheme="http://monlights.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SDOI2008]Sandy的卡片  后缀数组.SA  luoguP2463</title>
    <link href="http://monlights.github.io/2019/03/28/%5B%E9%A2%98%E8%A7%A3%5DluoguP2463/"/>
    <id>http://monlights.github.io/2019/03/28/[题解]luoguP2463/</id>
    <published>2019-03-27T16:00:00.000Z</published>
    <updated>2019-03-29T05:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>后缀数组，我们可以先将所有的卡片连成一个串，每一个卡片数列之间用一个极大数分开保证不出锅。然后的话，对于相同的定义有些鬼，使得我们不能直接做 $SA$ ，这个时候我们将所有的卡片数列的值都转换为当前位置减去上个位置的值即可。</p><a id="more"></a><p>然后就是统计答案，我们二分这个最长公共子序列的长度，每一次去判断是否合法。怎么判断呢？首先对于 $height$ 数组，如果要满足要求的话选取的这一段的 $height$ 数组的值都不能小于当前的 $mid$ ，这是显然的。</p><p>怎么确保我们将所有的卡片数列都选了呢？直接开一个 $vis​$ 数组即可，然后在碰到不合法的地方(也就是 $height[i]​$ 小于了 $mid​$ )全部清空即可。</p><p>最后如何判断当前的 $mid$ 是否合法呢？很显然，只有在所有的卡片数列都成功选择的情况下就合法了。我们用一个栈维护 $vis$ ，清空方便，然后当栈顶为卡片序列数的时候，也就是所有的卡片序列都选择的时候，$mid$ 就合法了。</p><p>然后有个悲催的事情，窝打二分的时候……打成了这样： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(mid)) ans=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">    r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，$r$ 前面应该要有 $else$ ，但是窝看了一晚上都没看出来…….</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">5e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G=<span class="number">5e3</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch))<span class="keyword">if</span>(ch==<span class="string">'-'</span>)flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SA &#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,S[N],sa[N],height[N],x[N],y[N],hep[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre_sa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) x[i]=S[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) hep[x[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) hep[i]+=hep[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) sa[hep[x[i]]--]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">1</span>,p=<span class="number">0</span>;m=p,p&lt;n;w&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">            p=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=w;++i) y[++p]=n-w+i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(sa[i]&gt;w) y[++p]=sa[i]-w;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i) hep[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) hep[x[i]]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) hep[i]+=hep[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) sa[hep[x[y[i]]]--]=y[i];</span><br><span class="line">            swap(x,y);</span><br><span class="line">            x[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">                x[sa[i]]=(y[sa[i]]==y[sa[i<span class="number">-1</span>]]&amp;&amp;y[sa[i]+w]==y[sa[i<span class="number">-1</span>]+w])?p:++p;</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre_height</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)x[sa[i]]=i;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            k-=k&gt;<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j=sa[x[i]<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">while</span>(j+k&lt;=n&amp;&amp;i+k&lt;=n&amp;&amp;S[j+k]==S[i+k])++k;</span><br><span class="line">            height[x[i]]=k;</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> SA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[G],<span class="built_in">stack</span>[G],top;</span><br><span class="line"><span class="keyword">int</span> num,len[G],id[N],a[G][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top) vis[<span class="built_in">stack</span>[top--]]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i]&lt;x) &#123;</span><br><span class="line">            <span class="keyword">while</span>(top) vis[<span class="built_in">stack</span>[top--]]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!vis[id[sa[i]]]) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top]=id[sa[i]],vis[id[sa[i]]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(top==num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(num);</span><br><span class="line">    <span class="keyword">int</span> mx=-inf,mi=inf,l=<span class="number">0</span>,r=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i) &#123;</span><br><span class="line">        IN(len[i]),r=min(r,len[i]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len[i];++j) &#123;</span><br><span class="line">            IN(a[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(j!=<span class="number">1</span>)mx=max(mx,a[i][j]-a[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=len[i];++j)</span><br><span class="line">            S[++n]=a[i][j]-a[i][j<span class="number">-1</span>],id[n]=i,mi=min(mi,S[n]);</span><br><span class="line">        S[++n]=++mx;</span><br><span class="line">    &#125;</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        S[i]=S[i]-mi+<span class="number">1</span>,m=max(m,S[i]);</span><br><span class="line">    pre_sa(),pre_height();</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid))ans=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;后缀数组，我们可以先将所有的卡片连成一个串，每一个卡片数列之间用一个极大数分开保证不出锅。然后的话，对于相同的定义有些鬼，使得我们不能直接做 $SA$ ，这个时候我们将所有的卡片数列的值都转换为当前位置减去上个位置的值即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="后缀数组.SA" scheme="http://monlights.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-SA/"/>
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【考试总结】  Test-2019.3.28  HNOI2019模拟</title>
    <link href="http://monlights.github.io/2019/03/28/%5B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%5Dtest20190328/"/>
    <id>http://monlights.github.io/2019/03/28/[考试总结]test20190328/</id>
    <published>2019-03-27T16:00:00.000Z</published>
    <updated>2019-04-03T09:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的题目貌似暴力分好拿写欸，然而……窝只有 $70$ ？不过排名比昨天上升了什么鬼。</p><p>$QwQ$ 题目的确很难懂，所以窝听了讲解后也没听懂多少，不过还是改出了第一题(第一题是人就改的出好吧o(≧口≦)o)。</p><a id="more"></a><p><a href="https://github.com/monlights/image/blob/master/problem20190328.zip?raw=true" target="_blank" rel="noopener">题目压缩包戳我!!!<code>~\(≧▽≦)/~</code>(有时链接可能会崩，如果崩了的话请稍后尝试QwQ)</a></p><hr><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><blockquote><p>期望得分：30分<br>实际得分：30分<br>正解：找规律??<br>窝的解法：暴力模拟题意</p></blockquote><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>第一眼看到题目，欸，如果按照题面模拟就有 $30$ 分！出题人良心啊。然后看数据范围，$100\%$ 的数据的 $n\leq 3\times10^7$ ，这应该是 $O(n)$ 算法才行啊，于是想，或许是线性 $DP$ ，然后推式子，推出这么一个鬼玩意：</p><script type="math/tex; mode=display">f[i]=f[i-1]+sum(a[i])</script><p>$sum(a[i])$ 就是在 $1$ 到 $i-1$ 中大于 $a[i]$ 的数的个数，然后 $f[i]$ 表示将前 $i$ 个元素进行冒泡需要的交换次数。</p><p>很显然这是错的。</p><p>然后我就想到了 $NOI$ 往年的冒泡排序(貌似是 $NOI$ 的?)，其实两道题没什么联系。</p><p>哎好吧发现过不去直接上暴力吧，题目说什么就做什么，于是把我用来对拍的暴力程序提交了上去，$30$ 分。</p><p>接下来讲讲正解。</p><p>很显然，对于一个元素 $a_i$ ，它所在的位置为 $i$ ，然而最后排好序后 $ta$ 应该回到的位置为 $a_i$ 。观察冒泡过程，发现对于一个元素，每次冒泡排序都最多会将 $ta$ 向自己的目标位置移动一格。</p><p>然后就是，比如说当前序列的最小元素，假设最小元素的起点位置为 $s$ ,我们发现每次冒泡总会将 $ta$ 向前移一格，然后在第 $s-1$ 次冒泡排序的时候 $1$ 归位了。然后发现 $1$ 的移动对 $2$ 的移动次数并没有产生影响，这个时候将 $1$ 删去，发现 $2$ 归位的移动次数变成了 $2$ 的初始位置 $-$ $1$ ，放在原序列中就是 $2$ 的初始位置 $-$ $2$ 。</p><p>这至少说明，对于任意一个元素 $i$ ，其所需要的移动次数为 $i-a_i$ 。</p><p>那么，如果要使序列有序，所需要的排序次数就是 $max\{ i-a_i \}$ 。直接计算答案即可。</p><p>(实际上窝也不是很明白…..貌似是这样的吧 $QwQ$ )</p><h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,S,B,C,D,A[<span class="number">10006</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"magician.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"magician.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;n,&amp;S,&amp;B,&amp;C,&amp;D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        A[i]=i;</span><br><span class="line">        S=(S*B+C)%D;</span><br><span class="line">        swap(A[i],A[(S%i)+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)counter=max(counter,i-A[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><blockquote><p>期望得分：30分<br>实际得分：0分<br>正解：容斥+搜索+剪枝<br>窝的解法：暴搜</p></blockquote><h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>不会………….然后暴搜打挂了没得分。</p><p>所以这不能说是题解，留个坑吧。</p><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><blockquote><p>期望得分：40分<br>实际得分：40分<br>正解：将所有颜色维护成链，然后分块加速<br>窝的解法：直接维护成链</p></blockquote><p>对于一个 $i$ ，如果 $a_i=k$ ，并且 $a_j=k$ ，而且 $i$ 和 $j$ 是离得最近的，则将它们向前向星那样连起来，最后对询问的区间直接暴力跳即可。</p><h2 id="Code：-1"><a href="#Code：-1" class="headerlink" title="Code："></a>Code：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LogN=<span class="number">27</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hashs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,a[N],head[N],nxt[N],f[LogN+<span class="number">7</span>][N],logs[N],ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch))<span class="keyword">if</span>(ch==<span class="string">'-'</span>)flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre_st</span><span class="params">()</span></span>&#123;</span><br><span class="line">    logs[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)logs[i]=logs[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[<span class="number">0</span>][i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;LogN;++t)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;t)<span class="number">-1</span>&lt;=n)</span><br><span class="line">                f[t][i]=max(f[t<span class="number">-1</span>][i],f[t<span class="number">-1</span>][i+(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>))]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=logs[y-x+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max(f[t][x],f[t][y-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> now=x,last=nxt[x];last&gt;=lim;last=nxt[last]) &#123;</span><br><span class="line">        <span class="keyword">while</span>(now&gt;last&amp;&amp;query(last,now)&gt;a[last]) now=nxt[now];</span><br><span class="line">        ans=max(ans,now-last+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_hashs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(seq.begin(),seq.end());</span><br><span class="line">    seq.erase(unique(seq.begin(),seq.end()),seq.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;seq.size();++i) hashs[seq[i]]=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=hashs[a[i]];</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"spiral.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"spiral.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    IN(n),IN(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        IN(a[i]),seq.push_back(a[i]);</span><br><span class="line">    make_hashs();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        nxt[i]=head[a[i]],head[a[i]]=i;</span><br><span class="line">    pre_st();</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x,y;IN(x),IN(y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&gt;=x;--i) solve(i,x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正解不费………………………………….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的题目貌似暴力分好拿写欸，然而……窝只有 $70$ ？不过排名比昨天上升了什么鬼。&lt;/p&gt;
&lt;p&gt;$QwQ$ 题目的确很难懂，所以窝听了讲解后也没听懂多少，不过还是改出了第一题(第一题是人就改的出好吧o(≧口≦)o)。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="考试总结" scheme="http://monlights.github.io/tags/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【考试总结】  Test-2019.3.27  HNOI2019模拟</title>
    <link href="http://monlights.github.io/2019/03/27/%5B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%5Dtest20190327/"/>
    <id>http://monlights.github.io/2019/03/27/[考试总结]test20190327/</id>
    <published>2019-03-26T16:00:00.000Z</published>
    <updated>2019-04-03T09:32:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天全是原题，然而窝几乎都没做过，于是挂了……</p><p>丢人的是考场上组合数的式子 $C[i][j]$=$C[i$-$1][j]$+$C[i$-$1][j$-$1]$ 写成了 $C[i][j]$=$C[i][j$-$1]$+$C[i$-$1][j$-$1]$ ，然后第一题光荣爆 $0​$ ……TAT。</p><p>吸取教训！</p><a id="more"></a><p><a href="https://github.com/monlights/image/blob/master/problem20190327.zip?raw=true" target="_blank" rel="noopener">题目压缩包戳我!!!<code>~\(≧▽≦)/~</code>(有时链接可能会崩，如果崩了的话请稍后尝试QwQ)</a></p><hr><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><blockquote><p>期望得分：100分<br>实际得分：0分<br>正解：Purfer+DP+组合数学<br>窝的解法：Purfer+DP+组合数学</p></blockquote><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><del>十年OI一场空，组合数打错见祖宗。</del></p><p>上面的正解有误，听说 $DP$ 不是正解，不过，$DP$ 复杂度高达 $O(n^4)$  ，本应该 $T$ 的，却仗着小常数不仅 $AC$ ，还爆踩标程？<del>这究竟是道德的沦丧还是人性的扭曲？</del></p><p>不了不了，正经一点。众所周知，有个东西叫 $Purfer$ 序列，对于每一个不同的树，都有不同的 $Purfer$ 序列。所以每个树都可以用其 $Purfer$ 序列来表示，这个树中的每个结点在 $Purfer$ 序列中的出现次数为<strong>其度数减一</strong>。至于$Purfer​$ 序列具体是什么就不赘述了。</p><p>那么 $DP​$ 方程怎么设？</p><p>我们设 $f[i][j][k]$ 表示 <strong>从前 $i$ 个结点中选出 $j$ 个结点，并且这 $j$ 个结点共在原树的 $Purfer$ 序列出现了 $k$ 次的合法 $Purfer$ 序列的数量</strong> 。</p><p>那么转移呢？很显然分为两种情况：</p><ul><li>没选第 $i​$ 个点。</li><li>选了第 $i​$ 个点。</li></ul><p>然后分别进行转移，这就很简单了：</p><ul><li>没选：$f[i][j][k]+=f[i-1][j][k]​$ </li><li>选了：$f[i][j][k]+=f[i-1][j-1][k-d]\times C[k][d]​$</li></ul><p>其中 $d​$ 为我们正在枚举的第 $i​$ 个点的出现次数 $(0​$ ~ $du[i]-1)​$ ，然后就是下面的组合数，就是代表着<strong>在 $k-d​$ 长度的序列中插入 $d​$ 个 $i​$ 的方案数</strong> 。<br>当然也可以这么写：</p><script type="math/tex; mode=display">f[i][j+1][d+k]+=C[d+k][d]\times f[i-1][j][k]​</script><p> 我们知道一棵 $n​$ 个结点的树的 $Purfer​$ 序列的长度是 $n-2​$ 的，所以我们的答案应该就是 $f[n][i][i-2]​$ 。</p><p> 最后，记得随时<del>膜</del>模！</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">57</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> du[N],n,T;</span><br><span class="line">ll C[N][N],f[N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;++i)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=C[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%MOD;<span class="comment">//就是这儿!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;du[i]);</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n<span class="number">-2</span>;++k) &#123;</span><br><span class="line">                    f[i][j][k]=(f[i][j][k]+f[i<span class="number">-1</span>][j][k])%MOD;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;du[i]&amp;&amp;d+k&lt;=n<span class="number">-2</span>;++d)</span><br><span class="line">                        f[i][j+<span class="number">1</span>][d+k]=(f[i][j+<span class="number">1</span>][d+k]+C[d+k][d]*f[i<span class="number">-1</span>][j][k]%MOD)%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)<span class="built_in">printf</span>(<span class="string">"%lld "</span>,f[n][i][i<span class="number">-2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><blockquote><p>期望得分：5分<br>实际得分：30分<br>正解：???没发sol……<br>窝的解法：手玩小数据+瞎搞</p></blockquote><h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>一看就是懵逼题……但是看到 $30$ 分的数据很小，并且还有菊花图，所以我们来瞎搞吧！刚开始的时候以为前六个点都是菊花图，然后都手玩，到后面才看清，只能说数据太弱了啊。</p><p>正解表示不明白……贴一发考场上的代码：</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"b.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"b.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> x,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(x!=<span class="number">0</span>)flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">"1\n"</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123;<span class="comment">//菊花图输出瞎搞手玩？</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;k&gt;=<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">"1\n"</span>),<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>&amp;&amp;k&gt;=<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">"1\n"</span>),<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>&amp;&amp;k==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">"1\n"</span>),<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>&amp;&amp;k&gt;=<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">"3\n"</span>),<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">4</span>&amp;&amp;k==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">"1\n"</span>),<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">4</span>&amp;&amp;k==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">"7\n"</span>),<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">4</span>&amp;&amp;k&gt;=<span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">"10\n"</span>),<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">5</span>&amp;&amp;k==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">"1\n"</span>),<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">5</span>&amp;&amp;k==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">"13\n"</span>),<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//其他情况输出样例？？</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">4</span>)&#123;<span class="built_in">printf</span>(<span class="string">"8\n"</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">6</span>)&#123;<span class="built_in">printf</span>(<span class="string">"28\n"</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上玩到 $n​$=$5\&amp;\&amp;k​$=$2​$ 的时候我就崩了，玩不下去了。</p><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><blockquote><p>期望得分：0分<br>实际得分：0分<br>正解：最小割<br>窝的解法：没做….</p></blockquote><h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><p>真的看不出来是最小割啊 $QwQ$ ，以为是数论题，还看到质因子了感觉就更不像最小割了……但是在想题目的时候最小割的确出现在了我的脑海中，但是一闪就过了……</p><p>一个有趣的事情：考试期间高二机房神仙一度怀疑此题为数论题，这个时候 $chl$神仙 和另一位 $Dalao$ 走了出去，站在门外讨论此题中的”物理”，说什么重心和”物理”有关因此此题不可做，然后树王神仙表示不懂”物理”中的”重心”准备弃疗，然而最终树王神仙还是选择了网络流……</p><p>好吧不扯淡了，我们来讨论一下这题的粗略解法。</p><p>可以发现题目给出了一个限制：$N$ 最多有两个质因子。这个限制有什么用呢？</p><p>对于一个有 $N$ 个扇叶的风扇，我们考虑平衡的并且独立扇叶只有一个的风扇：</p><p><img src="/2019/03/27/[考试总结]test20190327/A.png" alt=""></p><p>左边的就是有 $(N=8)$ 个扇叶的风扇，右边的呢就是在 $8$ 个扇叶中有 $2$ 个扇叶的风扇 ($(A_1,D_1,F_1),$$(A_1,H_1,B_1)$)，可以知道这个 $2$ 个扇叶的风扇是一定平衡的，因为 $2$ 是 $8$ 的因子。</p><p>可以知道，对于 $8$ 的其他因子(例如 $4$ )是可以被质因子 $2$ 组成的，因此也是平衡的风扇。</p><p>那么对于两个不同的质因子，可以组成两个不同样式的且平衡的 $N$ 个扇叶的风扇的子风扇。</p><p>当然还有位置不同，对于上图中 $2$ 个扇叶的子风扇根据不同的位置有很多个：</p><p><img src="/2019/03/27/[考试总结]test20190327/B.png" alt=""></p><p>这个时候我们的问题就可以转化如下了：</p><blockquote><p>有两种类型的风扇 $p,q$ ，风扇类型等于 $2$ 的样子如上图，现在我们需要用这两种风扇<strong>无重叠</strong>的覆盖尽可能多的剩下的残缺扇叶。</p></blockquote><p>这个时候考虑建图，我们从 $S$ 向所有不同位置的 $p$ 类风扇连一条边，边权为 $p$ ，表示选择了这个风扇可以多覆盖一共 $p$ 个扇叶。所有不同位置的 $q$ 类风扇向 $T$ 连边，边权为 $q$ ，和上面同理。</p><p>然后这个时候的最小割是什么呢？对于一个起点为 $x$ 的 $p$ 类风扇，我们将 $S$ 连向Ta的边切断，表示不使用起点为 $x$ 的 $p$ 类风扇，$q$ 类风扇同理。当然是不使用的风扇越少越好，剩下的可用的风扇当然是越多越好，所以成了最小割。</p><p>那么怎么表示<strong>无重叠</strong>呢？</p><p>可以知道同类风扇是不可能重叠的，我们考虑异类风扇。我们对于一个 $p$ 类风扇和一个 $q$ 类风扇，如果其重叠了，那么只能选择其中一个，于是我们在这两个风扇间连一条边，边权为 $inf$ ，这个时候跑最大流的时候必定有流经过此地，也就是说这两个风扇必然要割掉一个才行。</p><p>所以什么事情都解决了，就差代码了。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">2e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch))<span class="keyword">if</span>(ch==<span class="string">'-'</span>)flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;<span class="comment">//Dinic板子封装</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Que;</span><br><span class="line">    <span class="keyword">int</span> s,t,sum,head[N&lt;&lt;<span class="number">1</span>],cnt=<span class="number">1</span>,dep[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> nxt,to,val;&#125;G[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        G[++cnt]=&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">        G[++cnt]=&#123;head[v],u,<span class="number">0</span>&#125;,head[v]=cnt;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">        dep[s]=<span class="number">1</span>,Que.push(s);</span><br><span class="line">        <span class="keyword">while</span>(!Que.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=Que.front(),v;Que.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt)</span><br><span class="line">                <span class="keyword">if</span>(!dep[v=G[i].to]&amp;&amp;G[i].val&gt;<span class="number">0</span>)</span><br><span class="line">                    dep[v]=dep[u]+<span class="number">1</span>,Que.push(v);</span><br><span class="line">        &#125;<span class="keyword">return</span> dep[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flow||u==t) <span class="keyword">return</span> flow;</span><br><span class="line">        <span class="keyword">int</span> used=<span class="number">0</span>,rlow,v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(dep[v=G[i].to]==dep[u]+<span class="number">1</span>&amp;&amp;G[i].val&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                used+=(rlow=dfs(v,min(G[i].val,flow-used)));</span><br><span class="line">                G[i].val-=rlow,G[i^<span class="number">1</span>].val+=rlow;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(!used) dep[u]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> used;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(bfs()) sum-=dfs(s,inf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Dinic;</span><br><span class="line"><span class="keyword">int</span> n,m,p,q,point,bock[N],vis[N],fan[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/p;++i) <span class="keyword">if</span>(!bock[i]) &#123;<span class="comment">//起点扇叶没有损坏</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=n/p) <span class="keyword">if</span>(bock[j]) <span class="keyword">goto</span> end1;</span><br><span class="line">        <span class="comment">//枚举每个扇叶，如果损坏的那么该风扇就不合法</span></span><br><span class="line">        ++point,add(s,point,p),sum+=p;<span class="comment">//连边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=n/p) fan[j]=point;<span class="comment">//标记</span></span><br><span class="line">        end1:;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/q;++i) <span class="keyword">if</span>(!bock[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=n/q) <span class="keyword">if</span>(bock[j]) <span class="keyword">goto</span> end2;</span><br><span class="line">        ++point,add(point,t,q),sum+=q;<span class="comment">//连边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=n/q) vis[fan[j]]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//清理标记，防止有风扇被连两次边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=n/q)</span><br><span class="line">            <span class="keyword">if</span>(fan[j]&amp;&amp;!vis[fan[j]]) </span><br><span class="line">                vis[fan[j]]=<span class="literal">true</span>,add(fan[j],point,inf);<span class="comment">//连边</span></span><br><span class="line">        end2:;</span><br><span class="line">    &#125;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(m);s=<span class="number">0</span>,t=N<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;<span class="keyword">int</span> x;IN(x),bock[x]=<span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> copy=n,sqr=<span class="built_in">sqrt</span>(n),first=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqr;++i) &#123;<span class="comment">/*寻找两个质因子p和q*/</span></span><br><span class="line">        <span class="keyword">if</span>(!(n%i)&amp;&amp;!first) &#123;</span><br><span class="line">            first=<span class="literal">true</span>,p=i;</span><br><span class="line">            <span class="keyword">while</span>(!(n%p))n/=p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!(n%i)) &#123;</span><br><span class="line">            q=i;</span><br><span class="line">            <span class="keyword">while</span>(!(n%q))n/=q;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)q=n;n=copy;</span><br><span class="line">    pre(),dinic();</span><br><span class="line">    <span class="keyword">if</span>(!sum)<span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-m-sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天全是原题，然而窝几乎都没做过，于是挂了……&lt;/p&gt;
&lt;p&gt;丢人的是考场上组合数的式子 $C[i][j]$=$C[i$-$1][j]$+$C[i$-$1][j$-$1]$ 写成了 $C[i][j]$=$C[i][j$-$1]$+$C[i$-$1][j$-$1]$ ，然后第一题光荣爆 $0​$ ……TAT。&lt;/p&gt;
&lt;p&gt;吸取教训！&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="考试总结" scheme="http://monlights.github.io/tags/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 「网络流24题」最长不下降子序列问题  网络流  luoguP2766</title>
    <link href="http://monlights.github.io/2019/03/26/%5B%E9%A2%98%E8%A7%A3%5DluoguP2766/"/>
    <id>http://monlights.github.io/2019/03/26/[题解]luoguP2766/</id>
    <published>2019-03-25T16:00:00.000Z</published>
    <updated>2019-03-29T05:54:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一问显然是一个很简单的 $DP$ ，但是第二问和第三问就要用最大流来求了，怎么求呢？</p><p>首先我们 $DP$ 出来的 $f$ 数组，$f[i]$ 表示<strong>以i结尾的最长不下降子序列的长度</strong> ，然后就是网络流的连边了。首先因为一个点只能经过两次，我们需要将其拆为入点和出点，中间连的边的边权自然是 $1$ ，然后对于一个 $i$ ，如果 $f[i]$ 等于最长长度($s$)，那么很显然这个 $i$ 就可以给答案做出一个贡献，这个时候 $i$ 的出点向 $t$ 连一条边权为 $1$ 边。</p><a id="more"></a><p>如果 $i$ 等于 $1$ ，那么自然 $1$ 是可以作为一个起点的，那么 $s$ 向 $i$ 的入点连一条边权为 $1$ 的边即可。</p><p>然后就是剩下的情况了，可以想到让 $i$ 向 $i$ 能够最优转移的位置连边，也就是说，如果有一个 $j$ ，使得 $f[j]=f[i]+1$ 并且 $a[i]&lt;=a[j]$ ，这个时候如果是在最优方案中 $i$ 是可以转移到 $j$ 的，这个时候从 $i$ 的出点向 $j$ 的入点连一条边，边权依旧是 $1$ 。</p><p>然后我们这个时候跑最大流，就是第二问的答案。</p><p>那么第三问呢？</p><p>很显然，对于 $1$ ，如果它是连向 $s$ 的，则将其连向 $s$ 的边的边权改为 $inf$ ，并将入点连出点的边权改为 $inf$ ，表示可以取无限次。然后 $n$ 如果连向了 $t$ ，也将边权改为 $inf$ ，并将入点连出点的边权改为 $inf$ ，和上面同理。这个时候再跑一次最大流即可，这就是第三问的答案了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">5e2</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch))<span class="keyword">if</span>(ch==<span class="string">'-'</span>)flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> s,t,head[N],cnt=<span class="number">1</span>,dep[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> nxt,to,val;&#125;G[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        G[++cnt]=&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">        G[++cnt]=&#123;head[v],u,<span class="number">0</span>&#125;,head[v]=cnt;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">        dep[s]=<span class="number">1</span>,q.push(s);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.front(),v;q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt)</span><br><span class="line">                <span class="keyword">if</span>(!dep[v=G[i].to]&amp;&amp;G[i].val&gt;<span class="number">0</span>)</span><br><span class="line">                    dep[v]=dep[u]+<span class="number">1</span>,q.push(v);</span><br><span class="line">        &#125;<span class="keyword">return</span> dep[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flow||u==t) <span class="keyword">return</span> flow;</span><br><span class="line">        <span class="keyword">int</span> used=<span class="number">0</span>,rlow,v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=G[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(dep[v=G[i].to]==dep[u]+<span class="number">1</span>&amp;&amp;G[i].val&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                used+=(rlow=dfs(v,min(G[i].val,flow-used)));</span><br><span class="line">                G[i].val-=rlow,G[i^<span class="number">1</span>].val+=rlow;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(!used) dep[u]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> used;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(bfs()) maxflow+=dfs(s,inf);</span><br><span class="line">        <span class="keyword">return</span> maxflow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Dinic;</span><br><span class="line"><span class="keyword">int</span> n,l,ans,a[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> type,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type*n+x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);s=<span class="number">0</span>,t=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        IN(a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;=a[i]) f[i]=max(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        l=max(l,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,l);<span class="comment">/*Q1*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        add(id(<span class="number">0</span>,i),id(<span class="number">1</span>,i),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(f[i]==<span class="number">1</span>) add(s,id(<span class="number">0</span>,i),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(f[i]==l) add(id(<span class="number">1</span>,i),t,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j) </span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;=a[i]&amp;&amp;f[i]==f[j]+<span class="number">1</span>)add(id(<span class="number">1</span>,j),id(<span class="number">0</span>,i),<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans=dinic();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">/*Q2*/</span></span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">1</span>]==<span class="number">1</span>)add(s,id(<span class="number">0</span>,<span class="number">1</span>),inf),add(id(<span class="number">0</span>,<span class="number">1</span>),id(<span class="number">1</span>,<span class="number">1</span>),inf);</span><br><span class="line">    <span class="keyword">if</span>(f[n]==l)add(id(<span class="number">1</span>,n),t,inf),add(id(<span class="number">0</span>,n),id(<span class="number">1</span>,n),inf);</span><br><span class="line">    ans+=dinic();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">/*Q3*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一问显然是一个很简单的 $DP$ ，但是第二问和第三问就要用最大流来求了，怎么求呢？&lt;/p&gt;
&lt;p&gt;首先我们 $DP$ 出来的 $f$ 数组，$f[i]$ 表示&lt;strong&gt;以i结尾的最长不下降子序列的长度&lt;/strong&gt; ，然后就是网络流的连边了。首先因为一个点只能经过两次，我们需要将其拆为入点和出点，中间连的边的边权自然是 $1$ ，然后对于一个 $i$ ，如果 $f[i]$ 等于最长长度($s$)，那么很显然这个 $i$ 就可以给答案做出一个贡献，这个时候 $i$ 的出点向 $t$ 连一条边权为 $1$ 边。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="网络流" scheme="http://monlights.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 浅谈K-D Tree&amp;学习笔记</title>
    <link href="http://monlights.github.io/2019/03/26/%5B%E7%AE%97%E6%B3%95%5DKD-Tree/"/>
    <id>http://monlights.github.io/2019/03/26/[算法]KD-Tree/</id>
    <published>2019-03-25T16:00:00.000Z</published>
    <updated>2019-03-30T07:17:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>又是一个神奇的数据结构……</p><p>$K$-$D \ Tree$ 中 $D$ 是维度($Dimension$)的缩写，所以 $K$-$D \ Tree$ 的实际意思就是 $K$ 维树。当然 $K$-$D \ Tree $ 一般用于维护二维平面上的信息，所以我们平常用的 $K$-$D\ Tree$  又叫 $2$-$D \ Tree$ 。</p><a id="more"></a><p>假设我们现在有一个二维平面，二维平面上有若干个点 ，现在怎么用 $2​$-$D \ Tree​$ 维护这些点呢？很简单，我们将这些点建成一颗树，最好是一颗二叉搜索树，但是怎么建树呢？我们就来分割这个平面，横着一刀，竖着一刀，每次选取最优的结点当根即可。</p><p>可能很抽象，我们以下图为例，假设我们需要将下图的 $7$ 个点建成二叉搜索树：</p><p><img src="/2019/03/26/[算法]KD-Tree/A.png" alt=""></p><p>首先我们准备竖着切，这个竖着切切哪里呢？我们会发现 $D$ 是最中间的结点，于是我们对着 $D$ 就是一刀，现在的矩阵分割成了两半，那么自然的 $A,B,C$ 就是 $D$ 的左子树中的结点，$E,F,G$ 就是 $D$ 的右子树中的结点。</p><p>然后我们先建 $D$ 的左子树，由于上一次是竖着切的，这一次我们需要横着切。我们递归下去，发现 $A,B,C$ 这一块 $B$ 是最中间的(以横着的视角，因为需要横着切嘛)，那么很显然 $D$ 的左儿子就是 $B$ 了，$A,C$ 分别是 $B$ 的两孩子，由于 $A,C$ 已经在 $B$ 的左右了并且只有一个点了，那么理所当然 $C$ 就是 $B$ 的左孩子，$A$ 就是 $B$ 的右儿子(横着看就好了)。</p><p><img src="/2019/03/26/[算法]KD-Tree/B.png" alt=""></p><p>同样的，我们发现 $G$ 是 $D$ 左边横着切时最合适的结点(因为在横着的视角中 $G$ 是最中间的 )，于是我们将 $D$ 的右儿子定为 $G$ ，同样的，$F,E$ 为 $G$ 的两孩子。</p><p>那么这样子我们的树就建好了。</p><h4 id="Code-build-kdt"><a href="#Code-build-kdt" class="headerlink" title="Code-build-kdt:"></a>Code-build-kdt:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> wd)</span> </span>&#123;<span class="comment">//lr:当前对应的结点区间,wd:当前需要切的方向</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x=new_node(),mid=(l+r)&gt;&gt;<span class="number">1</span>;<span class="comment">//新建结点</span></span><br><span class="line">    WD=wd,nth_element(p+l,p+mid,p+r+<span class="number">1</span>),<span class="comment">//重载了运算符，按照当前切的方向排序</span></span><br><span class="line">    tr[x].tp=p[mid];<span class="comment">//找到最合适切割的最中间的结点</span></span><br><span class="line">    tr[x].l=build(l,mid<span class="number">-1</span>,wd^<span class="number">1</span>);<span class="comment">//建立左子树</span></span><br><span class="line">    tr[x].r=build(mid+<span class="number">1</span>,r,wd^<span class="number">1</span>);<span class="comment">//建立右子树</span></span><br><span class="line">    <span class="keyword">return</span> pushup(x),x;<span class="comment">//上传信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是怎么查询呢？实际上查询跟普通的二叉搜索树差不多，按照方位坐标查找即可。</p><p>对于一个结点的信息是这样的：</p><h4 id="Code-node-kdt"><a href="#Code-node-kdt" class="headerlink" title="Code-node-kdt"></a>Code-node-kdt</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mi[<span class="number">2</span>],mx[<span class="number">2</span>],l,r,sz;</span><br><span class="line">    point tp;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure><p><code>l,r,sz</code> 就是左右儿子以及子树大小，<code>point</code> 显然是该结点代表的二维平面上的点，但是 $mi,mx$ 是干什么的呢？我们用 $mi,mx$ 记录的就是当前结点已经它的子树中的所有节点中，最大/最小的 $x$ 坐标以及最大/最小的 $y$ 坐标。</p><p>这样记录有什么用呢？假设我们将这个看成一个矩形，那么对于一个我们需要搜索的坐标，如果这个需要搜索坐标 已经不属于 $mi,mx$ 围城的矩阵中，那么这个需要搜索的坐标就跟当前子树没关系了，这也就相当于一个剪枝。</p><p>我们的 $pushup$ 上传时就是对 $mi,mx$ 进行更新，所以 $pushup$ 应该这样写：</p><h4 id="Code-pushup-kdt"><a href="#Code-pushup-kdt" class="headerlink" title="Code-pushup-kdt"></a>Code-pushup-kdt</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=tr[x].l,r=tr[x].r;<span class="comment">//简写左右儿子</span></span><br><span class="line">    tr[x].sz=tr[l].sz+tr[r].sz+<span class="number">1</span>;<span class="comment">//更新size</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;++i) &#123;<span class="comment">//枚举方向，节省码量</span></span><br><span class="line">        <span class="comment">/*---------更新mi[x],mx[x]---------*/</span></span><br><span class="line">        tr[x].mi[i]=tr[x].mx[i]=tr[x].tp.x[i];</span><br><span class="line">        <span class="keyword">if</span>(l) &#123;</span><br><span class="line">            tr[x].mi[i]=min(tr[x].mi[i],tr[l].mi[i]);</span><br><span class="line">            tr[x].mx[i]=max(tr[x].mx[i],tr[l].mx[i]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(r) &#123;</span><br><span class="line">            tr[x].mi[i]=min(tr[x].mi[i],tr[r].mi[i]);</span><br><span class="line">            tr[x].mx[i]=max(tr[x].mx[i],tr[r].mx[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*---------更新mi[x],mx[x]---------*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后呢，这里不待修改的，那么如果说要兹磁插入节点怎么办？</p><p>需要兹磁插入节点的题目：<a href="https://www.luogu.org/problemnew/show/P4169" target="_blank" rel="noopener">[Violet]天使玩偶/SJY摆棋子</a> </p><p>这道题因为允许离线，我们可以使用 $CDQ​$ ，但是如果强制在线的话就只能用 $K​$-$D \ Tree​$ 了。我们来讨论 $K​$-$D \ Tree​$ 的做法。</p><p>实际上 $K​$-$D \ Tree​$ 插入节点非常简单，就像普通的二叉搜索树那样找个位置插就好了。</p><h4 id="Code-Insert-kdt"><a href="#Code-Insert-kdt" class="headerlink" title="Code-Insert-kdt"></a>Code-Insert-kdt</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(point tmp,<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> wd)</span> </span>&#123;<span class="comment">//tmp:当前需要插入的点,x:当前树中结点,wd:当前切割方向</span></span><br><span class="line">    <span class="keyword">if</span>(!x) &#123;<span class="comment">//找到要插入的位置了</span></span><br><span class="line">        x=new_node();<span class="comment">//新建结点</span></span><br><span class="line">        tr[x].tp=tmp,tr[x].l=tr[x].r=<span class="number">0</span>;</span><br><span class="line">        pushup(x);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tp.x[wd]&lt;tmp.x[wd]) Insert(tmp,tr[x].r,wd^<span class="number">1</span>);<span class="comment">//应该往右插</span></span><br><span class="line">    <span class="keyword">else</span> Insert(tmp,tr[x].l,wd^<span class="number">1</span>); <span class="comment">//否则往左插</span></span><br><span class="line">    pushup(x);<span class="comment">//更新结点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是呢，你会发现就像一般的二叉搜索树一样，这个插入很容易被卡，卡成一条链，这就很不舒服了。于是我们需要一些平衡树的思想，使得 $K$-$D \ Tree$ 保持平衡。</p><p><strong>“我会 $Splay$ ！我会 无旋$Treap$ ！”</strong></p><p>呸呸呸，今天我们讲的是替罪羊树，跟你俩没关系。</p><p>没错，就是用替罪羊树的思想，将 $K​$-$D \ Tree​$ 拍扁重建。差不多就是 $insert​$ 的时候，在 $insert​$ 的最后 $check​$ 一下子树是否平衡，如果当前结点的子树已经”不平衡”了，那么拍扁该结点以及该结点子树，重建。</p><p>这里的 $\alpha$ 的值一般定为 $0.75$ 左右，但是也不能确定，如果实在要掐得准的话就得看看询问多还是插入多了。不过一般用 $0.75$ 是没问题的。</p><h4 id="Code-check-amp-pia-kdt"><a href="#Code-check-amp-pia-kdt" class="headerlink" title="Code-check&amp;pia-kdt:"></a>Code-check&amp;pia-kdt:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pia</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> num)</span> </span>&#123;<span class="comment">//就是拍扁的意思,sto litble orz</span></span><br><span class="line">    <span class="keyword">if</span>(tr[x].l) pia(tr[x].l,num);<span class="comment">//先拍左子树</span></span><br><span class="line">    p[num+tr[tr[x].l].sz+<span class="number">1</span>]=tr[x].tp,trh[++top]=x;<span class="comment">//再拍自己</span></span><br><span class="line">    <span class="keyword">if</span>(tr[x].r) pia(tr[x].r,num+tr[tr[x].l].sz+<span class="number">1</span>);<span class="comment">//然后拍右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> wd)</span> </span>&#123;<span class="comment">//判断x的子树是否满足"平衡",wd记录当前切割方向,建树的时候有用</span></span><br><span class="line">    <span class="keyword">if</span>(alph*tr[x].sz&lt;tr[tr[x].l].sz||alph*tr[x].sz&lt;tr[tr[x].r].sz)<span class="comment">//判断</span></span><br><span class="line">        pia(x,<span class="number">0</span>),x=build(<span class="number">1</span>,tr[x].sz,wd);<span class="comment">//拍扁 and 重新build建树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是应用了，值得注意的是，如果维护的不是点而是矩形，那么有些地方(例如边界，$mi,mx​$ 都要注意)。</p><p>就像这道题：<a href="https://www.luogu.org/problemnew/show/P4631" target="_blank" rel="noopener">[APIO2018] Circle selection 选圆圈</a>，注意一下细节就好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一个神奇的数据结构……&lt;/p&gt;
&lt;p&gt;$K$-$D \ Tree$ 中 $D$ 是维度($Dimension$)的缩写，所以 $K$-$D \ Tree$ 的实际意思就是 $K$ 维树。当然 $K$-$D \ Tree $ 一般用于维护二维平面上的信息，所以我们平常用的 $K$-$D\ Tree$  又叫 $2$-$D \ Tree$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="算法" scheme="http://monlights.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="学习笔记" scheme="http://monlights.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="K-D Tree" scheme="http://monlights.github.io/tags/K-D-Tree/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SCOI2010]股票交易  单调队列优化DP  luoguP2569</title>
    <link href="http://monlights.github.io/2019/03/24/%5B%E9%A2%98%E8%A7%A3%5DluoguP2569/"/>
    <id>http://monlights.github.io/2019/03/24/[题解]luoguP2569/</id>
    <published>2019-03-23T16:00:00.000Z</published>
    <updated>2019-03-25T07:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们一起来推一推。</p><p>设 $f[i][j]$ 表示：<strong>现在是第 $i$ 天，手上拥有的股票数为 $j$ 时赚到的最多的钱 </strong></p><p>我们考虑转移几个方向：空手买，不买不卖，之前买过了现在继续买，买过后需要卖</p><a id="more"></a><h4 id="空手买"><a href="#空手买" class="headerlink" title="空手买"></a>空手买</h4><p>空手买就是第一次买，显然不要考虑 “间隔 $w$ 天” 的限制，直接买就好。</p><p>那么很容易得到转移式：</p><script type="math/tex; mode=display">f[i][j]= - AP_i\times j</script><p>因为是买入，所以是负数。</p><h4 id="不买不卖"><a href="#不买不卖" class="headerlink" title="不买不卖"></a>不买不卖</h4><p>很显然可以直接从 $f[i-1][j]$ 转移过来。</p><p>转移式：</p><script type="math/tex; mode=display">f[i][j]=f[i-1][j]</script><h4 id="之前买过了现在继续买"><a href="#之前买过了现在继续买" class="headerlink" title="之前买过了现在继续买"></a>之前买过了现在继续买</h4><p>很显然这次我们需要考虑 $w$ 的限制了，不过我们可以直接从 $i-w-1$ 天转移。</p><p>假设我们是从 $f[i-w-1][k]$ 转移过来的，那么这次转移我们多买了 $j-k$ 张股票，容易得到转移式：</p><script type="math/tex; mode=display">f[i][j]=max\{f[i-w-1][k]-(j-k)\times AP_i\}</script><p>当然因为规定了一天最多买入 $AS_i$ 股，上面的式子必须满足 $j-AS_i\leq k \leq j$</p><h4 id="买过之后需要卖"><a href="#买过之后需要卖" class="headerlink" title="买过之后需要卖"></a>买过之后需要卖</h4><p>同样的有 $w$ 的限制，但是跟上面的第三种情况没什么两样，转移式：</p><script type="math/tex; mode=display">f[i][j]=max\{ f[i-w-1][k] + (k-j)\times BP_i\}</script><p>因为 $BS_i$ 的限制条件，上面的式子必须满足 $j\leq k \leq j+BS_i$</p><h4 id="时间复杂度？"><a href="#时间复杂度？" class="headerlink" title="时间复杂度？"></a>时间复杂度？</h4><p>枚举 $i,j$ 状态就需要 $n^2$ 的复杂度，在这个基础上转移的复杂度为：</p><ul><li><strong>空手买</strong> ： $O(1)$ </li><li><strong>不买不卖</strong> ： $O(1)$</li><li><strong>之前买过了现在继续买</strong> ：$O(n)$ </li><li><strong>买过之后需要卖</strong> ：$O(n)$</li></ul><p>会发现如果加上枚举状态的复杂度，后面两个转移的总复杂度为 $O(n^3)$ ！</p><p>于是考虑优化。</p><p> 我们观察第三个转移式：</p><script type="math/tex; mode=display">f[i][j]=max\{f[i-w-1][k]-(j-k)\times AP_i\}</script><p>对于当前的 $i,j$ ，假设有 $a,b$ 作为 $k$ 的两个选项对 $f[i][j]$ 进行转移，我们算一算 $a$ 比 $b$ 优的条件是什么：</p><script type="math/tex; mode=display">f[i][j]=max\{f[i-w-1][k]-(j-k)\times AP_i\}</script><script type="math/tex; mode=display">=max\{f[i-w-1][k]+k\times AP_i-j\times AP_i\}</script><p>这里我们会发现 $j\times AP_i$ 跟里面的式子没有任何关系，提出来不会产生仍和影响</p><script type="math/tex; mode=display">=max\{f[i-w-1][k]+k\times AP_i\}-j\times AP_i​</script><p>于是我们发现我们只需要得到最大的 $f[i-w-1][k]+k\times AP_i$ 就好了，这里我们可以用到<strong>单调队列优化DP</strong> 。</p><p>具体代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=MaxP;++j) &#123;<span class="comment">/*枚举所有的合法的j*/</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;j-AS) ++l;<span class="comment">/*淘汰掉过期的队头*/</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r&amp;&amp;f[i-W<span class="number">-1</span>][q[r]]+q[r]*AP&lt;=f[i-W<span class="number">-1</span>][j]+j*AP) --r;<span class="comment">/*淘汰掉不如当前决策优的队尾*/</span></span><br><span class="line">    q[++r]=j;<span class="comment">/*当前决策进队*/</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=r) f[i][j]=max(f[i][j],f[i-W<span class="number">-1</span>][q[l]]+q[l]*AP-j*AP);<span class="comment">/*转移*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为每一个状态都只进队/出队了一次，所以可以证明时间复杂度现在变为 $O(n^2)$ 了。</p><p>第四个操作一样可以这样优化，可以尝试一下，不贴解释了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,MaxP,W,AP,BP,AS,BS,l,r;</span><br><span class="line"><span class="keyword">int</span> q[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">128</span>,<span class="keyword">sizeof</span>(f));<span class="comment">/*赋极小值*/</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;T,&amp;MaxP,&amp;W);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;AP,&amp;BP,&amp;AS,&amp;BS);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=AS;++j) f[i][j]=-AP*j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=MaxP;++j) f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=W)<span class="keyword">continue</span>;</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=MaxP;++j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;j-AS) ++l;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;f[i-W<span class="number">-1</span>][q[r]]+q[r]*AP&lt;=f[i-W<span class="number">-1</span>][j]+j*AP) --r;</span><br><span class="line">            q[++r]=j;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;=r) f[i][j]=max(f[i][j],f[i-W<span class="number">-1</span>][q[l]]+q[l]*AP-j*AP);</span><br><span class="line">        &#125;</span><br><span class="line">        l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=MaxP;j&gt;=<span class="number">0</span>;--j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;j+BS) ++l;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r&amp;&amp;f[i-W<span class="number">-1</span>][q[r]]+q[r]*BP&lt;=f[i-W<span class="number">-1</span>][j]+j*BP) --r;</span><br><span class="line">            q[++r]=j;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;=r) f[i][j]=max(f[i][j],f[i-W<span class="number">-1</span>][q[l]]+q[l]*BP-j*BP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MaxP;++i)ans=max(ans,f[T][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们一起来推一推。&lt;/p&gt;
&lt;p&gt;设 $f[i][j]$ 表示：&lt;strong&gt;现在是第 $i$ 天，手上拥有的股票数为 $j$ 时赚到的最多的钱 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们考虑转移几个方向：空手买，不买不卖，之前买过了现在继续买，买过后需要卖&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://monlights.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://monlights.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="DP" scheme="http://monlights.github.io/tags/DP/"/>
    
      <category term="单调队列" scheme="http://monlights.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
