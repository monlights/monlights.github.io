<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qiuly&#39;s blog!</title>
  
  <subtitle>A weak OIer from HN-YZ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qiulyblog.github.io/"/>
  <updated>2019-05-07T02:42:18.017Z</updated>
  <id>http://qiulyblog.github.io/</id>
  
  <author>
    <name>Qiuly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【题解】 [HNOI2009]双递增序列  线性DP  luoguP4728</title>
    <link href="http://qiulyblog.github.io/2019/05/07/%5B%E9%A2%98%E8%A7%A3%5DluoguP4728/"/>
    <id>http://qiulyblog.github.io/2019/05/07/[题解]luoguP4728/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-07T02:42:18.017Z</updated>
    
    <content type="html"><![CDATA[<p>其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示<strong>第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立</strong> ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。</p><a id="more"></a><p>考虑设 $dp_{i,j}$ 表示第一个序列的最终位置为 $i-1$ 且长度为 $j$ 时第二个序列的最终位置的最小值。枚举当前数字 $i$ ，然后分两种情况进行转移——将 $a_i$ 放到第一个序列末尾 $\texttt{and}$ 将 $a_i$ 放到第二个序列末尾。</p><p>放到第一个序列末尾很好想：因为当前第一个序列的结尾处就是 $a_{i-1}$ ，比较一下大小直接转移就好了：</p><script type="math/tex; mode=display">dp_{i,j}=min(dp_{i,j},dp_{i-1,j-1}) \ \ \ (a_i>a_{i-1})</script><p>因为第二个序列的末尾没变，所有直接转移就好。</p><p>接下来考虑将第 $i$ 个数放到第二个序列末尾的情况，其实第一个序列和第二个序列没区别，当然除了名字上有一个字的差异，假设第 $i-1$ 个数是第二个序列末尾，当前第一个序列的长度为 $j-1$ ，那么第二个序列的长度因该就是 $(i-1)-(j-1)$ 了，因为我们假设了第 $i-1$ 个数是第二个序列末尾，那么 $dp_{i-1,i-j}$ 又可以被解释为<strong>第二个序列的末尾为 $i-1$ 个数且第二个序列的长度为 $i-j$ 的时候第一个序列的末尾的最小值</strong> ，如果这个最小值小于 $a_i$ ，说明 $a_i$ 可以接到第一个序列前面，那么这个时候第二个序列的末尾为 $a_{i-1}$ ，显然又有转移：</p><script type="math/tex; mode=display">dp_{i,j}=min(dp_{i,j},a_{i-1}) \ \ \ (a_i>dp_{i-1,i-j})</script><p>开始的时候我们将 $dp$ 数组赋成极大值，然后最后判断一下 $dp_{n,n/2}$ 这个状态变小没有就好。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;IN(n);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    a[<span class="number">0</span>]=f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i&amp;&amp;j&lt;=n/<span class="number">2</span>;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i<span class="number">-1</span>]) f[i][j]=min(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;f[i<span class="number">-1</span>][i-j]) f[i][j]=min(f[i][j],a[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> f[n][n/<span class="number">2</span>]&lt;<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">puts</span>(solve()?<span class="string">"Yes!"</span>:<span class="string">"No!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这道题的确很绕……=。=</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示&lt;strong&gt;第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立&lt;/strong&gt; ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HEOI2013]SAO  组合数学+树形DP  luoguP4099</title>
    <link href="http://qiulyblog.github.io/2019/05/06/%5B%E9%A2%98%E8%A7%A3%5DluoguP4099/"/>
    <id>http://qiulyblog.github.io/2019/05/06/[题解]luoguP4099/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-05-06T10:07:38.445Z</updated>
    
    <content type="html"><![CDATA[<p>$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：<a href="https://www.luogu.org/problemnew/show/P4099" target="_blank" rel="noopener">转送门😄</a> 。</p><p>我们先不考虑边的权值(&lt;与&gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&lt;,&gt;) ，我们分类讨论即可。</p><p>首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢<a id="more"></a>，对于一个 $u$ 的儿子 $v$ ，我们虽然知道 $u$ 和 $v$ 的攻克的前后关系，但是合并答案貌似并不好合并。这个时候我们增加一维 $j$ ，$f_{u,j}$ 表示 $u$ 的子树的所有合法拓扑序中 $u$ 在第 $j$ 位上的总状态数。</p><p>也就是说，对于一个必须在 $u$ 前面攻克的关卡 $v$ ，我们考虑枚举一个 $j$ ，$v$ 子树中 $j$ 个结点在合并 $u,v$ 后放到 $u$ 前面，另外 $sz_v-j$ 个放到 $u$ 后面，然后枚举一个 $k$ ，表示当前的 $v$ 排在 $v$ 子树的拓扑序中的第 $k$ 位，只有 $k\leq j$ 的时候 $v$ 才可以转移 $u$ ，因为这个时候 $v$ 在 $u$ 前面。</p><p>现在再来考虑$“$ $j$ 个结点放在 $u$ 前面 $”$ 的方案数和$“$ $sz_v-j$ 个结点放在 $u$ 后面的方案数$”$，这个显然可以用组合数算，合并 $v$ 的子树后，$u$ 的排名从 $i$ 变成了 $i+j$ ，也就是说我们需要将 $j$ 个乱序插入到 $u$ 前面 $i+j-1$ 个数中，方案数显然为 $C_{i+j-1}^{j}$ ，那么现在总节点数显然为 $sz_u+sz_v$ (现在 $sz_u$ 和 $sz_v$ 还没有并在一起) ，$u$ 后面理所当然有 $sz_u+sz_v-i-j$ 个位置，将 $sz_v-j$ 个数插进去的方案数显然为 $C_{sz_u+sz_v-i-j}^{sz_v-j}$ 个，这两个数再乘上 $f_{u,i}$ 和 $f_{v,k}$ 就好了，这一次合并后 $u$ 的位置显然到了 $i+j$ ，所以 $f_{u,i+j}$ 显然要加上这一组贡献。</p><p>经整理后的转移方程如下：</p><script type="math/tex; mode=display">pls(f_{u,i+j},f_{u,i}\cdot f_{v,k}\cdot C_{i+j-1}^{j}\cdot C_{sz_u+sz_v-i-j}^{sz_v-j})</script><p>代码就是这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span> to sz[u]</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span> to sz[v]</span><br><span class="line">        <span class="keyword">for</span> k=<span class="number">1</span> to j</span><br><span class="line">            pls(f[u][i+j],f[u][i]*f[v][k]*C[i+j<span class="number">-1</span>][j]*C[sz[u]+sz[v]-i-j][sz[v]-j])</span><br></pre></td></tr></table></figure><p>这是 $n^3$ 的，过不去。考虑前缀和优化，几下 $f_v$ 的前缀和，最后的一层循环就可以直接丢掉了。</p><p>这个就是 $v$ 要在 $u$ 前面的情况，$u$ 在 $v$ 前面的情况和这个差不多，不过转移的时候 $j$ 就要从 $0$ 开始了，因为那个时候 $u$ 前面是可以不多放任何东西的，还有就是 $u$ 在 $v$ 前面的时候注意 $k\geq j$ 时才可以转移 !</p><p>最后的答案就是 $\sum\limits_{i=1}^{n} f_{1,i}$ 啦。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to,val;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> C[N][N],f[N][N],pre[N][N],suf[N][N],sz[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[v],u,w^<span class="number">1</span>&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;=mod)x-=mod;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[u]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=head[u];l;l=G[l].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[l].to,w=G[l].val;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u);</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">if</span>(w) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=sz[v];++j)</span><br><span class="line">                    pls(g[i+j],<span class="number">1l</span>l*f[u][i]*pre[v][j]%mod*C[i+j<span class="number">-1</span>][j]%mod</span><br><span class="line">                    *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=sz[v];++j)</span><br><span class="line">                    pls(g[i+j],<span class="number">1l</span>l*f[u][i]*suf[v][j+<span class="number">1</span>]%mod*C[i+j<span class="number">-1</span>][j]%mod</span><br><span class="line">                    *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="built_in">memcpy</span>(f[u],g,<span class="keyword">sizeof</span>(g));</span><br><span class="line">    &#125;</span><br><span class="line">    pre[u][<span class="number">0</span>]=suf[u][sz[u]+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i) pre[u][i]=(pre[u][i<span class="number">-1</span>]+f[u][i])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sz[u];i&gt;=<span class="number">1</span>;--i) suf[u][i]=(suf[u][i+<span class="number">1</span>]+f[u][i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head)),cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> n;IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;<span class="keyword">char</span> sign;</span><br><span class="line">        IN(u),sign=getchar(),IN(v);</span><br><span class="line">        add(u+<span class="number">1</span>,v+<span class="number">1</span>,sign==<span class="string">'&lt;'</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) pls(ans,f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*预处理组合数*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N<span class="number">-2</span>;++i) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N<span class="number">-2</span>;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人会问，如果 $u$ 的儿子 $v$ 下面的边全都是 $&gt;$ ，并且 $u$ 连向 $v$ 的边也是 $&gt;$ ，那么这个时候 $v$ 以及其子树的所有点都必须在 $u$ 前面完成，在转移的时候为什么可以 $“$ 提出 $j$ 个结点放到 $u$ 前面 $”$ 呢？</p><p>其实想想就可以明白，在向上统计答案的时候对于一个 $v$ 的儿子 $a$ ，我们只统计了合并后 $a$ 在 $v$ 前面的情况，同样在 $u$ 统计 $v$ 时也只是统计了合并后 $v$ 在 $u$ 前面的情况，所有我们也只是统计了 $“$ $a$ 在 $v$ 前面且 $v$ 在 $u$ 前面 $”$ 的情况，所有被统计的情况一定是合法的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4099&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转送门😄&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;我们先不考虑边的权值(&amp;lt;与&amp;gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&amp;lt;,&amp;gt;) ，我们分类讨论即可。&lt;/p&gt;
&lt;p&gt;首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="树形DP" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】  [HAOI2018]苹果树  组合数学  loj2526</title>
    <link href="http://qiulyblog.github.io/2019/05/05/%5B%E9%A2%98%E8%A7%A3%5Dloj2526/"/>
    <id>http://qiulyblog.github.io/2019/05/05/[题解]loj2526/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-06T05:23:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的题目，可爱的传送门：<a href="https://loj.ac/problem/2526" target="_blank" rel="noopener">戳这呢=￣ω￣=</a></p><p>刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。</p><p>我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。</p><a id="more"></a><p>易知节点数为 $n$ 的二叉树的总形态数为 $n!$ ，而且 $i$ 子树下的所有节点的编号一定要大于 $i$ ，我们考虑”先将 $i$ 子树构造出来再填入节点”的过程，子树的形态数显然为 $j!$ ，然后我们只能选剩下的 $n-i$ 个节点(编号要比 $i$ 大) ，填入剩下的 $j-1$ 个位置( $i$ 占了一个位置) ，显然这样的方案数为 $C_{n-i}^{j-1}$ 。</p><p>这样的一个 $i$ ，其子树大小为 $j$ ，那么它可以做出多少贡献呢？考虑 $fa_i \Rightarrow i$ 这条边会经过多少次，显然是 $j\cdot(n-j)$ 次( $j$ 为子树节点个数，$n-j$ 为上面的节点个数) ，也就是说这样的方案可以造成 $j\cdot (n-j)$ 的贡献。</p><p>那么现在 $i$ 的子树得到确定了，我们将 $i$ 以及其子树看做一个点，我们考虑 $1$ 到 $i$ 这些节点，它们可以以任意形态组成一棵树，方案数是 $i!$ 。</p><p>接着我们需要将剩下的 $n-j-(i-1)$ 个节点挂到树上去。对于第 $i$ 个挂到树上的点，它有 $i$ 个位置可以挂。但是因为 $i$ 一定要占一个位置，所以这个节点只有 $i-1$ 个位置可以挂了，第二个多出来的节点就有 $i$ 个位置可以挂……第 $k$ 个显然有 $i-2+k$ 个位置可以挂。也就是说这些点挂上去的总方案数为 $\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 。</p><p>将上面的乘起来就是这一组 $i,j$ 对答案造成的贡献了：</p><script type="math/tex; mode=display">j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)</script><p>$\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 比较不好计算，但是简单的变化后发现这个是和 $(n-j-1)!/(i-2)!$ 等价的，我们带进原式子。</p><script type="math/tex; mode=display">j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot(n-j-1)!/(i-2)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i\cdot (i-1)\cdot(n-j-1)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot i\cdot (i-1)\cdot (n-j)!</script><p>这样就很好算了，我们预处理组合数和阶乘，上面的式子 $O(1)$ 算~</p><p>代码很短。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,ans,fac[N],C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x+=y;x%=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(p);</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;++j)</span><br><span class="line">            pls(ans,(ll)fac[j]*fac[n-j]%p*C[n-i][j<span class="number">-1</span>]%p*(i*(i<span class="number">-1</span>))%p*j%p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有趣的题目，可爱的传送门：&lt;a href=&quot;https://loj.ac/problem/2526&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳这呢=￣ω￣=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。&lt;/p&gt;
&lt;p&gt;我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [六省联考2017]分手是祝愿  概率DP  loj2145</title>
    <link href="http://qiulyblog.github.io/2019/05/05/%5B%E9%A2%98%E8%A7%A3%5Dloj2145/"/>
    <id>http://qiulyblog.github.io/2019/05/05/[题解]loj2145/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-05T02:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>概率神仙题的传送门：<a href="https://loj.ac/problem/2145" target="_blank" rel="noopener"><del>别戳偏了</del></a></p><p>设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程：</p><script type="math/tex; mode=display">f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})</script><p>因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。</p><a id="more"></a><script type="math/tex; mode=display">f_i=\frac{i}{n}+1\cdot (1+f_i+f_{i+1})-\frac{i}{n}\cdot (1+f_i+f_{i+1})\\\\f_i=\frac{i}{n}+1+f_i+f_{i+1}-\frac{i}{n}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\f_i=1+f_i+f_{i+1}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\\frac{i}{n}f_i=1+f_{i+1}-\frac{i}{n}f_{i+1}\\\\f_i=\frac{1+f_{i+1}-\frac{i}{n}f_{i+1}}{\frac{i}{n}}\\\\f_i=\frac{n\cdot(1+f_{i+1})-i\cdot f_{i+1}}{i}\\\\f_i=\frac{n+(n-i)\cdot f_{i+1}}{i}\\\\f_i=1+\frac{(n-i)\cdot (f_{i+1}+1)}{i}</script><p>预处理逆元就可以直接计算了，记得最后乘上 $n!$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,step,a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,f[N],inv[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    inv[<span class="number">0</span>]=<span class="number">0</span>,inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) inv[i]=(<span class="keyword">long</span> <span class="keyword">long</span>)(p-p/i)*inv[p%i]%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i) g[j].push_back(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) <span class="keyword">if</span>(a[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[i].size();++j) a[g[i][j]]^=<span class="number">1</span>;</span><br><span class="line">        ++step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(step&lt;=k) ans=step;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">1</span>;--i) f[i]=(<span class="number">1l</span>l+(<span class="number">1l</span>l*n-i)*(f[i+<span class="number">1</span>]+<span class="number">1</span>)*inv[i])%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&gt;k;--i) ans=(ans+f[i])%p;</span><br><span class="line">        ans=(ans+k)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans=(<span class="number">1l</span>l*i*ans)%p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;概率神仙题的传送门：&lt;a href=&quot;https://loj.ac/problem/2145&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;del&gt;别戳偏了&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})&lt;/script&gt;&lt;p&gt;因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SCOI2014]方伯伯的玉米田  树状数组优化DP  luoguP3287</title>
    <link href="http://qiulyblog.github.io/2019/05/04/%5B%E9%A2%98%E8%A7%A3%5DluoguP3287/"/>
    <id>http://qiulyblog.github.io/2019/05/04/[题解]luoguP3287/</id>
    <published>2019-05-03T16:00:00.000Z</published>
    <updated>2019-05-05T02:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>以后不要被这种傻逼题给蒙骗了。传送门：<a href="https://www.luogu.org/problemnew/show/P3287" target="_blank" rel="noopener">方伯伯的传送门=。=</a></p><p>首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。</p><p>设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程：</p><a id="more"></a><script type="math/tex; mode=display">f_{i,j}=\max\{f_{k,l}+1\} \ \ (k<i,l\leq j,h_i+j\geq h_k+l)</script><p>可能有人会问为什么 $l\leq j$ ，很显然就是上面的道理，越大的 $i$ 一定拔高次数是单调不减的。</p><p>发现上面的转移其实是 $O(n^2k^2)$ 的，万恶的出题人不会给这个复杂度一丁点分……这个时候用树状数组优化转移，发现上面有三个限制条件，我们正着枚举 $i$ ，就已经满足第一个条件了，因为这个时候树状数组中的都是小于 $i$ 的 $k$ 。然后将每个点按照 $(j+1,h_i+j)$ 放到平面上，然后树状数组统计答案即可。</p><p>树状数组维护的是 $\max$  ，不是和。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],n,k,mx;</span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line">    <span class="keyword">int</span> c[N][<span class="number">5009</span>+K];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">const</span> <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;=mx+k;x+=(x&amp;-x))<span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&lt;=k+<span class="number">1</span>;i+=(i&amp;-i))</span><br><span class="line">                c[x][i]=max(c[x][i],v); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x;x-=(x&amp;-x))<span class="keyword">for</span>(<span class="keyword">int</span> i=y;i;i-=(i&amp;-i))</span><br><span class="line">                ans=max(ans,c[x][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> BIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),mx=max(mx,a[i]);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k;~j;--j) &#123;</span><br><span class="line">            <span class="keyword">int</span> res=query(a[i]+j,j+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            ans=max(ans,res),update(a[i]+j,j+<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以后不要被这种傻逼题给蒙骗了。传送门：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3287&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;方伯伯的传送门=。=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。&lt;/p&gt;
&lt;p&gt;设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="树状数组" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="二维树状数组" scheme="http://qiulyblog.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SHOI2014]概率充电器  概率DP  loj2192</title>
    <link href="http://qiulyblog.github.io/2019/05/02/%5B%E9%A2%98%E8%A7%A3%5Dloj2192/"/>
    <id>http://qiulyblog.github.io/2019/05/02/[题解]loj2192/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-05T02:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>传送门在这：<a href="https://loj.ac/problem/2192" target="_blank" rel="noopener">我是传送门$QwQ$</a></p><p>其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。</p><p>因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。</p><a id="more"></a><p>枚举每一个儿子，对于这个儿子只有两种情况：该儿子没有通上电，该儿子通上电了且传送失败。两种情况的概率都很好算。我们可以列出转移方程：</p><script type="math/tex; mode=display">f_u=(1-q_u)\cdot \prod (f_v+(1-f_v)\cdot(1-G_i.p))</script><p>其中 $(1-q_u)$ 显然为该点本身不通电的概率，然后枚举儿子 $v$ ，$f_v$ 就是该儿子本来就没有通上电的概率，$(1-f_v)\cdot(1-G_i.p)$ 就是通上电的传送失败(注：$G_i.p$ 是当前连接 $u,v$ 的边的通电概率) 。</p><p>那么如何计算父亲传来的电呢？设 $g_i$ 表示点 $i$ 的父亲没有向点 $i$ 通电的概率。计算一下父节点不通电的概率，注意不要计算上该儿子的贡献，不然会乱。计算完不通电的概率后分上面两种情况讨论即可。</p><script type="math/tex; mode=display">res=g_u\cdot f_v / (f_v+(1-f_v)\cdot(1-G_i.p))\\\\g_v=res+(1-res)\cdot(1-G_i.p)</script><p>两边 $dfs$ 就可以搞定。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans,f[N],g[N],q[N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,n,tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to;<span class="keyword">double</span> p;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> p)</span> </span>&#123;G[++cnt]=(Edge)&#123;head[x],y,p&#125;,head[x]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[u]=<span class="number">1</span>-q[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>((v=G[i].to)!=fa)</span><br><span class="line">            dfs1(v,u),f[u]*=(f[v]+(<span class="number">1</span>-f[v])*(<span class="number">1</span>-G[i].p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>((v=G[i].to)!=fa) &#123;</span><br><span class="line">            <span class="keyword">double</span> res=g[u]*f[u]/(f[v]+(<span class="number">1</span>-f[v])*(<span class="number">1</span>-G[i].p));</span><br><span class="line">            g[v]=res+(<span class="number">1</span>-res)*(<span class="number">1</span>-G[i].p);dfs2(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,p;IN(x),IN(y),IN(p);</span><br><span class="line">        add(x,y,p/<span class="number">100.0</span>),add(y,x,p/<span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) IN(x),q[i]=x/<span class="number">100.0</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1.0</span>,dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans+=<span class="number">1</span>-f[i]*g[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门在这：&lt;a href=&quot;https://loj.ac/problem/2192&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我是传送门$QwQ$&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。&lt;/p&gt;
&lt;p&gt;因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2015]寿司晚宴  状压DP  loj2131</title>
    <link href="http://qiulyblog.github.io/2019/05/01/%5B%E9%A2%98%E8%A7%A3%5Dloj2131/"/>
    <id>http://qiulyblog.github.io/2019/05/01/[题解]loj2131/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-05T01:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。</p><p>设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mul=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,s[N];ll p,f[<span class="number">2</span>][mul][mul];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(ll&amp;x,ll&amp;y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;p)x-=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">// freopen("1.out","w",stdout);</span></span><br><span class="line">    IN(n),IN(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;++j)</span><br><span class="line">            <span class="keyword">if</span>(!(i%pri[j])) s[i]|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now=i&amp;<span class="number">1</span>,lst=!now;</span><br><span class="line">        <span class="built_in">memcpy</span>(f[now],f[lst],<span class="keyword">sizeof</span>(f[lst]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;mul;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;mul;++s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[lst][s1][s2]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;s[i])) pls(f[now][s1|s[i]][s2],f[lst][s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;s[i])) pls(f[now][s1][s2|s[i]],f[lst][s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;mul;++s1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;mul;++s2) pls(ans,f[n&amp;<span class="number">1</span>][s1][s2]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以知道 $n\leq 500$ 的时候，每一个数最多带上一个大于等于 $23$ 的质因子。我们首先将所有的寿司分为两类：带了大于等于 $23$ 的质因子的和没带的。</p><p>没带的显然可以向上面那样转移。那么带了的呢？这个显然不能压缩吧。</p><p>我们考虑将带了同样的大于等于 $23$ 的质因子的分成一组，这一组要不小 $\rm{G}$ 吃小 $\rm{W}$ 不吃，要不小 $\rm{W}$ 吃小 $G$ 不吃。分别讨论即可。</p><p>设 $f1[s1][s2]$ 表示这一组是小 $\rm{G}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。同理，设 $f2[s1][s2]$ 表示这一组是小 $\rm{W}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。分别转移就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i) &#123; <span class="comment">/*枚举这些寿司*/</span></span><br><span class="line">    <span class="keyword">if</span>(a[i].t!=a[i<span class="number">-1</span>].t) <span class="comment">/*大质因子不同了*/</span></span><br><span class="line">        <span class="built_in">memcpy</span>(f1,f,<span class="keyword">sizeof</span>(f)),<span class="built_in">memcpy</span>(f2,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">        <span class="comment">/*倒着枚举所以没用滚动数组*/</span></span><br><span class="line">        <span class="comment">/*所谓的分别转移*/</span></span><br><span class="line">        <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]);</span><br><span class="line">        <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这一组结束了，需要合并答案*/</span></span><br><span class="line">    <span class="keyword">if</span>(a[i].t!=a[i+<span class="number">1</span>].t||i==n)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2)</span><br><span class="line">            <span class="comment">/*因为f1[s1][s2]和f2[s1][s2]都重复算了一遍原来的</span></span><br><span class="line"><span class="comment">            f[s1][s2]，所以减掉后再取膜*/</span></span><br><span class="line">            f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">ll p,f[M][M],f1[M][M],f2[M][M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> t,s;&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span> </span>&#123;<span class="keyword">return</span> a.t&lt;b.t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(ll&amp;x,ll&amp;y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;=p)x%=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;IN(n),IN(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        a[i].t=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;++j)<span class="keyword">if</span>(!(i%pri[j])) &#123;</span><br><span class="line">            a[i].s|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>),a[i].t/=pri[j];</span><br><span class="line">            <span class="keyword">while</span>(!(a[i].t%pri[j])) a[i].t/=pri[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    sort(a+<span class="number">2</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[pos].t==<span class="number">1</span>) ++pos;--pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=pos;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f[s1|a[i].s][s2],f[s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f[s1][s2|a[i].s],f[s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].t!=a[i<span class="number">-1</span>].t)</span><br><span class="line">            <span class="built_in">memcpy</span>(f1,f,<span class="keyword">sizeof</span>(f)),<span class="built_in">memcpy</span>(f2,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i].t!=a[i+<span class="number">1</span>].t||i==n)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2)</span><br><span class="line">                f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2) pls(ans,f[s1][s2]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans+p)%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。&lt;/p&gt;
&lt;p&gt;设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状态压缩" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [JSOI2016]灯塔  决策单调性&amp;DP  loj2074</title>
    <link href="http://qiulyblog.github.io/2019/04/30/%5B%E9%A2%98%E8%A7%A3%5Dloj2047/"/>
    <id>http://qiulyblog.github.io/2019/04/30/[题解]loj2047/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2019-05-05T01:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：<a href="https://loj.ac/problem/2074" target="_blank" rel="noopener">在这呢o(￣︶￣)o</a></p><p>刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了：</p><script type="math/tex; mode=display">h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}</script><p>设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续：</p><a id="more"></a><script type="math/tex; mode=display">f_i=\max\{ h_j +\sqrt{|i−j|}\}-h_i</script><p>发现绝对值很烦人，将绝对值拆开。</p><script type="math/tex; mode=display">f_i=\max(\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\},\max\limits_{j=i}^{n}\{h_j +\sqrt{j-i}\})-h_i</script><p>原序列翻转一下就可以直接计算后面的式子，也就是说我们只需要考虑第一个：</p><script type="math/tex; mode=display">f_i=\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\}-h_i</script><p>假设对于 $i$ 来说 $j$ 是最优的决策，那么如果存在一个小于 $j$ 的 $k$ ，是否在转移一个大于 $i$ 的 $l$ 会更优呢？显然不会，可以知道 $i-k$ 显然是大于 $i-j$ 的，而且根号是增长的越来越慢的。所以如果在 $i$ 时 $k$ 就没有 $j$ 优了，那么在以后所以大于 $i$ 的 $l$ 转移时 $k$ 也不可能比 $j$ 优。</p><p>也就是说上面的式子满足决策单调性，那么我们可以 $O(n\log n)$ 愉快求出了。</p><p>这里说明两个方法：</p><ul><li><strong>1.</strong> 单调队列维护三元组，三元组包含 $v$ (决策点 $v$) ，$l$ (决策点 $v$ 作为最优决策点的最左端点) ，$r$ (决策点 $v$ 作为最优决策点的最右端点) ，每一次排除掉最右端点小于 $i$ 的元素(因为该元素已经没用了) ，插入队列的时候去掉完全劣于 $i$ 的，然后对于折中的二分即可。(具体参见诗人小 $\rm{G}$ 的题解) 。</li><li><strong>2.</strong> 分治计算答案。设 $slove(al,ar,vl,vr)$ 表示在原数组 $al$ 到 $ar$ 这段区间的最优决策点位于 $vl$ 到 $vr$ 区间。我们每一次找到 $al$ 到 $ar$ 的中间点，也就是 $mid$ ，然后在 $vl$ 到 $vr$ 寻找最优的决策点更新 $f_{mid}$ ( $\rm{DP}$ 数组)，设这个最优点为 $g$ 。因为满足决策单调性，$al$ 到 $mid-1$ 的所有点的最优决策点一定在 $vl$ 到 $g$ 之间，右边 $mid+1$ 到 $ar$ 的也同理，就这么分治下去即可。</li></ul><p>实际运用中分治的效率不如三元组，但是代码却好写得多，很短，并且调试难度也大大降低，所以最终我选择了分治……分治的具体细节看代码。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;ll a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> f1[N],f2[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f1</span><span class="params">(<span class="keyword">int</span> al,<span class="keyword">int</span> ar,<span class="keyword">int</span> vl,<span class="keyword">int</span> vr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(al&gt;ar) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(al+ar)&gt;&gt;<span class="number">1</span>,g=<span class="number">0</span>;</span><br><span class="line">    f1[mid]=a[mid];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vl;i&lt;=min(vr,mid);++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> calc=a[i]+<span class="built_in">sqrt</span>(<span class="keyword">double</span>(mid-i));</span><br><span class="line">        <span class="keyword">if</span>(calc&gt;f1[mid]) f1[mid]=calc,g=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mid;f1[mid]-=a[mid];</span><br><span class="line">    solve_f1(al,mid<span class="number">-1</span>,vl,g),solve_f1(mid+<span class="number">1</span>,ar,g,vr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f2</span><span class="params">(<span class="keyword">int</span> al,<span class="keyword">int</span> ar,<span class="keyword">int</span> vl,<span class="keyword">int</span> vr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(al&gt;ar) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(al+ar)&gt;&gt;<span class="number">1</span>,g=<span class="number">0</span>;</span><br><span class="line">    f2[mid]=a[mid];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vr;i&gt;=max(vl,mid);--i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> calc=a[i]+<span class="built_in">sqrt</span>(<span class="keyword">double</span>(i-mid));</span><br><span class="line">        <span class="keyword">if</span>(calc&gt;f2[mid]) f2[mid]=calc,g=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mid;f2[mid]-=a[mid];</span><br><span class="line">    solve_f2(al,mid<span class="number">-1</span>,vl,g),solve_f2(mid+<span class="number">1</span>,ar,g,vr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    solve_f1(<span class="number">1</span>,n,<span class="number">1</span>,n),solve_f2(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line">    <span class="comment">/*最终没有翻转序列，而是选择做两遍分治*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ll)<span class="built_in">ceil</span>(max(f1[i],f2[i])));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：&lt;a href=&quot;https://loj.ac/problem/2074&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在这呢o(￣︶￣)o&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}&lt;/script&gt;&lt;p&gt;设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
      <category term="分治" scheme="http://qiulyblog.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2016]国王饮水记  斜率优化DP  loj2087</title>
    <link href="http://qiulyblog.github.io/2019/04/29/%5B%E9%A2%98%E8%A7%A3%5Dloj2087/"/>
    <id>http://qiulyblog.github.io/2019/04/29/[题解]loj2087/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-29T13:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>可爱的题目传送门：<a href="https://loj.ac/problem/2087" target="_blank" rel="noopener">戳我戳我·(<em>╹▽╹</em>)·</a></p><p>说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧……</p><ul><li><strong>1.</strong> 初始水位小于 $h_1$ 的没有用。</li></ul><p>这很显然。</p><a id="more"></a><ul><li><strong>2.</strong> 如果 $n\leq k$ ，那么只需要将所以大于 $h_1$ 的跟 $1$ 城市连就好了。</li></ul><p>每次连接的城市数越少贡献越大，那么每个逐一连一次一定是最优方案。</p><ul><li><strong>3.</strong> 每次操作必然跟 $1$ 城市有关系。</li></ul><p>不然没贡献。</p><ul><li><strong>4.</strong> 除了 $1$ 号城市，其他每个城市最多连一次。</li></ul><p>因为连过一次的城市的水位已经和 $1$ 城市一样了，简单点说肯定就是废了。</p><ul><li><strong>5.</strong> 每次连的所有城市中最小的 $h_i$ 必然大于上一次链接的最大的 $h_i$ 。</li></ul><p>这很显然，不然不满足最优方案。</p><ul><li><strong>6.</strong> 将所以城市按水位排序后，每次选择的必然是连续一段区间。</li></ul><p>和上一个差不多。</p><ul><li><strong>7.</strong> 每次选择的区间必然和上一次的选择区间接触。</li></ul><p>这很显然。</p><ul><li><strong>8.</strong> 每次选择的区间的长度必定单调不增。</li></ul><p>满足最优，都说了每次连接的城市越少贡献越大。</p><hr><p>那么显然就变成了一个区间问题了，我们需要将这个区间分成若干块。</p><p>设 $f_{i,j}$ 表示排序后前 $i$ 个城市联通了 $j$ 次后 $1$ 号城市的最大水位高度。那么转移直接枚举一个 $k$ ，在新的一次连接中连接了 $k+1$ 到 $i$ 这些城市。转移方程显然：</p><script type="math/tex; mode=display">f_{i,j}=\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1}</script><p>*注：$s_i$ 为前缀和。</p><p>上式的复杂度为 $O(n^2k)$  ，肯定爆炸。但是这个是可以<strong>斜率优化</strong>的：</p><script type="math/tex; mode=display">\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1} =\frac{s_i-(s_k-f_{k,j-1})}{i-(k-1)}\Rightarrow \frac{Y(i)-Y(k)}{X(i)-X(k)}</script><p>然后通过第 $8$ 条性质可以得知 $\texttt{DP}$ 是有<strong>决策单调性</strong>的，故复杂度为 $O(nk)$ 。因为恶心的高精度小数的运算还需要 $O(p)$ 的复杂度，所以最终总时间复杂度为 $O(nkp)$ 。</p><p>我们发现 $k$ 有 $10^9$ ，所以复杂度带 $k$ 的一定假掉了。</p><p>那么观察第 $2$ 条性质会发现，如果 $k$ 大于 $n$ 了直接将 $k$ 设为 $n$ 就好了。也就是说复杂度应该为 $O(n^2p)$ ，这样就是 $86$ 分，通过数据来看会发现这个倾向于大众分，一车厢的人都是这个分数。</p><p>那么如果想要 $\texttt{AC}$ 的话需要最后一条很迷的性质：</p><ul><li><strong>9.</strong> 因为 $h$ 各不同，选择的区间最多只有 $14$ 个区间长度大于 $1$ ，其他的区间均等于 $1$ 。</li></ul><p>很迷，准确的说这样的区间是 $O(\log\frac{nh}{\min_i\{h_i-h_{i-1}\}})$ 个。</p><p>证明不会……但是这里写了证明(唯一的且很迷的证明)：<a href="https://github.com/qiulyblog/image/blob/master/[NOI2016]%E5%9B%BD%E7%8E%8B%E9%A5%AE%E6%B0%B4%E8%AE%B0%E9%A2%98%E8%A7%A3.pdf?raw=true" target="_blank" rel="noopener">哈哈我是传送门O(∩_∩)O</a></p><p>那么就丢代码了，实际上是需要高精小数的，这里先给出一个除去高精小数板子的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">8e3</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Decimal ans;</span><br><span class="line"><span class="keyword">int</span> n,k,p,lim,h[N],s[N],pre[N][<span class="number">16</span>],tot;</span><br><span class="line"><span class="keyword">int</span> q[N],head,tail;</span><br><span class="line"><span class="keyword">double</span> f[N][<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span><span class="keyword">double</span> x,y;&#125;t[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(point a,point b)</span> </span>&#123;<span class="keyword">return</span> (a.y-b.y)/(a.x-b.x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Decimal <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!j) <span class="keyword">return</span> h[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> (solve(pre[i][j],j<span class="number">-1</span>)+s[i]-s[pre[i][j]])/(i-pre[i][j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;k,&amp;p,&amp;h[tot=<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;h[i]);</span><br><span class="line">        <span class="keyword">if</span>(h[i]&gt;h[<span class="number">1</span>]) h[++tot]=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    n=tot;sort(&amp;h[<span class="number">1</span>],&amp;h[n+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i][<span class="number">0</span>]=h[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]=s[i<span class="number">-1</span>]+h[i];</span><br><span class="line">    k=min(k,n),lim=min(k,<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lim;++j) &#123;</span><br><span class="line">        q[head=tail=<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t[i]=(point)&#123;i<span class="number">-1</span>,s[i]-f[i][j<span class="number">-1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            point now=(point)&#123;i,s[i]&#125;;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(now,t[q[head]])&lt;slope(now,t[q[head+<span class="number">1</span>]])) ++head;</span><br><span class="line">            f[i][j]=(f[q[head]][j<span class="number">-1</span>]+s[i]-s[q[head]])/(i-q[head]+<span class="number">1</span>);</span><br><span class="line">            pre[i][j]=q[head];</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(t[q[tail]],t[q[tail<span class="number">-1</span>]])&gt;slope(t[q[tail]],t[i])) --tail;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=n-k+lim,pos;</span><br><span class="line">    <span class="keyword">double</span> mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i) </span><br><span class="line">        <span class="keyword">if</span>(f[m][i]&gt;mx) mx=f[m][i],pos=i;</span><br><span class="line">    ans=solve(m,pos);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=n;++i) ans=(ans+h[i])/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans.to_string(p&lt;&lt;<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么高精度小数板子的下载链接就贴这了：<a href="https://loj.ac/problem/2087/download/additional_file" target="_blank" rel="noopener">$loj$ 的下载地址传送们(～￣▽￣)～</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可爱的题目传送门：&lt;a href=&quot;https://loj.ac/problem/2087&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳我戳我·(&lt;em&gt;╹▽╹&lt;/em&gt;)·&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1.&lt;/strong&gt; 初始水位小于 $h_1$ 的没有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这很显然。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 小谈斜率优化</title>
    <link href="http://qiulyblog.github.io/2019/04/28/%5B%E7%AE%97%E6%B3%95%5D%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://qiulyblog.github.io/2019/04/28/[算法]斜率优化/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-05-06T05:42:53.964Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="再此输入你的密码以便阅读全文" />    <label for="pass">再此输入你的密码以便阅读全文</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本文为加密文章，阅读本文需要输入密码。
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="算法" scheme="http://qiulyblog.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2015]亚瑟王  概率DP  loj2112</title>
    <link href="http://qiulyblog.github.io/2019/04/28/%5B%E9%A2%98%E8%A7%A3%5Dloj2112/"/>
    <id>http://qiulyblog.github.io/2019/04/28/[题解]loj2112/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-29T13:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现 <a href="https://loj.ac" target="_blank" rel="noopener">$loj$</a> 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。</p><p>顺便贴一下题目传送门：<a href="https://loj.ac/problem/2112" target="_blank" rel="noopener">$loj$的传送门就戳我啦(～￣▽￣)～</a></p><p>概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。</p><a id="more"></a><p>第一种情况：$j$ 轮中都没有打出第 $i+1$ 张牌，由于一轮中不打出第 $i+1$ 张牌的概率为 $1-p_i$ ，那么 $j$ 轮都不打出该牌的概率显然为 $(1-p_i)^j$ 。转移方程显然：</p><script type="math/tex; mode=display">f_{i+1,j}+=f_{i,j}\cdot (1-p_i)^j​</script><p>因为 $f_{i+1,j}$ 可能从多方向转移过来，所以是 $+=$ 。</p><p>第二种情况：$j$ 轮中至少有一轮打出了第 $i+1$ 张牌，概率显然为 $1-(1-p_i)^j$ ，转移也就很显然了：</p><script type="math/tex; mode=display">f_{i+1,j-1}+=f_{i,j}\cdot （1-(1-p_i)^j）</script><p>如果我们打出了第 $i+1$ 张牌，那么肯定是要计算贡献的，这个时候直接用这个概率算贡献就好了。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,r,d[N];</span><br><span class="line"><span class="keyword">double</span> f[N][N],p[N],pw[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>,&amp;p[i],&amp;d[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            pw[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=r;++j) pw[i][j]=pw[i][j<span class="number">-1</span>]*(<span class="number">1</span>-p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][r]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=r;++j) &#123;</span><br><span class="line">                f[i+<span class="number">1</span>][j]+=f[i][j]*pw[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j) &#123;</span><br><span class="line">                    <span class="keyword">double</span> calc=f[i][j]*(<span class="number">1</span>-pw[i+<span class="number">1</span>][j]);</span><br><span class="line">                    f[i+<span class="number">1</span>][j<span class="number">-1</span>]+=calc,ans+=calc*d[i+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现 &lt;a href=&quot;https://loj.ac&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$loj$&lt;/a&gt; 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。&lt;/p&gt;
&lt;p&gt;顺便贴一下题目传送门：&lt;a href=&quot;https://loj.ac/problem/2112&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$loj$的传送门就戳我啦(～￣▽￣)～&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [CEOI2017]Building Bridges 斜率优化DP loj2483</title>
    <link href="http://qiulyblog.github.io/2019/04/27/%5B%E9%A2%98%E8%A7%A3%5Dloj2483/"/>
    <id>http://qiulyblog.github.io/2019/04/27/[题解]loj2483/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-04-29T13:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>愉快的推式子吧(ﾉ≧∀≦)ﾉ！</p><p>设 $f_i$ 表示前 $i$ 根柱子完工后的最小代价。枚举一个小于 $i$ 的 $j$ ，表示为从 $j$ 向 $i$ 连了一座桥，中间的柱子当然全部推掉，计算一下就好：</p><script type="math/tex; mode=display">f_i=\min\{f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\}</script><p>*其中 $s$ 为 $w$ 的前缀和。</p><a id="more"></a><script type="math/tex; mode=display">f_i=f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\\\\f_i=f_j+s_{i-1}-s_j+h_i^2+h_j^2-2h_ih_j\\\\f_j+s_{i-1}-s_j+h_i^2+h_j^2=2h_ih_j+f_i</script><p>于是最终式子变成了 $y=kx+b$ 的形式，斜率优化！</p><p>但是……注意这个式子的 $k$ 不是单调递增的，并且 $x$ 也不是单调递增的！那么我们不能用朴素做法了，也不能用二分……难道用 $Splay$ ？(码量巨大) 。</p><p>不，用 $CDQ$ 分治。</p><p>对于一个 $i$ ，可能可以对 $i$ 做出贡献的只有所有小于 $i$ 的 $j$ 。为了保证 $x$ 单调我们先大力将原来的数组按照 $x$ 从小到大排个序，然后 $CDQ$ 的时候分左右两边，左边的所有元素在初始数组的位置都小于右边的左右元素，也就是说我们直接用左边元素对右边元素做出贡献。</p><p>同时这里也保证了左右两边的 $x$ 一定是单调上增的。</p><p>我们使用单调队列，扫一遍左边的元素，留下能做贡献的点(下凸壳上的点)，这时候左边的所有元素可以保证 $x$ 和斜率都是单调上增的。</p><p>右边呢？因为直线的斜率是 $2x$ ，而右边的 $x$ 也是单调上增的，所以我们可以愉快的做朴素的单调队列了。</p><p>$CDQ$ 分治部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;<span class="comment">/*一个点的时候直接计算y值*/</span></span><br><span class="line">        a[l].y=f[a[l].id]-s[a[l].id]+S(a[l].x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(a[i].id&lt;=mid) b[c1++]=a[i]; <span class="comment">/*编号小的左边去*/</span></span><br><span class="line">        <span class="keyword">else</span> b[c2++]=a[i]; <span class="comment">/*编号大些的右边去*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    CDQ(l,mid); <span class="comment">/*计算出左边所有元素的 f*/</span></span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i) &#123; <span class="comment">/*处理出左边所有元素组成的下凸壳*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail<span class="number">-1</span>],q[tail])&gt;slope(q[tail],i)) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;++i) &#123; <span class="comment">/*计算左边元素对右边元素产生的贡献*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*a[i].x) ++head; <span class="comment">/*维护队列*/</span></span><br><span class="line">        <span class="keyword">int</span> x=a[i].id,y=a[q[head]].id;</span><br><span class="line">        f[x]=min(f[x],f[y]+s[x<span class="number">-1</span>]-s[y]+S(a[i].x-a[q[head]].x));</span><br><span class="line">        <span class="comment">/*可能计算多次所以要取min*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i)  <span class="comment">/*还原a数组至初始状态*/</span></span><br><span class="line">        <span class="keyword">if</span>(c2&gt;r||(c1&lt;=mid&amp;&amp;a[c1].x&lt;a[c2].x)) b[i]=a[c1++];</span><br><span class="line">        <span class="keyword">else</span> b[i]=a[c2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数中</span></span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp),CDQ(<span class="number">1</span>,n); <span class="comment">/*排序后CDQ开始*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]); <span class="comment">/*输出*/</span></span><br></pre></td></tr></table></figure><p>最后因为存在 $0$ ，在计算斜率的时候需要特判一下。还需要注意一下 $long\ long$ 的问题，记得将 $f$ 数组初始化。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e18</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span><span class="keyword">int</span> x,id;ll y;&#125;a[N],b[N];</span><br><span class="line">ll s[N],w[N],f[N];<span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point x,point y)</span> </span>&#123;<span class="keyword">return</span> x.x&lt;y.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i].x==a[j].x) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[i].y&lt;a[j].y?inf:-inf;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="keyword">double</span>(a[i].y-a[j].y)/<span class="keyword">double</span>(a[i].x-a[j].x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;a[l].y=f[a[l].id]-s[a[l].id]+S(a[l].x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(a[i].id&lt;=mid) b[c1++]=a[i];</span><br><span class="line">        <span class="keyword">else</span> b[c2++]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    CDQ(l,mid);</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail<span class="number">-1</span>],q[tail])&gt;slope(q[tail],i)) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*a[i].x) ++head;</span><br><span class="line">        <span class="keyword">int</span> x=a[i].id,y=a[q[head]].id;</span><br><span class="line">        f[x]=min(f[x],f[y]+s[x<span class="number">-1</span>]-s[y]+S(a[i].x-a[q[head]].x));</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(c2&gt;r||(c1&lt;=mid&amp;&amp;a[c1].x&lt;a[c2].x)) b[i]=a[c1++];</span><br><span class="line">        <span class="keyword">else</span> b[i]=a[c2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        IN(a[i].x),a[i].id=i,f[i]=inf;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(w[i]),s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp),CDQ(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;愉快的推式子吧(ﾉ≧∀≦)ﾉ！&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示前 $i$ 根柱子完工后的最小代价。枚举一个小于 $i$ 的 $j$ ，表示为从 $j$ 向 $i$ 连了一座桥，中间的柱子当然全部推掉，计算一下就好：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\min\{f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\}&lt;/script&gt;&lt;p&gt;*其中 $s$ 为 $w$ 的前缀和。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [APIO2010]特别行动队  斜率优化DP  luoguP3628</title>
    <link href="http://qiulyblog.github.io/2019/04/24/%5B%E9%A2%98%E8%A7%A3%5DluoguP3628/"/>
    <id>http://qiulyblog.github.io/2019/04/24/[题解]luoguP3628/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-28T05:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>依旧是斜率优化的套路。</p><p>设 $f_i$ 表示前 $i$ 个士兵的最大贡献，转移显然是枚举一个 $j$ ，将 $j+1$ 到 $i$ 这些士兵组成特别行动队算贡献：</p><script type="math/tex; mode=display">f_i=\max\{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c\}​</script><p>其中 $s_i$ 为战斗力的前缀和。这个方程是 $O(n^2)$ 的，需要优化。发现这个转移式貌似不满足单调队列优化的条件，于是将中间的式子拆开看看可不可以斜率优化。</p><a id="more"></a><script type="math/tex; mode=display">f_i=\max\{f_j+a(s_i^2+s_j^2-2s_is_j)+b\cdot s_i-b\cdot s_j+c\}\\f_i=\max\{f_j+a\cdot s_i^2+a\cdot s_j^2-2a\cdot s_is_j)+b\cdot s_i-b\cdot s_j+c\}\\f_i=f_j+a\cdot s_i^2+a\cdot s_j^2-2a\cdot s_is_j+b\cdot s_i-b\cdot s_j+c\\f_j+a\cdot s_i^2+a\cdot s_j^2+b\cdot s_i-b\cdot s_j+c=2a\cdot s_i\cdot s_j +f_i​</script><p>诶，是 $y=kx+b$ 的形式，而且满足斜率优化的条件诶。继续将 $x,y$ 找出来放到坐标系上( $x=s_j$,$y=f_j+a\cdot s_j^2-b\cdot s_j$) 。</p><p>因为是 $\max​$ ，所以用单调队列维护一下上凸壳然后转移即可，复杂度 $O(n)​$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,head,tail;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[N],f[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> s[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]+<span class="number">1l</span>l*S(s[i])*a<span class="number">-1l</span>l*s[i]*b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> (Y(j)-Y(i))/(X(j)-X(i));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    f[i]=f[j]+<span class="number">1l</span>l*S(s[i]-s[j])*a+<span class="number">1l</span>l*(s[i]-s[j])*b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(a),IN(b),IN(c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(s[i]),s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&gt;<span class="number">2</span>*a*s[i]) ++head;</span><br><span class="line">        calc(i,q[head]);</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail],i)&gt;slope(q[tail],q[tail<span class="number">-1</span>])) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依旧是斜率优化的套路。&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示前 $i$ 个士兵的最大贡献，转移显然是枚举一个 $j$ ，将 $j+1$ 到 $i$ 这些士兵组成特别行动队算贡献：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\max\{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c\}​&lt;/script&gt;&lt;p&gt;其中 $s_i$ 为战斗力的前缀和。这个方程是 $O(n^2)$ 的，需要优化。发现这个转移式貌似不满足单调队列优化的条件，于是将中间的式子拆开看看可不可以斜率优化。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2008]玩具装箱TOY  斜率优化DP  luoguP3195</title>
    <link href="http://qiulyblog.github.io/2019/04/24/%5B%E9%A2%98%E8%A7%A3%5DluoguP3195/"/>
    <id>http://qiulyblog.github.io/2019/04/24/[题解]luoguP3195/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-28T05:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>差不多搞懂了斜率优化吧……说实话网上的文章都写得很迷，还好找到了一个不错的文章：<a href="https://www.cnblogs.com/yangsongyi/p/9630227.html" target="_blank" rel="noopener">转送门戳我(￣▽￣)~*</a> 。(为什么突然发现这道题和诗人小G很像呢) </p><p>这个 $\texttt{DP}$ 方程谁都会设：设 $f_i$ 表示前 $i$ 个玩具的最小费用，转移显然如下：</p><script type="math/tex; mode=display">f_i=\min\limits_{j=1}^{i-1}\{f_j+(sum_i-sum_j+i-j-l)^2\}</script><p>(其中 $sum$ 是前缀和)。这个复杂度是 $O(n^2)$ 的，过不去……</p><a id="more"></a><p>继续推式子：</p><script type="math/tex; mode=display">f_i=\min\limits_{j=1}^{i-1}\{f_j+[(sum_i+i)-(sum_j+j)-l]^2\}</script><p>设 $s_i=sum_i+i$ ，我们假设 $j$ 为最优决策，将 $\min$ 去掉。</p><script type="math/tex; mode=display">f_i=f_j+(s_i-s_j-l)^2\\f_i=f_j+s_i^2+(s_j+l)^2-2\cdot s_i\cdot(s_j+l)\\f_j+s_i^2+(s_j+l)^2=2\cdot s_i\cdot(s_j+l)+f_i​</script><p>于是上面的式子变成了 $y=kx+b$ 的形式，其中 $y=f_j+s_i^2+(s_j+l)^2$ ，$k=2\cdot s_i$ ，$x=s_j+l$ ，$b=f_i$ 。</p><p>然后将 $x,y$ 两个值作为点 $(x,y)$ 放到平面上即可，因为最终答案是取 $min$ ，所以我们需要维护的是下凸壳。有一点需要注意的是，我们算斜率的时候可以将每个点的常数项或者只和 $i$ 有关的项去掉，因为算斜率是相减的，减的时候这些项同样也没了。</p><p>上面的 $x$ 中的 $l$ 是常数项于是可以省略，$y$ 中的 $s_i^2$ 只和 $i$ 有关，于是也省略掉。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,l,head,tail;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N],s[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> s[i];&#125;<span class="comment">/*每个点的x坐标*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]+S(s[i]+l);&#125;<span class="comment">/*每个点的y坐标*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> (Y(j)-Y(i))/(X(j)-X(i));&#125;<span class="comment">/*算斜率*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;s[i]),s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]+=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*s[i]) ++head;</span><br><span class="line">        f[i]=f[q[head]]+S(s[i]-s[q[head]]-l<span class="number">-1</span>);<span class="comment">/*转移*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail],i)&lt;slope(q[tail],q[tail<span class="number">-1</span>])) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来解释一些问题。</p><h3 id="1-为什么要维护下凸壳"><a href="#1-为什么要维护下凸壳" class="headerlink" title="1.为什么要维护下凸壳"></a>1.为什么要维护下凸壳</h3><p>因为我们的 $\texttt{DP}$ 方程是在取 $\min$ ，如果是 $\max$ 的话则维护上凸壳。而且维护下凸壳显然是让 $f_i$ 更小。</p><p>以上面为例，我们用 $y=kx+b​$ 的直线从下面网上扫，注意这条直线的斜率就是 $k​$ 。很显然如果我们从下往上这样扫越往上扫 $b​$ 越大(不明白的画画图)，但是我们的目的是使得 $b​$ 最小( $b​$ 就是 $f_i​$ ) 。下凸壳包含了最下面的所有点，显然不是下凸壳上的点一定不能成为最优的。</p><h3 id="2-维护队列的过程是什么鬼操作"><a href="#2-维护队列的过程是什么鬼操作" class="headerlink" title="2.维护队列的过程是什么鬼操作"></a>2.维护队列的过程是什么鬼操作</h3><p>首先第一个过程，也就是下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*s[i]) ++head;</span><br></pre></td></tr></table></figure><p>上面讲了我们需要使得 $b​$ 最小，那么最优的决策点在直线从下往上扫的过程中肯定是最先扫到的，因为那样可以保证 $f_i​$ 最小。假设最优的点为 $i​$ ，上一个点为 $j​$ ，下一个点为 $k​$ ，那么 $i​$ 一定保证 $j​$ 到 $i​$ 的斜率小于直线斜率并且 $i​$ 到 $k​$ 的斜率大于直线斜率。</p><p>然后我们会发现对于单调上增的需要更新的 $i​$ ，其直线的斜率 $k​$ 一定是单调上增的，因为前缀和是单调上增的。</p><p>所以对于斜率已经不满足要求的点直接踢出队就好了。</p><p>然后康康出队的过程。如果在纸上画画会发现，如果满足 <code>slope(q[tail],i)&lt;slope(q[tail],q[tail-1])</code> ，那么说明 $q[tail]$ 已经不再下凸壳中了！没错吧？那么这个时候 $q[tail]$ 永远也不可能成为最优的转移点了，直接丢掉即可。</p><hr><p>最后有一些斜率优化的套路总结(自己总结出来的)：</p><ul><li>$\texttt{DP}$ 方程取 $\min$ 就维护下凸壳，取 $\max$ 就维护上凸壳</li><li>$y=kx+b​$ 中的 $k​$ 一定要是常量或者是完全是 $i​$ 的量(例如 $s_i,2\cdot g_i^2​$ 等)，$b​$ 一定是你需要转移的对象(就是 $f_i​$ )，$x​$ 和 $y​$ 两个值一定要包含和 $j​$ 有关的值，要随 $j​$ 的变化而变化。</li><li>提炼出来的 $x,y$ 放到坐标系上之前记得去掉没用的值。</li></ul><p>差不多就这些吧，也不知道是不是完全正确，至少这个套路还是过了几道题目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;差不多搞懂了斜率优化吧……说实话网上的文章都写得很迷，还好找到了一个不错的文章：&lt;a href=&quot;https://www.cnblogs.com/yangsongyi/p/9630227.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转送门戳我(￣▽￣)~*&lt;/a&gt; 。(为什么突然发现这道题和诗人小G很像呢) &lt;/p&gt;
&lt;p&gt;这个 $\texttt{DP}$ 方程谁都会设：设 $f_i$ 表示前 $i$ 个玩具的最小费用，转移显然如下：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\min\limits_{j=1}^{i-1}\{f_j+(sum_i-sum_j+i-j-l)^2\}&lt;/script&gt;&lt;p&gt;(其中 $sum$ 是前缀和)。这个复杂度是 $O(n^2)$ 的，过不去……&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SCOI2008]奖励关  状压DP  luoguP2473</title>
    <link href="http://qiulyblog.github.io/2019/04/23/%5B%E9%A2%98%E8%A7%A3%5DluoguP2473/"/>
    <id>http://qiulyblog.github.io/2019/04/23/[题解]luoguP2473/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-04-24T07:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现数据范围很小，并且涉及到”集合”，很容易可以想到用状压 $\texttt{DP}$ 。</p><p>设 $f[i][j]$ 表示已经抛出了 $i$ 次宝物，获得的宝物集合为 $j$ 时的最优分值。那么转移的时候枚举每一个宝物，分两种情况即可——选当前宝物或者不选。注意选当前宝物的前提是必须满足前提，按照最优情况选取即可。注意最后将所有的宝物的贡献加上后还需要$/n$ ，因为题目要求的是”平均”。</p><a id="more"></a><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">101</span>][<span class="number">65540</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">18</span>],d[<span class="number">18</span>],v[<span class="number">18</span>],N,K;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;++i) p[i]=<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;K,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(x) &#123;d[i]|=p[x];<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=K;i;--i) <span class="comment">/*倒着枚举会好些*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=p[N+<span class="number">1</span>]<span class="number">-1</span>;++j) &#123;</span><br><span class="line">            <span class="comment">/*上面两重循环枚举状态*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;++k)<span class="comment">/*枚举所有宝物并计算贡献*/</span></span><br><span class="line">                <span class="keyword">if</span>((d[k]&amp;j)==d[k]) <span class="comment">/*可以选取当前宝物*/</span></span><br><span class="line">                    f[i][j]+=max(f[i+<span class="number">1</span>][j],f[i+<span class="number">1</span>][j|p[k]]+v[k]);</span><br><span class="line">                    <span class="comment">/*按照最优选取*/</span></span><br><span class="line">                <span class="keyword">else</span> f[i][j]+=f[i+<span class="number">1</span>][j]; <span class="comment">/*不能选取直接转移*/</span></span><br><span class="line">            f[i][j]/=N;<span class="comment">/*所谓"平均"*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,f[<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">/*最终答案*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现数据范围很小，并且涉及到”集合”，很容易可以想到用状压 $\texttt{DP}$ 。&lt;/p&gt;
&lt;p&gt;设 $f[i][j]$ 表示已经抛出了 $i$ 次宝物，获得的宝物集合为 $j$ 时的最优分值。那么转移的时候枚举每一个宝物，分两种情况即可——选当前宝物或者不选。注意选当前宝物的前提是必须满足前提，按照最优情况选取即可。注意最后将所有的宝物的贡献加上后还需要$/n$ ，因为题目要求的是”平均”。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状压DP" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2011]Noi嘉年华  决策单调性优化DP  luoguP1973</title>
    <link href="http://qiulyblog.github.io/2019/04/22/%5B%E9%A2%98%E8%A7%A3%5DluoguP1973/"/>
    <id>http://qiulyblog.github.io/2019/04/22/[题解]luoguP1973/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-23T00:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题一共有两问，第一问瞎搞 $\texttt{DP}$ ，第二问如果直接 $\texttt{DP}$ 的话复杂度是 $O(n^4)$ 的过不去，这个时候需要用到决策单调性优化复杂度就可以降低至 $O(n^3)$ ，这样就过了。我们先来讨论一下第一问的做法。</p><p>时间的范围太大了，我们需要离散化一下。离散化后时间就控制在 $0$ 到 $2n$ 的范围内了。</p><p>首先可以发现最终的答案一定就是一段一段时间，每一段时间内的活动都是在同一个会场举行。我们可以预处理一个 $tot_{l,r}$ 表示完全在时间 $l,r$ 之内的活动有多少个。计算直接暴力，预处理的复杂度为 $O(n^3)$ 。</p><a id="more"></a><p>然后设一个 $pre_{i,j}​$ 表示 <strong>$1​$ 到 $i​$ 的时间一个会场的活动数为 $j​$ 时另一个会场的最大活动数</strong>。那么转移的话我们枚举一个时间 $k​$ ，然后考虑 $k​$ 到 $i​$ 这段时间中的所有活动分配给哪个会场即可。可以得到转移方程：</p><script type="math/tex; mode=display">pre_{i,j}=\max\limits_{k=1}^{i}\{pre_{k,j}+tot_{k,i},pre_{k,j-tot_{k,i}}\}​</script><p>这里我们 $pre$ 方程的定义中”一个会场”就是一号会场，”另一个会场”就是二号会场$。pre_{k,j}+tot_{k,i}$ 就是将 $k$ 到 $i$ 这段时间中所有活动都分配给了二号会场，$pre_{k,j-tot_{k,i}}$ 很显然就是分配给了一号会场。计算时枚举 $i,j,k$ ，复杂度是 $O(n^3)$ 。(其实准确的复杂度带个常数，因为 $i$ 枚举的是时间，而时间最大是 $2n$ 的) 。</p><p>我们设离散化后时间总长为 $m$ ，那么答案显然为 $\max\limits_{i=1}^m\{\min(pre_{m,i},i)\}$ 。接下来我们解决第二问。</p><p>我们的 $tot_{l,r}$ 统计的就是完全在时间 $l,r$ 的区间有多少个。那么对于第 $i$ 个活动，设该活动的起始时间与终止时间分别为 $s_i,t_i$ ，那么我们再考虑一对 $x,y \ \ (x\leq s_i,t_i\leq y)$ ，那么如果我们将答案计算上 $tot_{x,y}$ ，那么也就选择了第 $i$ 个活动了。</p><p>我们设 $f_{i,j}$ 表示一号会场强制选择 $i$ 到 $j$ 时间中的所有活动时的最优答案。(注意这里的最优答案就是两个会场中活动少的一方的最大值，我们只是考虑在一号会场<strong>强制选择</strong> $i$ 到 $j​$ 中的所有活动的情况下考虑最优的全局答案) 。</p><p>继续看向一号会场，假设在 $i$ 前面的时间中一号会场已经合法举办了 $x$ 场活动，在 $j$ 后面的时间中也合法举办了 $y$ 场活动。那么我们枚举 $i,j,x,y$ 也可以得到二号会场的活动数：$i$ 前面的时间种有 $pre_{i,x}$ 场活动，$j$ 后面的时间中有……诶这里用 $pre$ 貌似不是很好表示诶，于是我们新定义一个 $suf$ ，$suf_{i,j}$ 表示 <strong>$i$ 到 $m$ 的时间一个会场的活动数为 $j$ 时另一个会场的最大活动数</strong>，$suf$ 的状态转移方程和 $pre$ 的同理。</p><p>枚举 $i,j,x,y$ 后就可以得到两个会场的活动个数，那么就可以直接算答案了：</p><script type="math/tex; mode=display">f_{i,j}=\max\limits_{x=1}^{m}\max\limits_{y=1}^{m}\{\min(x+tot_{i,j}+y,pre_{i,x}+suf_{j,y})\}​</script><p>但是这样子的复杂度是 $O(n^4)​$ 的，过不了。</p><p>不过，我们会发现，<strong>对于单调递增的 $x$ ，对应的最优的 $y$ 一定是单调递减的</strong> 。为什么呢？首先对于一个单调递增的 $i$ ，$pre_{?_i},suf_{?_i}$ 一定是单调递减的( $?$ 为任意数) 。那么如果对于单调递增的 $x$ ，$pre_{i,x}$ 一定是单调递减的，这个时候如果 $y$ 单调递增也就意味着 $suf_{j,y}$ 会单调递减，那么 $x+tot_{i,j}+y$ 和 $pre_{i,x}+suf_{j,y}$ 将会越拉越大，对于答案显然是不利的。反过来，如果 $y$ 是单调递减的，那么就会相对比较均衡。(感性理解理解……)</p><p>那么我们就不需要枚举 $y$ 了，只需要扫一扫就好了，最终计算 $f$ 的时间复杂度为 $O(n^3)$ 。</p><p>最终统计答案的时候，对于一个活动 $i$ ，我们的答案显然为 $\max\limits_{x=1}^{s_i}\max\limits_{y=t_i}^{m}f_{x,y}$ 。必须满足 $x\leq s_i,t_i\leq y$ ，因为这样就会满足一定会选择第 $i$ 个活动。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,j,k) for((i)=(j);(i)&lt;=(k);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(i,j,k) for((i)=(j);(i)&gt;=(k);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e2</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,i,j,k,l,r,s[N],t[N],b[N];</span><br><span class="line"><span class="keyword">int</span> tot[N][N],pre[N][N],suf[N][N],f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> min(x+tot[l][r]+y,pre[l][x]+suf[r][y]);&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=IN();</span><br><span class="line">    F(i,<span class="number">1</span>,n) b[++m]=s[i]=IN(),b[++m]=t[i]=IN()+s[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+m),</span><br><span class="line">    m=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+m)-b<span class="number">-1</span>;<span class="comment">/*离散化去重*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        s[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,s[i])-b;</span><br><span class="line">        t[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,t[i])-b;</span><br><span class="line">        F(l,<span class="number">1</span>,s[i]) R(r,m,t[i]) ++tot[l][r];<span class="comment">/*计算出tot*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    F(i,<span class="number">1</span>,m) F(j,<span class="number">1</span>,n) pre[i][j]=suf[i][j]=-inf;<span class="comment">/*初始化*/</span> </span><br><span class="line">    <span class="comment">/*----------计算出pre和suf----------*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,m) F(j,<span class="number">0</span>,tot[<span class="number">1</span>][i]) F(k,<span class="number">1</span>,i) &#123;</span><br><span class="line">        pre[i][j]=max(pre[i][j],pre[k][j]+tot[k][i]);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=tot[k][i]) pre[i][j]=max(pre[i][j],pre[k][j-tot[k][i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    R(i,m,<span class="number">1</span>) F(j,<span class="number">0</span>,tot[i][m]) F(k,i,m) &#123;</span><br><span class="line">        suf[i][j]=max(suf[i][j],suf[k][j]+tot[i][k]);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=tot[i][k]) suf[i][j]=max(suf[i][j],suf[k][j-tot[i][k]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*计算f*/</span></span><br><span class="line">    F(l,<span class="number">1</span>,m) F(r,l+<span class="number">1</span>,m) <span class="keyword">for</span>(<span class="keyword">int</span> y=n,x=<span class="number">0</span>;x&lt;=n;++x) &#123;<span class="comment">/*y当做指针扫一遍*/</span></span><br><span class="line">        <span class="keyword">int</span> old_calc=calc(x,y),new_calc;</span><br><span class="line">        <span class="keyword">while</span>(y&amp;&amp;old_calc&lt;=(new_calc=calc(x,y<span class="number">-1</span>))) --y,old_calc=new_calc;</span><br><span class="line">        f[l][r]=max(f[l][r],calc(x,y));<span class="comment">/*转移*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*输出答案*/</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    F(i,<span class="number">1</span>,n) ans=max(ans,min(pre[m][i],i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">/*第一问*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        F(l,<span class="number">1</span>,s[i]) R(r,m,t[i]) ans=max(ans,f[l][r]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">/*第二问*/</span></span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题一共有两问，第一问瞎搞 $\texttt{DP}$ ，第二问如果直接 $\texttt{DP}$ 的话复杂度是 $O(n^4)$ 的过不去，这个时候需要用到决策单调性优化复杂度就可以降低至 $O(n^3)$ ，这样就过了。我们先来讨论一下第一问的做法。&lt;/p&gt;
&lt;p&gt;时间的范围太大了，我们需要离散化一下。离散化后时间就控制在 $0$ 到 $2n$ 的范围内了。&lt;/p&gt;
&lt;p&gt;首先可以发现最终的答案一定就是一段一段时间，每一段时间内的活动都是在同一个会场举行。我们可以预处理一个 $tot_{l,r}$ 表示完全在时间 $l,r$ 之内的活动有多少个。计算直接暴力，预处理的复杂度为 $O(n^3)$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [十二省联考2019]异或粽子  可持久化Trie树  luoguP5283</title>
    <link href="http://qiulyblog.github.io/2019/04/19/%5B%E9%A2%98%E8%A7%A3%5DluoguP5283/"/>
    <id>http://qiulyblog.github.io/2019/04/19/[题解]luoguP5283/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T11:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>要是我不是 $\texttt{HN}​$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……</p><p>[十二省联考2019]异或粽子，可持久化 $trie​$ 树的板子题，比最大异或和还要板子些。相信 $60​$ 分入门者都会做，那么 $100​$ 分的话我们上可持久化 $trie​$ 树维护前缀异或和，嗯没错就像主席树那样。然后对于每个节点的可持久化 $trie​$ 树我们将其当成区间右端点，然后在此位置上的 $trie​$ 树中贪心寻找左端点即可。</p><a id="more"></a><p>寻找前 $K$ 大区间的具体操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">    q.push(MKP(T.query(T.root[i],sum[i],qrank[i]=<span class="number">1</span>),i));</span><br><span class="line"><span class="comment">/*对于每一个右端点，找一个第一大(最优)的左端点放入优先队列*/</span></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(k--) &#123;</span><br><span class="line">    ll i=q.top().second;<span class="comment">/*取出当前最优元素*/</span></span><br><span class="line">    ans+=q.top().first;q.pop();</span><br><span class="line">    <span class="keyword">if</span>(qrank[i]!=i) q.push(MKP(T.query(T.root[i],sum[i],++qrank[i]),i));</span><br><span class="line">    <span class="comment">/*更新队列元素*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度大约是 $O(nlogn)​$ 级别。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKP make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll logN=<span class="number">33</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n,k,sum[N],qrank[N];</span><br><span class="line">priority_queue&lt;pair&lt;ll,ll&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    ll ch[N*logN][<span class="number">2</span>],sum[N*logN],root[N],tot;</span><br><span class="line">    <span class="function">ll <span class="title">newnode</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        ++tot,ch[tot][<span class="number">0</span>]=ch[x][<span class="number">0</span>],ch[tot][<span class="number">1</span>]=ch[x][<span class="number">1</span>];</span><br><span class="line">        sum[tot]=sum[x];<span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll&amp;rt,ll val)</span> </span>&#123;</span><br><span class="line">        rt=newnode(rt),++sum[rt];</span><br><span class="line">        ll now=rt;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">31</span>;~i;--i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> son=(val&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">            ch[now][son]=newnode(ch[now][son]);</span><br><span class="line">            now=ch[now][son],++sum[now];</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll now,ll val,ll k)</span> </span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">31</span>;~i;--i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> son=!((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=sum[ch[now][son]]) now=ch[now][son],ans|=(<span class="number">1u</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">else</span> k-=sum[ch[now][son]],now=ch[now][!son];</span><br><span class="line">        &#125;<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,x;i&lt;=n;++i) IN(x),sum[i]=sum[i<span class="number">-1</span>]^x;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i) T.root[i]=T.root[i<span class="number">-1</span>];</span><br><span class="line">        T.Insert(T.root[i],sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        q.push(MKP(T.query(T.root[i],sum[i],qrank[i]=<span class="number">1</span>),i));</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        ll i=q.top().second;</span><br><span class="line">        ans+=q.top().first;q.pop();</span><br><span class="line">        <span class="keyword">if</span>(qrank[i]!=i) q.push(MKP(T.query(T.root[i],sum[i],++qrank[i]),i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要是我不是 $\texttt{HN}​$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……&lt;/p&gt;
&lt;p&gt;[十二省联考2019]异或粽子，可持久化 $trie​$ 树的板子题，比最大异或和还要板子些。相信 $60​$ 分入门者都会做，那么 $100​$ 分的话我们上可持久化 $trie​$ 树维护前缀异或和，嗯没错就像主席树那样。然后对于每个节点的可持久化 $trie​$ 树我们将其当成区间右端点，然后在此位置上的 $trie​$ 树中贪心寻找左端点即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="可持久化Trie树" scheme="http://qiulyblog.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [十二省联考2019]春节十二响  堆+启发式合并  luoguP5290</title>
    <link href="http://qiulyblog.github.io/2019/04/19/%5B%E9%A2%98%E8%A7%A3%5DluoguP5290/"/>
    <id>http://qiulyblog.github.io/2019/04/19/[题解]luoguP5290/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T11:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>要是我不是 $\texttt{HN}$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……</p><p>[十二省联考2019]春节十二响，启发式合并裸题。对于树中的一个节点 $u$ ，从其子树中选择一段的方式显然只能是从 $u$ 的所有子树中各选出一个节点。于是我们每一个节点开一个堆，存的就是其子树中(包括自己)的所有段的内存。</p><p>然后从下往上启发式合并即可，复杂度大约是 $O(nlogn)$ 。</p><a id="more"></a><p>启发式合并的具体代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[x].size()&lt;q[y].size()) swap(q[x],q[y]);</span><br><span class="line">    <span class="keyword">while</span>(!q[y].empty()) &#123;</span><br><span class="line">        hep.push_back(max(q[x].top(),q[y].top()));</span><br><span class="line">        q[x].pop(),q[y].pop();</span><br><span class="line">        <span class="comment">/*贪心选取*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hep.size()) q[x].push(hep.back()),hep.pop_back();</span><br><span class="line">    <span class="comment">/*更新节点*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,sz=G[x].size();i&lt;sz;++i)</span><br><span class="line">        solve(G[x][i]),merge(x,G[x][i]);<span class="comment">/*将当前子树与之前枚举过的子树合并*/</span></span><br><span class="line">    q[x].push(s[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的总代码长度不超过 $40$ 行。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,f,s[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hep,G[N];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[x].size()&lt;q[y].size()) swap(q[x],q[y]);</span><br><span class="line">    <span class="keyword">while</span>(!q[y].empty()) &#123;</span><br><span class="line">        hep.push_back(max(q[x].top(),q[y].top()));</span><br><span class="line">        q[x].pop(),q[y].pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hep.size()) q[x].push(hep.back()),hep.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,sz=G[x].size();i&lt;sz;++i)</span><br><span class="line">        solve(G[x][i]),merge(x,G[x][i]);</span><br><span class="line">    q[x].push(s[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f),G[f].push_back(i);</span><br><span class="line">    solve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">1</span>].empty()) ans+=q[<span class="number">1</span>].top(),q[<span class="number">1</span>].pop();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要是我不是 $\texttt{HN}$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……&lt;/p&gt;
&lt;p&gt;[十二省联考2019]春节十二响，启发式合并裸题。对于树中的一个节点 $u$ ，从其子树中选择一段的方式显然只能是从 $u$ 的所有子树中各选出一个节点。于是我们每一个节点开一个堆，存的就是其子树中(包括自己)的所有段的内存。&lt;/p&gt;
&lt;p&gt;然后从下往上启发式合并即可，复杂度大约是 $O(nlogn)$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="堆" scheme="http://qiulyblog.github.io/tags/%E5%A0%86/"/>
    
      <category term="启发式合并" scheme="http://qiulyblog.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】【模板】动态DP  LCT+DP+矩阵  luoguP4751</title>
    <link href="http://qiulyblog.github.io/2019/04/19/%5B%E9%A2%98%E8%A7%A3%5DluoguP4751/"/>
    <id>http://qiulyblog.github.io/2019/04/19/[题解]luoguP4751/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T11:17:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>看懂了后发现 $\texttt{DDP}$ 其实不难呢……</p><p>其实主要思想就是将 $\texttt{DP}$ 转移式搞到矩阵上，然后如果是树形 $\texttt{DP}$ 的话就可以直接上树剖或者是 $LCT$ 进行维护，当然还可以用全局平衡二叉树(不费) 。如果只是线性的话可以直接用线段树等数据结构进行维护了。</p><p>注意这道模板树剖的复杂度是 $O(nlog^2n)$ ，而 $LCT$ 的复杂度为 $O(nlogn)$ ，于是窝选择了 $LCT$ ，跑的还挺快。</p><a id="more"></a><p>开始分析题目，如果没有”动态”限制的话就是一个裸的”没有上司的舞会”，解法显然是设 $f[u][0/1]​$ 表示 $u​$ 不选/选 的时候其子树的最大价值，转移显然为：</p><script type="math/tex; mode=display">f[u][0]=\sum \max(f[v][0],f[v][1])\\f[u][1]=val[u]+\sum f[v][0]</script><p>对于树中的一个节点 $u$ 的所有儿子中有个重儿子，其他的儿子就是轻儿子，我们将重儿子和轻儿子的贡献分开算。设一个 $g[u][0/1]$ ，其值为：</p><script type="math/tex; mode=display">g[u][0]=\sum\max(f[v][0],f[v][1])\\g[u][1]=val[u]+\sum f[v][0]</script><p>注意上式中的 $v$ 只的是轻儿子，然后 $f$ 的转移就变成了以下形式( $x$ 为重儿子)：</p><script type="math/tex; mode=display">f[u][0]=\max(f[x][0],f[x][1])+g[u][0]\\f[u][1]=g[u][1]+f[x][0]</script><p>其实这里的 $g$ 很好维护，我们在 $Access$ 的时候只要计算儿子变化时的贡献就好了。</p><p>接着我们构造出转移矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}g[u][0] & g[u][0]\\g[u][1] & -inf\end{bmatrix}\cdot\begin{bmatrix}f[x][0] \\f[x][1]\end{bmatrix}=\begin{bmatrix}f[u][0]\\f[u][1]\end{bmatrix}</script><p>这样子就可以直接更新了，对于每个节点我们只需要维护两个矩阵即可，一个就是上面乘法中的 $g$ 矩阵，一个就是上面乘法中的 $f$ 矩阵。</p><p>需要注意的是这是广义矩阵乘法，也就是说这个矩阵乘法的运算规则为：</p><script type="math/tex; mode=display">c[i][j]=max(c[i][j],a[i][k]+b[k][j])</script><p>很像 $floyd$ ，可以直接算了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span> &#123;</span><span class="keyword">int</span> c[<span class="number">2</span>][<span class="number">2</span>];matrix()&#123;c[<span class="number">0</span>][<span class="number">0</span>]=c[<span class="number">0</span>][<span class="number">1</span>]=c[<span class="number">1</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">1</span>]=-inf;&#125;&#125;;</span><br><span class="line">matrix <span class="keyword">operator</span> * (matrix&amp;a,matrix&amp;b) &#123;</span><br><span class="line">    matrix ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;++j)<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;++k)</span><br><span class="line">        ret.c[i][j]=max(ret.c[i][j],a.c[i][k]+b.c[k][j]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[N],dp[N][<span class="number">2</span>],head[N],nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;nxt[++cnt]=head[u],to[cnt]=v,head[u]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_cut_tree</span> &#123;</span></span><br><span class="line">    matrix f[N],g[N];</span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">2</span>],fa[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> !((ch[fa[x]][<span class="number">0</span>]==x)||(ch[fa[x]][<span class="number">1</span>]==x));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        f[x]=g[x];</span><br><span class="line">        <span class="keyword">if</span>(ch[x][<span class="number">0</span>]) f[x]=f[ch[x][<span class="number">0</span>]]*f[x];<span class="keyword">if</span>(ch[x][<span class="number">1</span>]) f[x]=f[x]*f[ch[x][<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y],k=ch[y][<span class="number">1</span>]==x,v=ch[x][!k];</span><br><span class="line">        <span class="keyword">if</span>(!isroot(y)) ch[z][ch[z][<span class="number">1</span>]==y]=x;ch[x][!k]=y,ch[y][k]=v;</span><br><span class="line">        <span class="keyword">if</span>(v) fa[v]=y;fa[y]=x,fa[x]=z;pushup(y);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!isroot(x)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isroot(fa[x]))</span><br><span class="line">                rotate((ch[fa[x]][<span class="number">0</span>]==x)^(ch[fa[fa[x]]][<span class="number">0</span>]==fa[x])?x:fa[x]);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;pushup(x);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;x=fa[y=x]) &#123;</span><br><span class="line">            Splay(x);</span><br><span class="line">            <span class="keyword">if</span>(ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">                g[x].c[<span class="number">0</span>][<span class="number">0</span>]+=max(f[ch[x][<span class="number">1</span>]].c[<span class="number">0</span>][<span class="number">0</span>],f[ch[x][<span class="number">1</span>]].c[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">                g[x].c[<span class="number">1</span>][<span class="number">0</span>]+=f[ch[x][<span class="number">1</span>]].c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y) &#123;</span><br><span class="line">                g[x].c[<span class="number">0</span>][<span class="number">0</span>]-=max(f[y].c[<span class="number">0</span>][<span class="number">0</span>],f[y].c[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">                g[x].c[<span class="number">1</span>][<span class="number">0</span>]-=f[y].c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            g[x].c[<span class="number">0</span>][<span class="number">1</span>]=g[x].c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            ch[x][<span class="number">1</span>]=y,pushup(x);</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        Access(x),Splay(x),g[x].c[<span class="number">1</span>][<span class="number">0</span>]-=v[x]-y;</span><br><span class="line">        pushup(x),v[x]=y;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        dp[u][<span class="number">1</span>]=v[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(v!=fa[u]) &#123;</span><br><span class="line">                fa[v]=u,build(v);</span><br><span class="line">                dp[u][<span class="number">0</span>]+=max(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]);</span><br><span class="line">                dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g[u].c[<span class="number">0</span>][<span class="number">0</span>]=g[u].c[<span class="number">0</span>][<span class="number">1</span>]=dp[u][<span class="number">0</span>];</span><br><span class="line">        g[u].c[<span class="number">1</span>][<span class="number">0</span>]=dp[u][<span class="number">1</span>];f[u]=g[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;IN(n),IN(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;++i)IN(u),IN(v),add(u,v),add(v,u);</span><br><span class="line">    T.build(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;IN(x),IN(y);</span><br><span class="line">        T.change(x,y),T.Splay(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(T.f[<span class="number">1</span>].c[<span class="number">0</span>][<span class="number">0</span>],T.f[<span class="number">1</span>].c[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看懂了后发现 $\texttt{DDP}$ 其实不难呢……&lt;/p&gt;
&lt;p&gt;其实主要思想就是将 $\texttt{DP}$ 转移式搞到矩阵上，然后如果是树形 $\texttt{DP}$ 的话就可以直接上树剖或者是 $LCT$ 进行维护，当然还可以用全局平衡二叉树(不费) 。如果只是线性的话可以直接用线段树等数据结构进行维护了。&lt;/p&gt;
&lt;p&gt;注意这道模板树剖的复杂度是 $O(nlog^2n)$ ，而 $LCT$ 的复杂度为 $O(nlogn)$ ，于是窝选择了 $LCT$ ，跑的还挺快。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LCT" scheme="http://qiulyblog.github.io/tags/LCT/"/>
    
      <category term="矩阵" scheme="http://qiulyblog.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[HNOI2019]白兔之舞  单位根反演+MTT  luoguP5293</title>
    <link href="http://qiulyblog.github.io/2019/04/17/%5B%E9%A2%98%E8%A7%A3%5DluoguP5293/"/>
    <id>http://qiulyblog.github.io/2019/04/17/[题解]luoguP5293/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-18T01:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>单位根反演不会啊怎么搞 $FFT$ 吧，还是了解了单位根反演后才可以搞的好吧……居然有人吐槽我说我<strong>学了 $FFT​$ 但是不会运用？！</strong>，嘤嘤嘤打击有些大……</p><p>实际上所谓的单位根反演就是这个东西：</p><script type="math/tex; mode=display">\frac{1}{n}\sum_{i=0}^{n-1}(\omega_n^d)^i=[n|d]</script><a id="more"></a><p>回到题目，我们先考虑正解的简化版—— $n=1$ 的版本，我们先定义 $W=w[1][1]$ 。</p><p>现在对于每一个 $t$ 的答案显然为 $\sum_{i=0}^{L}[i\% k=t] W^i (^L_i)$</p><p>这个式子显然等于 $\sum_{i=0}^{L}[k|(i-t)] w^i (^L_i)$ 。会发现 $[k|(i-t)]$ 和上面单位根反演的 $[n|d]$ 一样，于是我们尝试将单位根反演的式子带进去。</p><script type="math/tex; mode=display">=\sum_{i=0}^{L}\frac{1}{k}\sum_{j=0}^{k-1}(\omega_k^{i-t})^j W^i \binom{L}{i}\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \omega_k^{ij} W^i \binom{L}{i}\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \binom{L}{i}(\omega_k^{j} W)^i\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \binom{L}{i}(\omega_k^{j} W)^i 1^{n-i}\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}(\omega_k^{j} W+1)^L</script><p>后面的 $(\omega_k^{j} W+1)^L$ 显然可以预处理，记为 $num_j$ 。</p><p>然后发现 $-tj=\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}$</p><script type="math/tex; mode=display">=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}}num_j\\\\=\frac{1}{k}\omega_k^{\binom{t}{2}}\sum_{j=0}^{k-1}num_j\omega_k^{\binom{j}{2}}\cdot\omega_k^{-\binom{t+j}{2}}</script><p>后面的式子可以用 $FFT$ 加速，但是值域太大这里需要用到 $MTT$ 。现在就有 $40$ 分了，接下来考虑 $n&gt;1$ 的情况。</p><p>我们建矩阵，然后会发现 $n&gt;1$ 仅会对 $num_j$ 的计算方式有变化。</p><p>我们定义一个 $begin$ 矩阵，该矩阵只有 $(0,x)$ 位置上有值且值为 $1$ ，也就是说这是白兔的起点。那么最后我们需要留下来的也就是矩阵的 $(0,y)$ ，因为只有在第二维为 $y$ 是才会计入答案。</p><p>嗯，差不多可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin.c[<span class="number">0</span>][x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) </span><br><span class="line">    num[i]=(begin*<span class="built_in">pow</span>(w*num[i]+I,n)).c[<span class="number">0</span>][y]%MOD;</span><br><span class="line"><span class="comment">/*w就是上文中的W，不过这里是矩阵*/</span></span><br><span class="line"><span class="comment">/*I是矩阵中的单位'1'*/</span></span><br></pre></td></tr></table></figure><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">65536</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);   </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,k,n,x,y,MOD,G,num[N],A[N&lt;&lt;<span class="number">2</span>],B[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> F(x,i,j) for((x)=(i);(x)&lt;=(j);++(x))</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">IN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;ll x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">matrix</span> &#123;</span><span class="keyword">int</span> c[<span class="number">3</span>][<span class="number">3</span>];matrix()&#123;<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));&#125;&#125;;</span><br><span class="line">    matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> matrix&amp;a,<span class="keyword">const</span> matrix&amp;b) &#123;</span><br><span class="line">        matrix ans;<span class="keyword">int</span> i,j;F(i,<span class="number">0</span>,<span class="number">2</span>)F(j,<span class="number">0</span>,<span class="number">2</span>) &#123;</span><br><span class="line">            ans.c[i][j]=a.c[i][j]+b.c[i][j];</span><br><span class="line">            <span class="keyword">if</span>(ans.c[i][j]&gt;=MOD) ans.c[i][j]-=MOD;</span><br><span class="line">        &#125;<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix&amp;a,<span class="keyword">const</span> matrix&amp;b) &#123;</span><br><span class="line">        matrix ans;<span class="keyword">int</span> i,j,k;F(i,<span class="number">0</span>,<span class="number">2</span>)F(j,<span class="number">0</span>,<span class="number">2</span>)F(k,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            ans.c[i][k]=(ans.c[i][k]+<span class="number">1l</span>l*a.c[i][j]*b.c[j][k])%MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix&amp;a,<span class="keyword">const</span> <span class="keyword">int</span>&amp;b) &#123;</span><br><span class="line">        matrix ans;<span class="keyword">int</span> i,j;F(i,<span class="number">0</span>,<span class="number">2</span>)F(j,<span class="number">0</span>,<span class="number">2</span>)ans.c[i][j]=<span class="number">1l</span>l*a.c[i][j]*b%MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span><span class="keyword">complex</span>(<span class="keyword">long</span> <span class="keyword">double</span> a=<span class="number">0</span>,<span class="keyword">long</span> <span class="keyword">double</span> b=<span class="number">0</span>)&#123;x=a,y=b;&#125;<span class="keyword">long</span> <span class="keyword">double</span> x,y;&#125;;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> + (<span class="keyword">complex</span> a,<span class="keyword">complex</span> b)&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(a.x+b.x,a.y+b.y);&#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> - (<span class="keyword">complex</span> a,<span class="keyword">complex</span> b)&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(a.x-b.x,a.y-b.y);&#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> * (<span class="keyword">complex</span> a,<span class="keyword">complex</span> b)&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;</span><br><span class="line">    matrix I;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%MOD) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1l</span>l*res*x%MOD;</span><br><span class="line">        <span class="keyword">return</span> res%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> matrix <span class="title">pow</span><span class="params">(matrix x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        matrix res=I;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MTT &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> BLOCK 32768</span></span><br><span class="line">    <span class="keyword">int</span> limit=<span class="number">1</span>,cnt=<span class="number">0</span>,filp[N&lt;&lt;<span class="number">2</span>],Ans[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">complex</span> A1[N&lt;&lt;<span class="number">2</span>],B1[N&lt;&lt;<span class="number">2</span>],A2[N&lt;&lt;<span class="number">2</span>],B2[N&lt;&lt;<span class="number">2</span>],X[N&lt;&lt;<span class="number">2</span>],omg[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fft</span><span class="params">(<span class="keyword">complex</span> *f,<span class="keyword">short</span> inv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)<span class="keyword">if</span>(i&lt;filp[i])<span class="built_in">std</span>::swap(f[i],f[filp[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;limit;p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">complex</span> *a=f;a!=f+limit;a+=(p&lt;&lt;<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;p;++l)&#123;</span><br><span class="line">                    <span class="keyword">complex</span> t=a[l+p]*omg[limit/(p&lt;&lt;<span class="number">1</span>)*l];</span><br><span class="line">                    a[l+p]=a[l]-t,a[l]=a[l]+t;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mtt</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(limit&lt;(k*<span class="number">3</span>+<span class="number">5</span>)) limit&lt;&lt;=<span class="number">1</span>,++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) filp[i]=(filp[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(cnt<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) A1[i].x=A[i]&amp;(BLOCK<span class="number">-1</span>),A2[i].x=A[i]&gt;&gt;<span class="number">15</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) B1[i].x=B[i]&amp;(BLOCK<span class="number">-1</span>),B2[i].x=B[i]&gt;&gt;<span class="number">15</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) omg[i]=(<span class="keyword">complex</span>)&#123;<span class="built_in">cos</span>(i*PI*<span class="number">2</span>/limit),<span class="built_in">sin</span>(i*PI*<span class="number">2</span>/limit)&#125;;</span><br><span class="line">        fft(A1,<span class="number">1</span>),fft(B1,<span class="number">1</span>);fft(A2,<span class="number">1</span>),fft(B2,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">            <span class="keyword">complex</span> a1=A1[i],a2=A2[i],b1=B1[i],b2=B2[i];</span><br><span class="line">            A1[i]=a1*b1,A2[i]=a2*b2,B1[i]=a1*b2,B2[i]=a2*b1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) omg[i]=(<span class="keyword">complex</span>)&#123;<span class="built_in">cos</span>(i*PI*<span class="number">2</span>/limit),-<span class="built_in">sin</span>(i*PI*<span class="number">2</span>/limit)&#125;;</span><br><span class="line">        fft(A1,<span class="number">-1</span>),fft(B1,<span class="number">-1</span>);fft(A2,<span class="number">-1</span>),fft(B2,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)</span><br><span class="line">            A1[i].x/=limit,A2[i].x/=limit,B1[i].x/=limit,B2[i].x/=limit;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)</span><br><span class="line">            Ans[i]=((ll)(A1[i].x+<span class="number">0.5</span>)%MOD+<span class="number">1073741824l</span>l*((ll)(A2[i].x+<span class="number">0.5</span>)%MOD)%MOD+</span><br><span class="line">            <span class="number">32768l</span>l*((ll)(B1[i].x+<span class="number">0.5</span>)%MOD)%MOD+<span class="number">32768l</span>l*((ll)(B2[i].x+<span class="number">0.5</span>)%MOD)%MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> MTT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> divisor[<span class="number">105</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_G</span><span class="params">()</span> </span>&#123;<span class="comment">/*获取原根*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,S=MOD<span class="number">-1</span>;i&lt;=S;++i) </span><br><span class="line">        <span class="keyword">if</span>(S%i==<span class="number">0</span>) &#123;divisor[++tot]=i;<span class="keyword">while</span>(!(S%i)) S/=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> g=<span class="number">2</span>;;++g) &#123;</span><br><span class="line">        <span class="keyword">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;++j) <span class="keyword">if</span>(<span class="built_in">pow</span>(g,(MOD<span class="number">-1</span>)/divisor[j])==<span class="number">1</span>) &#123;ok=<span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(ok) <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matrix w,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    I.c[<span class="number">0</span>][<span class="number">0</span>]=I.c[<span class="number">1</span>][<span class="number">1</span>]=I.c[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    m=IN(),k=IN(),n=IN(),x=IN(),y=IN(),MOD=IN();--x,--y;</span><br><span class="line">    <span class="comment">/*num其实就是上文中的单位根，这里预处理一下计算方便些*/</span></span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">1</span>,num[<span class="number">1</span>]=<span class="built_in">pow</span>(G=get_G(),(MOD<span class="number">-1</span>)/k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;k;++i) num[i]=<span class="number">1l</span>l*num[<span class="number">1</span>]*num[i<span class="number">-1</span>]%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) w.c[i][j]=IN();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);++i) A[i]=num[(k<span class="number">-1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>%k)%k];</span><br><span class="line">    s.c[<span class="number">0</span>][x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) B[i]=<span class="number">1l</span>l*num[<span class="number">1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>%k]*(s*<span class="built_in">pow</span>(w*num[i]+I,n)).c[<span class="number">0</span>][y]%MOD;</span><br><span class="line">    <span class="comment">/*计算后面两个多项式的值*/</span></span><br><span class="line">    reverse(B,B+k+<span class="number">1</span>),mtt(A,B);</span><br><span class="line">    <span class="keyword">int</span> invk=<span class="built_in">pow</span>(k,MOD<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="number">1l</span>l*Ans[i+k]*invk%MOD*num[<span class="number">1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>%k]%MOD);</span><br><span class="line">    <span class="comment">/*计算答案*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单位根反演不会啊怎么搞 $FFT$ 吧，还是了解了单位根反演后才可以搞的好吧……居然有人吐槽我说我&lt;strong&gt;学了 $FFT​$ 但是不会运用？！&lt;/strong&gt;，嘤嘤嘤打击有些大……&lt;/p&gt;
&lt;p&gt;实际上所谓的单位根反演就是这个东西：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{n}\sum_{i=0}^{n-1}(\omega_n^d)^i=[n|d]&lt;/script&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="FFT" scheme="http://qiulyblog.github.io/tags/FFT/"/>
    
      <category term="单位根反演" scheme="http://qiulyblog.github.io/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
      <category term="MTT" scheme="http://qiulyblog.github.io/tags/MTT/"/>
    
  </entry>
  
</feed>
