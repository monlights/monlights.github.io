<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qiuly&#39;s blog!</title>
  
  <subtitle>A weak OIer from HN-YZ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qiulyblog.github.io/"/>
  <updated>2019-05-07T02:42:18.017Z</updated>
  <id>http://qiulyblog.github.io/</id>
  
  <author>
    <name>Qiuly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【题解】 [HNOI2009]双递增序列  线性DP  luoguP4728</title>
    <link href="http://qiulyblog.github.io/2019/05/07/%5B%E9%A2%98%E8%A7%A3%5DluoguP4728/"/>
    <id>http://qiulyblog.github.io/2019/05/07/[题解]luoguP4728/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-07T02:42:18.017Z</updated>
    
    <content type="html"><![CDATA[<p>其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示<strong>第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立</strong> ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。</p><a id="more"></a><p>考虑设 $dp_{i,j}$ 表示第一个序列的最终位置为 $i-1$ 且长度为 $j$ 时第二个序列的最终位置的最小值。枚举当前数字 $i$ ，然后分两种情况进行转移——将 $a_i$ 放到第一个序列末尾 $\texttt{and}$ 将 $a_i$ 放到第二个序列末尾。</p><p>放到第一个序列末尾很好想：因为当前第一个序列的结尾处就是 $a_{i-1}$ ，比较一下大小直接转移就好了：</p><script type="math/tex; mode=display">dp_{i,j}=min(dp_{i,j},dp_{i-1,j-1}) \ \ \ (a_i>a_{i-1})</script><p>因为第二个序列的末尾没变，所有直接转移就好。</p><p>接下来考虑将第 $i$ 个数放到第二个序列末尾的情况，其实第一个序列和第二个序列没区别，当然除了名字上有一个字的差异，假设第 $i-1$ 个数是第二个序列末尾，当前第一个序列的长度为 $j-1$ ，那么第二个序列的长度因该就是 $(i-1)-(j-1)$ 了，因为我们假设了第 $i-1$ 个数是第二个序列末尾，那么 $dp_{i-1,i-j}$ 又可以被解释为<strong>第二个序列的末尾为 $i-1$ 个数且第二个序列的长度为 $i-j$ 的时候第一个序列的末尾的最小值</strong> ，如果这个最小值小于 $a_i$ ，说明 $a_i$ 可以接到第一个序列前面，那么这个时候第二个序列的末尾为 $a_{i-1}$ ，显然又有转移：</p><script type="math/tex; mode=display">dp_{i,j}=min(dp_{i,j},a_{i-1}) \ \ \ (a_i>dp_{i-1,i-j})</script><p>开始的时候我们将 $dp$ 数组赋成极大值，然后最后判断一下 $dp_{n,n/2}$ 这个状态变小没有就好。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;IN(n);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    a[<span class="number">0</span>]=f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i&amp;&amp;j&lt;=n/<span class="number">2</span>;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i<span class="number">-1</span>]) f[i][j]=min(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;f[i<span class="number">-1</span>][i-j]) f[i][j]=min(f[i][j],a[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> f[n][n/<span class="number">2</span>]&lt;<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">puts</span>(solve()?<span class="string">"Yes!"</span>:<span class="string">"No!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这道题的确很绕……=。=</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示&lt;strong&gt;第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立&lt;/strong&gt; ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HEOI2013]SAO  组合数学+树形DP  luoguP4099</title>
    <link href="http://qiulyblog.github.io/2019/05/06/%5B%E9%A2%98%E8%A7%A3%5DluoguP4099/"/>
    <id>http://qiulyblog.github.io/2019/05/06/[题解]luoguP4099/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-05-06T10:07:38.445Z</updated>
    
    <content type="html"><![CDATA[<p>$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：<a href="https://www.luogu.org/problemnew/show/P4099" target="_blank" rel="noopener">转送门😄</a> 。</p><p>我们先不考虑边的权值(&lt;与&gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&lt;,&gt;) ，我们分类讨论即可。</p><p>首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢<a id="more"></a>，对于一个 $u$ 的儿子 $v$ ，我们虽然知道 $u$ 和 $v$ 的攻克的前后关系，但是合并答案貌似并不好合并。这个时候我们增加一维 $j$ ，$f_{u,j}$ 表示 $u$ 的子树的所有合法拓扑序中 $u$ 在第 $j$ 位上的总状态数。</p><p>也就是说，对于一个必须在 $u$ 前面攻克的关卡 $v$ ，我们考虑枚举一个 $j$ ，$v$ 子树中 $j$ 个结点在合并 $u,v$ 后放到 $u$ 前面，另外 $sz_v-j$ 个放到 $u$ 后面，然后枚举一个 $k$ ，表示当前的 $v$ 排在 $v$ 子树的拓扑序中的第 $k$ 位，只有 $k\leq j$ 的时候 $v$ 才可以转移 $u$ ，因为这个时候 $v$ 在 $u$ 前面。</p><p>现在再来考虑$“$ $j$ 个结点放在 $u$ 前面 $”$ 的方案数和$“$ $sz_v-j$ 个结点放在 $u$ 后面的方案数$”$，这个显然可以用组合数算，合并 $v$ 的子树后，$u$ 的排名从 $i$ 变成了 $i+j$ ，也就是说我们需要将 $j$ 个乱序插入到 $u$ 前面 $i+j-1$ 个数中，方案数显然为 $C_{i+j-1}^{j}$ ，那么现在总节点数显然为 $sz_u+sz_v$ (现在 $sz_u$ 和 $sz_v$ 还没有并在一起) ，$u$ 后面理所当然有 $sz_u+sz_v-i-j$ 个位置，将 $sz_v-j$ 个数插进去的方案数显然为 $C_{sz_u+sz_v-i-j}^{sz_v-j}$ 个，这两个数再乘上 $f_{u,i}$ 和 $f_{v,k}$ 就好了，这一次合并后 $u$ 的位置显然到了 $i+j$ ，所以 $f_{u,i+j}$ 显然要加上这一组贡献。</p><p>经整理后的转移方程如下：</p><script type="math/tex; mode=display">pls(f_{u,i+j},f_{u,i}\cdot f_{v,k}\cdot C_{i+j-1}^{j}\cdot C_{sz_u+sz_v-i-j}^{sz_v-j})</script><p>代码就是这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span> to sz[u]</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span> to sz[v]</span><br><span class="line">        <span class="keyword">for</span> k=<span class="number">1</span> to j</span><br><span class="line">            pls(f[u][i+j],f[u][i]*f[v][k]*C[i+j<span class="number">-1</span>][j]*C[sz[u]+sz[v]-i-j][sz[v]-j])</span><br></pre></td></tr></table></figure><p>这是 $n^3$ 的，过不去。考虑前缀和优化，几下 $f_v$ 的前缀和，最后的一层循环就可以直接丢掉了。</p><p>这个就是 $v$ 要在 $u$ 前面的情况，$u$ 在 $v$ 前面的情况和这个差不多，不过转移的时候 $j$ 就要从 $0$ 开始了，因为那个时候 $u$ 前面是可以不多放任何东西的，还有就是 $u$ 在 $v$ 前面的时候注意 $k\geq j$ 时才可以转移 !</p><p>最后的答案就是 $\sum\limits_{i=1}^{n} f_{1,i}$ 啦。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to,val;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> C[N][N],f[N][N],pre[N][N],suf[N][N],sz[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt;</span><br><span class="line">    G[++cnt]=(Edge)&#123;head[v],u,w^<span class="number">1</span>&#125;,head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;=mod)x-=mod;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[u]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=head[u];l;l=G[l].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[l].to,w=G[l].val;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u);</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">if</span>(w) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=sz[v];++j)</span><br><span class="line">                    pls(g[i+j],<span class="number">1l</span>l*f[u][i]*pre[v][j]%mod*C[i+j<span class="number">-1</span>][j]%mod</span><br><span class="line">                    *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=sz[v];++j)</span><br><span class="line">                    pls(g[i+j],<span class="number">1l</span>l*f[u][i]*suf[v][j+<span class="number">1</span>]%mod*C[i+j<span class="number">-1</span>][j]%mod</span><br><span class="line">                    *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="built_in">memcpy</span>(f[u],g,<span class="keyword">sizeof</span>(g));</span><br><span class="line">    &#125;</span><br><span class="line">    pre[u][<span class="number">0</span>]=suf[u][sz[u]+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz[u];++i) pre[u][i]=(pre[u][i<span class="number">-1</span>]+f[u][i])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sz[u];i&gt;=<span class="number">1</span>;--i) suf[u][i]=(suf[u][i+<span class="number">1</span>]+f[u][i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head)),cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> n;IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;<span class="keyword">char</span> sign;</span><br><span class="line">        IN(u),sign=getchar(),IN(v);</span><br><span class="line">        add(u+<span class="number">1</span>,v+<span class="number">1</span>,sign==<span class="string">'&lt;'</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) pls(ans,f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*预处理组合数*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N<span class="number">-2</span>;++i) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N<span class="number">-2</span>;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="keyword">int</span> T;IN(T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人会问，如果 $u$ 的儿子 $v$ 下面的边全都是 $&gt;$ ，并且 $u$ 连向 $v$ 的边也是 $&gt;$ ，那么这个时候 $v$ 以及其子树的所有点都必须在 $u$ 前面完成，在转移的时候为什么可以 $“$ 提出 $j$ 个结点放到 $u$ 前面 $”$ 呢？</p><p>其实想想就可以明白，在向上统计答案的时候对于一个 $v$ 的儿子 $a$ ，我们只统计了合并后 $a$ 在 $v$ 前面的情况，同样在 $u$ 统计 $v$ 时也只是统计了合并后 $v$ 在 $u$ 前面的情况，所有我们也只是统计了 $“$ $a$ 在 $v$ 前面且 $v$ 在 $u$ 前面 $”$ 的情况，所有被统计的情况一定是合法的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4099&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转送门😄&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;我们先不考虑边的权值(&amp;lt;与&amp;gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&amp;lt;,&amp;gt;) ，我们分类讨论即可。&lt;/p&gt;
&lt;p&gt;首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="树形DP" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】  [HAOI2018]苹果树  组合数学  loj2526</title>
    <link href="http://qiulyblog.github.io/2019/05/05/%5B%E9%A2%98%E8%A7%A3%5Dloj2526/"/>
    <id>http://qiulyblog.github.io/2019/05/05/[题解]loj2526/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-06T05:23:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的题目，可爱的传送门：<a href="https://loj.ac/problem/2526" target="_blank" rel="noopener">戳这呢=￣ω￣=</a></p><p>刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。</p><p>我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。</p><a id="more"></a><p>易知节点数为 $n$ 的二叉树的总形态数为 $n!$ ，而且 $i$ 子树下的所有节点的编号一定要大于 $i$ ，我们考虑”先将 $i$ 子树构造出来再填入节点”的过程，子树的形态数显然为 $j!$ ，然后我们只能选剩下的 $n-i$ 个节点(编号要比 $i$ 大) ，填入剩下的 $j-1$ 个位置( $i$ 占了一个位置) ，显然这样的方案数为 $C_{n-i}^{j-1}$ 。</p><p>这样的一个 $i$ ，其子树大小为 $j$ ，那么它可以做出多少贡献呢？考虑 $fa_i \Rightarrow i$ 这条边会经过多少次，显然是 $j\cdot(n-j)$ 次( $j$ 为子树节点个数，$n-j$ 为上面的节点个数) ，也就是说这样的方案可以造成 $j\cdot (n-j)$ 的贡献。</p><p>那么现在 $i$ 的子树得到确定了，我们将 $i$ 以及其子树看做一个点，我们考虑 $1$ 到 $i$ 这些节点，它们可以以任意形态组成一棵树，方案数是 $i!$ 。</p><p>接着我们需要将剩下的 $n-j-(i-1)$ 个节点挂到树上去。对于第 $i$ 个挂到树上的点，它有 $i$ 个位置可以挂。但是因为 $i$ 一定要占一个位置，所以这个节点只有 $i-1$ 个位置可以挂了，第二个多出来的节点就有 $i$ 个位置可以挂……第 $k$ 个显然有 $i-2+k$ 个位置可以挂。也就是说这些点挂上去的总方案数为 $\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 。</p><p>将上面的乘起来就是这一组 $i,j$ 对答案造成的贡献了：</p><script type="math/tex; mode=display">j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)</script><p>$\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 比较不好计算，但是简单的变化后发现这个是和 $(n-j-1)!/(i-2)!$ 等价的，我们带进原式子。</p><script type="math/tex; mode=display">j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot(n-j-1)!/(i-2)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i\cdot (i-1)\cdot(n-j-1)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot i\cdot (i-1)\cdot (n-j)!</script><p>这样就很好算了，我们预处理组合数和阶乘，上面的式子 $O(1)$ 算~</p><p>代码很短。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e3</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,ans,fac[N],C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(<span class="keyword">int</span>&amp;x,<span class="keyword">int</span> y)</span> </span>&#123;x+=y;x%=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(p);</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) fac[i]=<span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;++j)</span><br><span class="line">            pls(ans,(ll)fac[j]*fac[n-j]%p*C[n-i][j<span class="number">-1</span>]%p*(i*(i<span class="number">-1</span>))%p*j%p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有趣的题目，可爱的传送门：&lt;a href=&quot;https://loj.ac/problem/2526&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳这呢=￣ω￣=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。&lt;/p&gt;
&lt;p&gt;我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="组合数学" scheme="http://qiulyblog.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [六省联考2017]分手是祝愿  概率DP  loj2145</title>
    <link href="http://qiulyblog.github.io/2019/05/05/%5B%E9%A2%98%E8%A7%A3%5Dloj2145/"/>
    <id>http://qiulyblog.github.io/2019/05/05/[题解]loj2145/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-05T02:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>概率神仙题的传送门：<a href="https://loj.ac/problem/2145" target="_blank" rel="noopener"><del>别戳偏了</del></a></p><p>设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程：</p><script type="math/tex; mode=display">f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})</script><p>因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。</p><a id="more"></a><script type="math/tex; mode=display">f_i=\frac{i}{n}+1\cdot (1+f_i+f_{i+1})-\frac{i}{n}\cdot (1+f_i+f_{i+1})\\\\f_i=\frac{i}{n}+1+f_i+f_{i+1}-\frac{i}{n}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\f_i=1+f_i+f_{i+1}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\\frac{i}{n}f_i=1+f_{i+1}-\frac{i}{n}f_{i+1}\\\\f_i=\frac{1+f_{i+1}-\frac{i}{n}f_{i+1}}{\frac{i}{n}}\\\\f_i=\frac{n\cdot(1+f_{i+1})-i\cdot f_{i+1}}{i}\\\\f_i=\frac{n+(n-i)\cdot f_{i+1}}{i}\\\\f_i=1+\frac{(n-i)\cdot (f_{i+1}+1)}{i}</script><p>预处理逆元就可以直接计算了，记得最后乘上 $n!$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,step,a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,f[N],inv[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    inv[<span class="number">0</span>]=<span class="number">0</span>,inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) inv[i]=(<span class="keyword">long</span> <span class="keyword">long</span>)(p-p/i)*inv[p%i]%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i) g[j].push_back(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i) <span class="keyword">if</span>(a[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[i].size();++j) a[g[i][j]]^=<span class="number">1</span>;</span><br><span class="line">        ++step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(step&lt;=k) ans=step;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">1</span>;--i) f[i]=(<span class="number">1l</span>l+(<span class="number">1l</span>l*n-i)*(f[i+<span class="number">1</span>]+<span class="number">1</span>)*inv[i])%p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&gt;k;--i) ans=(ans+f[i])%p;</span><br><span class="line">        ans=(ans+k)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans=(<span class="number">1l</span>l*i*ans)%p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;概率神仙题的传送门：&lt;a href=&quot;https://loj.ac/problem/2145&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;del&gt;别戳偏了&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})&lt;/script&gt;&lt;p&gt;因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SCOI2014]方伯伯的玉米田  树状数组优化DP  luoguP3287</title>
    <link href="http://qiulyblog.github.io/2019/05/04/%5B%E9%A2%98%E8%A7%A3%5DluoguP3287/"/>
    <id>http://qiulyblog.github.io/2019/05/04/[题解]luoguP3287/</id>
    <published>2019-05-03T16:00:00.000Z</published>
    <updated>2019-05-05T02:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>以后不要被这种傻逼题给蒙骗了。传送门：<a href="https://www.luogu.org/problemnew/show/P3287" target="_blank" rel="noopener">方伯伯的传送门=。=</a></p><p>首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。</p><p>设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程：</p><a id="more"></a><script type="math/tex; mode=display">f_{i,j}=\max\{f_{k,l}+1\} \ \ (k<i,l\leq j,h_i+j\geq h_k+l)</script><p>可能有人会问为什么 $l\leq j$ ，很显然就是上面的道理，越大的 $i$ 一定拔高次数是单调不减的。</p><p>发现上面的转移其实是 $O(n^2k^2)$ 的，万恶的出题人不会给这个复杂度一丁点分……这个时候用树状数组优化转移，发现上面有三个限制条件，我们正着枚举 $i$ ，就已经满足第一个条件了，因为这个时候树状数组中的都是小于 $i$ 的 $k$ 。然后将每个点按照 $(j+1,h_i+j)$ 放到平面上，然后树状数组统计答案即可。</p><p>树状数组维护的是 $\max$  ，不是和。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],n,k,mx;</span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line">    <span class="keyword">int</span> c[N][<span class="number">5009</span>+K];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">const</span> <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;=mx+k;x+=(x&amp;-x))<span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&lt;=k+<span class="number">1</span>;i+=(i&amp;-i))</span><br><span class="line">                c[x][i]=max(c[x][i],v); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x;x-=(x&amp;-x))<span class="keyword">for</span>(<span class="keyword">int</span> i=y;i;i-=(i&amp;-i))</span><br><span class="line">                ans=max(ans,c[x][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> BIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),mx=max(mx,a[i]);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k;~j;--j) &#123;</span><br><span class="line">            <span class="keyword">int</span> res=query(a[i]+j,j+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            ans=max(ans,res),update(a[i]+j,j+<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以后不要被这种傻逼题给蒙骗了。传送门：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3287&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;方伯伯的传送门=。=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。&lt;/p&gt;
&lt;p&gt;设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="树状数组" scheme="http://qiulyblog.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="二维树状数组" scheme="http://qiulyblog.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SHOI2014]概率充电器  概率DP  loj2192</title>
    <link href="http://qiulyblog.github.io/2019/05/02/%5B%E9%A2%98%E8%A7%A3%5Dloj2192/"/>
    <id>http://qiulyblog.github.io/2019/05/02/[题解]loj2192/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-05T02:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>传送门在这：<a href="https://loj.ac/problem/2192" target="_blank" rel="noopener">我是传送门$QwQ$</a></p><p>其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。</p><p>因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。</p><a id="more"></a><p>枚举每一个儿子，对于这个儿子只有两种情况：该儿子没有通上电，该儿子通上电了且传送失败。两种情况的概率都很好算。我们可以列出转移方程：</p><script type="math/tex; mode=display">f_u=(1-q_u)\cdot \prod (f_v+(1-f_v)\cdot(1-G_i.p))</script><p>其中 $(1-q_u)$ 显然为该点本身不通电的概率，然后枚举儿子 $v$ ，$f_v$ 就是该儿子本来就没有通上电的概率，$(1-f_v)\cdot(1-G_i.p)$ 就是通上电的传送失败(注：$G_i.p$ 是当前连接 $u,v$ 的边的通电概率) 。</p><p>那么如何计算父亲传来的电呢？设 $g_i$ 表示点 $i$ 的父亲没有向点 $i$ 通电的概率。计算一下父节点不通电的概率，注意不要计算上该儿子的贡献，不然会乱。计算完不通电的概率后分上面两种情况讨论即可。</p><script type="math/tex; mode=display">res=g_u\cdot f_v / (f_v+(1-f_v)\cdot(1-G_i.p))\\\\g_v=res+(1-res)\cdot(1-G_i.p)</script><p>两边 $dfs$ 就可以搞定。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans,f[N],g[N],q[N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,n,tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nxt,to;<span class="keyword">double</span> p;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> p)</span> </span>&#123;G[++cnt]=(Edge)&#123;head[x],y,p&#125;,head[x]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[u]=<span class="number">1</span>-q[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>((v=G[i].to)!=fa)</span><br><span class="line">            dfs1(v,u),f[u]*=(f[v]+(<span class="number">1</span>-f[v])*(<span class="number">1</span>-G[i].p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i;i=G[i].nxt) </span><br><span class="line">        <span class="keyword">if</span>((v=G[i].to)!=fa) &#123;</span><br><span class="line">            <span class="keyword">double</span> res=g[u]*f[u]/(f[v]+(<span class="number">1</span>-f[v])*(<span class="number">1</span>-G[i].p));</span><br><span class="line">            g[v]=res+(<span class="number">1</span>-res)*(<span class="number">1</span>-G[i].p);dfs2(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,p;IN(x),IN(y),IN(p);</span><br><span class="line">        add(x,y,p/<span class="number">100.0</span>),add(y,x,p/<span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) IN(x),q[i]=x/<span class="number">100.0</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1.0</span>,dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans+=<span class="number">1</span>-f[i]*g[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门在这：&lt;a href=&quot;https://loj.ac/problem/2192&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我是传送门$QwQ$&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。&lt;/p&gt;
&lt;p&gt;因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2015]寿司晚宴  状压DP  loj2131</title>
    <link href="http://qiulyblog.github.io/2019/05/01/%5B%E9%A2%98%E8%A7%A3%5Dloj2131/"/>
    <id>http://qiulyblog.github.io/2019/05/01/[题解]loj2131/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-05T01:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。</p><p>设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mul=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,s[N];ll p,f[<span class="number">2</span>][mul][mul];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(ll&amp;x,ll&amp;y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;p)x-=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">// freopen("1.out","w",stdout);</span></span><br><span class="line">    IN(n),IN(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;++j)</span><br><span class="line">            <span class="keyword">if</span>(!(i%pri[j])) s[i]|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now=i&amp;<span class="number">1</span>,lst=!now;</span><br><span class="line">        <span class="built_in">memcpy</span>(f[now],f[lst],<span class="keyword">sizeof</span>(f[lst]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;mul;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;mul;++s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[lst][s1][s2]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;s[i])) pls(f[now][s1|s[i]][s2],f[lst][s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;s[i])) pls(f[now][s1][s2|s[i]],f[lst][s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;mul;++s1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;mul;++s2) pls(ans,f[n&amp;<span class="number">1</span>][s1][s2]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以知道 $n\leq 500$ 的时候，每一个数最多带上一个大于等于 $23$ 的质因子。我们首先将所有的寿司分为两类：带了大于等于 $23$ 的质因子的和没带的。</p><p>没带的显然可以向上面那样转移。那么带了的呢？这个显然不能压缩吧。</p><p>我们考虑将带了同样的大于等于 $23$ 的质因子的分成一组，这一组要不小 $\rm{G}$ 吃小 $\rm{W}$ 不吃，要不小 $\rm{W}$ 吃小 $G$ 不吃。分别讨论即可。</p><p>设 $f1[s1][s2]$ 表示这一组是小 $\rm{G}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。同理，设 $f2[s1][s2]$ 表示这一组是小 $\rm{W}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。分别转移就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i) &#123; <span class="comment">/*枚举这些寿司*/</span></span><br><span class="line">    <span class="keyword">if</span>(a[i].t!=a[i<span class="number">-1</span>].t) <span class="comment">/*大质因子不同了*/</span></span><br><span class="line">        <span class="built_in">memcpy</span>(f1,f,<span class="keyword">sizeof</span>(f)),<span class="built_in">memcpy</span>(f2,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">        <span class="comment">/*倒着枚举所以没用滚动数组*/</span></span><br><span class="line">        <span class="comment">/*所谓的分别转移*/</span></span><br><span class="line">        <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]);</span><br><span class="line">        <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这一组结束了，需要合并答案*/</span></span><br><span class="line">    <span class="keyword">if</span>(a[i].t!=a[i+<span class="number">1</span>].t||i==n)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2)</span><br><span class="line">            <span class="comment">/*因为f1[s1][s2]和f2[s1][s2]都重复算了一遍原来的</span></span><br><span class="line"><span class="comment">            f[s1][s2]，所以减掉后再取膜*/</span></span><br><span class="line">            f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">ll p,f[M][M],f1[M][M],f2[M][M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="keyword">int</span> t,s;&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span> </span>&#123;<span class="keyword">return</span> a.t&lt;b.t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pls</span><span class="params">(ll&amp;x,ll&amp;y)</span> </span>&#123;x+=y;<span class="keyword">if</span>(x&gt;=p)x%=p;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;IN(n),IN(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        a[i].t=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;++j)<span class="keyword">if</span>(!(i%pri[j])) &#123;</span><br><span class="line">            a[i].s|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>),a[i].t/=pri[j];</span><br><span class="line">            <span class="keyword">while</span>(!(a[i].t%pri[j])) a[i].t/=pri[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    sort(a+<span class="number">2</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[pos].t==<span class="number">1</span>) ++pos;--pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=pos;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f[s1|a[i].s][s2],f[s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f[s1][s2|a[i].s],f[s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].t!=a[i<span class="number">-1</span>].t)</span><br><span class="line">            <span class="built_in">memcpy</span>(f1,f,<span class="keyword">sizeof</span>(f)),<span class="built_in">memcpy</span>(f2,f,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s1=M<span class="number">-1</span>;~s1;--s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=M<span class="number">-1</span>;~s2;--s2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]);</span><br><span class="line">            <span class="keyword">if</span>(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i].t!=a[i+<span class="number">1</span>].t||i==n)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)<span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2)</span><br><span class="line">                f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s1=<span class="number">0</span>;s1&lt;M;++s1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s2=<span class="number">0</span>;s2&lt;M;++s2) pls(ans,f[s1][s2]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans+p)%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。&lt;/p&gt;
&lt;p&gt;设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状态压缩" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [JSOI2016]灯塔  决策单调性&amp;DP  loj2074</title>
    <link href="http://qiulyblog.github.io/2019/04/30/%5B%E9%A2%98%E8%A7%A3%5Dloj2047/"/>
    <id>http://qiulyblog.github.io/2019/04/30/[题解]loj2047/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2019-05-05T01:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：<a href="https://loj.ac/problem/2074" target="_blank" rel="noopener">在这呢o(￣︶￣)o</a></p><p>刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了：</p><script type="math/tex; mode=display">h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}</script><p>设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续：</p><a id="more"></a><script type="math/tex; mode=display">f_i=\max\{ h_j +\sqrt{|i−j|}\}-h_i</script><p>发现绝对值很烦人，将绝对值拆开。</p><script type="math/tex; mode=display">f_i=\max(\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\},\max\limits_{j=i}^{n}\{h_j +\sqrt{j-i}\})-h_i</script><p>原序列翻转一下就可以直接计算后面的式子，也就是说我们只需要考虑第一个：</p><script type="math/tex; mode=display">f_i=\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\}-h_i</script><p>假设对于 $i$ 来说 $j$ 是最优的决策，那么如果存在一个小于 $j$ 的 $k$ ，是否在转移一个大于 $i$ 的 $l$ 会更优呢？显然不会，可以知道 $i-k$ 显然是大于 $i-j$ 的，而且根号是增长的越来越慢的。所以如果在 $i$ 时 $k$ 就没有 $j$ 优了，那么在以后所以大于 $i$ 的 $l$ 转移时 $k$ 也不可能比 $j$ 优。</p><p>也就是说上面的式子满足决策单调性，那么我们可以 $O(n\log n)$ 愉快求出了。</p><p>这里说明两个方法：</p><ul><li><strong>1.</strong> 单调队列维护三元组，三元组包含 $v$ (决策点 $v$) ，$l$ (决策点 $v$ 作为最优决策点的最左端点) ，$r$ (决策点 $v$ 作为最优决策点的最右端点) ，每一次排除掉最右端点小于 $i$ 的元素(因为该元素已经没用了) ，插入队列的时候去掉完全劣于 $i$ 的，然后对于折中的二分即可。(具体参见诗人小 $\rm{G}$ 的题解) 。</li><li><strong>2.</strong> 分治计算答案。设 $slove(al,ar,vl,vr)$ 表示在原数组 $al$ 到 $ar$ 这段区间的最优决策点位于 $vl$ 到 $vr$ 区间。我们每一次找到 $al$ 到 $ar$ 的中间点，也就是 $mid$ ，然后在 $vl$ 到 $vr$ 寻找最优的决策点更新 $f_{mid}$ ( $\rm{DP}$ 数组)，设这个最优点为 $g$ 。因为满足决策单调性，$al$ 到 $mid-1$ 的所有点的最优决策点一定在 $vl$ 到 $g$ 之间，右边 $mid+1$ 到 $ar$ 的也同理，就这么分治下去即可。</li></ul><p>实际运用中分治的效率不如三元组，但是代码却好写得多，很短，并且调试难度也大大降低，所以最终我选择了分治……分治的具体细节看代码。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">6e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;ll a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> f1[N],f2[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f1</span><span class="params">(<span class="keyword">int</span> al,<span class="keyword">int</span> ar,<span class="keyword">int</span> vl,<span class="keyword">int</span> vr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(al&gt;ar) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(al+ar)&gt;&gt;<span class="number">1</span>,g=<span class="number">0</span>;</span><br><span class="line">    f1[mid]=a[mid];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vl;i&lt;=min(vr,mid);++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> calc=a[i]+<span class="built_in">sqrt</span>(<span class="keyword">double</span>(mid-i));</span><br><span class="line">        <span class="keyword">if</span>(calc&gt;f1[mid]) f1[mid]=calc,g=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mid;f1[mid]-=a[mid];</span><br><span class="line">    solve_f1(al,mid<span class="number">-1</span>,vl,g),solve_f1(mid+<span class="number">1</span>,ar,g,vr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_f2</span><span class="params">(<span class="keyword">int</span> al,<span class="keyword">int</span> ar,<span class="keyword">int</span> vl,<span class="keyword">int</span> vr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(al&gt;ar) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(al+ar)&gt;&gt;<span class="number">1</span>,g=<span class="number">0</span>;</span><br><span class="line">    f2[mid]=a[mid];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vr;i&gt;=max(vl,mid);--i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> calc=a[i]+<span class="built_in">sqrt</span>(<span class="keyword">double</span>(i-mid));</span><br><span class="line">        <span class="keyword">if</span>(calc&gt;f2[mid]) f2[mid]=calc,g=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mid;f2[mid]-=a[mid];</span><br><span class="line">    solve_f2(al,mid<span class="number">-1</span>,vl,g),solve_f2(mid+<span class="number">1</span>,ar,g,vr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(a[i]);</span><br><span class="line">    solve_f1(<span class="number">1</span>,n,<span class="number">1</span>,n),solve_f2(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line">    <span class="comment">/*最终没有翻转序列，而是选择做两遍分治*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ll)<span class="built_in">ceil</span>(max(f1[i],f2[i])));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：&lt;a href=&quot;https://loj.ac/problem/2074&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在这呢o(￣︶￣)o&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}&lt;/script&gt;&lt;p&gt;设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
      <category term="分治" scheme="http://qiulyblog.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2016]国王饮水记  斜率优化DP  loj2087</title>
    <link href="http://qiulyblog.github.io/2019/04/29/%5B%E9%A2%98%E8%A7%A3%5Dloj2087/"/>
    <id>http://qiulyblog.github.io/2019/04/29/[题解]loj2087/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-29T13:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>可爱的题目传送门：<a href="https://loj.ac/problem/2087" target="_blank" rel="noopener">戳我戳我·(<em>╹▽╹</em>)·</a></p><p>说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧……</p><ul><li><strong>1.</strong> 初始水位小于 $h_1$ 的没有用。</li></ul><p>这很显然。</p><a id="more"></a><ul><li><strong>2.</strong> 如果 $n\leq k$ ，那么只需要将所以大于 $h_1$ 的跟 $1$ 城市连就好了。</li></ul><p>每次连接的城市数越少贡献越大，那么每个逐一连一次一定是最优方案。</p><ul><li><strong>3.</strong> 每次操作必然跟 $1$ 城市有关系。</li></ul><p>不然没贡献。</p><ul><li><strong>4.</strong> 除了 $1$ 号城市，其他每个城市最多连一次。</li></ul><p>因为连过一次的城市的水位已经和 $1$ 城市一样了，简单点说肯定就是废了。</p><ul><li><strong>5.</strong> 每次连的所有城市中最小的 $h_i$ 必然大于上一次链接的最大的 $h_i$ 。</li></ul><p>这很显然，不然不满足最优方案。</p><ul><li><strong>6.</strong> 将所以城市按水位排序后，每次选择的必然是连续一段区间。</li></ul><p>和上一个差不多。</p><ul><li><strong>7.</strong> 每次选择的区间必然和上一次的选择区间接触。</li></ul><p>这很显然。</p><ul><li><strong>8.</strong> 每次选择的区间的长度必定单调不增。</li></ul><p>满足最优，都说了每次连接的城市越少贡献越大。</p><hr><p>那么显然就变成了一个区间问题了，我们需要将这个区间分成若干块。</p><p>设 $f_{i,j}$ 表示排序后前 $i$ 个城市联通了 $j$ 次后 $1$ 号城市的最大水位高度。那么转移直接枚举一个 $k$ ，在新的一次连接中连接了 $k+1$ 到 $i$ 这些城市。转移方程显然：</p><script type="math/tex; mode=display">f_{i,j}=\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1}</script><p>*注：$s_i$ 为前缀和。</p><p>上式的复杂度为 $O(n^2k)$  ，肯定爆炸。但是这个是可以<strong>斜率优化</strong>的：</p><script type="math/tex; mode=display">\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1} =\frac{s_i-(s_k-f_{k,j-1})}{i-(k-1)}\Rightarrow \frac{Y(i)-Y(k)}{X(i)-X(k)}</script><p>然后通过第 $8$ 条性质可以得知 $\texttt{DP}$ 是有<strong>决策单调性</strong>的，故复杂度为 $O(nk)$ 。因为恶心的高精度小数的运算还需要 $O(p)$ 的复杂度，所以最终总时间复杂度为 $O(nkp)$ 。</p><p>我们发现 $k$ 有 $10^9$ ，所以复杂度带 $k$ 的一定假掉了。</p><p>那么观察第 $2$ 条性质会发现，如果 $k$ 大于 $n$ 了直接将 $k$ 设为 $n$ 就好了。也就是说复杂度应该为 $O(n^2p)$ ，这样就是 $86$ 分，通过数据来看会发现这个倾向于大众分，一车厢的人都是这个分数。</p><p>那么如果想要 $\texttt{AC}$ 的话需要最后一条很迷的性质：</p><ul><li><strong>9.</strong> 因为 $h$ 各不同，选择的区间最多只有 $14$ 个区间长度大于 $1$ ，其他的区间均等于 $1$ 。</li></ul><p>很迷，准确的说这样的区间是 $O(\log\frac{nh}{\min_i\{h_i-h_{i-1}\}})$ 个。</p><p>证明不会……但是这里写了证明(唯一的且很迷的证明)：<a href="https://github.com/qiulyblog/image/blob/master/[NOI2016]%E5%9B%BD%E7%8E%8B%E9%A5%AE%E6%B0%B4%E8%AE%B0%E9%A2%98%E8%A7%A3.pdf?raw=true" target="_blank" rel="noopener">哈哈我是传送门O(∩_∩)O</a></p><p>那么就丢代码了，实际上是需要高精小数的，这里先给出一个除去高精小数板子的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">8e3</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Decimal ans;</span><br><span class="line"><span class="keyword">int</span> n,k,p,lim,h[N],s[N],pre[N][<span class="number">16</span>],tot;</span><br><span class="line"><span class="keyword">int</span> q[N],head,tail;</span><br><span class="line"><span class="keyword">double</span> f[N][<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span><span class="keyword">double</span> x,y;&#125;t[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(point a,point b)</span> </span>&#123;<span class="keyword">return</span> (a.y-b.y)/(a.x-b.x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Decimal <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!j) <span class="keyword">return</span> h[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> (solve(pre[i][j],j<span class="number">-1</span>)+s[i]-s[pre[i][j]])/(i-pre[i][j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;k,&amp;p,&amp;h[tot=<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;h[i]);</span><br><span class="line">        <span class="keyword">if</span>(h[i]&gt;h[<span class="number">1</span>]) h[++tot]=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    n=tot;sort(&amp;h[<span class="number">1</span>],&amp;h[n+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i][<span class="number">0</span>]=h[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]=s[i<span class="number">-1</span>]+h[i];</span><br><span class="line">    k=min(k,n),lim=min(k,<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lim;++j) &#123;</span><br><span class="line">        q[head=tail=<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t[i]=(point)&#123;i<span class="number">-1</span>,s[i]-f[i][j<span class="number">-1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            point now=(point)&#123;i,s[i]&#125;;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(now,t[q[head]])&lt;slope(now,t[q[head+<span class="number">1</span>]])) ++head;</span><br><span class="line">            f[i][j]=(f[q[head]][j<span class="number">-1</span>]+s[i]-s[q[head]])/(i-q[head]+<span class="number">1</span>);</span><br><span class="line">            pre[i][j]=q[head];</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(t[q[tail]],t[q[tail<span class="number">-1</span>]])&gt;slope(t[q[tail]],t[i])) --tail;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=n-k+lim,pos;</span><br><span class="line">    <span class="keyword">double</span> mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;++i) </span><br><span class="line">        <span class="keyword">if</span>(f[m][i]&gt;mx) mx=f[m][i],pos=i;</span><br><span class="line">    ans=solve(m,pos);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=n;++i) ans=(ans+h[i])/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans.to_string(p&lt;&lt;<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么高精度小数板子的下载链接就贴这了：<a href="https://loj.ac/problem/2087/download/additional_file" target="_blank" rel="noopener">$loj$ 的下载地址传送们(～￣▽￣)～</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可爱的题目传送门：&lt;a href=&quot;https://loj.ac/problem/2087&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳我戳我·(&lt;em&gt;╹▽╹&lt;/em&gt;)·&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1.&lt;/strong&gt; 初始水位小于 $h_1$ 的没有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这很显然。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 小谈斜率优化</title>
    <link href="http://qiulyblog.github.io/2019/04/28/%5B%E7%AE%97%E6%B3%95%5D%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://qiulyblog.github.io/2019/04/28/[算法]斜率优化/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-05-06T05:42:53.964Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="再此输入你的密码以便阅读全文" />    <label for="pass">再此输入你的密码以便阅读全文</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX185xJo3sxpxgyGNCMB4z5znhMcT+GhSHAzSyjCUP26pXNMnFbP7x9tvk48dgOHiBmPSDgZFLw6cmfnBZKYsSXXEhlAJnQLzj8g0IRzlRN+OcUTfqyISsEXkfQ7auiYFKuADC1kmmkIbwqZmHEWpFx6jVLAUGdQNup33MKnwslxDoBQt/+NMBLB9q55NcaEQfzNi7C7ZEjGJX5kiScvvawL7qRy5tB8AY5nvvhyl+YAkBiz0zSlNSNCT8ZDWocC/2iXb7dgU0Yj3I4Xxi1syOt6RqdJ1LeO4ffBHpvyX+t/m86nC5ubdtD5IQmq6TyED6Q365UL+slscM2sAUCGaJPKXxFtLVD2uAJ767dY9a3OPN5rF28d9ZdgaCaUHglHUdSGrHXsEDljkI/oJ2mpGnQzFt/5BWEVT87KjDjZTBOq5KnVrSbUEOrDwuhdwj9lizPkN68anuhOKgLvaEE7bsk1b1QzC3f6GviBaKbGJYMx5qSQ0k6rv7rFZwniC/XmkYb6gNitfwdZE4kqNfuISPMmqzoAtbZmenJ4xR1IfX1E3EGyDJMjj0+RpoqLmtdT0OZiy2gubVIdiljCe0DxfGYXmmQuS7GFoTWNvJKAQsVnpbUwQB4QtZxf/+IMbJsaV+57jLED3XdJsR/my6M6I/7jNe99aMi6kKXukjdfuPqF70W5ERkeSZZ+6suLjeDK/lKfzutzNzB6HRM0SBziZgbZvODWO9lP8FyGg79l5KHjgWABO5uUweN5pTJNr1uZmC++KCJkbYZv5dJATpB6zrnKZ/3ZKXjnBZSIHJeOrb0d0EGmH8oEfO9kCy7bX5Kj0c7Zulq+sU7r9rRx4ZM6z7hjg1JzuDa5KkIZPqrotuZwkFxhXi5W2gdl3+IYrQkvoAhBE4OmuKDWOVYh7JoeMZYHKmtIC3MSM+a4jP5K2VaRl9hnOmGx0O6bEdE311Ztt6pZE6usKtxRdS8pEPY0twLlv3x9mc68aSB/zrRg6TU6Xj0aGl+X+kHnKSCOQ76T+HMTgzxeqywD0GGCF9pmm+3wXWm8ckg39Xtz9YBMNVnsuZE4Y95El1cqaHVNBzzhNdR7nUafS/Pyh4i7nguHsGWst88pLMrZSjJzQsWwSs/2E/N/ePcUep3nsY02VqE6FxdX76pmdYPnBRFYKr0EXgkNsePLiSOIIm/CcyWIV1OEkN/j7hXdOzoiVXwDQY4XfSPApql1+CZpPvUpmgpIoOnBU4KtH+2mUtTAE8CMD+zdZa11FL7wkkEox9UnrWaa1jvyBebumdrEpL9TRUZgxaMs7f5W+N7Hu/fpLAr/x4tmUbANTTL11rz7dqBYWkR6sFb+jgeqRPg232f6ULC1P6JmsDLVEpq9BKyqtFTToIWyAtK/VXW5Hmu+oc959C8V/+DXvmzL7DcBpHWKZkbzUhjkciijkRXr3VTWOz3OgADEXHmWTLvbgMaI5ItYT0BdJK4avyg1QJ07LF/+uNXDNR9ff4ok8pnsET0WFUVeyXSJMmwj4QPBVe2h1wFJ+pi5q/3fYAdSG44dN2zGj+B3247ycQfuaEu6difXOr+N8eJpOesgoR3Q+kl2zUiO48m/i+ycfF/vzlGuURRtSkx3KZ8Bz/KplwidRBswFRDTWFXiANvbNiJfnhRxbeY9Zc9WGQhhzVCck1XfYo3+xy36hFCwueHvJi3J49TU5RzoqhDeW7TfwTcTjsgAoyhqqEdaOuTwWbVe22HfVGeHM5GjdW4DdT/kJafrxp8TEkHHB7iz+739+ZQetReim2znBt6PfotjhVPFpCMdT3hQOjf+PNs9UeX6Ni12KvygsfRDJvsWTIzxMPVHlAHHey3i42O0Pd/UB8CqyNAyVvg54QpetuAJ1U1Njwt9a7vqBfjKBFkSYPbYCTzjH3zfA7BbWh6kGF2ynQF4Krfg68otXJu82YTo0gD8lisCfx7Si1twksm5Wut6uinmL1Gi/bsTAVMZk4s+HO3Ck0Y0nNveBJv4A6PQFF105u7oZKDboB+CMGkpG+RkcupNWx/0SKPAKld4CjAKBGTaV3fIUVUaLy4vx5+OnIwO9kwo89v9fYHXUna1MDgAehrEGd8+qO/DoHsA1i26IpxEpWKhcML5LvHPY2lOMLPY/8Pgyyekg6178OGOnafxDjlnxuA8O907qCuywQNdgK3SmmJYMzNHUaXcBQHajDlC3WQrV6oxrmEOik2Q2tILNlkn7J8D8VyKeyUiMe46RPLf2jYh13JF/5zhsadxefeDOfJcwoTR42phe4FosL2Ur7VpJmCBTUfgPgsG/jn6xwpbOpXHMEZm//zBMUtxWXOxd5W+R4zH2QnNKe42671WsYtTrLuJVhawGkFNkeeULQq8R2HihE093BjwdtIfSEjGrHWZcuhybv1kZK2ICeXQByLUBYWrI3DTo3PWDvBVfvUjXTZOjAmabcI0l8fSOkU2CdFbqAygVQRTBTuhwoX5C7GeQrf2hs56Wh4ciPQCdF9+v1LUSk/f0bB1cZ5GSzhXeNqlii2bVHMOPLqr1LUkY5Oq7nWfmhifHt3bj0YmLU5jW9inb7YygaRON0fb87aAlTEyUt0QuiexSNWwM1MD7HL5OFiB7ItFnnozBSc1pBt4p4zTB1HwGLSgmEvImL/6mawDWIoU+RSoDXSSlV3NiO6MCNMWVFpbuYY8D2nf90OwoFsjJnZUAxrjDIGP/JCYDd8ze3x1dEz6aXf1PKEdlLqcLhgnkdOL3uxzxh34RKSje+vqVNOpjJAUVJsunlqpQGZfCPcTpfcBmqaMdaCALEEq6k7pJWrl/KXeJ+K+X1erJW8p9QJNpTtHccOAbYUhvUWN0ebw3Ae04Dk26pYc71UsshLLZw5kCl1tpcHEzsDrgQ0zJQCKD8LkCoKCSNcgv9o/VYRmKY8IbXiD91wbnJeiNCW8mqobdPA2lczU34ksau9okx2GR8k8b8fsopY1f2NiXRg1+zuh7c6gBPYBfwdKm3UN7zJKdEtAS/iOVTwmrkBNHc8EeTwoS1be6IqVtMr8gjRGHdLrMaMQWeBelxLAdVse2Dv3IQu/taEELuLnbWN/vM3G4qK3QdScogYu72LMvgWRrLmWPB1zGOYo97n78Sa2m4JpVByhJHGXXSNJc3l+SWobRj/KciNQGu9wUCgcxT1QAHGjfDT6lytICWZky2vwcAo7cV3UTkNgmogjPyyLxd36b11JBx2sVuBB4nMA/ekvVHeInWH+yuW8jKfgM1rXmnnpwOAsL4lHGvbphSe1IAr7vxgKBqANxJ/hIh7Kelzuv2Sk1MOvsKJZyidbDuS/vESrCvPrRbff3GIvnAOtrl3aiK1A519swBzKKax6BKiCVSYLV8DCV4WL4RrRe0TKxQT96Gy1KJkZTdbKVXYfkI7cKKNI/EGEQp9gzL0rkaooJixNKPduAzaDIS78nYcqXY+1fVko6ImRGGJnwaA9W6csgtQkzWpi98S4oW5SZv4O7fq2f45qSJUN2BhIUJ9MYLDdVT+cLcUr0Xs9yRpGM1M0XYd5oHvLBEm2OYqEUDD93FvTXCg5ywOi9FcS2PnrZNsMBSKzROIjXzaFXsQxFPzQDW6FdhNkZEWDx73hhPq8YZc2v0wYpedK3QqcQ1WkLUtpa/UmbAMpi6RGWgu9iWUKs8oPmpGnSoH7nH9CD6R2K39utCVgEg8ZOeyX3xNka4QYB9SSPVdEI82dHTuFGC+wqnz+67soKZlNhYgMlgV2fEYsJTowTir1uV7BRJEHmoKyn2fU76rdCaHKMcGc3XfOIpSEAXGp7C4C81/RXc+1NHjd+Ce9pGlsjjG9RGldi8/+S5CyAFjdtZISPu0jkXU7Mica4IfVrW1wrbWlwAEq7Kp7w8z19DNQ+Dbj6DdWM5KvVHOg7ECp6AmW3fY053eBVNyrXcBrmCTz3nlI210ORjOedfeOesBMUD7hn55k6znNcSL3kkgiygfxRK/K9VfPhpbVd5WexSYlZM/RIOdr5/w96WTjcwFpkP0GRvGd4A718c1NbiLvPh5rEGMpt3z/AiCBl7CSV+5SrEk5dqGd8CO04NU+75lXrXLTzG6R+JsDGh2weeyxy+EcmMoHJFXFJrZ6trw7HWXqSNfxyrYZilN+qStUCF/scj8uif8BE6JRWDYLPsCk5hNiVYRLqmiHGKXnoQq6kYEVJybU72X/xLNGdsPxKW1Sj3k7sPyMWrKvEzkS0cMG9+HKH1aAyLM5WtA4uWc53XaMGkxcfjGt7+kK5qu4HyRlU6xRFgqHInxJRoZAc0C/JDxsC8DWxlG/TmnJW/KS5odUhqm6pt+gGj9Zv0II8OPXr/Q75Wdr4WdEiP25nrlXKpkkF7gyS4tr3GswMZKPWWTPkXsmvs5bW+3TKzOgYfJEqLvBdArGZObTlbmhoUPmSzNKcDjMMFRiWzgF5lDz4Cp/XPkbvuPJ4Vqvz9zzrkLdv0rb751yiW99PU2wu/xYU//qt6Zgw7NsiIo9AyAlg18DWeCvb/q/hv2mJPZaeuFXL9oxCM0Q5fdzLdx1UBeCeAzhQqwinvEIIjgC3ydsuC/yC7OcfRfoc3ImpWCl8pZ+br7Rmoxq/s/e0Pztjw0qOIyJYDYuMZjzZ/sBbtNauQ5X4SrbgeueKQxijQI8QoHTApgdpd7ys8Tp689jyBOUOJg/RsiH/4usig+qftxo3FKtQ4jVEAp3DiIRLFatbFVXJdnecL5sDQH7dMEANkWxuk3SfhBipbMcBbhh9cuLd2gq87fai0/3YAl7ZgYiJhFd/B+HOcZactVxBFuG8u6ndQ8I5PUCJtm1X4NsFkxRbh2UJg4EU9kZ5vNeWaiHeLtCidesC3r7TEYaU61N3vmOcI2kzyJjLvs+9ojty3PJJtaQvvIV3vWMnRjv4/R5Jp/gBxn5MtyEbJCsErWhxSvVlWC11WsKXAzL9DNc8uFFv0DAd+tSuPLFQlFaGek3XbzlKXALL2ypwY8bMmplIHlr4PTVujxUz5tJlabYFbF3097NiKUIWzn8hJDOUZoh2o5++yYfN3FUOJJjbsXjfXXS+46I4VPc00AhjwiJ4tb0nOKkyHOX+Of9LF30ZtoG/syJjg632IKJyPQnY4MGMsOy/fBkqTID3o8Ak6gAlDXAyed6E2eJpgdb4AwP2I8K3VT3uKTZJZKbiF1szw+zCeSTiNUIW91Q5pFKBaF1GZeyJ2M3OkDXf1h9MBdS6dy5oekpAE1pYYj2MjlbVzRptdmHb+26k4EQZMsNRVXaccrEFYlHY91ANEyhCMhNAtk3f6hTUEVAmP3K/B/86lzcYt2SRm7eJy94UB2wKxiqHfxTqAXB9FPnj8DA5jZwQwkswhRNPCcBmy/Dp5gNCYfkeoAxP29YAFaG+9XsvDb8Z/vs9fzhg4s8s/kuLoiacXdWe2Kld7WXI3ovPt882sz83wjj881uozy2RIZqmFXI84eeoBzJZom5RyeVdaiCPiSZ9ABXF5aMaoPdqSv7aPkzNCelCNc1UNXnd9X782xog7ohnX+c0KY19qB4klmIIjXEFLecWcCjP6AM+g6UiYkZ78J661lW+bwva+8zx6w5pHylQKs9XNyNcq0PjZwECkcWlJmHzQY0ONC8APoQkrWVIFnh3PHmPNHXx47WHvI+X4TRR2xo/aZXiu3igqxcBmfDpX5ho7EunYoeLAq6KZQboiRiBSzowlhCoxE7L1G8wifCvfMHzVu4k6I5AV/JjFkeKZvGHY0Xt/mKYrcRF7nI2XyoBc7Ld6agwUM30E5Bkg67r7P0w1FEVYkNOvxuWTlh3QcgrVJwTqwDEtvAyT++g0rersexYLWVIn0Nxfp+rggSCCaQP+2AzOo7lMFf6Vs/DrqvyCo4VapKzT2Te2sD9872Tsnb/xXFeR/aciQypwo71P6BdsN6LcxlSXyLd+ilqEPH0tLjER3lOxOm6ivlxvXfZ2kvPJlWRRTt8JXAgMTZmO8TqWK1iL4yUQrndrehbqi5ZdyMXbWvopamfHE7dwje3vtWE+P2NEJ/azjF5JEWVD3+B0YPiDWib5I6nHOBeO+9tqhQgsONI+B+lkfUi13nMUhV2Okf8+GUKlQsPAFz0rvLn8Ad007ar6fgZU78hNdPlT7kgXS6R/+gI+lE+6o8Ap+oQc3e2EMXuDAI83C8d1smCXgHUAQBCpXKWNXm9UMDpqxELMePMZzN7FQJYGG/QuXo7yIpAJfUtTemzTwvUtDAuzuvMJLBAiRvKburc4/xhja/cuD28j9cAMYNIlbFWFYZ5fvijtjZxNlVN3NHeYKSo3Z+aujeg5An1WlJq6QMbVYCMSnJ7KZuFZJP/KCS4IuqEGMkBxSjOOQIfOQK3bEC1NW8Omu6Jcz5JHYHtqSaSgk12Otk9DoJArrGOC3IApM5FQ+oVno/1K59TYSyv12tRYoGgTbcKisj3pH7ea3exTO2lJg4skFQWxujw67jP3p8DksWvkNB3udw5jlNBp7ehb4y+lw8PMHw98i1QV+ntqWcWEZVE/8K7iUD9Qya+A0XM9luJfgQJ3Eyer85J6em8Vepo3gOAkqQgChWnFBlvfJU5aEJEpaZqNWUjDNaLWFFOlbXEc8Rn+VvmXf1mRUMn3QbT969XmjleJh+h3cOl26IJPkI8B72ZFpICMaZ0HDNyvygAu3cpznjGFzNhTIAVnz5vO35sR3c+CWUN/krTxu+bTY+YOIebE57LINd6qoGu90cDPnjMu6/vIbLtqfeM4GIe6emHCJ8dsQvEOKrTyK1dlw5PsA2YqBg3L5hc5+TKPTU9eQN3y9smPsfjEgnmgIOjivEjijEKPkiKZOv9CEd2ADfrwtdCJHa3c2MMPOSrjK3qIThF/kPISamSxnLL+XK83JraQIoAheabJHh4z9Pb4uQCh8FHAV95LJTiVL0poz7OtYnPHh6EF+N+QbMTZvdqY7SuEMwgVGV5MS/u7Dk8DsyNa4GxnbMYoH7t42nAP+7D43ANGtyePhul3U+2IhsTGzrpdv5f1rTFKBk5fcy8UQZnEkRL5fhyt9ku2AxY4eLtq9h4Vi5/Vy7LS2usRw3Ur212rnUwSM6VY5GOX2knLho+qNPdvf2antfhvJzYFnvbhU7C16oD5HL/XcJntpgFUtBCIzsgY7UCXiIYLsKn6lNkR+IEHGKAyLa1Us1huayCUo7PgfWg0PVQWCPGbQAbd83yB6F7uP0/fzHFp57MCam914H/AacepOL5tfa7cqFhlYWFMIAaBDYzYxxPv1fDxzKrv6cIehwkntY6Uy/y3UEgXz3pG+PlOFGepihNkThDG6VHi9Td5r/iMKb3XkPBpGdIxUKKA15sc9F1+B99trE3l1G2tq+uE3Si5roIEGybZd3tVyfibZWOUqKp4yidHoPlJt5gf5M6LiK8KQnlIE7X1vM2YsX3+goFwT4AciolgGzUXU5EL6vMsU1R5C+Azh1tDZwxTZ8P0QUq+Fq7ozeaPwPPqD5YgZj9mfbc0U72IPn9MWQZ1l968QpPMu43Ujv8L7Q7N7VhUfkT7zRtBEnxrMHERdHvDwR0kL3iV5YvoT5uDBhrDIgV59tONM4msXg2FQgjyT6QPMMYitQve0fNI/GGxvpB/UC4t0CB5Zgehq5m6T1pIjMFPQm6F58fQfze61u4TTUSTE6q6j44kHUDcqhDkgGnBkVIyYPpxv4mJG/+B1Q+3pK1WGokcOTFJtIbKQU+RgRYFjSGlWF/WoMYSHBdbULRiI1RGppvORP/I3pm0P82g3ER9TDPllRV5d5Wz/Opir6kykTgF/nwLHtCKZpDN2cnmOvhVvbX75HzwuWvQQURN55JDlN/cHrz47xDrxK/ywWZiR+t1EFVyYlj3cyaU108u9rct0aJ8QjvxzCbfSxA8w+wyx/SaDm3Slfc+a3QltIQK55U/nSmdd9jmierrdC+u7r/f8iEsKUMKZHGzIK3uwex4Gopgoryd2ooKEuDbNTofsqzF9Q3jNnORaiH/WUhWCiiOWOZ0zhuuO2gw33U9KumlZzrMIbpoTxPuAkYFHXhKPikhkEkV7Xjq0fY2JEOPxNr/taGIw3rgoDXRk5/Q6ntRYWrWpQv0pOmoouF0z0vgvIZ1ep6Lu9SlxXUnz+Jhyn4vjItEpOV/qTVVH53vfokqKfbTEZsWGMDN2y1/UihuXTwWrp5/QdR/U2M0TxJxo0vYr79a+tUhWE2WHN2wzBTi91SX2aMqE6079SWi562mk68o2knAyXGUt+/SvV6nB3EPohVy6Jt2G5uZtZR+LAa5BQyiok9QOwsoZRwFYnT/pdSKyek7MyYBwLdzf7V6B9ZkKBLPMsfH8mditnTbYlfW1Smy2UiABPtpXNGNIajWTPVS3d4X/9/zJmUuHwnVJVikUU5/A3h8MRt2W3LCep5+0FCIdKpUxwJfIxcs2FD7gBaixFMwnqo2O8GaJkN/DM+lAcB1M8nspjpvN+DysvVm93nomVPQ2AJGrE+WG7Z/WQROgHNMe1VqT1eGa80td3cF9NMCFjiK2clib7rStwl9c3CsWn70MPPjH3BaaY0Jo76+djHOcxEk3AOpYjgEb/Ka+aRaics4+x4IpA36YEODKDh4lU/+VeS0uM4Fm+ERhZiwb3Kc9fTTgh0izTzn4J1FTVeolAMkLJHjvmUR3YcrzafRBmXbRrd7fE1ucIDNEZ7Yhl2GjbwYCV6oYiSFXAwEIWSy34iAeG0d65ylYH+JBB41D2PMr6an+FhqCEaC5nXbob6mfcbXRkZOA2yhGNTFer+WwkobVf59768fL1kmitfVzbRKlJwtVWu3KpGKBag7ZkoMlQi/UMlmomA8b1oQShuax37gviewR9ZW2pmG46ZBLJboS5CUjRaibU0LqPVHOcATW1rZHQvRZPFZgsmKHrsiDf7OGFJz+vpIjqbQLQXugyKiNIqahBmAS8v3F3T+cnF1l4m8du5XZNgPQ/dL/Ekok4ZT2/OONymha2NNhHTmTQhOXHKPRxd4nK0DbCO6x10tUo+8bp09F3l/Z0XPCA80jAj4uqAZueAHJpuQK3e+DEyllNx4JS6MEkrDv5MqTNUmNcmF/WWApl5ljScI2syZysi/VS+a302z6BKx1Vuo7SWfhl+pUMiN8n69d9zK9UFNvK5zMzb9q5XNv8nCbpn5HgjlkHBsMKeNELKnSi1t9xCYHQbR4+l0juLtpfHQ1qzxuXY47FRkBZXrGPRgIVeKy49dB0WSrhy6ACH9wSci/HHd1Kh8S79CdAucknlT7O1K5OaIxJ8ex6i9hCN136wOcspC87GTc1GpAoX/WdPhWBPktxPa23RSKj4gi1Icj3jq4hpuyEKGjv1qOQxL4HenlHw0TRqt/xaxqW9NAU0C261MxVFb01mC+n+8pNjCQEEV/eUSJKWlO9jod7iEsPbbkJRexeCfSljprRrAm2pGUcBvn5qWe1GSGcy23eOe3GZUBRsnwq1E2SXCIGY8YdzKdRnw6fefm4aD8bfqQtO8zRS87NVKfbYbx5T+WZguebSNOtc+Quq0siasM9SCLK/5Quqm0ZTOME8EPU5gLw34NkbI9Q4H3Hl5lGA2bWQOxsttjj5HgDN0iOWWGtU4LZjUGuziafxFhE174Jb0JsRy4zAtDhjnpGe4oLBxsgKfR9UxUWxlCXp3kCj8cgfeviBE3SUKRrIKK2yI3fcyAxtcCH7uShdXeFrN5DSTe/hxgnjzWdgb9DiPOV4EHVEqSIkNhp9xSwn1rzKOlvikrnEMTG8K3OGhkCPfv+8EvXLWl9XvY2GuoooeDu++jRgIYJole+ftMlLvfSBj9xjCJgVAJxN3XoO9eD63AMZrOJkv1utc2ngR+14XbNJMnF/clUogKLcDJ5cg5gEQJ+asf/1TQt3GNW1sLtdYKe4Xpa4k+K0r38VPkRGG2of55V0M9bSNmY613iEbTMJCC9EXQIgIKnCsH5fRd7+uoaSX89oLxG/nCT5LlKKwrbjNvm7ihbZMbOffom6JOu038xRxhbXn1lurM5KdWatJgNlq+sfG3vpSz3lh8EfdW+xQpjoqeyQ+NfARDOJTA44jkQijBgG2nh/mn6rzQjWb1kuOrqwehleAgjylyeodRP0lRHvXfGcfKFBei+ZtXrsuvl4XTBkK320L/k5VSkRAN9f6XqQFvGBXZSzaIvocEtmOsngJnwq1i3p1vffBqEMTGjErBBZa9ToeibYGRQykNUC006c0hh02wOo3c/Y+dc9ldA426xg2fpldbYO51kzhyxmuI8awnHrEAWnaP6NcYrnT+0jbR9+K2Ga0cgoms8XNod4tvlCOO5sKagDo+5jbvL7qtVLGeZgssMwgRglF3wdWDUmTsELp8Yydh7w0RMx34UG4vynUoUHpJJyCxEgxTSKAx+QecArFviUi52CX44nre5+t1gFGpWdYeH1/3p1dVpHL8d2hDjdNn+6B6/XcvaGSam+YZelg/BqzFUnf33v0ZtE1sVM12VP/Wkyz/fLPMoEj81fFwJv+8McJD+S4y0dSVlejqNuXfL9/5piK6IACp3ctqZlIGONKlrEw3zGUOqU1gOTNcTyQsszGGdUoz1fb4RCjLI+V4/QWOEnzwOZFc4CGfW3wGlSYz+53nGtVKHgEox84S2s1Z/gnkKBPlU6XBjcF2m/Oi15xpaQzDm4/uBXEMp5mZejFydw1WA67CD32F00nDII2ADW0jul2mAnsr7i2MAXb6xwSPlFH4SKXZ4lhtEZAKikFpBIQg3Ur715q+4+Tt04YnUxLmjLqlxfhHRgsjKb1EO2c9sIsy1To0APXvSNHF2Jio1L4QspTdmFrVbDNGzOZyelKZTXIIz4g9IMOr/aXhfXlPVbHWP5vZzXVevBSE/qS4tiuHPqcmBWXj2ykaR5v1jQcc9imGrGAwArn1ILop2mNWt2jLXD5Bkp1tTRPZx4lCq+nzUMtMbEzsfpEwUk5d83tp1YdWOUPsGmrF1JRpBIdKcdrBSoxqBIqBj2GpiAv/tuyu5Fz/EiTfbmknumwgdrwRN3Cb0KZ7SRYT7fHr6XNVx2BGCK2IKmOTefn+gjghDq/EsXbDzoVLuyTcSK69JNTmWamJV9nAsQ8bGYFgIoG9orN4xoSvvolbigweLq8BA66YlyEql5PutH9KF0ppXBYteND036DJWJlxkBpQhOlWrxbaqKkvYpnwoJxqpnrqY3KZUJRVos7Y8sfgNRVyTROTsPX9bKUhN7e0Mv0vWT6Rcic2OwfEhGXhmKn/Df35ToQ/JG8lSRXIW7IZHvfRkuOEJ963XwxJ0Qq1n1He9PeOYGiuguWYaBc6jlCLZk24wZK+t7qKKZu1jOSUR32m445q96Mm0VeMPAiDxtWrGLsBnL9qqp3BpRN60CGIwCTIf2iwZWGyCQFzPVpOcOTE/Esj+FwzwCQkUStjEdv/WWr5sz8/v0hhq2Baqz79Qlz+eadmzujoD7hGlFg+6VW6YSTzpAX6MaTsPdhx6o7Okxm1UbjzE39iIF4ohotir3ORuRwqTyYieRVn4Fl0oJ0FXafm0gVBmOweADejLK1n22SCqmO7wTBZbXhghuWOLEtk/tDyyRRA1iP6SQGLJ+s3pwWoOJfUhSVb8si7ZdvdlR/bSmimh5CkWYVJ2KOJhWX/M9rJyzlHAd74+AySa4JRL8k6U48fRiE5iSdk0o86MC/RS4kLC9Y+hhRJEWUziKAZpmvxj/MhNGB5F/Jrk/NBCAB9ejL+vjjJ1h3edXoBJG75h80X7D9RA0PJBN+bphLUEskqiGy+ydFZSbZDGnR2GDNDXmKRzrbc90pvbkK3SYT78Sgf0YmVcx2cdf68xJsI8XZ/2GYOONIz3XACSBFEE0+eRyv9G+UE/OnoAXBZ0Z2l5B1CDfnFceeFNLw6egjVHZvymt6Ul7hR4czLPqP0uqz43JMDOAHe4czJNT13AxNmwn52eumxxhZNBOjr7hgHJjRhLLGw6TQmmfNs+77PwOAvwHhTHe/WAEpBfaoFYcFySK4DrNiAcmHjTMrrd/FuU72PvmaQAP+Ce880cZJPpPXb2qwCr5ZsxSoos/fPA/6REmxR29Mf0jogJgrP8YXEYS1+TK8RVRt2L5q8oZA+WyaxY0OVzV3vNb+0O7zR0iYp/7purQYtuTOs/WJ9l3Cv9xOdwWlkOu7oZcHKI5VJueSV7a2CK7M8BcmlYSi85QcUi7Us720u7sD+JY4RbZwWjXvi/Dh/7hnmRkfTcgc1NNadQpeH1rOTb919CtIruDbrMHHDQPXKodC1wI10m9rsZNsfLfQWE5J4NUzD8/dC/AccNQbmI4/NBUI9ZaAZjxi5qcj+JvE22Ycd74Fst8a5hWax6CyXs6q3QpRVR1+3lC47VadKoWEig5NMTw6U3arECkONvl9db+HFafFeyYbpNvbqzkBuAfqb1goTZv+VBl1hqw7k2axEDbeJSW5YGXPoBAA5SmHoUjTfRF6zmi2a7D7jpb/ukGAFjPpUVbQbspIo+iTNTMVnOlCBSvvtPhCGj/9nzYpR04ELB9MEdNf5kXpHPjc0D7aa8vQcBzqlFsBvnDdcmPEEORuMy2puF89jj3VVuJ+DsABLJTL9xztzy5NpJos5bno1BMGT97vqyd8O1JK+63IQCZgx/IElvxed43kJk1C4wLAmuEOLD7jh9YB+ixJ0MblRUW1ukRQKeCqy1RG0GU7oMVeY0G4O8s4hF2OUUWDnKwRHqYcxu7kN9gV4+lfyJ5WNqm9ChMJbhmrfZ96n2UC2WemroMComi9M7tncgghu+446FAN87VfPb64Yc1qUc/y+55MYmjH3fpLLRo3ZPK4cOMIUcge1GKM9+lPnioKPjM1kaTWSv61COvcWuHKozFj3PT4Cil7c9JZHrppiImcKpOvRWQ97kZwEbiV3XQ3w2DtxIzQUTLuIVUai3RQnfuPfMeZ3xFgJQauIcyqGtTiB69MBfCFvzSpVb+l+WCvceKu/CCRr3lLc0+uEhM/ULKvvV1KOS8B4oyVO219UZa93RlvacUrEXzXxwA/Ivxr06QCid79KI8zNtM+EA/KEW0nksascPQk02iVrdvDEKUPiF0FWDOLfVwAYBmi7GeO3DDUkiA2ayYFGE0o2ylAt8+u+jFYP4zOBdEFgBbq4zQDvB0fEzGMZefKaddKSRAFbwrd1n7uldhwS/iuAzAMR0G0udi0tIBt+NZlx02YRw28klhJzNvgphxzJBoIzB50UXLuGUsWP+u7vDPw+BxyOKDHzzhM8XElDi5K+TK5wc4k7Yx1JknTniXlwsIg1hovQR8iFIGJraWA6aUV1KGiLImifezmdR06aqKUn9IyqLR36Eu15squHA44u/YJP7rrPORUi+cWkv56vXfDHJrZkUwmJuNFLY5eObXjgUhuedLYxY3lr+l/H4Ue8+cdFLnl2eCmHWu83mfKS8D2zhQ8CUA9qBIyBlj8Y1iWm6/38K/0eQqB2DIF0h8P8hZhuPSNXlFBIqWXP0uUm2KEA7mtQmfSvb06qHVB2v1fdDbpDN0vlyvRmYA9DAXAHpFCKob0VFNrvJzOra+uLHdmQ3XXKAnRtYUnzEQz4qgVXfum0Hcjh+5Zqsglb9IFnfdqNjmZmP1MzTWklH8rJUzU5wBpz44BYwftVsyNvRWZqGHD1D2G5gKaJ+r4ealPVUDdqx2qYTg/ciNcSk+0MV+clK1CNS4Fu6kMY1l0sivI85DfO+84wF4h9TPpOqTc7ORjOP18V7Tv909ZG4+v5ZCNFEVgWqG+pJucIFj/g6o+d9xQSfr7bCmujLKs/V7mch21iPlyTXsTvOTMEG3NYxyHpsYH5m4KU8MFjf/2O/AqLEiX4RcZk0h3Sjr01mMyeyoK+j7tZVf8B8eAgllBSuMmaGfPVK+8nqq7BJYV0VSnvvgpCU8X64KghSoFZZIlBE3tcZmrUS+7IRPHPkJUTfhbNQR7R+WCQD2K+dlb10XXv50rc4ftx4b25XU0/SKsUNm0OVTy7aOm5ewlk770dDYHKKqarzkD1DssIYioB5HQFNh+v9G1g88XghkFLy3VMLPy/HZx+9LOJSDsUx7pqu5cihsm1nkLKLNPBp1xnHsh3W6A0om4mylx2G5rsPsyIon8X9OAggCOl0aAqBXbMtSucDTPSaQYOB0Oh+tmOXXdGA5/tp6+1I2gwq7UFxJ7mtIR1klEXCxfxgngb5fdfLEp1MsZOFmyprcwE+XBCqwmY4U7skvLqHze2WJGnaJ/n/KHMiZ/9cjWuACtnuMVbJD7AqYcWBUgj6mfYPu45d5aglOcOkB7hf4OiwFru9vrbZ6lw+lGxzYIWltNjFUIjM0u9ci0S4i7Ou1ukzndpsY8P7XEJEAIbTufb284nkob1VafZaeo5cZjgD/N9furZ+ho7wiUo+Q6m635CVn1VSKvyJvJdQTcxL1pb/Uh7so6SnqXyGD6hkgVH1h7IYGSftHt9X0DWMAbdovAiZWm2/LM7AHRea5PGIj/r5BTTZf6W4YOxEAWV57dz5K6CVM90IEiEQNQuEflMI0Ar7Z/u8eGKld9SuA3UK4tnp6utSs7X/Bwq0k0ngITqBAhRtpKmY0y0eX5celS4HQln4dR+vgmdzvTNMt6z+64x9rztLDyiSYuNu0+lrmXeMK5EjKkygH1+1WGnG6/WA4fSRtkWCOxF82oBFdOtF5ToogleHPjO3z8hmxT6vFYelqveVSy63Ten4Rx13cZKOi83j6gUEVO/NGbZOXX5qv0vplhOcMV4G39475eT9zUoYVrMD9wCHcozbe0sWGdj90MovtRWGT7r/z3VUSR8ZfCRDus2BRXppMS0q29Zs4ScU5fIu/+bUvtSwb9TojguqKqlT0UDDTpVejxB+a1yrd5WYP1Jktdj4Y1vCVg9hNqdmbiql+/8hpXsXLEbB2XqdaCo0ZaLBDwDfKMX1S9F+nq2Gsoy/CP/R6KHPy2K2U35QM+x7K0SidD5iMJvy6ZyY/rjLgKLwpgpkrO2F669jDTh39kVK1Eh3sielAKwBJ0uHPbdLh2ic8iuB5Xgu9/rQsRtzpdOySraMQqxSt6ZHrJ3hi86bkga652o5ro3rDeojADFC/BELafaHPDA9YXLZDdIDQuC1vgM02V4U7sxJfrwf05ys+ibDc7R81lk7pWayUVB8+DFGFJjXRYxYj9ObmbVBrYAyc2F4tdSwSSTaEl+JhJolM+3DboNoe+ozVwbkO/CuQMd2CpmoaTbYOfD/5YsXJfbgwZLikreuzRH7thEb9Foe2dxwPKTxd8ZcurYwFRNkmHVHBkRtolIKxW81vGZFNYD87MPyNK6nCcLoUnq/wvR4PTUxbKR2BRs/heYGp4CYxKUAPffZ8w1F77Wzt2lTLvsQcUBXUzO0h1wGCPs0+yv4dDMSh6pDntC2f/t+jDoYD2qSqEseeVjaRnMoSjP1uiPzXsLG29dsj97MbMNDwJq2InbDFshZOKDq5sLboQjb/IcbJr0lwU5d3ckJNBZIHQS3dyNfjQZoVNzi6M8hAPMT8Pvx3j5fyoF/jQAVcMIudeXpmuX3z2BrO6yoYaVifEFhIjkateoObk/ZyS10Uoz0AQ31BEtvFoVr4wyujyBqJc7lH6LrXM5jcFODWDeF9iaTPSNXp9a44W3pRc+aQyeu2TnwTZRDcaIuoXyDyf2PUu/2nHkOcSYMobiZqnHJFUE5dwE+OBkzzw+B7IW+NdUljKapassCfPqva54vNEt9QnLEL5QU+vY+2rtjJSTATOtY4u/w7jM7XlSfFQI+ipBNFh2oTMN3+nesYs+DDunxDsV7zbAuCkpcMFyH9ZJcWSJjmL4ptUVxYfbYnu5aM6djSIOdpxDJ1HkUTguD5pOZ/zitdqKrX8leGfZPHcwQeFlxZP/vxo/mTeDMx83vdDUmJ7/uQNA2BtNcls6EpKI9vAL6rhRMiwS2oyim4pgiS6niumxK0k3wTH2JWvxcvkw8yOxEm0wHg0JGejrbIQbPR6u9YunENEZATpW4zs0tO4HcgJDCuYWjUT34f0FjQ3SRxHpQ9jTb3506lPxQJ9kZkmeb6I9eEID+snLYUaP6+wwlExtX4/5TFPFadRtFw3UaoV2WhffftPmWFfcaD6XwfDLXOj2xoHB69+NT0jUDq0rMBg3SqJCAftyW2tGSLtrWFj2ueH0MRZbhSpoPQE9EjOyDLYmucXDp274kGKzoF9nJ38l1/I348LqMQzzC9YeSB3IVlL3EhRSas8KKn8cgez6+U/x51gcoBfM3MJ8VD4M6hydB6ysWBPAnf3rDBInGz+e3HUX9QgDFrFX6EW/GN2vX77+t6thDYdYD4zwOQx+f3MDv/Q76iN463PvHDJFtFQYaNIrZY8gjIHVDzJer6OEUi537OlQe84EUd6PKmczjDgc2yJASQz2xcaWelY5dLE/e0xwE0xle557pyGfXwgvl1alg+EMQYnQsm4MBG6FmupevI9exyZ3gOXYxt7xcd6t4T3YjMNqsOnCJ9xU5q+HjOdSrMcXrZdSR4MEKZxn6qljU/tuTQclXDQYr2cCU6KRwjq3/RSgF8uQhs+BZk8z5u/5wdMkAldK0CZKe8mp7XB/VwFHkZ9mlgIcPp8Klc1Et+MR4AgcZQMBXD8vboG5VbNpJj6HQxs0UGOc5HKmg9R/REYHvo5NhMLpgUfDI52zPMRJGM4Krj8HfFZQiJCWsPu/nSJsuaCEVAwEifEe+gUL2HwKOjb7eUQhG7x7nzC2v9jvUmajtqcIA2u6Yzo3ESMePaj0ym8bEjqiB9yBCba6u0fINQ/ZPza/3p9TpoHxaJgpav1cOkPQfAe3g33EzYez744rOfJ00CNM1Z/LpK/92+3FNWqNvLRZUJm3evrXZtc4B8ILJ4pnYlvi/dL6q98J84ui3+nCtjJrdWZAZNrROsq3HXXEGmjgHYXdtPh2UHph7DNIkXd6TXeB/Xrc3vPv+Ie5W7HFHGYeKGz0GrXUPK+it4H+bxl6T2l4UE2FggCa1c71FoUHQubM3eyCC6j2hTC19w/6U/cE5VVKSP3VsdtFJFftXGLTP9F49gzz9WJZkzrpoG2/Fn5t2nyeRFfMaJ/jKNd11Tj8ZBI/ARVqTjg38SeHFinMRZ/7ZSuFwPKMD+N/Ktn4DSlaoYJV8CaZ83XKLHdch1vidorZS3Hx84Qf1KyUhqNCXdXK4nSEKPFiXlEFRllbbY/vjnvjBGLlsfhQ9R6hA9mefVpwO2Xvrgy0dAlNyQ4N0ZFWdLFSh0z7LNTOSXnE/AwkVxEyi2IoPnVgP0HAgBumCqNp9my+DvZvos+LFpkma/BDripQD2C/LvICPJuowGOqfiZRxXN/+qlgZ49iHTMH2XDGhuFRWzq3bI1z6LySKgmFh9CxMKiKJDrgBW7Uz4zv1lX8vLjrG4lBtXKaPPnK2KSq+sfOIytbgSIjLWmJ6jr0v5snLnTAzBryUctj0VFQ43w+eO7PXJiwWx/bQy405+C75yo6nAyCcSySeGJ2c86Zq52pgTUaUQs1MgYJkMJBhoC7XKimIK+vIEXd2gM3El2jl074FXtSakeX15ggTDBy7BoK6QpFJGoZPuXp6DcXaHYDM/ZiMesSYd9n/KFlN+mgU05KDWu3lCxPtAs0/WtzW/q5rjcf3RhFjaeqH95ZI+5foLl4vNguVOH8uX/Tn4OmqoZ6r1y+8mRcAuUJb+waLgbdbvSUzd4zpGdzP2llyQo4OiYWjZ1d7e2nvtqPmiBwNMTW0snOGEZDCy+zw4JTtxD9DPZkRnrNiVu/aJ09iCRpmeHgz5J71RQeKyLVd+6b7pz3+jEGAxrpcJja0vAnXOs5YmcF/d3uuEeNuxPXks5imNaM0onxh+TCew9w0KRDuNUdvR6JVxnwmaJgBEdZeIg6Gn46/McnHyUu18zEmZtCcc7e9U2uTBTlWPLM+cBGbRbXDQOaX9rWn0W5ae4mrAxB6yNvqHvYCvxz4xPLlltIsZgZlQqzXKYsbAqEKdDjpHAUvT2DODW0KWYZmGzzBRUrGLuvLpI8Eq1bJu1GQZSv4SpZdLbU3uoUNcP0ZzqJVjnio1H6c/NlWn5BufTybPx2tOaRQEjGBWekAcIjobZt/BXwjc4QY+YAhL8Fl6LIFhJxpYHioMy43DBpWSH/PzzPopgUaW9PIht+BJYR09xPJ0reMaufQrmm/NZQ+4AnNN5eykU9uQ8otADP3UyJJUvkAgD4mFTaGJH8Z2MQaaBMyNXUrZSyupxqWdO/jvFMC4uOCcDHu7pSKd8DJat4RKYezG0D6YHoF7Vr2QeH+vqCEgwjGqCq/WXeDpZ1Xq6sxwAMDXm9r+Vq/DCcY3xESymupiHx79ShjMnymAeIafu/De2VwDVnEvUvNj00+yFhMpho6wuTeiDEKHkbAiQB8ztelyFKNYHAhlJ/h+PCUdr8oAetIJatyCFw1zZN/TIegoalHZx07izucgwM6RDOpFipp/88Oh18rImga+stN7dLrCg/wJxv6+UikiTpmsVBCDnzEWawnAWBkIRrq+8u2wS1Kfgc8O1cc5/yNKxS00ZLYG/7H0JkCwi24BwpGJFztzbtxVghF4Y1g0sBXzt4z1U+ZZPMEmrNn/3sIJSo464ypcrwg6qHwCx6oE9kJE1F3FS0ncxv3MCcJX//ykXenTEAf3LRS57bdricdoMHmUEABmfHxO9IaZSXkbrYMyvsYqNblWbs7airb99hVl2QqonKruNOwFCgnDIbyGusks/spyxov2mIWwLEGOO8HJj5zU9EE2bwGl2tbOxYr70kKSM7ttiWQHjozYaT5gTukLu60TiTCrunUpMVUONHNy/z6kkm5/RrgCDQQAgZYShBIyUVEZV6GbaIJFE9EQ15G9IlKyc0W+7kt5oaXffbxLA1J4y0gOkCu0ezgkBOVW6Ul2kDcTx9OE35gvA+Nn2qCZE6OjtcSCJ6jHxTy9VZqH93E+1Tb/lMzpe5p4udUHDlLE4ZaJfcf0RWeJJk1jmO/UdtKLRHxbeFtEtkV40l1FBBKJmAP3XPPpk8xaAWR/8+cXMkCCsjEprLYOJ3m+5eyW3WYSKqjMzrXsRVurCARgz4K5ZeQE9xDYDDwyQWVZghvn2PY1y361nNb9CXj+rp9aw/hp3s/qyKQYJlBq/XBP4sUA1ipXzHpk2S2CL7UWEK/4Qr88RrHKAapr37Tgh5Vp+UZXA9NaKTC5hELZrAf89ZvRhQfXBXF9MsfFYBbZBlGivKyFoutpRg28apxZzABxG5BPmjvrD6pCcCsECLqTTY1DcBKaDrsbgp5V0UO8QvKS+/nHIbktS7+1QmN5nPY8tMhLrUVNLD8Qs2aSv/SLAi4W1c8BMMz/FD4IogzaeXV/x6bFXjrnz7P+pTxYMcG3UNY0Q2lPY72xOXuVyggOnrrXCAwfrsaXLyoarSC1SiZeQahJglNX2nO1ACk3pY0MLKTE/rkNuO9xPDNuKBTjxWncidvaJ7yc/EURsjiPSYyc2dftj/+o2uyXV/9Vr6EO</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本文为加密文章，阅读本文需要输入密码。
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="算法" scheme="http://qiulyblog.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2015]亚瑟王  概率DP  loj2112</title>
    <link href="http://qiulyblog.github.io/2019/04/28/%5B%E9%A2%98%E8%A7%A3%5Dloj2112/"/>
    <id>http://qiulyblog.github.io/2019/04/28/[题解]loj2112/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-29T13:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现 <a href="https://loj.ac" target="_blank" rel="noopener">$loj$</a> 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。</p><p>顺便贴一下题目传送门：<a href="https://loj.ac/problem/2112" target="_blank" rel="noopener">$loj$的传送门就戳我啦(～￣▽￣)～</a></p><p>概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。</p><a id="more"></a><p>第一种情况：$j$ 轮中都没有打出第 $i+1$ 张牌，由于一轮中不打出第 $i+1$ 张牌的概率为 $1-p_i$ ，那么 $j$ 轮都不打出该牌的概率显然为 $(1-p_i)^j$ 。转移方程显然：</p><script type="math/tex; mode=display">f_{i+1,j}+=f_{i,j}\cdot (1-p_i)^j​</script><p>因为 $f_{i+1,j}$ 可能从多方向转移过来，所以是 $+=$ 。</p><p>第二种情况：$j$ 轮中至少有一轮打出了第 $i+1$ 张牌，概率显然为 $1-(1-p_i)^j$ ，转移也就很显然了：</p><script type="math/tex; mode=display">f_{i+1,j-1}+=f_{i,j}\cdot （1-(1-p_i)^j）</script><p>如果我们打出了第 $i+1$ 张牌，那么肯定是要计算贡献的，这个时候直接用这个概率算贡献就好了。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,r,d[N];</span><br><span class="line"><span class="keyword">double</span> f[N][N],p[N],pw[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>,&amp;p[i],&amp;d[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">            pw[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=r;++j) pw[i][j]=pw[i][j<span class="number">-1</span>]*(<span class="number">1</span>-p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][r]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=r;++j) &#123;</span><br><span class="line">                f[i+<span class="number">1</span>][j]+=f[i][j]*pw[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j) &#123;</span><br><span class="line">                    <span class="keyword">double</span> calc=f[i][j]*(<span class="number">1</span>-pw[i+<span class="number">1</span>][j]);</span><br><span class="line">                    f[i+<span class="number">1</span>][j<span class="number">-1</span>]+=calc,ans+=calc*d[i+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现 &lt;a href=&quot;https://loj.ac&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$loj$&lt;/a&gt; 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。&lt;/p&gt;
&lt;p&gt;顺便贴一下题目传送门：&lt;a href=&quot;https://loj.ac/problem/2112&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;$loj$的传送门就戳我啦(～￣▽￣)～&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="概率" scheme="http://qiulyblog.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
      <category term="期望" scheme="http://qiulyblog.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [CEOI2017]Building Bridges 斜率优化DP loj2483</title>
    <link href="http://qiulyblog.github.io/2019/04/27/%5B%E9%A2%98%E8%A7%A3%5Dloj2483/"/>
    <id>http://qiulyblog.github.io/2019/04/27/[题解]loj2483/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-04-29T13:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>愉快的推式子吧(ﾉ≧∀≦)ﾉ！</p><p>设 $f_i$ 表示前 $i$ 根柱子完工后的最小代价。枚举一个小于 $i$ 的 $j$ ，表示为从 $j$ 向 $i$ 连了一座桥，中间的柱子当然全部推掉，计算一下就好：</p><script type="math/tex; mode=display">f_i=\min\{f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\}</script><p>*其中 $s$ 为 $w$ 的前缀和。</p><a id="more"></a><script type="math/tex; mode=display">f_i=f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\\\\f_i=f_j+s_{i-1}-s_j+h_i^2+h_j^2-2h_ih_j\\\\f_j+s_{i-1}-s_j+h_i^2+h_j^2=2h_ih_j+f_i</script><p>于是最终式子变成了 $y=kx+b$ 的形式，斜率优化！</p><p>但是……注意这个式子的 $k$ 不是单调递增的，并且 $x$ 也不是单调递增的！那么我们不能用朴素做法了，也不能用二分……难道用 $Splay$ ？(码量巨大) 。</p><p>不，用 $CDQ$ 分治。</p><p>对于一个 $i$ ，可能可以对 $i$ 做出贡献的只有所有小于 $i$ 的 $j$ 。为了保证 $x$ 单调我们先大力将原来的数组按照 $x$ 从小到大排个序，然后 $CDQ$ 的时候分左右两边，左边的所有元素在初始数组的位置都小于右边的左右元素，也就是说我们直接用左边元素对右边元素做出贡献。</p><p>同时这里也保证了左右两边的 $x$ 一定是单调上增的。</p><p>我们使用单调队列，扫一遍左边的元素，留下能做贡献的点(下凸壳上的点)，这时候左边的所有元素可以保证 $x$ 和斜率都是单调上增的。</p><p>右边呢？因为直线的斜率是 $2x$ ，而右边的 $x$ 也是单调上增的，所以我们可以愉快的做朴素的单调队列了。</p><p>$CDQ$ 分治部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;<span class="comment">/*一个点的时候直接计算y值*/</span></span><br><span class="line">        a[l].y=f[a[l].id]-s[a[l].id]+S(a[l].x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(a[i].id&lt;=mid) b[c1++]=a[i]; <span class="comment">/*编号小的左边去*/</span></span><br><span class="line">        <span class="keyword">else</span> b[c2++]=a[i]; <span class="comment">/*编号大些的右边去*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    CDQ(l,mid); <span class="comment">/*计算出左边所有元素的 f*/</span></span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i) &#123; <span class="comment">/*处理出左边所有元素组成的下凸壳*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail<span class="number">-1</span>],q[tail])&gt;slope(q[tail],i)) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;++i) &#123; <span class="comment">/*计算左边元素对右边元素产生的贡献*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*a[i].x) ++head; <span class="comment">/*维护队列*/</span></span><br><span class="line">        <span class="keyword">int</span> x=a[i].id,y=a[q[head]].id;</span><br><span class="line">        f[x]=min(f[x],f[y]+s[x<span class="number">-1</span>]-s[y]+S(a[i].x-a[q[head]].x));</span><br><span class="line">        <span class="comment">/*可能计算多次所以要取min*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i)  <span class="comment">/*还原a数组至初始状态*/</span></span><br><span class="line">        <span class="keyword">if</span>(c2&gt;r||(c1&lt;=mid&amp;&amp;a[c1].x&lt;a[c2].x)) b[i]=a[c1++];</span><br><span class="line">        <span class="keyword">else</span> b[i]=a[c2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数中</span></span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp),CDQ(<span class="number">1</span>,n); <span class="comment">/*排序后CDQ开始*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]); <span class="comment">/*输出*/</span></span><br></pre></td></tr></table></figure><p>最后因为存在 $0$ ，在计算斜率的时候需要特判一下。还需要注意一下 $long\ long$ 的问题，记得将 $f$ 数组初始化。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e18</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span><span class="keyword">int</span> x,id;ll y;&#125;a[N],b[N];</span><br><span class="line">ll s[N],w[N],f[N];<span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point x,point y)</span> </span>&#123;<span class="keyword">return</span> x.x&lt;y.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i].x==a[j].x) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[i].y&lt;a[j].y?inf:-inf;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="keyword">double</span>(a[i].y-a[j].y)/<span class="keyword">double</span>(a[i].x-a[j].x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;a[l].y=f[a[l].id]-s[a[l].id]+S(a[l].x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(a[i].id&lt;=mid) b[c1++]=a[i];</span><br><span class="line">        <span class="keyword">else</span> b[c2++]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    CDQ(l,mid);</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail<span class="number">-1</span>],q[tail])&gt;slope(q[tail],i)) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*a[i].x) ++head;</span><br><span class="line">        <span class="keyword">int</span> x=a[i].id,y=a[q[head]].id;</span><br><span class="line">        f[x]=min(f[x],f[y]+s[x<span class="number">-1</span>]-s[y]+S(a[i].x-a[q[head]].x));</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,c1=l,c2=mid+<span class="number">1</span>;i&lt;=r;++i) </span><br><span class="line">        <span class="keyword">if</span>(c2&gt;r||(c1&lt;=mid&amp;&amp;a[c1].x&lt;a[c2].x)) b[i]=a[c1++];</span><br><span class="line">        <span class="keyword">else</span> b[i]=a[c2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]=b[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        IN(a[i].x),a[i].id=i,f[i]=inf;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(w[i]),s[i]=s[i<span class="number">-1</span>]+w[i];</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp),CDQ(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;愉快的推式子吧(ﾉ≧∀≦)ﾉ！&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示前 $i$ 根柱子完工后的最小代价。枚举一个小于 $i$ 的 $j$ ，表示为从 $j$ 向 $i$ 连了一座桥，中间的柱子当然全部推掉，计算一下就好：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\min\{f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\}&lt;/script&gt;&lt;p&gt;*其中 $s$ 为 $w$ 的前缀和。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [HNOI2008]玩具装箱TOY  斜率优化DP  luoguP3195</title>
    <link href="http://qiulyblog.github.io/2019/04/24/%5B%E9%A2%98%E8%A7%A3%5DluoguP3195/"/>
    <id>http://qiulyblog.github.io/2019/04/24/[题解]luoguP3195/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-28T05:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>差不多搞懂了斜率优化吧……说实话网上的文章都写得很迷，还好找到了一个不错的文章：<a href="https://www.cnblogs.com/yangsongyi/p/9630227.html" target="_blank" rel="noopener">转送门戳我(￣▽￣)~*</a> 。(为什么突然发现这道题和诗人小G很像呢) </p><p>这个 $\texttt{DP}$ 方程谁都会设：设 $f_i$ 表示前 $i$ 个玩具的最小费用，转移显然如下：</p><script type="math/tex; mode=display">f_i=\min\limits_{j=1}^{i-1}\{f_j+(sum_i-sum_j+i-j-l)^2\}</script><p>(其中 $sum$ 是前缀和)。这个复杂度是 $O(n^2)$ 的，过不去……</p><a id="more"></a><p>继续推式子：</p><script type="math/tex; mode=display">f_i=\min\limits_{j=1}^{i-1}\{f_j+[(sum_i+i)-(sum_j+j)-l]^2\}</script><p>设 $s_i=sum_i+i$ ，我们假设 $j$ 为最优决策，将 $\min$ 去掉。</p><script type="math/tex; mode=display">f_i=f_j+(s_i-s_j-l)^2\\f_i=f_j+s_i^2+(s_j+l)^2-2\cdot s_i\cdot(s_j+l)\\f_j+s_i^2+(s_j+l)^2=2\cdot s_i\cdot(s_j+l)+f_i​</script><p>于是上面的式子变成了 $y=kx+b$ 的形式，其中 $y=f_j+s_i^2+(s_j+l)^2$ ，$k=2\cdot s_i$ ，$x=s_j+l$ ，$b=f_i$ 。</p><p>然后将 $x,y$ 两个值作为点 $(x,y)$ 放到平面上即可，因为最终答案是取 $min$ ，所以我们需要维护的是下凸壳。有一点需要注意的是，我们算斜率的时候可以将每个点的常数项或者只和 $i$ 有关的项去掉，因为算斜率是相减的，减的时候这些项同样也没了。</p><p>上面的 $x$ 中的 $l$ 是常数项于是可以省略，$y$ 中的 $s_i^2$ 只和 $i$ 有关，于是也省略掉。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,l,head,tail;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N],s[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> s[i];&#125;<span class="comment">/*每个点的x坐标*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]+S(s[i]+l);&#125;<span class="comment">/*每个点的y坐标*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> (Y(j)-Y(i))/(X(j)-X(i));&#125;<span class="comment">/*算斜率*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;s[i]),s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]+=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*s[i]) ++head;</span><br><span class="line">        f[i]=f[q[head]]+S(s[i]-s[q[head]]-l<span class="number">-1</span>);<span class="comment">/*转移*/</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail],i)&lt;slope(q[tail],q[tail<span class="number">-1</span>])) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来解释一些问题。</p><h3 id="1-为什么要维护下凸壳"><a href="#1-为什么要维护下凸壳" class="headerlink" title="1.为什么要维护下凸壳"></a>1.为什么要维护下凸壳</h3><p>因为我们的 $\texttt{DP}$ 方程是在取 $\min$ ，如果是 $\max$ 的话则维护上凸壳。而且维护下凸壳显然是让 $f_i$ 更小。</p><p>以上面为例，我们用 $y=kx+b​$ 的直线从下面网上扫，注意这条直线的斜率就是 $k​$ 。很显然如果我们从下往上这样扫越往上扫 $b​$ 越大(不明白的画画图)，但是我们的目的是使得 $b​$ 最小( $b​$ 就是 $f_i​$ ) 。下凸壳包含了最下面的所有点，显然不是下凸壳上的点一定不能成为最优的。</p><h3 id="2-维护队列的过程是什么鬼操作"><a href="#2-维护队列的过程是什么鬼操作" class="headerlink" title="2.维护队列的过程是什么鬼操作"></a>2.维护队列的过程是什么鬼操作</h3><p>首先第一个过程，也就是下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&lt;<span class="number">2</span>*s[i]) ++head;</span><br></pre></td></tr></table></figure><p>上面讲了我们需要使得 $b​$ 最小，那么最优的决策点在直线从下往上扫的过程中肯定是最先扫到的，因为那样可以保证 $f_i​$ 最小。假设最优的点为 $i​$ ，上一个点为 $j​$ ，下一个点为 $k​$ ，那么 $i​$ 一定保证 $j​$ 到 $i​$ 的斜率小于直线斜率并且 $i​$ 到 $k​$ 的斜率大于直线斜率。</p><p>然后我们会发现对于单调上增的需要更新的 $i​$ ，其直线的斜率 $k​$ 一定是单调上增的，因为前缀和是单调上增的。</p><p>所以对于斜率已经不满足要求的点直接踢出队就好了。</p><p>然后康康出队的过程。如果在纸上画画会发现，如果满足 <code>slope(q[tail],i)&lt;slope(q[tail],q[tail-1])</code> ，那么说明 $q[tail]$ 已经不再下凸壳中了！没错吧？那么这个时候 $q[tail]$ 永远也不可能成为最优的转移点了，直接丢掉即可。</p><hr><p>最后有一些斜率优化的套路总结(自己总结出来的)：</p><ul><li>$\texttt{DP}$ 方程取 $\min$ 就维护下凸壳，取 $\max$ 就维护上凸壳</li><li>$y=kx+b​$ 中的 $k​$ 一定要是常量或者是完全是 $i​$ 的量(例如 $s_i,2\cdot g_i^2​$ 等)，$b​$ 一定是你需要转移的对象(就是 $f_i​$ )，$x​$ 和 $y​$ 两个值一定要包含和 $j​$ 有关的值，要随 $j​$ 的变化而变化。</li><li>提炼出来的 $x,y$ 放到坐标系上之前记得去掉没用的值。</li></ul><p>差不多就这些吧，也不知道是不是完全正确，至少这个套路还是过了几道题目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;差不多搞懂了斜率优化吧……说实话网上的文章都写得很迷，还好找到了一个不错的文章：&lt;a href=&quot;https://www.cnblogs.com/yangsongyi/p/9630227.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转送门戳我(￣▽￣)~*&lt;/a&gt; 。(为什么突然发现这道题和诗人小G很像呢) &lt;/p&gt;
&lt;p&gt;这个 $\texttt{DP}$ 方程谁都会设：设 $f_i$ 表示前 $i$ 个玩具的最小费用，转移显然如下：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\min\limits_{j=1}^{i-1}\{f_j+(sum_i-sum_j+i-j-l)^2\}&lt;/script&gt;&lt;p&gt;(其中 $sum$ 是前缀和)。这个复杂度是 $O(n^2)$ 的，过不去……&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [APIO2010]特别行动队  斜率优化DP  luoguP3628</title>
    <link href="http://qiulyblog.github.io/2019/04/24/%5B%E9%A2%98%E8%A7%A3%5DluoguP3628/"/>
    <id>http://qiulyblog.github.io/2019/04/24/[题解]luoguP3628/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-28T05:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>依旧是斜率优化的套路。</p><p>设 $f_i$ 表示前 $i$ 个士兵的最大贡献，转移显然是枚举一个 $j$ ，将 $j+1$ 到 $i$ 这些士兵组成特别行动队算贡献：</p><script type="math/tex; mode=display">f_i=\max\{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c\}​</script><p>其中 $s_i$ 为战斗力的前缀和。这个方程是 $O(n^2)$ 的，需要优化。发现这个转移式貌似不满足单调队列优化的条件，于是将中间的式子拆开看看可不可以斜率优化。</p><a id="more"></a><script type="math/tex; mode=display">f_i=\max\{f_j+a(s_i^2+s_j^2-2s_is_j)+b\cdot s_i-b\cdot s_j+c\}\\f_i=\max\{f_j+a\cdot s_i^2+a\cdot s_j^2-2a\cdot s_is_j)+b\cdot s_i-b\cdot s_j+c\}\\f_i=f_j+a\cdot s_i^2+a\cdot s_j^2-2a\cdot s_is_j+b\cdot s_i-b\cdot s_j+c\\f_j+a\cdot s_i^2+a\cdot s_j^2+b\cdot s_i-b\cdot s_j+c=2a\cdot s_i\cdot s_j +f_i​</script><p>诶，是 $y=kx+b$ 的形式，而且满足斜率优化的条件诶。继续将 $x,y$ 找出来放到坐标系上( $x=s_j$,$y=f_j+a\cdot s_j^2-b\cdot s_j$) 。</p><p>因为是 $\max​$ ，所以用单调队列维护一下上凸壳然后转移即可，复杂度 $O(n)​$ 。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,head,tail;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[N],f[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> s[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Y</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]+<span class="number">1l</span>l*S(s[i])*a<span class="number">-1l</span>l*s[i]*b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> (Y(j)-Y(i))/(X(j)-X(i));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    f[i]=f[j]+<span class="number">1l</span>l*S(s[i]-s[j])*a+<span class="number">1l</span>l*(s[i]-s[j])*b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IN(n),IN(a),IN(b),IN(c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(s[i]),s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[head],q[head+<span class="number">1</span>])&gt;<span class="number">2</span>*a*s[i]) ++head;</span><br><span class="line">        calc(i,q[head]);</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;slope(q[tail],i)&gt;slope(q[tail],q[tail<span class="number">-1</span>])) --tail;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依旧是斜率优化的套路。&lt;/p&gt;
&lt;p&gt;设 $f_i$ 表示前 $i$ 个士兵的最大贡献，转移显然是枚举一个 $j$ ，将 $j+1$ 到 $i$ 这些士兵组成特别行动队算贡献：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_i=\max\{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c\}​&lt;/script&gt;&lt;p&gt;其中 $s_i$ 为战斗力的前缀和。这个方程是 $O(n^2)$ 的，需要优化。发现这个转移式貌似不满足单调队列优化的条件，于是将中间的式子拆开看看可不可以斜率优化。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://qiulyblog.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [SCOI2008]奖励关  状压DP  luoguP2473</title>
    <link href="http://qiulyblog.github.io/2019/04/23/%5B%E9%A2%98%E8%A7%A3%5DluoguP2473/"/>
    <id>http://qiulyblog.github.io/2019/04/23/[题解]luoguP2473/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-04-24T07:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现数据范围很小，并且涉及到”集合”，很容易可以想到用状压 $\texttt{DP}$ 。</p><p>设 $f[i][j]$ 表示已经抛出了 $i$ 次宝物，获得的宝物集合为 $j$ 时的最优分值。那么转移的时候枚举每一个宝物，分两种情况即可——选当前宝物或者不选。注意选当前宝物的前提是必须满足前提，按照最优情况选取即可。注意最后将所有的宝物的贡献加上后还需要$/n$ ，因为题目要求的是”平均”。</p><a id="more"></a><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">101</span>][<span class="number">65540</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">18</span>],d[<span class="number">18</span>],v[<span class="number">18</span>],N,K;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;++i) p[i]=<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;K,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(x) &#123;d[i]|=p[x];<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=K;i;--i) <span class="comment">/*倒着枚举会好些*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=p[N+<span class="number">1</span>]<span class="number">-1</span>;++j) &#123;</span><br><span class="line">            <span class="comment">/*上面两重循环枚举状态*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;++k)<span class="comment">/*枚举所有宝物并计算贡献*/</span></span><br><span class="line">                <span class="keyword">if</span>((d[k]&amp;j)==d[k]) <span class="comment">/*可以选取当前宝物*/</span></span><br><span class="line">                    f[i][j]+=max(f[i+<span class="number">1</span>][j],f[i+<span class="number">1</span>][j|p[k]]+v[k]);</span><br><span class="line">                    <span class="comment">/*按照最优选取*/</span></span><br><span class="line">                <span class="keyword">else</span> f[i][j]+=f[i+<span class="number">1</span>][j]; <span class="comment">/*不能选取直接转移*/</span></span><br><span class="line">            f[i][j]/=N;<span class="comment">/*所谓"平均"*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,f[<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">/*最终答案*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现数据范围很小，并且涉及到”集合”，很容易可以想到用状压 $\texttt{DP}$ 。&lt;/p&gt;
&lt;p&gt;设 $f[i][j]$ 表示已经抛出了 $i$ 次宝物，获得的宝物集合为 $j$ 时的最优分值。那么转移的时候枚举每一个宝物，分两种情况即可——选当前宝物或者不选。注意选当前宝物的前提是必须满足前提，按照最优情况选取即可。注意最后将所有的宝物的贡献加上后还需要$/n$ ，因为题目要求的是”平均”。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="状压DP" scheme="http://qiulyblog.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [NOI2011]Noi嘉年华  决策单调性优化DP  luoguP1973</title>
    <link href="http://qiulyblog.github.io/2019/04/22/%5B%E9%A2%98%E8%A7%A3%5DluoguP1973/"/>
    <id>http://qiulyblog.github.io/2019/04/22/[题解]luoguP1973/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-23T00:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题一共有两问，第一问瞎搞 $\texttt{DP}$ ，第二问如果直接 $\texttt{DP}$ 的话复杂度是 $O(n^4)$ 的过不去，这个时候需要用到决策单调性优化复杂度就可以降低至 $O(n^3)$ ，这样就过了。我们先来讨论一下第一问的做法。</p><p>时间的范围太大了，我们需要离散化一下。离散化后时间就控制在 $0$ 到 $2n$ 的范围内了。</p><p>首先可以发现最终的答案一定就是一段一段时间，每一段时间内的活动都是在同一个会场举行。我们可以预处理一个 $tot_{l,r}$ 表示完全在时间 $l,r$ 之内的活动有多少个。计算直接暴力，预处理的复杂度为 $O(n^3)$ 。</p><a id="more"></a><p>然后设一个 $pre_{i,j}​$ 表示 <strong>$1​$ 到 $i​$ 的时间一个会场的活动数为 $j​$ 时另一个会场的最大活动数</strong>。那么转移的话我们枚举一个时间 $k​$ ，然后考虑 $k​$ 到 $i​$ 这段时间中的所有活动分配给哪个会场即可。可以得到转移方程：</p><script type="math/tex; mode=display">pre_{i,j}=\max\limits_{k=1}^{i}\{pre_{k,j}+tot_{k,i},pre_{k,j-tot_{k,i}}\}​</script><p>这里我们 $pre$ 方程的定义中”一个会场”就是一号会场，”另一个会场”就是二号会场$。pre_{k,j}+tot_{k,i}$ 就是将 $k$ 到 $i$ 这段时间中所有活动都分配给了二号会场，$pre_{k,j-tot_{k,i}}$ 很显然就是分配给了一号会场。计算时枚举 $i,j,k$ ，复杂度是 $O(n^3)$ 。(其实准确的复杂度带个常数，因为 $i$ 枚举的是时间，而时间最大是 $2n$ 的) 。</p><p>我们设离散化后时间总长为 $m$ ，那么答案显然为 $\max\limits_{i=1}^m\{\min(pre_{m,i},i)\}$ 。接下来我们解决第二问。</p><p>我们的 $tot_{l,r}$ 统计的就是完全在时间 $l,r$ 的区间有多少个。那么对于第 $i$ 个活动，设该活动的起始时间与终止时间分别为 $s_i,t_i$ ，那么我们再考虑一对 $x,y \ \ (x\leq s_i,t_i\leq y)$ ，那么如果我们将答案计算上 $tot_{x,y}$ ，那么也就选择了第 $i$ 个活动了。</p><p>我们设 $f_{i,j}$ 表示一号会场强制选择 $i$ 到 $j$ 时间中的所有活动时的最优答案。(注意这里的最优答案就是两个会场中活动少的一方的最大值，我们只是考虑在一号会场<strong>强制选择</strong> $i$ 到 $j​$ 中的所有活动的情况下考虑最优的全局答案) 。</p><p>继续看向一号会场，假设在 $i$ 前面的时间中一号会场已经合法举办了 $x$ 场活动，在 $j$ 后面的时间中也合法举办了 $y$ 场活动。那么我们枚举 $i,j,x,y$ 也可以得到二号会场的活动数：$i$ 前面的时间种有 $pre_{i,x}$ 场活动，$j$ 后面的时间中有……诶这里用 $pre$ 貌似不是很好表示诶，于是我们新定义一个 $suf$ ，$suf_{i,j}$ 表示 <strong>$i$ 到 $m$ 的时间一个会场的活动数为 $j$ 时另一个会场的最大活动数</strong>，$suf$ 的状态转移方程和 $pre$ 的同理。</p><p>枚举 $i,j,x,y$ 后就可以得到两个会场的活动个数，那么就可以直接算答案了：</p><script type="math/tex; mode=display">f_{i,j}=\max\limits_{x=1}^{m}\max\limits_{y=1}^{m}\{\min(x+tot_{i,j}+y,pre_{i,x}+suf_{j,y})\}​</script><p>但是这样子的复杂度是 $O(n^4)​$ 的，过不了。</p><p>不过，我们会发现，<strong>对于单调递增的 $x$ ，对应的最优的 $y$ 一定是单调递减的</strong> 。为什么呢？首先对于一个单调递增的 $i$ ，$pre_{?_i},suf_{?_i}$ 一定是单调递减的( $?$ 为任意数) 。那么如果对于单调递增的 $x$ ，$pre_{i,x}$ 一定是单调递减的，这个时候如果 $y$ 单调递增也就意味着 $suf_{j,y}$ 会单调递减，那么 $x+tot_{i,j}+y$ 和 $pre_{i,x}+suf_{j,y}$ 将会越拉越大，对于答案显然是不利的。反过来，如果 $y$ 是单调递减的，那么就会相对比较均衡。(感性理解理解……)</p><p>那么我们就不需要枚举 $y$ 了，只需要扫一扫就好了，最终计算 $f$ 的时间复杂度为 $O(n^3)$ 。</p><p>最终统计答案的时候，对于一个活动 $i$ ，我们的答案显然为 $\max\limits_{x=1}^{s_i}\max\limits_{y=t_i}^{m}f_{x,y}$ 。必须满足 $x\leq s_i,t_i\leq y$ ，因为这样就会满足一定会选择第 $i$ 个活动。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,j,k) for((i)=(j);(i)&lt;=(k);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(i,j,k) for((i)=(j);(i)&gt;=(k);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e2</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,i,j,k,l,r,s[N],t[N],b[N];</span><br><span class="line"><span class="keyword">int</span> tot[N][N],pre[N][N],suf[N][N],f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> min(x+tot[l][r]+y,pre[l][x]+suf[r][y]);&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=IN();</span><br><span class="line">    F(i,<span class="number">1</span>,n) b[++m]=s[i]=IN(),b[++m]=t[i]=IN()+s[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+m),</span><br><span class="line">    m=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+m)-b<span class="number">-1</span>;<span class="comment">/*离散化去重*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        s[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,s[i])-b;</span><br><span class="line">        t[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,t[i])-b;</span><br><span class="line">        F(l,<span class="number">1</span>,s[i]) R(r,m,t[i]) ++tot[l][r];<span class="comment">/*计算出tot*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    F(i,<span class="number">1</span>,m) F(j,<span class="number">1</span>,n) pre[i][j]=suf[i][j]=-inf;<span class="comment">/*初始化*/</span> </span><br><span class="line">    <span class="comment">/*----------计算出pre和suf----------*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,m) F(j,<span class="number">0</span>,tot[<span class="number">1</span>][i]) F(k,<span class="number">1</span>,i) &#123;</span><br><span class="line">        pre[i][j]=max(pre[i][j],pre[k][j]+tot[k][i]);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=tot[k][i]) pre[i][j]=max(pre[i][j],pre[k][j-tot[k][i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    R(i,m,<span class="number">1</span>) F(j,<span class="number">0</span>,tot[i][m]) F(k,i,m) &#123;</span><br><span class="line">        suf[i][j]=max(suf[i][j],suf[k][j]+tot[i][k]);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=tot[i][k]) suf[i][j]=max(suf[i][j],suf[k][j-tot[i][k]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*计算f*/</span></span><br><span class="line">    F(l,<span class="number">1</span>,m) F(r,l+<span class="number">1</span>,m) <span class="keyword">for</span>(<span class="keyword">int</span> y=n,x=<span class="number">0</span>;x&lt;=n;++x) &#123;<span class="comment">/*y当做指针扫一遍*/</span></span><br><span class="line">        <span class="keyword">int</span> old_calc=calc(x,y),new_calc;</span><br><span class="line">        <span class="keyword">while</span>(y&amp;&amp;old_calc&lt;=(new_calc=calc(x,y<span class="number">-1</span>))) --y,old_calc=new_calc;</span><br><span class="line">        f[l][r]=max(f[l][r],calc(x,y));<span class="comment">/*转移*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*输出答案*/</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    F(i,<span class="number">1</span>,n) ans=max(ans,min(pre[m][i],i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">/*第一问*/</span></span><br><span class="line">    F(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        F(l,<span class="number">1</span>,s[i]) R(r,m,t[i]) ans=max(ans,f[l][r]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">/*第二问*/</span></span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题一共有两问，第一问瞎搞 $\texttt{DP}$ ，第二问如果直接 $\texttt{DP}$ 的话复杂度是 $O(n^4)$ 的过不去，这个时候需要用到决策单调性优化复杂度就可以降低至 $O(n^3)$ ，这样就过了。我们先来讨论一下第一问的做法。&lt;/p&gt;
&lt;p&gt;时间的范围太大了，我们需要离散化一下。离散化后时间就控制在 $0$ 到 $2n$ 的范围内了。&lt;/p&gt;
&lt;p&gt;首先可以发现最终的答案一定就是一段一段时间，每一段时间内的活动都是在同一个会场举行。我们可以预处理一个 $tot_{l,r}$ 表示完全在时间 $l,r$ 之内的活动有多少个。计算直接暴力，预处理的复杂度为 $O(n^3)$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="决策单调性" scheme="http://qiulyblog.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [十二省联考2019]春节十二响  堆+启发式合并  luoguP5290</title>
    <link href="http://qiulyblog.github.io/2019/04/19/%5B%E9%A2%98%E8%A7%A3%5DluoguP5290/"/>
    <id>http://qiulyblog.github.io/2019/04/19/[题解]luoguP5290/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T11:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>要是我不是 $\texttt{HN}$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……</p><p>[十二省联考2019]春节十二响，启发式合并裸题。对于树中的一个节点 $u$ ，从其子树中选择一段的方式显然只能是从 $u$ 的所有子树中各选出一个节点。于是我们每一个节点开一个堆，存的就是其子树中(包括自己)的所有段的内存。</p><p>然后从下往上启发式合并即可，复杂度大约是 $O(nlogn)$ 。</p><a id="more"></a><p>启发式合并的具体代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[x].size()&lt;q[y].size()) swap(q[x],q[y]);</span><br><span class="line">    <span class="keyword">while</span>(!q[y].empty()) &#123;</span><br><span class="line">        hep.push_back(max(q[x].top(),q[y].top()));</span><br><span class="line">        q[x].pop(),q[y].pop();</span><br><span class="line">        <span class="comment">/*贪心选取*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hep.size()) q[x].push(hep.back()),hep.pop_back();</span><br><span class="line">    <span class="comment">/*更新节点*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,sz=G[x].size();i&lt;sz;++i)</span><br><span class="line">        solve(G[x][i]),merge(x,G[x][i]);<span class="comment">/*将当前子树与之前枚举过的子树合并*/</span></span><br><span class="line">    q[x].push(s[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的总代码长度不超过 $40$ 行。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,f,s[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hep,G[N];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[x].size()&lt;q[y].size()) swap(q[x],q[y]);</span><br><span class="line">    <span class="keyword">while</span>(!q[y].empty()) &#123;</span><br><span class="line">        hep.push_back(max(q[x].top(),q[y].top()));</span><br><span class="line">        q[x].pop(),q[y].pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hep.size()) q[x].push(hep.back()),hep.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,sz=G[x].size();i&lt;sz;++i)</span><br><span class="line">        solve(G[x][i]),merge(x,G[x][i]);</span><br><span class="line">    q[x].push(s[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f),G[f].push_back(i);</span><br><span class="line">    solve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">1</span>].empty()) ans+=q[<span class="number">1</span>].top(),q[<span class="number">1</span>].pop();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要是我不是 $\texttt{HN}$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……&lt;/p&gt;
&lt;p&gt;[十二省联考2019]春节十二响，启发式合并裸题。对于树中的一个节点 $u$ ，从其子树中选择一段的方式显然只能是从 $u$ 的所有子树中各选出一个节点。于是我们每一个节点开一个堆，存的就是其子树中(包括自己)的所有段的内存。&lt;/p&gt;
&lt;p&gt;然后从下往上启发式合并即可，复杂度大约是 $O(nlogn)$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="堆" scheme="http://qiulyblog.github.io/tags/%E5%A0%86/"/>
    
      <category term="启发式合并" scheme="http://qiulyblog.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【题解】 [十二省联考2019]异或粽子  可持久化Trie树  luoguP5283</title>
    <link href="http://qiulyblog.github.io/2019/04/19/%5B%E9%A2%98%E8%A7%A3%5DluoguP5283/"/>
    <id>http://qiulyblog.github.io/2019/04/19/[题解]luoguP5283/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T11:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>要是我不是 $\texttt{HN}​$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……</p><p>[十二省联考2019]异或粽子，可持久化 $trie​$ 树的板子题，比最大异或和还要板子些。相信 $60​$ 分入门者都会做，那么 $100​$ 分的话我们上可持久化 $trie​$ 树维护前缀异或和，嗯没错就像主席树那样。然后对于每个节点的可持久化 $trie​$ 树我们将其当成区间右端点，然后在此位置上的 $trie​$ 树中贪心寻找左端点即可。</p><a id="more"></a><p>寻找前 $K$ 大区间的具体操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">    q.push(MKP(T.query(T.root[i],sum[i],qrank[i]=<span class="number">1</span>),i));</span><br><span class="line"><span class="comment">/*对于每一个右端点，找一个第一大(最优)的左端点放入优先队列*/</span></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(k--) &#123;</span><br><span class="line">    ll i=q.top().second;<span class="comment">/*取出当前最优元素*/</span></span><br><span class="line">    ans+=q.top().first;q.pop();</span><br><span class="line">    <span class="keyword">if</span>(qrank[i]!=i) q.push(MKP(T.query(T.root[i],sum[i],++qrank[i]),i));</span><br><span class="line">    <span class="comment">/*更新队列元素*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度大约是 $O(nlogn)​$ 级别。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKP make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll logN=<span class="number">33</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n,k,sum[N],qrank[N];</span><br><span class="line">priority_queue&lt;pair&lt;ll,ll&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    ll ch[N*logN][<span class="number">2</span>],sum[N*logN],root[N],tot;</span><br><span class="line">    <span class="function">ll <span class="title">newnode</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        ++tot,ch[tot][<span class="number">0</span>]=ch[x][<span class="number">0</span>],ch[tot][<span class="number">1</span>]=ch[x][<span class="number">1</span>];</span><br><span class="line">        sum[tot]=sum[x];<span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll&amp;rt,ll val)</span> </span>&#123;</span><br><span class="line">        rt=newnode(rt),++sum[rt];</span><br><span class="line">        ll now=rt;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">31</span>;~i;--i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> son=(val&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">            ch[now][son]=newnode(ch[now][son]);</span><br><span class="line">            now=ch[now][son],++sum[now];</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll now,ll val,ll k)</span> </span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">31</span>;~i;--i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> son=!((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=sum[ch[now][son]]) now=ch[now][son],ans|=(<span class="number">1u</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">else</span> k-=sum[ch[now][son]],now=ch[now][!son];</span><br><span class="line">        &#125;<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IN(n),IN(k);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,x;i&lt;=n;++i) IN(x),sum[i]=sum[i<span class="number">-1</span>]^x;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i) T.root[i]=T.root[i<span class="number">-1</span>];</span><br><span class="line">        T.Insert(T.root[i],sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        q.push(MKP(T.query(T.root[i],sum[i],qrank[i]=<span class="number">1</span>),i));</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        ll i=q.top().second;</span><br><span class="line">        ans+=q.top().first;q.pop();</span><br><span class="line">        <span class="keyword">if</span>(qrank[i]!=i) q.push(MKP(T.query(T.root[i],sum[i],++qrank[i]),i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要是我不是 $\texttt{HN}​$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响……&lt;/p&gt;
&lt;p&gt;[十二省联考2019]异或粽子，可持久化 $trie​$ 树的板子题，比最大异或和还要板子些。相信 $60​$ 分入门者都会做，那么 $100​$ 分的话我们上可持久化 $trie​$ 树维护前缀异或和，嗯没错就像主席树那样。然后对于每个节点的可持久化 $trie​$ 树我们将其当成区间右端点，然后在此位置上的 $trie​$ 树中贪心寻找左端点即可。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="可持久化Trie树" scheme="http://qiulyblog.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【题解】【模板】动态DP  LCT+DP+矩阵  luoguP4751</title>
    <link href="http://qiulyblog.github.io/2019/04/19/%5B%E9%A2%98%E8%A7%A3%5DluoguP4751/"/>
    <id>http://qiulyblog.github.io/2019/04/19/[题解]luoguP4751/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T11:17:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>看懂了后发现 $\texttt{DDP}$ 其实不难呢……</p><p>其实主要思想就是将 $\texttt{DP}$ 转移式搞到矩阵上，然后如果是树形 $\texttt{DP}$ 的话就可以直接上树剖或者是 $LCT$ 进行维护，当然还可以用全局平衡二叉树(不费) 。如果只是线性的话可以直接用线段树等数据结构进行维护了。</p><p>注意这道模板树剖的复杂度是 $O(nlog^2n)$ ，而 $LCT$ 的复杂度为 $O(nlogn)$ ，于是窝选择了 $LCT$ ，跑的还挺快。</p><a id="more"></a><p>开始分析题目，如果没有”动态”限制的话就是一个裸的”没有上司的舞会”，解法显然是设 $f[u][0/1]​$ 表示 $u​$ 不选/选 的时候其子树的最大价值，转移显然为：</p><script type="math/tex; mode=display">f[u][0]=\sum \max(f[v][0],f[v][1])\\f[u][1]=val[u]+\sum f[v][0]</script><p>对于树中的一个节点 $u$ 的所有儿子中有个重儿子，其他的儿子就是轻儿子，我们将重儿子和轻儿子的贡献分开算。设一个 $g[u][0/1]$ ，其值为：</p><script type="math/tex; mode=display">g[u][0]=\sum\max(f[v][0],f[v][1])\\g[u][1]=val[u]+\sum f[v][0]</script><p>注意上式中的 $v$ 只的是轻儿子，然后 $f$ 的转移就变成了以下形式( $x$ 为重儿子)：</p><script type="math/tex; mode=display">f[u][0]=\max(f[x][0],f[x][1])+g[u][0]\\f[u][1]=g[u][1]+f[x][0]</script><p>其实这里的 $g$ 很好维护，我们在 $Access$ 的时候只要计算儿子变化时的贡献就好了。</p><p>接着我们构造出转移矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}g[u][0] & g[u][0]\\g[u][1] & -inf\end{bmatrix}\cdot\begin{bmatrix}f[x][0] \\f[x][1]\end{bmatrix}=\begin{bmatrix}f[u][0]\\f[u][1]\end{bmatrix}</script><p>这样子就可以直接更新了，对于每个节点我们只需要维护两个矩阵即可，一个就是上面乘法中的 $g$ 矩阵，一个就是上面乘法中的 $f$ 矩阵。</p><p>需要注意的是这是广义矩阵乘法，也就是说这个矩阵乘法的运算规则为：</p><script type="math/tex; mode=display">c[i][j]=max(c[i][j],a[i][k]+b[k][j])</script><p>很像 $floyd$ ，可以直接算了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IN</span><span class="params">(_Tp&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(flag) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span> &#123;</span><span class="keyword">int</span> c[<span class="number">2</span>][<span class="number">2</span>];matrix()&#123;c[<span class="number">0</span>][<span class="number">0</span>]=c[<span class="number">0</span>][<span class="number">1</span>]=c[<span class="number">1</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">1</span>]=-inf;&#125;&#125;;</span><br><span class="line">matrix <span class="keyword">operator</span> * (matrix&amp;a,matrix&amp;b) &#123;</span><br><span class="line">    matrix ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;++j)<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;++k)</span><br><span class="line">        ret.c[i][j]=max(ret.c[i][j],a.c[i][k]+b.c[k][j]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[N],dp[N][<span class="number">2</span>],head[N],nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;nxt[++cnt]=head[u],to[cnt]=v,head[u]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_cut_tree</span> &#123;</span></span><br><span class="line">    matrix f[N],g[N];</span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">2</span>],fa[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> !((ch[fa[x]][<span class="number">0</span>]==x)||(ch[fa[x]][<span class="number">1</span>]==x));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        f[x]=g[x];</span><br><span class="line">        <span class="keyword">if</span>(ch[x][<span class="number">0</span>]) f[x]=f[ch[x][<span class="number">0</span>]]*f[x];<span class="keyword">if</span>(ch[x][<span class="number">1</span>]) f[x]=f[x]*f[ch[x][<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y],k=ch[y][<span class="number">1</span>]==x,v=ch[x][!k];</span><br><span class="line">        <span class="keyword">if</span>(!isroot(y)) ch[z][ch[z][<span class="number">1</span>]==y]=x;ch[x][!k]=y,ch[y][k]=v;</span><br><span class="line">        <span class="keyword">if</span>(v) fa[v]=y;fa[y]=x,fa[x]=z;pushup(y);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!isroot(x)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isroot(fa[x]))</span><br><span class="line">                rotate((ch[fa[x]][<span class="number">0</span>]==x)^(ch[fa[fa[x]]][<span class="number">0</span>]==fa[x])?x:fa[x]);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;pushup(x);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;x=fa[y=x]) &#123;</span><br><span class="line">            Splay(x);</span><br><span class="line">            <span class="keyword">if</span>(ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">                g[x].c[<span class="number">0</span>][<span class="number">0</span>]+=max(f[ch[x][<span class="number">1</span>]].c[<span class="number">0</span>][<span class="number">0</span>],f[ch[x][<span class="number">1</span>]].c[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">                g[x].c[<span class="number">1</span>][<span class="number">0</span>]+=f[ch[x][<span class="number">1</span>]].c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y) &#123;</span><br><span class="line">                g[x].c[<span class="number">0</span>][<span class="number">0</span>]-=max(f[y].c[<span class="number">0</span>][<span class="number">0</span>],f[y].c[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">                g[x].c[<span class="number">1</span>][<span class="number">0</span>]-=f[y].c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            g[x].c[<span class="number">0</span>][<span class="number">1</span>]=g[x].c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            ch[x][<span class="number">1</span>]=y,pushup(x);</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        Access(x),Splay(x),g[x].c[<span class="number">1</span>][<span class="number">0</span>]-=v[x]-y;</span><br><span class="line">        pushup(x),v[x]=y;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        dp[u][<span class="number">1</span>]=v[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(v!=fa[u]) &#123;</span><br><span class="line">                fa[v]=u,build(v);</span><br><span class="line">                dp[u][<span class="number">0</span>]+=max(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]);</span><br><span class="line">                dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g[u].c[<span class="number">0</span>][<span class="number">0</span>]=g[u].c[<span class="number">0</span>][<span class="number">1</span>]=dp[u][<span class="number">0</span>];</span><br><span class="line">        g[u].c[<span class="number">1</span>][<span class="number">0</span>]=dp[u][<span class="number">1</span>];f[u]=g[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;IN(n),IN(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) IN(v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;++i)IN(u),IN(v),add(u,v),add(v,u);</span><br><span class="line">    T.build(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;IN(x),IN(y);</span><br><span class="line">        T.change(x,y),T.Splay(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(T.f[<span class="number">1</span>].c[<span class="number">0</span>][<span class="number">0</span>],T.f[<span class="number">1</span>].c[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看懂了后发现 $\texttt{DDP}$ 其实不难呢……&lt;/p&gt;
&lt;p&gt;其实主要思想就是将 $\texttt{DP}$ 转移式搞到矩阵上，然后如果是树形 $\texttt{DP}$ 的话就可以直接上树剖或者是 $LCT$ 进行维护，当然还可以用全局平衡二叉树(不费) 。如果只是线性的话可以直接用线段树等数据结构进行维护了。&lt;/p&gt;
&lt;p&gt;注意这道模板树剖的复杂度是 $O(nlog^2n)$ ，而 $LCT$ 的复杂度为 $O(nlogn)$ ，于是窝选择了 $LCT$ ，跑的还挺快。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://qiulyblog.github.io/tags/DP/"/>
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LCT" scheme="http://qiulyblog.github.io/tags/LCT/"/>
    
      <category term="矩阵" scheme="http://qiulyblog.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>【题解】[HNOI2019]白兔之舞  单位根反演+MTT  luoguP5293</title>
    <link href="http://qiulyblog.github.io/2019/04/17/%5B%E9%A2%98%E8%A7%A3%5DluoguP5293/"/>
    <id>http://qiulyblog.github.io/2019/04/17/[题解]luoguP5293/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-18T01:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>单位根反演不会啊怎么搞 $FFT$ 吧，还是了解了单位根反演后才可以搞的好吧……居然有人吐槽我说我<strong>学了 $FFT​$ 但是不会运用？！</strong>，嘤嘤嘤打击有些大……</p><p>实际上所谓的单位根反演就是这个东西：</p><script type="math/tex; mode=display">\frac{1}{n}\sum_{i=0}^{n-1}(\omega_n^d)^i=[n|d]</script><a id="more"></a><p>回到题目，我们先考虑正解的简化版—— $n=1$ 的版本，我们先定义 $W=w[1][1]$ 。</p><p>现在对于每一个 $t$ 的答案显然为 $\sum_{i=0}^{L}[i\% k=t] W^i (^L_i)$</p><p>这个式子显然等于 $\sum_{i=0}^{L}[k|(i-t)] w^i (^L_i)$ 。会发现 $[k|(i-t)]$ 和上面单位根反演的 $[n|d]$ 一样，于是我们尝试将单位根反演的式子带进去。</p><script type="math/tex; mode=display">=\sum_{i=0}^{L}\frac{1}{k}\sum_{j=0}^{k-1}(\omega_k^{i-t})^j W^i \binom{L}{i}\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \omega_k^{ij} W^i \binom{L}{i}\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \binom{L}{i}(\omega_k^{j} W)^i\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \binom{L}{i}(\omega_k^{j} W)^i 1^{n-i}\\\\=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}(\omega_k^{j} W+1)^L</script><p>后面的 $(\omega_k^{j} W+1)^L$ 显然可以预处理，记为 $num_j$ 。</p><p>然后发现 $-tj=\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}$</p><script type="math/tex; mode=display">=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}}num_j\\\\=\frac{1}{k}\omega_k^{\binom{t}{2}}\sum_{j=0}^{k-1}num_j\omega_k^{\binom{j}{2}}\cdot\omega_k^{-\binom{t+j}{2}}</script><p>后面的式子可以用 $FFT$ 加速，但是值域太大这里需要用到 $MTT$ 。现在就有 $40$ 分了，接下来考虑 $n&gt;1$ 的情况。</p><p>我们建矩阵，然后会发现 $n&gt;1$ 仅会对 $num_j$ 的计算方式有变化。</p><p>我们定义一个 $begin$ 矩阵，该矩阵只有 $(0,x)$ 位置上有值且值为 $1$ ，也就是说这是白兔的起点。那么最后我们需要留下来的也就是矩阵的 $(0,y)$ ，因为只有在第二维为 $y$ 是才会计入答案。</p><p>嗯，差不多可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin.c[<span class="number">0</span>][x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) </span><br><span class="line">    num[i]=(begin*<span class="built_in">pow</span>(w*num[i]+I,n)).c[<span class="number">0</span>][y]%MOD;</span><br><span class="line"><span class="comment">/*w就是上文中的W，不过这里是矩阵*/</span></span><br><span class="line"><span class="comment">/*I是矩阵中的单位'1'*/</span></span><br></pre></td></tr></table></figure><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">65536</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);   </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,k,n,x,y,MOD,G,num[N],A[N&lt;&lt;<span class="number">2</span>],B[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OI &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> F(x,i,j) for((x)=(i);(x)&lt;=(j);++(x))</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">IN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;<span class="keyword">bool</span> flag=<span class="number">0</span>;ll x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch=getchar(),!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(flag) x=-x;<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">matrix</span> &#123;</span><span class="keyword">int</span> c[<span class="number">3</span>][<span class="number">3</span>];matrix()&#123;<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));&#125;&#125;;</span><br><span class="line">    matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> matrix&amp;a,<span class="keyword">const</span> matrix&amp;b) &#123;</span><br><span class="line">        matrix ans;<span class="keyword">int</span> i,j;F(i,<span class="number">0</span>,<span class="number">2</span>)F(j,<span class="number">0</span>,<span class="number">2</span>) &#123;</span><br><span class="line">            ans.c[i][j]=a.c[i][j]+b.c[i][j];</span><br><span class="line">            <span class="keyword">if</span>(ans.c[i][j]&gt;=MOD) ans.c[i][j]-=MOD;</span><br><span class="line">        &#125;<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix&amp;a,<span class="keyword">const</span> matrix&amp;b) &#123;</span><br><span class="line">        matrix ans;<span class="keyword">int</span> i,j,k;F(i,<span class="number">0</span>,<span class="number">2</span>)F(j,<span class="number">0</span>,<span class="number">2</span>)F(k,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">            ans.c[i][k]=(ans.c[i][k]+<span class="number">1l</span>l*a.c[i][j]*b.c[j][k])%MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix&amp;a,<span class="keyword">const</span> <span class="keyword">int</span>&amp;b) &#123;</span><br><span class="line">        matrix ans;<span class="keyword">int</span> i,j;F(i,<span class="number">0</span>,<span class="number">2</span>)F(j,<span class="number">0</span>,<span class="number">2</span>)ans.c[i][j]=<span class="number">1l</span>l*a.c[i][j]*b%MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span><span class="keyword">complex</span>(<span class="keyword">long</span> <span class="keyword">double</span> a=<span class="number">0</span>,<span class="keyword">long</span> <span class="keyword">double</span> b=<span class="number">0</span>)&#123;x=a,y=b;&#125;<span class="keyword">long</span> <span class="keyword">double</span> x,y;&#125;;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> + (<span class="keyword">complex</span> a,<span class="keyword">complex</span> b)&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(a.x+b.x,a.y+b.y);&#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> - (<span class="keyword">complex</span> a,<span class="keyword">complex</span> b)&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(a.x-b.x,a.y-b.y);&#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> * (<span class="keyword">complex</span> a,<span class="keyword">complex</span> b)&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;</span><br><span class="line">    matrix I;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1l</span>l*x*x%MOD) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1l</span>l*res*x%MOD;</span><br><span class="line">        <span class="keyword">return</span> res%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> matrix <span class="title">pow</span><span class="params">(matrix x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        matrix res=I;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> OI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MTT &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> BLOCK 32768</span></span><br><span class="line">    <span class="keyword">int</span> limit=<span class="number">1</span>,cnt=<span class="number">0</span>,filp[N&lt;&lt;<span class="number">2</span>],Ans[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">complex</span> A1[N&lt;&lt;<span class="number">2</span>],B1[N&lt;&lt;<span class="number">2</span>],A2[N&lt;&lt;<span class="number">2</span>],B2[N&lt;&lt;<span class="number">2</span>],X[N&lt;&lt;<span class="number">2</span>],omg[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fft</span><span class="params">(<span class="keyword">complex</span> *f,<span class="keyword">short</span> inv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)<span class="keyword">if</span>(i&lt;filp[i])<span class="built_in">std</span>::swap(f[i],f[filp[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;limit;p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">complex</span> *a=f;a!=f+limit;a+=(p&lt;&lt;<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;p;++l)&#123;</span><br><span class="line">                    <span class="keyword">complex</span> t=a[l+p]*omg[limit/(p&lt;&lt;<span class="number">1</span>)*l];</span><br><span class="line">                    a[l+p]=a[l]-t,a[l]=a[l]+t;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mtt</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(limit&lt;(k*<span class="number">3</span>+<span class="number">5</span>)) limit&lt;&lt;=<span class="number">1</span>,++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) filp[i]=(filp[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(cnt<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) A1[i].x=A[i]&amp;(BLOCK<span class="number">-1</span>),A2[i].x=A[i]&gt;&gt;<span class="number">15</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) B1[i].x=B[i]&amp;(BLOCK<span class="number">-1</span>),B2[i].x=B[i]&gt;&gt;<span class="number">15</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) omg[i]=(<span class="keyword">complex</span>)&#123;<span class="built_in">cos</span>(i*PI*<span class="number">2</span>/limit),<span class="built_in">sin</span>(i*PI*<span class="number">2</span>/limit)&#125;;</span><br><span class="line">        fft(A1,<span class="number">1</span>),fft(B1,<span class="number">1</span>);fft(A2,<span class="number">1</span>),fft(B2,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">            <span class="keyword">complex</span> a1=A1[i],a2=A2[i],b1=B1[i],b2=B2[i];</span><br><span class="line">            A1[i]=a1*b1,A2[i]=a2*b2,B1[i]=a1*b2,B2[i]=a2*b1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i) omg[i]=(<span class="keyword">complex</span>)&#123;<span class="built_in">cos</span>(i*PI*<span class="number">2</span>/limit),-<span class="built_in">sin</span>(i*PI*<span class="number">2</span>/limit)&#125;;</span><br><span class="line">        fft(A1,<span class="number">-1</span>),fft(B1,<span class="number">-1</span>);fft(A2,<span class="number">-1</span>),fft(B2,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)</span><br><span class="line">            A1[i].x/=limit,A2[i].x/=limit,B1[i].x/=limit,B2[i].x/=limit;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;limit;++i)</span><br><span class="line">            Ans[i]=((ll)(A1[i].x+<span class="number">0.5</span>)%MOD+<span class="number">1073741824l</span>l*((ll)(A2[i].x+<span class="number">0.5</span>)%MOD)%MOD+</span><br><span class="line">            <span class="number">32768l</span>l*((ll)(B1[i].x+<span class="number">0.5</span>)%MOD)%MOD+<span class="number">32768l</span>l*((ll)(B2[i].x+<span class="number">0.5</span>)%MOD)%MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> MTT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> divisor[<span class="number">105</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_G</span><span class="params">()</span> </span>&#123;<span class="comment">/*获取原根*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,S=MOD<span class="number">-1</span>;i&lt;=S;++i) </span><br><span class="line">        <span class="keyword">if</span>(S%i==<span class="number">0</span>) &#123;divisor[++tot]=i;<span class="keyword">while</span>(!(S%i)) S/=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> g=<span class="number">2</span>;;++g) &#123;</span><br><span class="line">        <span class="keyword">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;++j) <span class="keyword">if</span>(<span class="built_in">pow</span>(g,(MOD<span class="number">-1</span>)/divisor[j])==<span class="number">1</span>) &#123;ok=<span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(ok) <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matrix w,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    I.c[<span class="number">0</span>][<span class="number">0</span>]=I.c[<span class="number">1</span>][<span class="number">1</span>]=I.c[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    m=IN(),k=IN(),n=IN(),x=IN(),y=IN(),MOD=IN();--x,--y;</span><br><span class="line">    <span class="comment">/*num其实就是上文中的单位根，这里预处理一下计算方便些*/</span></span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">1</span>,num[<span class="number">1</span>]=<span class="built_in">pow</span>(G=get_G(),(MOD<span class="number">-1</span>)/k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;k;++i) num[i]=<span class="number">1l</span>l*num[<span class="number">1</span>]*num[i<span class="number">-1</span>]%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) w.c[i][j]=IN();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);++i) A[i]=num[(k<span class="number">-1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>%k)%k];</span><br><span class="line">    s.c[<span class="number">0</span>][x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) B[i]=<span class="number">1l</span>l*num[<span class="number">1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>%k]*(s*<span class="built_in">pow</span>(w*num[i]+I,n)).c[<span class="number">0</span>][y]%MOD;</span><br><span class="line">    <span class="comment">/*计算后面两个多项式的值*/</span></span><br><span class="line">    reverse(B,B+k+<span class="number">1</span>),mtt(A,B);</span><br><span class="line">    <span class="keyword">int</span> invk=<span class="built_in">pow</span>(k,MOD<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="number">1l</span>l*Ans[i+k]*invk%MOD*num[<span class="number">1l</span>l*i*(i<span class="number">-1</span>)/<span class="number">2</span>%k]%MOD);</span><br><span class="line">    <span class="comment">/*计算答案*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单位根反演不会啊怎么搞 $FFT$ 吧，还是了解了单位根反演后才可以搞的好吧……居然有人吐槽我说我&lt;strong&gt;学了 $FFT​$ 但是不会运用？！&lt;/strong&gt;，嘤嘤嘤打击有些大……&lt;/p&gt;
&lt;p&gt;实际上所谓的单位根反演就是这个东西：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{n}\sum_{i=0}^{n-1}(\omega_n^d)^i=[n|d]&lt;/script&gt;
    
    </summary>
    
      <category term="OI" scheme="http://qiulyblog.github.io/categories/OI/"/>
    
    
      <category term="题解" scheme="http://qiulyblog.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="FFT" scheme="http://qiulyblog.github.io/tags/FFT/"/>
    
      <category term="单位根反演" scheme="http://qiulyblog.github.io/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
      <category term="MTT" scheme="http://qiulyblog.github.io/tags/MTT/"/>
    
  </entry>
  
</feed>
