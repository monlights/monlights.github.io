<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【题解】 [HNOI2019]多边形 组合数学 luoguP5288]]></title>
    <url>%2F2019%2F04%2F12%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP5288%2F</url>
    <content type="text"><![CDATA[$\texttt{HNOI2019}$ 终于改出来一道题目了……感谢 $JerryC$ 跟我一起讨论，不然我也看不懂题解。这题真的是 $\texttt{HNOI2019}$ 最可做的题啊，可想而知 $\texttt{HNOI2019}$ 有多么毒瘤了。 $orz yyb$ ，感谢 $yyb$ 大佬的题解。 这一题一共有两问，并且部分分也比较多，接下来我们一起来逐一攻破这些特殊条件。 1.只有第一问且 $m=0$ 的情况其实这个时候我们可以发现，最终的答案是要满足所有的点都连向 $n$ 。 对于每一次旋转操作，可以让 一个没有连向 $n$ 的点连向 $n$ ，并且一次旋转操作也最多可以使得一个没有连向 $n$ 的点连向 $n$ 。既然要求最少步数，我们考虑最优情况：每一次旋转都有一个新的点连向 $n$ 。这个时候最终需要的最少步数显然就是 $n-1-$已经与 $n$ 连接了的点数，为什么 $-1$ ？因为最终需要连向 $n$ 的点不包括 $n$ 。(ps：这里指的已经与 $n$ 连接了的点数其实包括 $1$ 与 $n-1$) 。 至于代码实现的话，我们用个 $vector$ 来存连接的点，最后统计一下 $size$ 即可。 2.有两问且 $m=0$ 的情况初始局面的第一问我们已经解决了，现在我们来看看怎么解决初始局面的第二问。 假设当前与 $n$ 连接了的点的集合为 $S=\{a_1,a_2,\cdots ,a_s\}$ ，这个时候我们将 $1$ 到 $n$ 分成若干个区间：$[1,a_1],[a_1,a_2],\cdots,[a_{s-1},a_s],[a_s,n-1]$ ，我们会发现，每一次旋转操作的四个点一定属于同一个区间 。在最终状态，每一个区间中的所有的点都是连向 $n$ 的。 那么我们考虑计算每一个区间的操作序列，我们设 $[a_i,a_{i+1}]$ 区间的操作序列长度为 $sz(a_i)$ 。注意这个操作序列指的就是一个区间从初始状态到最终状态的所有旋转操作组成的序列。 我们现在考虑方案数，假设我们知道了 $sz(a_i),sz(a_{i+1})$ ，也就是区间 $[a_i,a_{i+1}]$ 和区间 $[a_{i+1},a_{i+2}]$ 的操作序列的长度。那么使得这两个区间都到达最终状态的方案数显然为 $C_{sz(a_i)+sz(a_{i+1})}^{sz(a_i)}$，当然也是 $C_{sz(a_i)+sz(a_{i+1})}^{sz(a_{i+1})}$ 。 这下子计算就变得简单多了，但是我们怎么求出使得单个区间变为最终状态的方案数以及当个区间的操作序列长度呢？这个时候我们可以将每一个区间 $[a_i,a_{i+1}]$ 建成一棵二叉树，每一次将 $[a_i,a_{i+1}]$ 拆成 $[a_i,p],[p,a_{i+1}]$ ，在树中这两个子区间就是 $[a_i,a_{i+1}]$ 的两个儿子。 这下子使得 $[a_i,a_{i+1}]$ 变为最终状态的方案数显然可以从其树中的两个儿子得出了，计算的方法和上面同理。 至于这个 $p$ ，假设当前区间为 $l,r$ ，我们可以选择 第一个比 $l+1$ 大且与 $r$ 连了边的点 ，那么这个时候可以理解为 拆掉 $p,r$ 这条边，然后连起来 $p,n$ 这条边 ，于是 $l,p$ 可以作为一个区间了，$p,r$ 也可以作为一个区间了。 为什么一定要选择第一个比 $l+1$ 大且与 $r$ 连了边的点呢？我们考虑两个点 $a$ 和 $b$ ，其中 $a$ 就是第一个比 $l+1$ 大且与 $r$ 连了边的点，$b$ 则是一个小于 $r$ 大于 $a$ 并且和 $r$ 连了边的点 。如果这个时候选择将 $b,r$ 断开连接 $b,n$ 的话，线段 $a,r$ 和线段 $b,n$ 显然会交叉 ，那么就不合法了。所以我们选择第一个比 $l+1$ 大且与 $r$ 连了边的点，这样至少是合法的。当然如果这个点大于 $r$ 了就没办法了。 代码的话一个 $dfs$ 可以搞定。 3.$m&gt;0$ 且只有第一问的情况首先我们会发现，第一问的答案其实就是我们的树的结点个数。 然后考虑这个旋转操作，现在有 $a&lt;b&lt;c&lt;d​$ ，我们需要求出的就是 $(a,c)​$ 旋转对第一问带来的变化。 既然 $a,c$ 是连了边的，那么在树中也一定有一个节点代表 $[a,c]$ 区间，我们先在树中找到这个节点，然后再分两种情况来讨论。 一.该节点在树中有父节点我们将图画出来： （左边的是原来的，右边的是经过了 $(a,c)$ 旋转的） 可以发现，旋转之后我们损失了 $(a,c)$ 节点，但是多了个 $(b,d)$ 节点，我们的节点数实际上是没有变的。也就是说我们第一问的答案没有变。 二.该节点在树中没有父节点这个时候 $a,c$ 肯定都是已经连向了 $n$ 的，不然不可能没有父节点。那么这个时候 $d$ 要不是 $n$ 要不是其他区间的点了。上文已经讲了，旋转操作只可能在一个区间内进行，也就是说 $d$ 只能等于 $n$ 。 那么 $d=n$ 的话树会怎么变换呢？很显然，$(a,c)$ 会消失，剩下的就是 $(a,b)$ 和 $(b,c)$ 。这个时候是少了一个点的，那么第一问的答案就要减一了。 如果从多边形的角度理解的话，会发现多了一个连接了 $n$ 的点，那么第一问的答案自然就少了一。 这个代码实现就不讲了。 4.$m&gt;0$ 且两问都有的情况解决了这个情况我们就胜利了。 也就是说现在我们需要解决 $m&gt;0$ 时第二问怎么变化。 按照上面的来就行了。 一.该节点在树中有父节点按照上面的图，我们可以先将这些节点的贡献去掉。然后再加上新的贡献即可。 二.该节点在树中没有父节点我们直接去掉 $(a,c)$ 的贡献，然后加上 $(a,b),(b,c)$ 的贡献即可。 这一部分可以参照代码了。 综上，我们解决了所有的问题，接下来贴出代码 $QwQ$ 。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e5+2;const int MOD=1e9+7;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int W,n,Ans1,Ans2=1;vector&lt;int&gt; G[N];/*G[i]表示与i相连接的点的集合*/map&lt;pair&lt;int,int&gt;,int&gt; vis;/*这个是为了方便快速找到代表(a,c)节点所用的map*/inline void solve() &#123;//初始化 for(int i=2;i&lt;n;++i) G[i].push_back(i+1),G[i].push_back(i-1); G[1].push_back(n),G[1].push_back(2); G[n].push_back(n-1),G[n].push_back(1); for(int i=1;i&lt;=n;++i) sort(G[i].begin(),G[i].end());&#125;int inv[N&lt;&lt;1],fct[N&lt;&lt;1],fci[N&lt;&lt;1];/*分别对应逆元，阶乘，逆元的阶乘。主要用于计算组合数*/inline int C(int n,int m) &#123; if(n&lt;0||m&lt;0||n&lt;m) return 0; return 1ll*fct[n]*fci[m]%MOD*fci[n-m]%MOD;&#125;inline int Inv_C(int n,int m) &#123; if(n&lt;0||m&lt;0||n&lt;m) return 0; return 1ll*fci[n]*fct[m]%MOD*fct[n-m]%MOD;&#125;inline int calc(int n,int m) &#123;return C(n+m,n);&#125;inline int Inv_calc(int n,int m) &#123;return Inv_C(n+m,n);&#125;/*上面的组合数不再赘述......*/int root[N],fa[N&lt;&lt;1],sz[N&lt;&lt;1],ch[N&lt;&lt;1][2],tot;/*root[i]就是S集合中的区间ai,ai+1在树中的节点的编号*//*fa表示父节点，sz表示节点子树大小，ch表示节点的左右儿子*/void dfs(int&amp;x,int f,int l,int r) &#123; if(r-l&lt;=1) return; x=++tot,sz[x]=1,fa[x]=f; int p=lower_bound(G[r].begin(),G[r].end(),l+1)-G[r].begin(); /*找到这个p*/ p=G[r][p],vis[make_pair(l,r)]=x; /*找到p在原多边形中对应的点，并记录l,r在树中的点的编号*/ dfs(ch[x][0],x,l,p),dfs(ch[x][1],x,p,r);/*向下计算子树*/ sz[x]+=sz[ch[x][0]]+sz[ch[x][1]];/*统计子树大小*/ Ans2=1ll*Ans2*calc(sz[ch[x][0]],sz[ch[x][1]])%MOD;/*计算贡献*/&#125;int main() &#123; IN(W),IN(n); inv[0]=inv[1]=fct[0]=fci[0]=1; for(int i=2;i&lt;=n+n;++i) inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD; for(int i=1;i&lt;=n+n;++i) fct[i]=1ll*fct[i-1]*i%MOD; for(int i=1;i&lt;=n+n;++i) fci[i]=1ll*fci[i-1]*inv[i]%MOD; /*以上为初始化逆元，阶乘，逆元的阶乘*/ for(int i=1;i&lt;=n-3;++i) &#123; int x,y;IN(x),IN(y); G[x].push_back(y),G[y].push_back(x); &#125; solve(),Ans1=n-1-G[n].size(); for(int i=0,len=G[n].size();i&lt;len-1;++i) dfs(root[i],0,G[n][i],G[n][i+1]);/*计算每个区间ai,ai+1的树*/ int Size=0; for(int i=0,len=G[n].size();i&lt;len-1;++i) Ans2=1ll*Ans2*calc(Size,sz[root[i]])%MOD,Size+=sz[root[i]]; /*统计答案*/ if(!W) printf("%d\n",Ans1); else printf("%d %d\n",Ans1,Ans2); int q;IN(q); while(q--) &#123; int a,b;IN(a),IN(b); if(a&gt;b) a^=b^=a^=b; int x=vis[make_pair(a,b)];/*找到在原树中a,b所代表的节点*/ if(!W) &#123;printf("%d\n",Ans1-(fa[x]?0:1));continue;&#125; else &#123; int nowans1=Ans2; if(fa[x]) &#123; int y=fa[x],k=ch[y][1]==x; nowans1=1ll*nowans1*Inv_calc(sz[ch[x][0]],sz[ch[x][1]])%MOD; nowans1=1ll*nowans1*Inv_calc(sz[ch[y][0]],sz[ch[y][1]])%MOD; nowans1=1ll*nowans1*calc(sz[ch[x][!k]],sz[ch[y][!k]])%MOD; nowans1=1ll*nowans1*calc(1+sz[ch[y][!k]]+sz[ch[x][!k]],sz[ch[x][k]])%MOD; /*除掉贡献与增加贡献*/ &#125; else &#123; nowans1=1ll*nowans1*Inv_calc(sz[ch[x][0]],sz[ch[x][1]])%MOD; nowans1=1ll*nowans1*Inv_calc(Size-sz[x],sz[x])%MOD; nowans1=1ll*nowans1*calc(Size-sz[x],sz[ch[x][0]])%MOD; nowans1=1ll*nowans1*calc(Size-sz[x]+sz[ch[x][0]],sz[ch[x][1]])%MOD; /*除掉贡献与增加贡献*/ &#125; printf("%d %d\n",Ans1-(fa[x]?0:1),nowans1);/*输出答案*/ &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 不同子串个数 后缀数组.SA luoguP2408]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2408%2F</url>
    <content type="text"><![CDATA[后缀数组。 假设我们现在已经求出了 $height$ 数组，我们发现，对两个后缀，其重复了的字串的个数就是 $height$ 数组所记录的数。我们举个例子： 后缀$sa[i-1]$: $aaabbdbs$后缀$sa[i]$ : $aabbdbs$ 会发现，最前面的”$aa$”是两个串都有的，”$aa$”中包含的”$a$”也是两个串都有的，这样子就有两个重复的了，可以发现这个重复个数正好是 $height[i]$ 的值。 但是后面还是有重复的啊？没关系，因为我们有所有的后缀，所以整个串中所有的重复的串都会被统计进来。所以这下子我们可以很容易的求出整个串中重复的串的个数了，就是 $\sum_{i=1}^{n}height[i]$ 。 子串的个数显然是 $\frac{n(n+1)}{2}$ ，这两项相减就是我们需要的答案了，记得开 $longlong$ 。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e5+2;const int inf=1e9+9;namespace Suffix_array &#123; char s[N]; int sa[N],x[N],y[N],hep[N],height[N],n,m; void Sort() &#123; for(int i=0;i&lt;=m;++i) hep[i]=0; for(int i=1;i&lt;=n;++i) ++hep[x[i]]; for(int i=1;i&lt;=m;++i) hep[i]+=hep[i-1]; for(int i=n;i&gt;=1;--i) sa[hep[x[y[i]]]--]=y[i]; &#125; void Pre_sa() &#123; for(int i=1;i&lt;=n;++i) x[i]=s[i],y[i]=i; m=129;Sort(); for(int w=1,p=0;m=p,p&lt;n;w&lt;&lt;=1) &#123; p=0; for(int i=1;i&lt;=w;++i) y[++p]=n-w+i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;w) y[++p]=sa[i]-w; Sort(),swap(x,y),x[sa[1]]=p=1; for(int i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+w]==y[sa[i-1]+w])?p:++p; &#125;return; &#125; ll Pre_height() &#123; for(int i=1;i&lt;=n;++i) x[sa[i]]=i; int k=0,res=0; for(int i=1;i&lt;=n;++i) &#123; k-=k&gt;0; int j=sa[x[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) ++k; height[x[i]]=k,res+=k; &#125;return res;//直接返回height数组的和 &#125;&#125;using namespace Suffix_array;int main() &#123; scanf("%d\n",&amp;n); scanf("%s",s+1); Pre_sa(); ll ans=1ll*n*(n+1)/2; ans-=Pre_height(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>后缀数组.SA</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[SDOI2017]数字表格 莫比乌斯反演 luoguP3704]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3704%2F</url>
    <content type="text"><![CDATA[我们设 $n \leq m​$ ，然后开始推式子，我们将 $gcd(i,j)​$ 的值作为 “$d​$” 提出来： \prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}if(gcd(i,j)=d) f[d]=\prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}if(gcd(i,j)=d) f[d]=\prod_{d=1}^{n}\prod_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\prod_{j=1}^{ \lfloor\frac{m}{d}\rfloor }if(gcd(i,j)=1) f[d]=\prod_{d=1}^{n} f[d]^{\sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]} $\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]​$ 是个熟悉的式子，我们从这个式子继续开刀： \sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{ \lfloor\frac{m}{d}\rfloor }[gcd(i,j)=1]​=\sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{ \lfloor\frac{m}{d}\rfloor }\sum_{x|gcd(i,j)} \mu(x)​=\sum_{x=1}^{n}\mu(x)\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor​于是原来的式子变成了： \prod_{d=1}^{n} f[d]^{\sum_{x=1}^{n}\mu(x)\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor}​设 $T=dx$ ，并将 $T$ 提出来枚举： \prod_{d=1}^{n} f[d]^{\sum_{x=1}^{n}\mu(x)\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor}​=\prod_{T=1}^{n}\prod_{d|T} f[d]^{\mu( \lfloor\frac{T}{d}\rfloor )\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor}=\prod_{T=1}^{n}(\prod_{d|T} f[d]^{\mu( \lfloor\frac{T}{d}\rfloor )})^{\lfloor\frac{n}{T}{\rfloor\lfloor\frac{m}{T}\rfloor}}这个样子多好啊，我们可以将可爱的 $(\prod_{d|T} f[d]^{\mu( \lfloor\frac{T}{d}\rfloor )})$ 预处理，也就是枚举每一个 $d$ ，然后将可以整除 $d$ 的每一个 $T$ 都算上 $d$ 带来的贡献即可。最后的时候可以整除分块。最终的时间复杂度为 $O(\sqrt{n})$ ，当然不算上预处理时候的复杂度，如果加上预处理的复杂度，最终的复杂度应该为 $O(N(log\ N+log\ mod)+T(\sqrt{n} \ log\ mod))$ ，$log\ mod$ 就是算逆元的复杂度。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e6+2;#define MOD 1000000007template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;bool vis[N+15];int mui[N+15],inv[N+15],fib[N+15],sum[N+15],prime[N],cnt;inline int pow(int x,int y) &#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%MOD) if(y&amp;1) res=1ll*res*x%MOD; return res%MOD;&#125;inline void pre() &#123; fib[1]=inv[1]=sum[0]=sum[1]=1; vis[1]=true,mui[1]=1; for(int i=2;i&lt;=N;++i) &#123; fib[i]=(fib[i-1]+fib[i-2])%MOD; inv[i]=pow(fib[i],MOD-2),sum[i]=1; if(!vis[i]) prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;++j) &#123; vis[i*prime[j]]=1; if(!(i%prime[j])) break; else mui[i*prime[j]]=-mui[i]; &#125; &#125; for(int d=1;d&lt;=N;++d) &#123; if(!mui[d]) continue; for(int T=d;T&lt;=N;T+=d) sum[T]=1ll*sum[T]*(mui[d]==1?fib[T/d]:inv[T/d])%MOD; &#125; for(int i=2;i&lt;=N;++i) sum[i]=1ll*sum[i]*sum[i-1]%MOD; return;&#125;int T,n,m;int main() &#123; pre(),IN(T); while(T--) &#123; IN(n),IN(m); if(n&gt;m) swap(n,m); int ans=1,res,num; for(int l=1,r=0;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); num=1ll*(n/l)*(m/l)%(MOD-1); res=1ll*sum[r]*pow(sum[l-1],MOD-2)%MOD; ans=1ll*ans*pow(res,num)%MOD; &#125; printf("%d\n",(ans+MOD)%MOD); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【游记】 HNOI2019酱油记]]></title>
    <url>%2F2019%2F04%2F08%2F%5B%E6%B8%B8%E8%AE%B0%5DHNOI2019%2F</url>
    <content type="text"><![CDATA[嘤嘤嘤嘤虽然还是六年级不至于退役但鸭梨还是好大好大。 这一次 $\texttt{HNOI2019}$ 仅仅是去走过场，$\texttt{HNOI2020}$ 才是真正需要重视的，于是鸭梨又小了许多，却还是不希望分数太难看。算了比完了再说吧。($2019.4.4 $$\ Qiuly$记) 给自己立个小目标——试着在 $\texttt{HNOI2019}$ 踩 $20\%$ 的人。 Day -2上午考试，下午改题，晚上颓废 上午考的不是很好，本来估计又 $150$ 的结果第三题全炸变成了 $85$ …… 晚上和 $JerryC​$ 一起颓废，后来有些虚了于是不玩了，去 $\texttt{HNFMSOJ}​$ 上将喵星球上的点名过掉了，实际上是看了题解的所以还是有些虚。然后九点的时候 $JerryC​$ 问窝最小路径覆盖问题怎么做，讨论了一番，然后感觉又没那么虚了。 Day -1上午考试，下午不想改题。 上午的考试不想写总结了，因为没有改出来一道题。上午的题目确实没有昨天的好做看到第二题是比较裸的 $AC​$ 自动机于是做掉了(结果最后只有 $80​$ 分？！) ，众所周知 $AC​$ 自动机是很好打的，我打完就没事干了，于是去高一机房看 $JerryC​$ 秒题去了。 中午和 $JerryC​$ 和史哥一起吃饭，但是出去的时候已经完了，出不了校门了。于是去小卖部吃泡面，味道海星。 下午回来先休息，$2​$ 点钟开始，然后看到洛谷智推有个永无乡于是切掉了。期间高二的年级组长(貌似是？)和高二机房的常规班上的班主任来了，说是来鼓励大家，给大家带来的许多吃的。当然没有窝的份于是窝继续做窝的永无乡，哎感觉我从头到尾就是个客人。 嗯打完了永无乡后将线段树合并的代码发给史哥了，因为史哥中午曾问窝线段树合并肿么打。 然后写 $\texttt{HNOI2019}​$ 游记(就是现在这篇)。 写完游记没事干了，然后去切掉了最小路径覆盖问题。这个时候差不多要吃晚饭于是跟着 $JerryC,CYjian,Yasar​$ 一起吃的晚饭。他们是住的什么托管，感觉……那个晚饭还是不吃为好。 结果最后回机房的时候也没有碰过一点吃的东西，于是 $JerryC$ 给了窝一包巧克力充充饥，好久没有这么一大包巧克力了，一口大满足美滋滋。 晚上无聊，不敢颓，于是康康板子，康康别人的博客，然后整理了一下自己的博客，差不多就回家了。 Day 0清明节是不可能有假期的，今天还是要来机房，没有睡成懒觉…… 嗯但是今天不考试，于是上午继续康康板子，不是很想打，只是看了一遍之前的代码： $\texttt{AC}$自动机，$\texttt{SAM}$，$\texttt{SA}$，$\texttt{FFT}$，$\texttt{NTT}$，$\texttt{MTT}$，$\texttt{Splay}$，$\texttt{LCT}$，树剖，杜教筛，莫比乌斯反演，$\texttt{CDQ}$分治，$\texttt{K-D Tree}$ 当然树套树是不可能看的，这辈子也不会复习的……光是码量就可以吓到我了。 $JerryC$ 说昨天他去康了 $\texttt{ICPC2019}$ 直播，但是窝没看因为窝不知道有这个比赛因为窝不能颓。 不想干活，跟熠宝聊了一下天，吃饭去了。 下午回来休息，然后快三点的时候看了下书，很讨厌这种恶心的感觉，希望 $\texttt{HNOI2019}$ 赶快比完，不然心里一直有鸭梨，并且已经厌烦这种恶心的感觉了，心里不是滋味。 看《进阶指南》，然后看了看 $DP$，看了看开车旅行想打但是不敢打，发现链表的次小不理解……于是也就没有打了。 不知道晚上要干些什么……于是玩了玩就睡觉了。 Day 1 辣鸡几何，毁我青春！ 早上在车上吃的面包，到了理工碰到了 $CYjian$ ，然后一大群 $yl,cj$ 的，几乎没有看到 $yz$ 的，差不多一刻钟以后才有 $yz$ 的陆陆续续赶来。 进入考场，嘿嘿两边的都是 $yz$ 的。解压题目，读了一遍。 (#`O′)怎么没有一道数据结构啊这是什么题啊！ 不急不急咱慢慢来，发现第一题不可做，第三题也不可做，第二题貌似可以骗分。于是开始肝第二题，$20$ 分比较简单，一个 $kmp$ 就够了，于是打打打，然而…… 发现自己忘记了 $kmp$ ! $mmp$，只好自己开始 $\texttt{YY}$ $kmp$ 了， 好几个都被自己 $hack$ 掉了……难道今天要爆零？虽然才六年级机会很多但是爆零的滋味不好受啊。于是打了个很虚的暴力查找，复杂度大概是……$O(n^3)$ ？我去这不T飞才怪，然后发现 $x\leq300$ ，嗯？我们一次最多加上 $300$ 个字符，那么……直接算多出来的这些贡献然后加上不久好了嘛，自己怎么这么$sb$呢。 嗯敲完了一遍过样例，然后不想拍了，第三题依旧感觉不可做，先康康第一题。 嗯，第一题的 $20​$ 可以暴力枚举点对，然后…… 角度怎么算啊喂，欺负窝是小学森是吧？！ 好吧然后想了想，距离相等的话很好算，关键是角度。我们对于这个角，将角的位置放到原点上，然后将其中另一个点放在 $y$ 轴上，剩下的一个点判断一下，如果跟 $y$ 轴上的点同号的话说明是锐角，不然就是钝角，当然直角的情况特判就好了。 嗯打完了，过了样例。 不过……发现我的程序对于”三点一线”的情况也算进去了，这样子显然构不成一条鱼啊。于是加了个特判，再测一遍手造数据，对了。然后又想了想，发现……如果是斜着的三点一线没有判！然后搞个斜率判了一判，应该可以吧……不过说实话第一题窝特别虚。(最后为了发泄，判斜率的函数名是”$check _ fuck$”……) 。 嗯第一题没什么做了，第三题又做不出，于是花费最后的一个半小时再康康第二题。翻到题面，发现，这道题是……可持久化后缀自动机？！，又逗小学森是吧……算了不会打。不过看了看 $30$ 分的部分分发现很像主席树，啪啪啪敲了个主席树，然后一直 $\texttt{WA}$ 到了最后 $15$ 分钟…… 算了算了不打了，索性把主席树全删了，然后检查文件名，康康有没有打错。最后带着发泄的心理将第三题输出样例，觉得不够，然后剩下的全部输出 $rand()$ ……第一题也如法炮制，将拿不到分的点全部输出 $rand()$ …… $Ctrl+s$ 保存，然后编译一波。全部都好了，然后正准备休息一下，讲台上的监考老师却突然大声喊道:”下考了！同学们请离开自己的座位！” 出去以后发现今天的题目确实挺难，听说 $boshi$ 只有 $100$ 分，$kb$ 只有 $125$ ，其他的都没有到达 $100$ 分的……然后跑去跟 $JerryC$ 闲聊，发现第三题的 $30$ 分可以直接记忆化，顿时失去智商 $QwQ$ 。 回家吃饭，然后只有正式选手的成绩出来了，发现很多人都挂了……自己也有些虚。 没多想什么，睡觉。 Day 2 辣鸡图论，毁我青春！ 早上到了理工大，跟 $wjj$ 毒奶今天三道数据结构，他不信，又奶到今天有图论题，疑似泄题 。 进考场，到机位，开机子，然后敲 $main​$ 。正敲着快读，监考老师却在台上大声嚷嚷道：”不许敲，敲就算作弊！”，我去这是搞什么啊，敲配置都不让，于是放慢了敲的节奏。$jbj​$ 进来听到了这一句话，小声骂了一句鬼监考(此处省略粗口)，然后大声的打键盘(是打不是敲…..)，监考满怀恨意的瞪了一眼 $jbj​$ 就走了(真想吐槽这个监考)。 打开题目，读了一遍，我去今天哪有什么数据结构题啊。刚开始看到第三题”序列”以为是一道数据结构，结果发现也挺毒瘤的。 做题顺序 $\texttt{T3-&gt;T2-&gt;T1}$ 。 看看 $\texttt{T3}$ 的数据范围，还有小数？小学森要气哭了。没关系有整数部分呢，貌似可以 $\texttt{DP}$，也就是用 $f[i][j]$ 表示第 $B_i$ 的值为 $j$ 时的最小差值，转移很显然。这样……貌似自己拿到这 $10$ 分了吧。 $\texttt{T2}$ 开始直接上爆搜打表找规律，设 $f[i][j]$ 为当前$L$的值为$i$，$n=1$ ，白兔跳的长度为 $j$ 时的不同路径数。爆搜一下子就打出来了，观察前十个，写在纸上，发现…… 这是个广义杨辉三角！ 普通杨辉三角：$c[i][1]​$=$c[i][i]​$=$1​$,$c[i][j]​$=$c[i​$-$1][j]​$+$c[i​$-$1][j​$-$1]​$ 广义杨辉三角：只满足 $c[i][j]$=$c[i$-$1][j]$+$c[i$-$1][j$-$1]$。这道题中的广义杨辉三角就是：$c[i][1]$=$i,$$c[i][i]$=$1$,$c[i][j]$=$c[i$-$1][j]$+$c[i$-$1][j$-$1]$ 嗯实际上知道这个就不难拿到前 $40$ 分了吧……但是我不会 $Lucas$ ! 于是这题做不成了，看第一题吧。 $\texttt{T1}$ 发现有些有趣，可以搞出一个双向广搜的写法，但是自己貌似 $hack$ 掉了这个解法，于是没分…… 于是今天最高只有 $10$ 分！ 感觉今天的题目完全不可做啊，甚至比昨天的还毒瘤许多。$\texttt{T3}$ 有树套树的嫌疑？算了算了不管了，出考场舒服多了，走了走了回家了。 (出题人你给我过来，我保证不捶死你！) Day 4成绩出来了。的确踩了 $20\%$ 以上的人。 发现自己估分很不准确…… 小学生真好，上个期末考试考好了，妈妈再也不用担心被常规虐了 ，于是在家里休息休息，准备给自己可爱的博客搞一个小域名：$qiuly.ml$ ，免费的。不过最后没搞成，$DNSpod$ 检测，除了 HTTP 异常，其他均为正常，不过就是因为这个异常导致这个域名计划失效了嘤嘤嘤。 这段时间用的是家里的电脑，果然笔记本还是容易发烫的……而且不知道为什么我的微软笔记本很容易发烫，主板说烫就烫起来了……不过真的好用，这个屏幕分辨率真的清晰(陈独秀同志请您坐下，不要秀自己的笔记本了……)。 这次，$\texttt{HNOI2019}$ 才是真正结束了。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2012]永无乡 线段树+启发式合并 luoguP3224]]></title>
    <url>%2F2019%2F04%2F04%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3224%2F</url>
    <content type="text"><![CDATA[实际上可以用平衡树做的但是不喜欢平衡树。 还是喜欢可爱的线段树，于是打了一发线段树合并。很久没有这样子的做题感觉了，真是美妙，思路清晰，交上去一遍过(窝不会告诉泥萌窝第一次交的时候忘关文件=。=)。 我们对于每一个点维护一个权值线段树，然后用并查集维护点与点之间的联通关系。对于一个连通块，该连通块的所有结点信息都保留在该连通块的 $root$ 上。 这样子我们合并两个岛的时候 $x,y$ ，可以直接将 $x$ 所在连通块的 $root$ (简称 $fx$ ) 和 $y$ 所在连通块的 $root$ (简称 $fy$ ) 合并起来，也就是将 $fy$ 的线段树并到 $fx$ 上去。这样子 $fx$ 就维护了这两个连通块的信息了，最后我们按照并查集的套路将 $fy$ 的父亲设为 $fx$ 即可。 询问就是基础操作，权值线段树就像主席树那样询问即可。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N=1e5+7;const int Max=N*650;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;struct Seg_Tree &#123; #define mid ((l+r)&gt;&gt;1) int cnt,rt[N],val[Max],lc[Max],rc[Max]; inline void pushup(int x) &#123; val[x]=val[lc[x]]+val[rc[x]]; &#125; void update(int&amp;x,int l,int r,int pos) &#123; if(!x) x=++cnt; if(l==r) &#123;++val[x];return;&#125; if(pos&lt;=mid) update(lc[x],l,mid,pos); else update(rc[x],mid+1,r,pos); pushup(x); &#125; int query(int x,int l,int r,int k) &#123; if(l==r) return l; int th=val[lc[x]]; if(k&lt;=th) query(lc[x],l,mid,k); else return query(rc[x],mid+1,r,k-th); &#125; int merge(int x,int y,int l,int r) &#123; if(!x||!y) return x+y; if(l==r) &#123;val[x]+=val[y];return x;&#125; lc[x]=merge(lc[x],lc[y],l,mid), rc[x]=merge(rc[x],rc[y],mid+1,r); pushup(x);return x; &#125;&#125;T;int fa[N],pos[N],n,m,q;int find(int x) &#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125;int main() &#123; IN(n),IN(m); for(int i=1,x;i&lt;=n;++i) fa[i]=i,IN(x),pos[x]=i,T.update(T.rt[i],1,n,x); for(int i=1;i&lt;=m;++i) &#123; int u,v;IN(u),IN(v); int fu=find(u),fv=find(v); if(fu!=fv) T.merge(T.rt[fu],T.rt[fv],1,n),fa[fv]=fu; &#125; IN(q); for(int i=1;i&lt;=q;++i) &#123; char op[2];int x,y,k; scanf("%s",op); if(op[0]=='B') &#123; IN(x),IN(y); int fx=find(x),fy=find(y); if(fx!=fy) T.merge(T.rt[fx],T.rt[fy],1,n),fa[fy]=fx; &#125; else if(op[0]=='Q') &#123; IN(x),IN(k); int fx=find(x); if(T.val[T.rt[fx]]&lt;k) printf("-1\n"); else printf("%d\n",pos[T.query(T.rt[fx],1,n,k)]); /*我们query到的是第K大的权值而非岛屿的编号*/ /*于是加个pos数组就好了*/ &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【考试总结】 Test-2019.4.3 HNOI2019模拟]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%5Dtest20190403%2F</url>
    <content type="text"><![CDATA[三道题目，一眼出算法。 第一道题目显然是后缀自动机，第二道题目显然是莫比乌斯反演加上杜教筛。第三道题目显然是网络流。 然而考场上都没做出来……自闭了。 真的，现在已经是傍晚了，大后天就是毒瘤的省选了……小学中现在正在举办运动会，班级群中一群人在那里一个劲的喊加油，但是，班上有人给我加油吗？除了几个好朋友之外…… 题目压缩包戳我!!!~\(≧▽≦)/~(有时链接可能会崩，如果崩了的话请稍后尝试QwQ) T1 期望得分：40分实际得分：40分正解：后缀自动机(SAM)+FFT窝的解法：哈希 题解嗯后缀自动机是会的但是感觉不好做。 于是弄了个哈希上去骗分，暴力枚举字串然后玄学哈希即可。 不会正解。。。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=666;const int inf=1e9+9;const int MOD=100000007;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int k,m,cnt,res[N*N],ans;char s[N],c[N];map&lt;int,int&gt; hash;void dfs(int step,int sum) &#123; if(step==k+1&amp;&amp;sum==m) &#123;++ans;return;&#125; if(step==k+1) return; if(sum&gt;m) return; for(int i=1;i&lt;=cnt;++i) dfs(step+1,sum+res[i]); return;&#125;int main() &#123; freopen("tele.in","r",stdin); freopen("tele.out","w",stdout); IN(k),IN(m); scanf("%s",s+1); int n=strlen(s+1); for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;++j) &#123; int tot=0; for(int k=i;k&lt;=j;++k) tot=(1ll*tot*27%MOD+s[k]-'a'+1)%MOD; /*大力玄学哈希+map判重*/ hash[tot]++; &#125; for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;++j) &#123; int tot=0; for(int k=i;k&lt;=j;++k) tot=(1ll*tot*27%MOD+s[k]-'a'+1)%MOD; res[++cnt]=hash[tot]; &#125; dfs(1,0); /*灵机一动这样写，那么k打于2的时候如果数据小可以多拿一些分*/ /*实验证明这样布星*/ printf("%d\n",ans); return 0;&#125; T2 期望得分：60分实际得分：40分正解：莫比乌斯反演+杜教筛窝的解法：莫比乌斯反演 题解考场上忘记了杜教筛，于是GG。 本来有六十分的……脑抽的窝，预处理 $\sum_{i=1}^{T}\lfloor\frac{T}{i}\rfloor$ 居然用 $O(n\sqrt{n})$ 来解决……实际上改两个字符就变成 $O(n)$ 的复杂度了，就有 $60$ 分了…… 嗯然后筛 $\mu$ 的时候可以搞个杜教筛加速，这样子的话 $\mu$ 函数的前缀和就可以 $O(n^{\frac{2}{3}})$ 筛出。不过估计是标程质量不行，题目范围只有 $10^9$ ……杜教筛可以解决 $O(10^{11})$ 左右的问题……吧? Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=4e6;const int inf=1e9+9;const int MOD=1000000007;bitset&lt;N+7&gt; vis;int n,mui[N+7],prime[N],cnt;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;inline void pre() &#123; mui[1]=1; for(int i=2;i&lt;N;++i) &#123; if(!vis[i]) prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;N;++j) &#123; vis[i*prime[j]]=1; if(!(i%prime[j])) &#123;mui[i*prime[j]]=0;break;&#125; else mui[i*prime[j]]=-mui[i]; &#125; &#125;for(int i=1;i&lt;N;++i) mui[i]+=mui[i-1]; return;&#125;ll S(int MX) &#123; ll sum=0; for(int l=1,r;l&lt;=MX;l=r+1) &#123; r=MX/(MX/l); sum=(sum+1ll*(r-l+1)*(MX/l)%MOD)%MOD; &#125;return sum;&#125;map&lt;int,int&gt; MU;int Sum(int x) &#123;/*杜教筛*/ if(x&lt;N) return mui[x]; else if(MU.count(x)) return MU[x]; else if(!x) return 0; else &#123; int s=1; for(int l=2,r;l&lt;=x;l=r+1) &#123; r=x/(x/l); s-=(r-l+1)*Sum(x/l); &#125;return MU[x]=s; &#125;&#125;int main() &#123; freopen("math.in","r",stdin); freopen("math.out","w",stdout); scanf("%d",&amp;n); pre(); ll res=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); ll num=S(n/l); res=(res+1ll*(Sum(r)-Sum(l-1))*num*num%MOD+MOD)%MOD; &#125; printf("%lld\n",(res+MOD)%MOD); return 0;&#125; 嗯实际这题窝觉得是一道莫反板子题，但是没做出来，看来杜教筛还是不会…… T3 期望得分：50分实际得分：0分正解：最小割窝的解法：最小割+爆搜 题解看完题目后，窝决定第一个看这道题。 哇，一眼网络流题目欸！ 咦这题好像小$M$的作物欸，但是第二个操作又不对劲了……(实际上第二个操作就是文理分科那题，但是窝没做那题)。 嗯，需要花费的什么费用……费用流？！然后手画了一下图……自己模拟一下发现根本不好模拟，想着费用流板子也就 $10$ 分钟的事，于是打了个费用流照着窝之前的想法建一下边，跑一下后发现错了…… 然后苦苦思索……转眼间 $30$ 分钟过去了。发现时间过得比较快，于是决定先将暴力 $30$ 打好再想……嗯爆搜一下救过了样例(不过窝的爆搜又打错了以至于窝没拿到分？！) 嗯这个时候感觉前 $30$ 分稳了，于是观察部分分，发现有 $\%20$ 的数据不包含第二个操作，直接上小$M$的作物发现自己忘了，没办法只好自己瞎 $YY$ 一通。最后的结果发现是最小割，然后拆点，拆成牛羊两个点，源点连牛点，边权自然是其收益，羊点同理。然后中间连一条边权为 $inf$ 的边，表示这个要不圈牛要不圈羊只能圈一个。 嗯，发现还挺有道理的。对于，对于限制的话我们只需要再限制的两个牛羊点之间连上一条边权为 $inf$ 的边即可。 一遍过样例，美滋滋地开始造数据拍，嗯第一次和爆搜拍得挺顺利 $500$ 组数据全过了。 没过瘾，再来一组，结果第二组 $500$ 数据，拍到三百多个就 $WA$ 了…… 后面没有想出来，于是弃疗了。 接下来讲一讲正解怎么做 小$M$的作物自然不用讲，我们来讲讲文理分科怎么做。 对于本题的第二个操作，我们需要新建一个结点 $p​$ ，然后如果这个操作的 $a​$ 是 $0​$ 我们就从源点向其连一条边权为 $b​$ 的边，$a​$ 是 $1​$ 的情况同理。 然后呢，对于 $S$ 中的每个点，如果 $a$ 为 $0$ 则从 $p$ 向该点连边，$a$ 是 $1$ 的情况同理。 嗯，然后就是不需要拆点。然后就差不多了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e5+2;const int inf=1e9+9;int n,m,k,a[N],b[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;namespace Dinic&#123; queue&lt;int&gt; q; int s,t,head[N],dep[N],cnt=1; struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;1]; inline void add(int u,int v,int w) &#123; G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,0&#125;,head[v]=cnt; &#125; int bfs() &#123; memset(dep,0,sizeof(dep)); dep[s]=1,q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=head[u];i;i=G[i].nxt) &#123; int v=G[i].to; if(!dep[v]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,q.push(v); &#125; &#125;return dep[t]; &#125; int dfs(int u,int flow) &#123; if(u==t||!flow) return flow; int used=0,rlow; for(int i=head[u];i;i=G[i].nxt) &#123; int v=G[i].to; if(dep[v]==dep[u]+1&amp;&amp;G[i].val&gt;0) &#123; used+=(rlow=dfs(v,min(flow-used,G[i].val))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used) dep[u]=-1; return used; &#125;&#125;using namespace Dinic;int main() &#123; freopen("work.in","r",stdin); freopen("work.out","w",stdout); IN(n),IN(m),IN(k); int sum=0,nodetot=n+1;s=0,t=n+1; for(int i=1;i&lt;=n;++i) IN(a[i]),sum+=a[i]; for(int i=1;i&lt;=n;++i) IN(b[i]); for(int i=1;i&lt;=m;++i) &#123; int x,y,z;IN(x),IN(y),IN(z); add(x,y,z),add(y,x,z); &#125; for(int i=1;i&lt;=k;++i) &#123; int size,x,y; IN(size),IN(x),IN(y); sum+=y,++nodetot; x?add(nodetot,t,y):add(s,nodetot,y); for(int j=1;j&lt;=size;++j) &#123; int c;IN(c); x?add(c,nodetot,inf):add(nodetot,c,inf); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; if(a[i]&gt;=b[i]) add(s,i,a[i]-b[i]); else add(i,t,b[i]-a[i]),sum+=b[i]-a[i]; &#125; int maxflow=0; while(bfs()) maxflow+=dfs(s,inf); printf("%d\n",sum-maxflow); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>考试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2005]维护数列 Splay luoguP2042]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2042%2F</url>
    <content type="text"><![CDATA[神奇的题目。 网上说什么做了这道题 $Splay$ 就差不多了，嗯对窝也这么觉得。于是终于码掉了。 主要涉及的操作还是提取区间，我们组需要将 $l-1$ 提取至 $root$ ， 然后将 $r+1$ 提取至 $l-1$ 的下方，最终询问的 $l,r$ 区间的 $Splay$ 就是 $r+1$ 的左孩子。 这个时候该输出的就输出，该打标记的就打标记就好了。 至于插入的话我们可以先将所有需要插入的结点 $build$ 成一棵树，然后直接挂到 $r+1$ 的左孩子即可。 但是毒瘤出题人卡空间，于是我们需要将删除的结点全部重新应用，就像垃圾回收那样，搞个栈就行了。 最后因为怕 $l-1$ 和 $r+1$ 出界我们还需要新增两个”哨兵结点”，这样子的话需要提取的结点都加上了 $1$ ，提取区间变动的两个节点就变成 $l$ 和 $r+2$ 了。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=5.5e5+7;const int inf=1e8;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;struct Splay &#123; int root,cnt; int ch[N][2],sz[N],fa[N],val[N],tag[N],rev[N]; int sum[N],lmax[N],rmax[N],smax[N]; int date[N],trash[N],top; Splay()&#123;root=cnt=top=0;&#125; bool chk(int x) &#123;return ch[fa[x]][1]==x;&#125; void clear(int node) &#123; ch[node][0]=ch[node][0]=sz[node]=fa[node]=val[node]=0, rev[node]=sum[node]=lmax[node]=rmax[node]=smax[node]=0; tag[node]=inf; &#125; int MKN() &#123; int node; node=top?trash[top--]:++cnt; clear(node);return node; &#125; void pushup(int x) &#123; int l=ch[x][0],r=ch[x][1]; sz[x]=sz[l]+sz[r]+1; sum[x]=sum[l]+sum[r]+val[x]; lmax[x]=max(lmax[l],sum[l]+val[x]+lmax[r]); rmax[x]=max(rmax[r],sum[r]+val[x]+rmax[l]); smax[x]=max(rmax[l]+lmax[r]+val[x],max(smax[l],smax[r])); &#125; void pushdown(int x) &#123; int l=ch[x][0],r=ch[x][1]; if(tag[x]!=inf) &#123; if(l) val[l]=tag[l]=tag[x],sum[l]=tag[x]*sz[l]; if(r) val[r]=tag[r]=tag[x],sum[r]=tag[x]*sz[r]; if(tag[x]&gt;=0) &#123; if(l) lmax[l]=rmax[l]=smax[l]=sum[l]; if(r) lmax[r]=rmax[r]=smax[r]=sum[r]; &#125; else if(tag[x]&lt;0) &#123; if(l) lmax[l]=rmax[l]=0,smax[l]=tag[x]; if(r) lmax[r]=rmax[r]=0,smax[r]=tag[x]; &#125; tag[x]=inf; &#125; if(rev[x]) &#123; if(l) swap(ch[l][0],ch[l][1]),swap(lmax[l],rmax[l]),rev[l]^=1; if(r) swap(ch[r][0],ch[r][1]),swap(lmax[r],rmax[r]),rev[r]^=1; rev[x]=0; &#125; &#125; void rotate(int x) &#123; int y=fa[x],z=fa[y]; pushdown(y),pushdown(x); int k=chk(x),v=ch[x][k^1]; ch[z][chk(y)]=x,fa[x]=z,ch[y][k]=v,fa[v]=y, ch[x][k^1]=y,fa[y]=x;pushup(y),pushup(x); &#125; void splay(int x,int gola=0) &#123; while(fa[x]!=gola) &#123; if(fa[fa[x]]!=gola) rotate(chk(x)^chk(fa[x])?x:fa[x]); rotate(x); &#125;if(!gola) root=x; &#125; int kth(int x) &#123; int pos=root; while(pos) &#123; pushdown(pos); if(x&lt;=sz[ch[pos][0]]) pos=ch[pos][0]; else &#123; x-=sz[ch[pos][0]]+1; if(!x) return pos; pos=ch[pos][1]; &#125; &#125;return 0; &#125; int build(int l,int r,int f) &#123; if(l&gt;r) return 0; int x=MKN(),mid=(l+r)&gt;&gt;1; ch[x][0]=build(l,mid-1,x),ch[x][1]=build(mid+1,r,x); val[x]=date[mid],fa[x]=f,pushup(x); return x; &#125; void trashcan_node(int x) &#123; if(!x) return; trash[++top]=x,trashcan_node(ch[x][0]),trashcan_node(ch[x][1]); &#125; int split(int&amp;l,int&amp;r,int pos,int tot) &#123; l=kth(pos),r=kth(pos+tot+1);splay(l),splay(r,l); &#125; void work_insert() &#123; int pos,tot,l,r; IN(pos),IN(tot); for(int i=1;i&lt;=tot;++i) IN(date[i]); split(l,r,pos+1,0); ch[r][0]=build(1,tot,r),pushup(r),pushup(root); &#125; void work_delete() &#123; int pos,tot,l,r; IN(pos),IN(tot),split(l,r,pos,tot); trashcan_node(ch[r][0]),ch[r][0]=0,pushup(r),pushup(root); &#125; void work_same() &#123; int pos,tot,c,l,r; IN(pos),IN(tot),IN(c),split(l,r,pos,tot); int p=ch[r][0]; if(p) &#123; val[p]=tag[p]=c,sum[p]=c*sz[p]; if(c&gt;=0) lmax[p]=rmax[p]=smax[p]=sum[p]; else if(c&lt;0) lmax[p]=rmax[p]=0,smax[p]=c; &#125;pushup(r),pushup(root); &#125; void work_rev() &#123; int pos,tot,l,r; IN(pos),IN(tot),split(l,r,pos,tot); if(ch[r][0]) &#123; swap(ch[ch[r][0]][0],ch[ch[r][0]][1]); swap(lmax[ch[r][0]],rmax[ch[r][0]]); rev[ch[r][0]]^=1; &#125;pushup(r),pushup(root); &#125; void work_sum() &#123; int pos,tot,l,r; IN(pos),IN(tot),split(l,r,pos,tot); printf("%d\n",sum[ch[r][0]]); &#125; void work_max() &#123; int l=kth(1),r=kth(sz[root]);splay(l),splay(r,l); printf("%d\n",smax[ch[r][0]]); &#125;&#125;T;int n,m;char op[25];int main() &#123; // freopen("testdata.in","r",stdin); // freopen("myout.out","w",stdout); IN(n),IN(m); for(int i=1;i&lt;=n;++i) IN(T.date[i+1]); T.smax[0]=T.date[1]=-inf,T.date[n+2]=inf; T.root=T.build(1,n+2,0); while(m--) &#123; scanf("%s",op); if(op[0]=='M') &#123; if(op[3]=='E') T.work_same(); else T.work_max(); &#125; else if(op[0]=='I') T.work_insert(); else if(op[0]=='D') T.work_delete(); else if(op[0]=='R') T.work_rev(); else if(op[0]=='G') T.work_sum(); &#125; return 0;&#125; 哎离 $HNOI2019$ 不远了，感觉多多更博增加 $RP$ …… $QwQ$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [Vani有约会]雨天的尾巴 线段树+启发式合并 luoguP4556]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4556%2F</url>
    <content type="text"><![CDATA[毒瘤出题人，卡时间卡空间！ 嗯，如果这一题不是在树上的话貌似可以直接权值线段树维护？不过到了树上的话难道可以权值线段树+树链剖分，表示不明白。于是尝试了一发线段树合并，但是我们的线段树是权值线段树。 我们的权值线段树是用来存原树中 $x$ 结点以及其子树中的每种救济粮的个数。 怎么个合并法呢，其实特别简单，两个线段树同时进行，发现到了一个节点的时候一个线段树有这个结点另一个没有这个节点，那么这个节点以及其下面的结点的信息都可以直接作为新线段树的这个节点的信息。 当然如果到了一个叶子节点，直接将两个线段树的这个位置的救济粮的个数加起来即可。 嗯，每个线段树再维护一个值存出现最多次数的救济粮是什么，这样就可以得到答案了。但是为了避免一些结点与其子树压根就没有救济粮的情况，我们需要判断一下这个节点与其子树是否有救济粮即可。 然后直接一遍 $dfs$ ，遍历 $u$ 的所有孩子然后拿 $u$ 的线段树依次去和 $u$ 的儿子的线段树合并。最终合并完的线段树存储的就是 $u$ 以及其子树的信息了。然后就可以获得答案了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e5+7;const int LogN=27;const int M=6e6+7;int n,m,q,X[N],Y[N],Z[N],Ans[N],head[N],cnt;struct Edge &#123;int nxt,to;&#125;G[N&lt;&lt;1];inline void add(int u,int v) &#123; G[++cnt]=(Edge)&#123;head[u],v&#125;,head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u&#125;,head[v]=cnt;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=--x;&#125;namespace Lca &#123; int dep[N],fa[N][LogN+4]; void dfs(int u,int f) &#123; fa[u][0]=f,dep[u]=dep[f]+1; for(int i=1;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=f) dfs(G[i].to,u); &#125; int lca(int x,int y) &#123; if(x==y)return x; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=LogN;i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i]; if(x==y)return x; for(int i=LogN;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; &#125;&#125;using namespace Lca;struct Segment_Tree &#123; #define mid ((l+r)&gt;&gt;1) int rt[N],lc[M],rc[M],d[M],t[M],tot; void pushup(int x) &#123; if(d[lc[x]]&gt;=d[rc[x]]) d[x]=d[lc[x]],t[x]=t[lc[x]]; else d[x]=d[rc[x]],t[x]=t[rc[x]]; &#125; int update(int x,int l,int r,int pos,int val) &#123; if(!x) x=++tot; if(l==r) &#123;d[x]+=val;t[x]=l;return x;&#125; if(pos&lt;=mid) lc[x]=update(lc[x],l,mid,pos,val); else rc[x]=update(rc[x],mid+1,r,pos,val); pushup(x);return x; &#125; int merge(int x,int y,int l,int r) &#123; if(!x) return y; if(!y) return x; if(l==r) &#123;d[x]+=d[y];t[x]=l;return x;&#125; lc[x]=merge(lc[x],lc[y],l,mid); rc[x]=merge(rc[x],rc[y],mid+1,r); pushup(x);return x; &#125;&#125;T;void calc(int u,int f) &#123; for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=f) calc(G[i].to,u), T.rt[u]=T.merge(T.rt[u],T.rt[G[i].to],1,m); if(T.d[T.rt[u]]) Ans[u]=T.t[T.rt[u]];&#125;int main() &#123; IN(n),IN(q); for(int i=1,x,y;i&lt;n;++i) IN(x),IN(y),add(x,y); for(int i=1;i&lt;=q;++i) IN(X[i]),IN(Y[i]),IN(Z[i]),m=max(m,Z[i]); //权值线段树离线处理 dfs(1,0); for(int i=1;i&lt;=q;++i) &#123; int lca_xy=lca(X[i],Y[i]); T.rt[X[i]]=T.update(T.rt[X[i]],1,m,Z[i],1); T.rt[Y[i]]=T.update(T.rt[Y[i]],1,m,Z[i],1); T.rt[lca_xy]=T.update(T.rt[lca_xy],1,m,Z[i],-1); if(fa[lca_xy][0]) T.rt[fa[lca_xy][0]]=T.update(T.rt[fa[lca_xy][0]],1,m,Z[i],-1); &#125; calc(1,0); for(int i=1;i&lt;=n;++i) printf("%d\n",Ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 虚树入门]]></title>
    <url>%2F2019%2F04%2F01%2F%5B%E7%AE%97%E6%B3%95%5D%E8%99%9A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[虚树一般用于优化树形 $DP$ ，通常的关键词有”关键点”等。如果关键点的个数非常少，直接树形 $DP$ 无疑是处理了很多没有用的点，浪费时间。这个时候我们用虚树来优化，可以大大增加效率。 虚树的主要思想就是，只保留这些关键点以及这些关键点的 $lca$ ，那么虚树中的这些点都是有用的，直接在虚树上 $DP$ 就好了。 下面给出几个虚树的例子(其中红色的为关键点) ： 不过要注意的一点就是，如果我们一个一个去求 $lca$ ，那么复杂度就会变成 $O(k^2logn)$ (其中 $k$ 为关键点数) 。这个复杂度我们承受不了，我们需要一个更加高级的计算方式。 我们使用单调栈，单调的是结点 $dfn$ 时间戳。我们使用单调栈维护原点上的一条链。 假设，现在我们的单调栈维护的是原树中的这一条链(蓝色)： 然后这条链上的两个关键点(红色)显然已经被处理过了，我们下一个需要处理的将是这个点： 没错吧？按照时间戳排序后的顺序来依次处理这些关键点。 然后当前的栈顶显然是最下面的那个关键点，我们很简单的可以发现，当前要处理的关键点和栈顶点不在一条链上——这意味着我们需要退栈，换一条维护的链！ 我们先求出栈顶点和当前要处理的关键点的 $lca$ ，也就是上面的那个关键点。显而易见，我们可以先从栈顶逐次弹出节点直到当前栈顶是 $lca$ ，然后将当前要处理的关键点入栈。 当然我们的虚树也是要连边的，对于那些要弹出的节点直接依次连边就好了。 所以当前维护的链变成了这样： 但是实际情况可能会糟糕一些。比如说栈顶点和当前要处理的关键点的 $lca$ 不在栈中，这个时候我们还需要将其加入栈中。 先举个例子吧，比方说我们需要对下面的树建造虚树： 首先，输入数据给我们的关键点分别为：$5,7,10,8$ 然后我们按照 $dfn$ 排个序，排完序后显然变为了：$7,8,5,10$ 然后我们先将根节点($1$)入队。 第一个需要处理的关键点为 $7$ ，发现当前需要处理的关键点($7$)和栈顶结点($1$)的 $lca$ 为 $1$ ，也就说明了 $1,7$ 在同一条链上，直接将 $7$ 入栈即可。此时的栈为：$1,7$ 然后看到下一个需要处理的关键点($8$) ，这个时候栈顶结点($7$)和当前需要处理的关键点($8$) 的 $lca$ 不是栈顶结点，这说明不在一条链上了，于是我们连边 ($4,7$) ，然后将 $4$ 和 $7$ 入栈。 为什么要将 $4$ 入栈呢？我们发现判断的时候栈顶$-1$的结点是 $1$ ，$1$ 的 $dfn$ 是大于 $4$ 的，这说明 $4$ 没出现过，我们的虚树要有所有关键点的 $lca$ ，于是将 $4$ 入栈。 接下来看到 $5​$ ，发现又不在一条链上了，这个时候我们还发现 $2​$ 也没有算过，所以我们连完 $(4,8),(2,4)​$ 两条边并弹出两个结点后我们还需要将 $2​$ 入栈，然后再将 $5​$ 入栈。 下一个点是 $10$ ，我们发现又不在一条链上了于是我们沿着 $2,5$ 退栈，发现 $lca(5,10)$ 就是 $1$ ，也就是弹出 $2,5$ 后的栈顶结点。既然在栈中发现了 $lca$ 我们就没必要将 $lca$ 入栈了。这个时候直接将 $10$ 入栈。 发现没有关键点了，我们逐次退栈，由于栈维护的结点是在同一条链上的，我们直接连边就好。 所以，最后我们建成的虚树如下： Code:1234567891011121314151617181920212223242526272829void build(int k) &#123;//建造虚树,k:关键点个数 sort(point+1,point+1+k,cmp);//关键点按照时间戳排好序 stack[top=1]=1,//根节点入栈 G.cnt=0,G.head[1]=-1;//初始化 /*枚举每一个关键点，依次处理*/ /*这里判断的原因是为了防止1重复计算*/ for(int i=1;i&lt;=k;++i) if(point[i]!=1) &#123; /*获取当前要处理的关键点与栈顶结点的lca*/ int l=lca(stack[top],point[i]); /*发现不在同一条链上了，需要换链*/ if(l!=stack[top]) &#123; while(id[l]&lt;id[stack[top-1]]) &#123;//弹出lca下面的结点 G.add(stack[top-1],stack[top]);//顺带连边 --top; &#125; if(id[l]&gt;id[stack[top-1]]) &#123;//发现lca并没有访问过 G.head[l]=-1;//初始化 /*丢掉依旧在lca下面的栈顶结点并将lca入栈*/ G.add(l,stack[top]),stack[top]=l; &#125; else &#123; G.add(l,stack[top]),--top;//直接入栈就好了 &#125; &#125; G.head[point[i]]=-1,stack[++top]=point[i];//将当前关键点入栈 &#125; for(int i=1;i&lt;top;++i)//对于最后栈中剩余的元素依次连边 G.add(stack[i],stack[i+1]);&#125; 来一道例题吧。 [SDOI2011]消耗战题解戳我(≧ω≦)/！]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2011]消耗战 虚树+树形DP luoguP2495]]></title>
    <url>%2F2019%2F03%2F31%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2495%2F</url>
    <content type="text"><![CDATA[去 $Mina!$ 上了解了一波虚树，$\%\%\% XZY$ 学长太强辣！ 这次总算明白了些虚树，然后 $XZY$ 大佬的例题就是消耗战。 于是看了过来。 首先，考虑普通的树形 $DP​$ ，设 $dp[u]​$ 表示在 $u​$ 为根的子树中满足目标所花费的最小代价 ，那么转移方程也不是很难，我们枚举 $u​$ 的孩子 $v​$ 。如果 $v​$ 本身就是”能源丰富的岛屿”那么 $dp[u]+=G[i].val​$ ，其中 $G[i].val​$ 表示 $u​$ 到 $v​$ 的边的边权。为什么这样转移呢？因为 $v​$ 必须切断。 那么没有必要切断的岛屿呢？就分切/不切两种情况了： dp[u]+=min(G.val[i],dp[G.to[i]]);这个也很好懂。 这个时候我们打完代码交一发发现只有 $40$ 分……往下看，可以看到 $n$ 到最后的顶尖数据有 $250000$ …… 但是我们可以观察到，$\sum k_i \leq 5*10^5$ ，发现总共的 $k$ 也不过这么大，这个时候我们可以用虚树来解决。 $Qiuly$ ：有关虚树的文章先咕一下蛤，最近有点忙。 建好虚树后直接用上面的转移方程做就得了。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2.5e5+7;const int LogN=27;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct graph &#123; int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],val[N&lt;&lt;1],cnt; void init() &#123;memset(head,-1,sizeof(head));cnt=0;&#125; graph() &#123;init();&#125; void add(int u,int v,int w) &#123; nxt[cnt]=head[u],to[cnt]=v,val[cnt]=w,head[u]=cnt++; &#125;&#125;G;int n,m,point[N],stack[N],top;ll dp[N];bool vis[N];namespace LCA &#123; int dep[N],fa[N][LogN+3],num[N][LogN+3]; int id[N],dfn,Edge_Mx; void _Pre_Lca(int u,int f) &#123; fa[u][0]=f,dep[u]=dep[f]+1,id[u]=++dfn; for(int i=1;i&lt;=LogN;++i) &#123; fa[u][i]=fa[fa[u][i-1]][i-1]; num[u][i]=min(num[u][i-1],num[fa[u][i-1]][i-1]); &#125; for(int i=G.head[u];~i;i=G.nxt[i]) if(G.to[i]!=f)num[G.to[i]][0]=G.val[i],_Pre_Lca(G.to[i],u); &#125; int lca(int x,int y) &#123; Edge_Mx=inf; if(x==y)return x; if(dep[x]&lt;dep[y])swap(x,y); for(int i=LogN;i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) Edge_Mx=min(Edge_Mx,num[x][i]),x=fa[x][i]; if(x==y)return x; for(int i=LogN;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) Edge_Mx=min(Edge_Mx,min(num[x][i],num[y][i])), x=fa[x][i],y=fa[y][i]; return fa[x][0]; &#125;&#125;using namespace LCA;bool cmp(int x,int y) &#123;return id[x]&lt;id[y];&#125;void solve(int u) &#123;//DP过程 dp[u]=0; for(int i=G.head[u];~i;i=G.nxt[i]) &#123; solve(G.to[i]); if(vis[G.to[i]])dp[u]+=G.val[i]; else dp[u]+=min((ll)G.val[i],dp[G.to[i]]); &#125;return;&#125;void build(int k) &#123;//建立虚树 sort(point+1,point+1+k,cmp); stack[top=1]=1,G.cnt=0,G.head[1]=-1; for(int i=1;i&lt;=k;++i) if(point[i]!=1) &#123; int l=lca(stack[top],point[i]); if(l!=stack[top]) &#123; while(id[l]&lt;id[stack[top-1]]) &#123; lca(stack[top-1],stack[top]); G.add(stack[top-1],stack[top],Edge_Mx); --top; &#125; if(id[l]&gt;id[stack[top-1]]) &#123; G.head[l]=-1,lca(l,stack[top]); G.add(l,stack[top],Edge_Mx),stack[top]=l; &#125; else lca(l,stack[top]),G.add(l,stack[top],Edge_Mx),--top; &#125; G.head[point[i]]=-1,stack[++top]=point[i]; &#125; for(int i=1;i&lt;top;++i) lca(stack[i],stack[i+1]),G.add(stack[i],stack[i+1],Edge_Mx);&#125;int main() &#123; IN(n); for(int i=1;i&lt;n;++i) &#123; int u,v,w;IN(u),IN(v),IN(w); G.add(u,v,w),G.add(v,u,w); &#125; _Pre_Lca(1,0),IN(m); while(m--) &#123; int k;IN(k); for(int i=1;i&lt;=k;++i)IN(point[i]),vis[point[i]]=true; build(k); solve(1),printf("%lld\n",dp[1]); for(int i=1;i&lt;=k;++i)vis[point[i]]=false; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>题解</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HAOI2012]高速公路 线段树 luoguP2221]]></title>
    <url>%2F2019%2F03%2F31%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2221%2F</url>
    <content type="text"><![CDATA[$3$ 月份的最后一篇题解了呢……明天就属于 $4$ 月了，离省选不远了…$QwQ$… 发现窝真的很制杖，我们先来聊聊刚开始窝的想法。 我画了画图，然后发现，对于最后答案的分母(不是最简)，是这个序列中这些数的值(废话)，然后发现了每个点的出现次数，然后线段树维护求和。发现效率很低于是试图将出现次数般到二维平面上，然后曼哈顿距离转切比雪夫距离然后二维树状数组维护然后 $WA$ 了然后弃疗。 你可能认为窝很傻对吧？ 嗯对窝是挺傻的。 正解是线段树，没猜错，但是和什么二维树状数组有什么关系 我们考虑区间中的一个点 $i$ ，权值为 $v_i$ 。然后我们观察当前询问区间中有多少子区间包含了 $v_i$ ，这个个数就是点 $i$ 做出的贡献。现在我们来考虑怎么计算这个包含了 $i$ 的子区间个数。 可以发现，我们从 $i$ 向左扩展若干个点，然后又向右扩展若干个点，这样子一来就成了一个包含了 $i$ 子区间。这个就很好计算了，答案显然为 $(i-l)\times(r-i)$ 。然后还要算进没有向左/右扩展的情况，并且算上权值，最终 $i$ 造成的贡献显然为： v_i\times(i-l+1)\times (r-i+1)那么我们将式子拆开可以得到： v_i\times [i\times (r-i+1)-l\times(r-i+1)+(r-i+1)]v_i\times [i\times r-i\times i+i-l\times r+l\times i-l+r-i+1]v_i\times [i(r+l)-i^2-lr-l+r+1]v_i i(r+l)-v_ii^2-v_ilr+v_i(r-l)+v_i其中 $l,r$ 为当前询问区间，这个是可以直接算出的。我们发现我们需要维护的就是 $v_i\ ,\ v_ii\ ,\ v_ii^2$ 三个值，用线段树维护即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e5+2;const int inf=1e9+9;int n,m;char op[2];namespace OI &#123; template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x; &#125; template &lt;typename _Tp&gt; _Tp gcd(_Tp x,_Tp y) &#123; return y?gcd(y,x%y):x; &#125;&#125;using namespace OI;struct Segment_Tree &#123; #define mid ((l+r)&gt;&gt;1) #define LS(x) ((x)&lt;&lt;1) #define RS(x) ((x)&lt;&lt;1|1) ll ans1,ans2,ans3; ll sum1[N&lt;&lt;2],sum2[N&lt;&lt;2],sum3[N&lt;&lt;2]; ll tag[N&lt;&lt;2],suq[N&lt;&lt;2],rle[N&lt;&lt;2],len[N&lt;&lt;2]; void build(ll x,ll l,ll r) &#123; if(l==r) &#123; len[x]=1,suq[x]=l,rle[x]=l*l; return; &#125; build(LS(x),l,mid),build(RS(x),mid+1,r); len[x]=len[LS(x)]+len[RS(x)]; suq[x]=suq[LS(x)]+suq[RS(x)], rle[x]=rle[LS(x)]+rle[RS(x)]; &#125; void pushdown(ll x,ll l,ll r) &#123; ll k=tag[x];tag[x]=0; sum1[LS(x)]+=len[LS(x)]*k,sum1[RS(x)]+=len[RS(x)]*k; sum2[LS(x)]+=suq[LS(x)]*k,sum2[RS(x)]+=suq[RS(x)]*k; sum3[LS(x)]+=rle[LS(x)]*k,sum3[RS(x)]+=rle[RS(x)]*k; tag[LS(x)]+=k,tag[RS(x)]+=k; &#125; void update(ll x,ll l,ll r,ll L,ll R,ll v) &#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; tag[x]+=v; sum1[x]+=len[x]*v; sum2[x]+=suq[x]*v; sum3[x]+=rle[x]*v; return; &#125; if(tag[x])pushdown(x,l,r); if(L&lt;=mid)update(LS(x),l,mid,L,R,v); if(R&gt;mid)update(RS(x),mid+1,r,L,R,v); sum1[x]=sum1[LS(x)]+sum1[RS(x)]; sum2[x]=sum2[LS(x)]+sum2[RS(x)]; sum3[x]=sum3[LS(x)]+sum3[RS(x)]; &#125; void query(ll x,ll l,ll r,ll L,ll R) &#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; ans1+=sum1[x],ans2+=sum2[x],ans3+=sum3[x]; return; &#125; if(tag[x])pushdown(x,l,r); if(L&lt;=mid)query(LS(x),l,mid,L,R); if(R&gt;mid)query(RS(x),mid+1,r,L,R); &#125; &#125;T;int main() &#123; IN(n),IN(m); T.build(1,1,n); for(int i=1;i&lt;=m;++i) &#123; scanf("%s",op); ll l,r;IN(l),IN(r);--r; ll v; if(op[0]=='C') IN(v),T.update(1,1,n,l,r,v); else if(op[0]=='Q') &#123; T.ans1=T.ans2=T.ans3=0; T.query(1,1,n,l,r); ll res1=T.ans1,res2=T.ans2,res3=T.ans3; ll ans=(r-l+1-l*r)*res1+(r+l)*res2-res3; ll len=(r-l+1)*(r-l+2)/2; ll esw=gcd(ans,len); printf("%lld/%lld\n",ans/esw,len/esw); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [CQOI2011]动态逆序对 CDQ分治 luoguP3157]]></title>
    <url>%2F2019%2F03%2F30%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3157%2F</url>
    <content type="text"><![CDATA[一个可爱的 $CDQ$ ，我们将原始序列看成一个一个加入，然后后面的操作就是一个一个删除，这么一个一个操作我们都记下来，然后每个操作记一个 $id$ 表示它将为第几个时间点做出贡献。 当然对于原始序列的一个一个插入的操作这里的贡献是 $1$ ，删除操作的贡献自然是 $-1$ 。 每个时间点统计答案，最后输出前做一个前缀和然后依次输出就好了。 这是具体的框架，但是统计 $ans$ 数组具体怎么做呢？ 可以知道对于一个位置 $i$ ，位置上的元素是 $a_i$ 。对于一个 $j$ 满足 $j\leq i$ ，并且 $a_i\leq a_j$ ，而且还要保证 $id_j\leq id_i$ ，那么 $j$ 就可以对 $i$ 做出贡献。这个就是在 $i$ 前面的元素可以做出的贡献。$i$ 后面的元素做出的贡献同理。 这就是一个很普通的三位偏序了，注意要开 $long\ long$ 。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=2e5+2;template &lt;typename _Tp&gt; inline void IN(_Tp &amp;x)&#123; x=0;int flag=0;char ch; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int n,m,cnt,pos[N],a[N];long long ans[N];struct Query&#123;int r,v,d,id;&#125;Q[N];bool cmp(Query a,Query b) &#123;return a.d&lt;b.d;&#125;int C[N];#define lowbit(x) ((x)&amp;(-(x)))void add(int x,int v) &#123;for(;x&lt;=n;x+=lowbit(x))C[x]+=v;&#125;int sum(int x) &#123;int res=0;for(;x;x-=lowbit(x))res+=C[x];return res;&#125;inline void CDQ(int l,int r) &#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; CDQ(l,mid),CDQ(mid+1,r); sort(Q+l,Q+mid+1,cmp),sort(Q+mid+1,Q+r+1,cmp); int j=l; for(int i=mid+1;i&lt;=r;++i) &#123; while(j&lt;=mid&amp;&amp;Q[j].d&lt;=Q[i].d) add(Q[j].v,Q[j].r),++j; ans[Q[i].id]+=Q[i].r*(sum(n)-sum(Q[i].v)); &#125; for(int i=l;i&lt;j;++i) add(Q[i].v,-Q[i].r); j=mid; for(int i=r;i&gt;mid;--i) &#123; while(j&gt;=l&amp;&amp;Q[j].d&gt;=Q[i].d) add(Q[j].v,Q[j].r),--j; ans[Q[i].id]+=Q[i].r*sum(Q[i].v-1); &#125; for(int i=mid;i&gt;j;--i) add(Q[i].v,-Q[i].r);&#125;int main()&#123; IN(n),IN(m); for(int i=1;i&lt;=n;++i) IN(a[i]),pos[a[i]]=i,Q[++cnt]=(Query)&#123;1,a[i],i,0&#125;; for(int i=1;i&lt;=m;++i) &#123; int x;IN(x); Q[++cnt]=(Query)&#123;-1,x,pos[x],i&#125;; &#125; CDQ(1,cnt); for(int i=1;i&lt;=m;++i) ans[i]+=ans[i-1]; for(int i=0;i&lt;m;++i) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [AHOI2013]差异 后缀自动机.SAM luoguP4248]]></title>
    <url>%2F2019%2F03%2F30%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4248%2F</url>
    <content type="text"><![CDATA[刚开始发现 $SA$ 很可做，不过当时没有看范围，心想美滋滋了这个就是 $SA$ 的板子，然后一看范围心就凉了。 不过可以用 $SAM$ ，我们知道，对于两个串，它们的最长公共子串就是它们在前缀树上的 $Lca$ 。这是显然的，不明白的同学可以康康 $Qiuly$ 酱之前写的 $SAM$ ，可以观察观察图片。 我们观察式子，发现 $\sum_{1\leq i&lt;j\leq n} len(T_i)+len(T_j)$ 是等于 $\frac{(n-1)\times n\times(n+1)}{2}$ 的，这个可以 $O(1)$ 算出。 那么 $2\times lcp(T_i,T_j)$ 怎么求呢？ 那么对于一个结点 $x$ ，我们依次统计 $x$ 的儿子，并依次更新 $x$ 的 $size$ ，对于一个 $x$ 的儿子 $y$ ，枚举的时候它对答案的贡献显然是 $size[x]\times len[x]\times size[y]$ ，因为 $y$ 的子树中的任意一结点(包括 $y$ ) ，与 $x$ 之前枚举过的所有儿子的子树中的所有结点的 $Lca$ 都是 $x$ 。并且对于一个 $x$ ，它所造成的贡献就是 $Len[x]$ 。 最后统计出来的答案再乘上 $2$ 就是后面那个式子啦~\(≧▽≦)/~ 。 不过要注意一点，后缀自动机是会复制结点的，这些复制的结点不属于原串因此不能计算贡献。 然后就是代码的问题了。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e6+7;struct SAM &#123; int last,cnt; int ch[N][26],fa[N],len[N],sz[N],hep[N],tot[N]; SAM() &#123;last=cnt=1;&#125; inline void ins(int c) &#123; int p=last,np=++cnt; last=np,len[np]=len[p]+1,sz[np]=1; while(p&amp;&amp;!ch[p][c]) ch[p][c]=np,p=fa[p]; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt;len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[nq]=fa[q],fa[q]=fa[np]=nq; while(p&amp;&amp;ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125;return; &#125; inline ll calc() &#123; ll res=0; for(int i=1;i&lt;=cnt;++i) hep[len[i]]++; for(int i=1;i&lt;=cnt;++i) hep[i]+=hep[i-1]; for(int i=1;i&lt;=cnt;++i) tot[hep[len[i]]--]=i; for(int i=cnt;i&gt;=1;--i) &#123; int node=tot[i]; res+=(ll)sz[fa[node]]*sz[node]*len[fa[node]]; sz[fa[node]]+=sz[node]; &#125;return res; &#125;&#125;T;char s[N];int main() &#123; scanf("%s",s); int n=strlen(s); for(int i=0;i&lt;n;++i)T.ins(s[i]-'a'); printf("%lld\n",(ll)(n-1)*n*(n+1)/2-2*T.calc()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>后缀自动机.SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2013]森林 主席树+启发式合并 luoguP3302]]></title>
    <url>%2F2019%2F03%2F29%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3302%2F</url>
    <content type="text"><![CDATA[初看题面，看到 $K$ 大我们可以想到主席树，但是连边却又符合 $LCT$ ，但是毕竟 $LCT$ 是不能支持 $K$ 大的，因为 $Splay$ 辅助树不是二叉查找树。 不过主席树我们可以大力启发式合并，合并的时候重建节点的倍增数组并且重新建立节点的权值线段树。这样子每个节点要被修改的期望次数为 $logn​$ 次，那么时间复杂度就是 $O(nlog^2n)​$ (貌似是的)，这足以让我们过这道题了。 1.主席树如何上树上树[手动滑稽]…… 首先，对于节点 $u$ 的权值线段树，$ta$ 是由 $fa[u]$ 的权值线段树继承过来的，因为只是多了一个 $u$ ，所以主席树只是多增加了 $logn$ 个节点。 既然是从父亲节点继承过来的话，那么很显然我们可以在预处理倍增数组的时候顺便将主席树建好。 Code-builld:1234567void dfs(int u,int f) &#123; update(root[u],root[f],1,tmp,S(a[u])); fa[u][0]=f,dep[u]=dep[f]+1; for(int i=1;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=f) dfs(G[i].to,u);&#125; 这个很容易理解，那么我们怎么暴力合并两颗树呢？ 对于要合并的两颗树，我们选择将 $size$ 小的往 $size$ 大的并，对于给出的 $x,y$ ，我们先给 $x,y$ 连好边，然后将 $y$ 的权值线段树从 $x$ 更新，丢掉以前的。最后遍历 $y$ 的子树，更新其倍增数组和权值线段树即可。 至于 $size$ 的维护的话，我们可以找到 $x,y$ 所在的树的根。这个样子 $size$ 谁大谁小只需要判断 $x,y$ 所在的树的根的 $size$ 谁大谁小即可。我们在网下遍历 $y$ 的子树时每次都将$x$ 所在树的根的 $size$ 加一即可。 Code-merge:12345678910111213void merge(int rt,int u,int f) &#123; /*rt:x所在树的根，u:当前需要重构的节点,刚进入函数的时候为y*/ /*f:当前需要重构的节点的父节点，刚进入函数的时候为x*/ fa[u][0]=f,dep[u]=dep[f]+1;//更新深度 for(int i=1;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; /*更新倍增数组*/ size[rt]++,//更新size sta[u]=f,//记录父亲(不是倍增数组,这是用来查询所在树的根的) vis[u]=true;//记录一下 update(root[u],root[f],1,tmp,S(a[u]));//重建 for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=f) merge(rt,G[i].to,u);//遍历子树&#125; 然后差不多了，至于 $sta$ 的话，因为要查询所在树的根，为了提高效率我们可以将其作为并查集的形式。 还有一点，对于 $vis$ 数组，实际上我们建树的时候就直接用 $merge$ 好了，$vis$ 只是用来判重而已，因为是森林，有很多树。所以说我们可以不用 $dfs$ 就将初始形态的树建好。 Code-pre:12for(int i=1;i&lt;=n;++i) if(!vis[i]) &#123;merge(i,i,0);sta[i]=i;&#125; 最后需要注意的就是主席树的空间要开很大，差不多是 $nlog^2n$ ，因为有很多结点。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=8e4+7;const int LogN=22;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int testcase,lastans,n,m,T,a[N],b[N],tmp,head[N],cnt;int size[N],sta[N],vis[N];struct Edge &#123;int nxt,to;&#125;G[N&lt;&lt;2];inline int S(int x) &#123;return lower_bound(b+1,b+1+tmp,x)-b;&#125;inline void add(int u,int v) &#123; G[++cnt]=&#123;head[u],v&#125;,head[u]=cnt; G[++cnt]=&#123;head[v],u&#125;,head[v]=cnt;&#125;namespace Segment_Tree &#123; #define mid ((l+r)&gt;&gt;1) int root[N],tot; struct tree &#123;int l,r,v;&#125;t[N*601]; void update(int&amp;now,int last,int l,int r,int pos) &#123; now=++tot,t[now]=t[last],t[now].v++; if(l==r) return; if(pos&lt;=mid) update(t[now].l,t[last].l,l,mid,pos); else update(t[now].r,t[last].r,mid+1,r,pos); &#125; int query(int r1,int r2,int r3,int r4,int l,int r,int k) &#123; if(l==r) return l; int th=t[t[r1].l].v+t[t[r2].l].v-t[t[r3].l].v-t[t[r4].l].v; if(k&lt;=th) return query(t[r1].l,t[r2].l,t[r3].l,t[r4].l,l,mid,k); else return query(t[r1].r,t[r2].r,t[r3].r,t[r4].r,mid+1,r,k-th); &#125; #undef mid&#125;using namespace Segment_Tree;int dep[N],fa[N][LogN+4];int lca(int x,int y) &#123; if(x==y)return x; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=LogN;i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i]; if(x==y)return x; for(int i=LogN;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void merge(int rt,int u,int f) &#123; fa[u][0]=f,dep[u]=dep[f]+1; for(int i=1;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; size[rt]++, sta[u]=f, vis[u]=true; update(root[u],root[f],1,tmp,S(a[u])); for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=f) merge(rt,G[i].to,u);&#125;int find(int u) &#123;return u==sta[u]?u:sta[u]=find(sta[u]);&#125;int main() &#123; IN(testcase); IN(n),IN(m),IN(T); for(int i=1;i&lt;=n;++i) IN(a[i]),b[i]=a[i],sta[i]=i; sort(b+1,b+1+n); for(int i=1;i&lt;=n;++i) if(b[i]!=b[i-1])b[++tmp]=b[i]; for(int i=1;i&lt;=m;++i) &#123; int x,y;IN(x),IN(y);add(x,y); &#125; for(int i=1;i&lt;=n;++i) if(!vis[i]) &#123;merge(i,i,0);sta[i]=i;&#125; for(int i=1;i&lt;=T;++i) &#123; char op[2];int x,y,k; scanf("%s",op);IN(x),IN(y); if(op[0]=='L') &#123; x^=lastans,y^=lastans; add(x,y); int a=find(x),b=find(y); if(size[a]&lt;size[b])swap(x,y),swap(a,b); merge(a,y,x); &#125; else &#123; IN(k); x^=lastans,y^=lastans,k^=lastans; int lca_xy=lca(x,y); lastans=b[query(root[x],root[y], root[lca_xy],root[fa[lca_xy][0]],1,tmp,k)]; printf("%d\n",lastans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>启发式合并</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2008]Sandy的卡片 后缀数组.SA luoguP2463]]></title>
    <url>%2F2019%2F03%2F28%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2463%2F</url>
    <content type="text"><![CDATA[后缀数组，我们可以先将所有的卡片连成一个串，每一个卡片数列之间用一个极大数分开保证不出锅。然后的话，对于相同的定义有些鬼，使得我们不能直接做 $SA$ ，这个时候我们将所有的卡片数列的值都转换为当前位置减去上个位置的值即可。 然后就是统计答案，我们二分这个最长公共子序列的长度，每一次去判断是否合法。怎么判断呢？首先对于 $height$ 数组，如果要满足要求的话选取的这一段的 $height$ 数组的值都不能小于当前的 $mid$ ，这是显然的。 怎么确保我们将所有的卡片数列都选了呢？直接开一个 $vis​$ 数组即可，然后在碰到不合法的地方(也就是 $height[i]​$ 小于了 $mid​$ )全部清空即可。 最后如何判断当前的 $mid$ 是否合法呢？很显然，只有在所有的卡片数列都成功选择的情况下就合法了。我们用一个栈维护 $vis$ ，清空方便，然后当栈顶为卡片序列数的时候，也就是所有的卡片序列都选择的时候，$mid$ 就合法了。 然后有个悲催的事情，窝打二分的时候……打成了这样： 12345while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,l=mid+1; r=mid-1;&#125; 很显然，$r$ 前面应该要有 $else$ ，但是窝看了一晚上都没看出来……. Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2e6+7;const int M=5e2+7;const int G=5e3+7;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace SA &#123; int n,m,S[N],sa[N],height[N],x[N],y[N],hep[N]; inline void pre_sa() &#123; ++m; for(int i=1;i&lt;=n;++i) x[i]=S[i]; for(int i=1;i&lt;=n;++i) hep[x[i]]++; for(int i=1;i&lt;=m;++i) hep[i]+=hep[i-1]; for(int i=n;i&gt;=1;--i) sa[hep[x[i]]--]=i; for(int w=1,p=0;m=p,p&lt;n;w&lt;&lt;=1) &#123; p=0; for(int i=1;i&lt;=w;++i) y[++p]=n-w+i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;w) y[++p]=sa[i]-w; for(int i=0;i&lt;=m;++i) hep[i]=0; for(int i=1;i&lt;=n;++i) hep[x[i]]++; for(int i=1;i&lt;=m;++i) hep[i]+=hep[i-1]; for(int i=n;i&gt;=1;--i) sa[hep[x[y[i]]]--]=y[i]; swap(x,y); x[sa[1]]=p=1; for(int i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+w]==y[sa[i-1]+w])?p:++p; &#125;return; &#125; inline void pre_height()&#123; for(int i=1;i&lt;=n;++i)x[sa[i]]=i; int k=0; for(int i=1;i&lt;=n;++i)&#123; k-=k&gt;0; int j=sa[x[i]-1]; while(j+k&lt;=n&amp;&amp;i+k&lt;=n&amp;&amp;S[j+k]==S[i+k])++k; height[x[i]]=k; &#125;return; &#125;&#125;using namespace SA;int vis[G],stack[G],top;int num,len[G],id[N],a[G][M];inline bool check(int x) &#123; while(top) vis[stack[top--]]=0; for(int i=1;i&lt;=n;++i) &#123; if(height[i]&lt;x) &#123; while(top) vis[stack[top--]]=0; &#125; if(!vis[id[sa[i]]]) &#123; stack[++top]=id[sa[i]],vis[id[sa[i]]]=true; if(top==num) return true; &#125; &#125;return false;&#125;int main() &#123; IN(num); int mx=-inf,mi=inf,l=0,r=inf; for(int i=1;i&lt;=num;++i) &#123; IN(len[i]),r=min(r,len[i]-1); for(int j=1;j&lt;=len[i];++j) &#123; IN(a[i][j]); if(j!=1)mx=max(mx,a[i][j]-a[i][j-1]); &#125; &#125; for(int i=1;i&lt;=num;++i) &#123; for(int j=2;j&lt;=len[i];++j) S[++n]=a[i][j]-a[i][j-1],id[n]=i,mi=min(mi,S[n]); S[++n]=++mx; &#125; m=0; for(int i=1;i&lt;=n;++i) S[i]=S[i]-mi+1,m=max(m,S[i]); pre_sa(),pre_height(); int ans=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid))ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d\n",ans+1); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>后缀数组.SA</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【考试总结】 Test-2019.3.28 HNOI2019模拟]]></title>
    <url>%2F2019%2F03%2F28%2F%5B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%5Dtest20190328%2F</url>
    <content type="text"><![CDATA[今天的题目貌似暴力分好拿写欸，然而……窝只有 $70$ ？不过排名比昨天上升了什么鬼。 $QwQ$ 题目的确很难懂，所以窝听了讲解后也没听懂多少，不过还是改出了第一题(第一题是人就改的出好吧o(≧口≦)o)。 题目压缩包戳我!!!~\(≧▽≦)/~(有时链接可能会崩，如果崩了的话请稍后尝试QwQ) T1 期望得分：30分实际得分：30分正解：找规律??窝的解法：暴力模拟题意 题解：第一眼看到题目，欸，如果按照题面模拟就有 $30$ 分！出题人良心啊。然后看数据范围，$100\%$ 的数据的 $n\leq 3\times10^7$ ，这应该是 $O(n)$ 算法才行啊，于是想，或许是线性 $DP$ ，然后推式子，推出这么一个鬼玩意： f[i]=f[i-1]+sum(a[i])$sum(a[i])$ 就是在 $1$ 到 $i-1$ 中大于 $a[i]$ 的数的个数，然后 $f[i]$ 表示将前 $i$ 个元素进行冒泡需要的交换次数。 很显然这是错的。 然后我就想到了 $NOI$ 往年的冒泡排序(貌似是 $NOI$ 的?)，其实两道题没什么联系。 哎好吧发现过不去直接上暴力吧，题目说什么就做什么，于是把我用来对拍的暴力程序提交了上去，$30$ 分。 接下来讲讲正解。 很显然，对于一个元素 $a_i$ ，它所在的位置为 $i$ ，然而最后排好序后 $ta$ 应该回到的位置为 $a_i$ 。观察冒泡过程，发现对于一个元素，每次冒泡排序都最多会将 $ta$ 向自己的目标位置移动一格。 然后就是，比如说当前序列的最小元素，假设最小元素的起点位置为 $s$ ,我们发现每次冒泡总会将 $ta$ 向前移一格，然后在第 $s-1$ 次冒泡排序的时候 $1$ 归位了。然后发现 $1$ 的移动对 $2$ 的移动次数并没有产生影响，这个时候将 $1$ 删去，发现 $2$ 归位的移动次数变成了 $2$ 的初始位置 $-$ $1$ ，放在原序列中就是 $2$ 的初始位置 $-$ $2$ 。 这至少说明，对于任意一个元素 $i$ ，其所需要的移动次数为 $i-a_i$ 。 那么，如果要使序列有序，所需要的排序次数就是 $max\{ i-a_i \}$ 。直接计算答案即可。 (实际上窝也不是很明白…..貌似是这样的吧 $QwQ$ ) Code：12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n,S,B,C,D,A[10006];int main() &#123; freopen("magician.in","r",stdin); freopen("magician.out","w",stdout); scanf("%d%d%d%d%d",&amp;n,&amp;S,&amp;B,&amp;C,&amp;D); for(int i=1;i&lt;=n;++i) &#123; A[i]=i; S=(S*B+C)%D; swap(A[i],A[(S%i)+1]); &#125; int counter=0; for(int i=1;i&lt;=n;++i)counter=max(counter,i-A[i]); printf("%d\n",counter); return 0;&#125; T2 期望得分：30分实际得分：0分正解：容斥+搜索+剪枝窝的解法：暴搜 题解：不会………….然后暴搜打挂了没得分。 所以这不能说是题解，留个坑吧。 T3 期望得分：40分实际得分：40分正解：将所有颜色维护成链，然后分块加速窝的解法：直接维护成链 对于一个 $i$ ，如果 $a_i=k$ ，并且 $a_j=k$ ，而且 $i$ 和 $j$ 是离得最近的，则将它们向前向星那样连起来，最后对询问的区间直接暴力跳即可。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=5e5+7;const int LogN=27;vector&lt;int&gt; seq;map&lt;int,int&gt; hashs;int n,q,a[N],head[N],nxt[N],f[LogN+7][N],logs[N],ans;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline void pre_st()&#123; logs[0]=-1; for(int i=1;i&lt;=n;++i)logs[i]=logs[i&gt;&gt;1]+1; for(int i=1;i&lt;=n;++i)f[0][i]=a[i]; for(int t=1;t&lt;LogN;++t) for(int i=1;i&lt;=n;++i) if(i+(1&lt;&lt;t)-1&lt;=n) f[t][i]=max(f[t-1][i],f[t-1][i+(1&lt;&lt;(t-1))]);&#125; inline int query(int x,int y)&#123; int t=logs[y-x+1]; return max(f[t][x],f[t][y-(1&lt;&lt;t)+1]);&#125; inline void solve(int x,int lim) &#123; for(int now=x,last=nxt[x];last&gt;=lim;last=nxt[last]) &#123; while(now&gt;last&amp;&amp;query(last,now)&gt;a[last]) now=nxt[now]; ans=max(ans,now-last+1); &#125;&#125; inline void make_hashs() &#123; sort(seq.begin(),seq.end()); seq.erase(unique(seq.begin(),seq.end()),seq.end()); for(int i=0;i&lt;seq.size();++i) hashs[seq[i]]=i+1; for(int i=1;i&lt;=n;++i) a[i]=hashs[a[i]]; memset(head,-1,sizeof head);&#125;int main() &#123; freopen("spiral.in","r",stdin); freopen("spiral.out","w",stdout); IN(n),IN(q); for(int i=1;i&lt;=n;++i) IN(a[i]),seq.push_back(a[i]); make_hashs(); for(int i=1;i&lt;=n;++i) nxt[i]=head[a[i]],head[a[i]]=i; pre_st(); while(q--) &#123; ans=1; int x,y;IN(x),IN(y); for(int i=y;i&gt;=x;--i) solve(i,x); printf("%d\n",ans); &#125; return 0;&#125; 正解不费………………………………….]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>考试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【考试总结】 Test-2019.3.27 HNOI2019模拟]]></title>
    <url>%2F2019%2F03%2F27%2F%5B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%5Dtest20190327%2F</url>
    <content type="text"><![CDATA[今天全是原题，然而窝几乎都没做过，于是挂了…… 丢人的是考场上组合数的式子 $C[i][j]$=$C[i$-$1][j]$+$C[i$-$1][j$-$1]$ 写成了 $C[i][j]$=$C[i][j$-$1]$+$C[i$-$1][j$-$1]$ ，然后第一题光荣爆 $0​$ ……TAT。 吸取教训！ 题目压缩包戳我!!!~\(≧▽≦)/~(有时链接可能会崩，如果崩了的话请稍后尝试QwQ) T1 期望得分：100分实际得分：0分正解：Purfer+DP+组合数学窝的解法：Purfer+DP+组合数学 题解：十年OI一场空，组合数打错见祖宗。 上面的正解有误，听说 $DP$ 不是正解，不过，$DP$ 复杂度高达 $O(n^4)$ ，本应该 $T$ 的，却仗着小常数不仅 $AC$ ，还爆踩标程？这究竟是道德的沦丧还是人性的扭曲？ 不了不了，正经一点。众所周知，有个东西叫 $Purfer$ 序列，对于每一个不同的树，都有不同的 $Purfer$ 序列。所以每个树都可以用其 $Purfer$ 序列来表示，这个树中的每个结点在 $Purfer$ 序列中的出现次数为其度数减一。至于$Purfer​$ 序列具体是什么就不赘述了。 那么 $DP​$ 方程怎么设？ 我们设 $f[i][j][k]$ 表示 从前 $i$ 个结点中选出 $j$ 个结点，并且这 $j$ 个结点共在原树的 $Purfer$ 序列出现了 $k$ 次的合法 $Purfer$ 序列的数量 。 那么转移呢？很显然分为两种情况： 没选第 $i​$ 个点。 选了第 $i​$ 个点。 然后分别进行转移，这就很简单了： 没选：$f[i][j][k]+=f[i-1][j][k]​$ 选了：$f[i][j][k]+=f[i-1][j-1][k-d]\times C[k][d]​$ 其中 $d​$ 为我们正在枚举的第 $i​$ 个点的出现次数 $(0​$ ~ $du[i]-1)​$ ，然后就是下面的组合数，就是代表着在 $k-d​$ 长度的序列中插入 $d​$ 个 $i​$ 的方案数 。当然也可以这么写： f[i][j+1][d+k]+=C[d+k][d]\times f[i-1][j][k]​ 我们知道一棵 $n​$ 个结点的树的 $Purfer​$ 序列的长度是 $n-2​$ 的，所以我们的答案应该就是 $f[n][i][i-2]​$ 。 最后，记得随时膜模！ Code:1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=57;const int MOD=1000000007;int du[N],n,T;ll C[N][N],f[N][N][N];int main() &#123; C[0][0]=1; for(int i=1;i&lt;=50;++i)&#123; C[i][0]=C[i][i]=1; for(int j=1;j&lt;i;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;//就是这儿! &#125; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;du[i]); memset(f,0,sizeof(f)); f[0][0][0]=1; for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;i;++j) for(int k=0;k&lt;=n-2;++k) &#123; f[i][j][k]=(f[i][j][k]+f[i-1][j][k])%MOD; for(int d=0;d&lt;du[i]&amp;&amp;d+k&lt;=n-2;++d) f[i][j+1][d+k]=(f[i][j+1][d+k]+C[d+k][d]*f[i-1][j][k]%MOD)%MOD; &#125; printf("%d ",n); for(int i=2;i&lt;=n;++i)printf("%lld ",f[n][i][i-2]); printf("\n"); &#125; return 0;&#125; T2 期望得分：5分实际得分：30分正解：???没发sol……窝的解法：手玩小数据+瞎搞 题解：一看就是懵逼题……但是看到 $30$ 分的数据很小，并且还有菊花图，所以我们来瞎搞吧！刚开始的时候以为前六个点都是菊花图，然后都手玩，到后面才看清，只能说数据太弱了啊。 正解表示不明白……贴一发考场上的代码： Code:123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen("b.in","r",stdin); freopen("b.out","w",stdout); int n,k; scanf("%d%d",&amp;n,&amp;k); int x,flag=0; for(int i=1;i&lt;n;++i)&#123; scanf("%d",&amp;x); if(x!=0)flag=1; &#125; if(k==0)&#123;printf("1\n");exit(0);&#125; if(!flag) &#123;//菊花图输出瞎搞手玩？ if(n==1&amp;&amp;k&gt;=0)&#123;printf("1\n"),exit(0);&#125; if(n==2&amp;&amp;k&gt;=0)&#123;printf("1\n"),exit(0);&#125; if(n==3&amp;&amp;k==0)&#123;printf("1\n"),exit(0);&#125; if(n==3&amp;&amp;k&gt;=1)&#123;printf("3\n"),exit(0);&#125; if(n==4&amp;&amp;k==0)&#123;printf("1\n"),exit(0);&#125; if(n==4&amp;&amp;k==1)&#123;printf("7\n"),exit(0);&#125; if(n==4&amp;&amp;k&gt;=2)&#123;printf("10\n"),exit(0);&#125; if(n==5&amp;&amp;k==0)&#123;printf("1\n"),exit(0);&#125; if(n==5&amp;&amp;k==1)&#123;printf("13\n"),exit(0);&#125; &#125; else &#123;//其他情况输出样例？？ if(n==4)&#123;printf("8\n");exit(0);&#125; if(n==6)&#123;printf("28\n");exit(0);&#125; &#125; return 0;&#125; 实际上玩到 $n​$=$5\&amp;\&amp;k​$=$2​$ 的时候我就崩了，玩不下去了。 T3 期望得分：0分实际得分：0分正解：最小割窝的解法：没做…. 题解：真的看不出来是最小割啊 $QwQ$ ，以为是数论题，还看到质因子了感觉就更不像最小割了……但是在想题目的时候最小割的确出现在了我的脑海中，但是一闪就过了…… 一个有趣的事情：考试期间高二机房神仙一度怀疑此题为数论题，这个时候 $chl$神仙 和另一位 $Dalao$ 走了出去，站在门外讨论此题中的”物理”，说什么重心和”物理”有关因此此题不可做，然后树王神仙表示不懂”物理”中的”重心”准备弃疗，然而最终树王神仙还是选择了网络流…… 好吧不扯淡了，我们来讨论一下这题的粗略解法。 可以发现题目给出了一个限制：$N$ 最多有两个质因子。这个限制有什么用呢？ 对于一个有 $N$ 个扇叶的风扇，我们考虑平衡的并且独立扇叶只有一个的风扇： 左边的就是有 $(N=8)$ 个扇叶的风扇，右边的呢就是在 $8$ 个扇叶中有 $2$ 个扇叶的风扇 ($(A_1,D_1,F_1),$$(A_1,H_1,B_1)$)，可以知道这个 $2$ 个扇叶的风扇是一定平衡的，因为 $2$ 是 $8$ 的因子。 可以知道，对于 $8$ 的其他因子(例如 $4$ )是可以被质因子 $2$ 组成的，因此也是平衡的风扇。 那么对于两个不同的质因子，可以组成两个不同样式的且平衡的 $N$ 个扇叶的风扇的子风扇。 当然还有位置不同，对于上图中 $2$ 个扇叶的子风扇根据不同的位置有很多个： 这个时候我们的问题就可以转化如下了： 有两种类型的风扇 $p,q$ ，风扇类型等于 $2$ 的样子如上图，现在我们需要用这两种风扇无重叠的覆盖尽可能多的剩下的残缺扇叶。 这个时候考虑建图，我们从 $S$ 向所有不同位置的 $p$ 类风扇连一条边，边权为 $p$ ，表示选择了这个风扇可以多覆盖一共 $p$ 个扇叶。所有不同位置的 $q$ 类风扇向 $T$ 连边，边权为 $q$ ，和上面同理。 然后这个时候的最小割是什么呢？对于一个起点为 $x$ 的 $p$ 类风扇，我们将 $S$ 连向Ta的边切断，表示不使用起点为 $x$ 的 $p$ 类风扇，$q$ 类风扇同理。当然是不使用的风扇越少越好，剩下的可用的风扇当然是越多越好，所以成了最小割。 那么怎么表示无重叠呢？ 可以知道同类风扇是不可能重叠的，我们考虑异类风扇。我们对于一个 $p$ 类风扇和一个 $q$ 类风扇，如果其重叠了，那么只能选择其中一个，于是我们在这两个风扇间连一条边，边权为 $inf$ ，这个时候跑最大流的时候必定有流经过此地，也就是说这两个风扇必然要割掉一个才行。 所以什么事情都解决了，就差代码了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2e6+2;const int inf=2e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace Dinic &#123;//Dinic板子封装 queue&lt;int&gt; Que; int s,t,sum,head[N&lt;&lt;1],cnt=1,dep[N&lt;&lt;1]; struct Edge &#123;int nxt,to,val;&#125;G[N&lt;&lt;2]; inline void add(int u,int v,int w) &#123; G[++cnt]=&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=&#123;head[v],u,0&#125;,head[v]=cnt; &#125; inline int bfs() &#123; memset(dep,0,sizeof(dep)); dep[s]=1,Que.push(s); while(!Que.empty()) &#123; int u=Que.front(),v;Que.pop(); for(int i=head[u];i;i=G[i].nxt) if(!dep[v=G[i].to]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,Que.push(v); &#125;return dep[t]; &#125; int dfs(int u,int flow) &#123; if(!flow||u==t) return flow; int used=0,rlow,v; for(int i=head[u];i;i=G[i].nxt) if(dep[v=G[i].to]==dep[u]+1&amp;&amp;G[i].val&gt;0) &#123; used+=(rlow=dfs(v,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; if(!used) dep[u]=-1; return used; &#125; inline void dinic() &#123; while(bfs()) sum-=dfs(s,inf); &#125;&#125;using namespace Dinic;int n,m,p,q,point,bock[N],vis[N],fan[N];inline void pre() &#123; for(int i=1;i&lt;=n/p;++i) if(!bock[i]) &#123;//起点扇叶没有损坏 for(int j=i;j&lt;=n;j+=n/p) if(bock[j]) goto end1; //枚举每个扇叶，如果损坏的那么该风扇就不合法 ++point,add(s,point,p),sum+=p;//连边 for(int j=i;j&lt;=n;j+=n/p) fan[j]=point;//标记 end1:; &#125; for(int i=1;i&lt;=n/q;++i) if(!bock[i]) &#123; for(int j=i;j&lt;=n;j+=n/q) if(bock[j]) goto end2; ++point,add(point,t,q),sum+=q;//连边 for(int j=i;j&lt;=n;j+=n/q) vis[fan[j]]=false; //清理标记，防止有风扇被连两次边 for(int j=i;j&lt;=n;j+=n/q) if(fan[j]&amp;&amp;!vis[fan[j]]) vis[fan[j]]=true,add(fan[j],point,inf);//连边 end2:; &#125;return;&#125;int main() &#123; IN(n),IN(m);s=0,t=N-2; for(int i=1;i&lt;=m;++i) &#123;int x;IN(x),bock[x]=true;&#125; int copy=n,sqr=sqrt(n),first=0; for(int i=2;i&lt;=sqr;++i) &#123;/*寻找两个质因子p和q*/ if(!(n%i)&amp;&amp;!first) &#123; first=true,p=i; while(!(n%p))n/=p; &#125; else if(!(n%i)) &#123; q=i; while(!(n%q))n/=q; break; &#125; &#125; if(n!=1)q=n;n=copy; pre(),dinic(); if(!sum)printf("-1"); else printf("%d\n",n-m-sum); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>考试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 「网络流24题」最长不下降子序列问题 网络流 luoguP2766]]></title>
    <url>%2F2019%2F03%2F26%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2766%2F</url>
    <content type="text"><![CDATA[第一问显然是一个很简单的 $DP$ ，但是第二问和第三问就要用最大流来求了，怎么求呢？ 首先我们 $DP$ 出来的 $f$ 数组，$f[i]$ 表示以i结尾的最长不下降子序列的长度 ，然后就是网络流的连边了。首先因为一个点只能经过两次，我们需要将其拆为入点和出点，中间连的边的边权自然是 $1$ ，然后对于一个 $i$ ，如果 $f[i]$ 等于最长长度($s$)，那么很显然这个 $i$ 就可以给答案做出一个贡献，这个时候 $i$ 的出点向 $t$ 连一条边权为 $1$ 边。 如果 $i$ 等于 $1$ ，那么自然 $1$ 是可以作为一个起点的，那么 $s$ 向 $i$ 的入点连一条边权为 $1$ 的边即可。 然后就是剩下的情况了，可以想到让 $i$ 向 $i$ 能够最优转移的位置连边，也就是说，如果有一个 $j$ ，使得 $f[j]=f[i]+1$ 并且 $a[i]&lt;=a[j]$ ，这个时候如果是在最优方案中 $i$ 是可以转移到 $j$ 的，这个时候从 $i$ 的出点向 $j$ 的入点连一条边，边权依旧是 $1$ 。 然后我们这个时候跑最大流，就是第二问的答案。 那么第三问呢？ 很显然，对于 $1$ ，如果它是连向 $s$ 的，则将其连向 $s$ 的边的边权改为 $inf$ ，并将入点连出点的边权改为 $inf$ ，表示可以取无限次。然后 $n$ 如果连向了 $t$ ，也将边权改为 $inf$ ，并将入点连出点的边权改为 $inf$ ，和上面同理。这个时候再跑一次最大流即可，这就是第三问的答案了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e5+7;const int M=5e2+7;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace Dinic &#123; queue&lt;int&gt; q; int s,t,head[N],cnt=1,dep[N]; struct Edge &#123;int nxt,to,val;&#125;G[N]; inline void add(int u,int v,int w) &#123; G[++cnt]=&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=&#123;head[v],u,0&#125;,head[v]=cnt; &#125; inline int bfs() &#123; memset(dep,0,sizeof(dep)); dep[s]=1,q.push(s); while(!q.empty()) &#123; int u=q.front(),v;q.pop(); for(int i=head[u];i;i=G[i].nxt) if(!dep[v=G[i].to]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,q.push(v); &#125;return dep[t]; &#125; int dfs(int u,int flow) &#123; if(!flow||u==t) return flow; int used=0,rlow,v; for(int i=head[u];i;i=G[i].nxt) if(dep[v=G[i].to]==dep[u]+1&amp;&amp;G[i].val&gt;0) &#123; used+=(rlow=dfs(v,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; if(!used) dep[u]=-1; return used; &#125; inline int dinic() &#123; int maxflow=0; while(bfs()) maxflow+=dfs(s,inf); return maxflow; &#125;&#125;using namespace Dinic;int n,l,ans,a[N],f[N];inline int id(int type,int x) &#123; return type*n+x;&#125;int main() &#123; IN(n);s=0,t=2*n+1; for(int i=1;i&lt;=n;++i) &#123; IN(a[i]); for(int j=0;j&lt;i;++j) if(a[j]&lt;=a[i]) f[i]=max(f[i],f[j]+1); l=max(l,f[i]); &#125; printf("%d\n",l);/*Q1*/ for(int i=1;i&lt;=n;++i) &#123; add(id(0,i),id(1,i),1); if(f[i]==1) add(s,id(0,i),1); if(f[i]==l) add(id(1,i),t,1); for(int j=1;j&lt;i;++j) if(a[j]&lt;=a[i]&amp;&amp;f[i]==f[j]+1)add(id(1,j),id(0,i),1); &#125; ans=dinic(); printf("%d\n",ans);/*Q2*/ if(f[1]==1)add(s,id(0,1),inf),add(id(0,1),id(1,1),inf); if(f[n]==l)add(id(1,n),t,inf),add(id(0,n),id(1,n),inf); ans+=dinic(); printf("%d\n",ans);/*Q3*/ return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈K-D Tree&学习笔记]]></title>
    <url>%2F2019%2F03%2F26%2F%5B%E7%AE%97%E6%B3%95%5DKD-Tree%2F</url>
    <content type="text"><![CDATA[又是一个神奇的数据结构…… $K$-$D \ Tree$ 中 $D$ 是维度($Dimension$)的缩写，所以 $K$-$D \ Tree$ 的实际意思就是 $K$ 维树。当然 $K$-$D \ Tree $ 一般用于维护二维平面上的信息，所以我们平常用的 $K$-$D\ Tree$ 又叫 $2$-$D \ Tree$ 。 假设我们现在有一个二维平面，二维平面上有若干个点 ，现在怎么用 $2​$-$D \ Tree​$ 维护这些点呢？很简单，我们将这些点建成一颗树，最好是一颗二叉搜索树，但是怎么建树呢？我们就来分割这个平面，横着一刀，竖着一刀，每次选取最优的结点当根即可。 可能很抽象，我们以下图为例，假设我们需要将下图的 $7$ 个点建成二叉搜索树： 首先我们准备竖着切，这个竖着切切哪里呢？我们会发现 $D$ 是最中间的结点，于是我们对着 $D$ 就是一刀，现在的矩阵分割成了两半，那么自然的 $A,B,C$ 就是 $D$ 的左子树中的结点，$E,F,G$ 就是 $D$ 的右子树中的结点。 然后我们先建 $D$ 的左子树，由于上一次是竖着切的，这一次我们需要横着切。我们递归下去，发现 $A,B,C$ 这一块 $B$ 是最中间的(以横着的视角，因为需要横着切嘛)，那么很显然 $D$ 的左儿子就是 $B$ 了，$A,C$ 分别是 $B$ 的两孩子，由于 $A,C$ 已经在 $B$ 的左右了并且只有一个点了，那么理所当然 $C$ 就是 $B$ 的左孩子，$A$ 就是 $B$ 的右儿子(横着看就好了)。 同样的，我们发现 $G$ 是 $D$ 左边横着切时最合适的结点(因为在横着的视角中 $G$ 是最中间的 )，于是我们将 $D$ 的右儿子定为 $G$ ，同样的，$F,E$ 为 $G$ 的两孩子。 那么这样子我们的树就建好了。 Code-build-kdt:123456789int build(int l,int r,int wd) &#123;//lr:当前对应的结点区间,wd:当前需要切的方向 if(l&gt;r) return 0; int x=new_node(),mid=(l+r)&gt;&gt;1;//新建结点 WD=wd,nth_element(p+l,p+mid,p+r+1),//重载了运算符，按照当前切的方向排序 tr[x].tp=p[mid];//找到最合适切割的最中间的结点 tr[x].l=build(l,mid-1,wd^1);//建立左子树 tr[x].r=build(mid+1,r,wd^1);//建立右子树 return pushup(x),x;//上传信息&#125; 但是怎么查询呢？实际上查询跟普通的二叉搜索树差不多，按照方位坐标查找即可。 对于一个结点的信息是这样的： Code-node-kdt1234struct node &#123; int mi[2],mx[2],l,r,sz; point tp;&#125;tr[N]; l,r,sz 就是左右儿子以及子树大小，point 显然是该结点代表的二维平面上的点，但是 $mi,mx$ 是干什么的呢？我们用 $mi,mx$ 记录的就是当前结点已经它的子树中的所有节点中，最大/最小的 $x$ 坐标以及最大/最小的 $y$ 坐标。 这样记录有什么用呢？假设我们将这个看成一个矩形，那么对于一个我们需要搜索的坐标，如果这个需要搜索坐标 已经不属于 $mi,mx$ 围城的矩阵中，那么这个需要搜索的坐标就跟当前子树没关系了，这也就相当于一个剪枝。 我们的 $pushup$ 上传时就是对 $mi,mx$ 进行更新，所以 $pushup$ 应该这样写： Code-pushup-kdt1234567891011121314151617inline void pushup(int x) &#123; int l=tr[x].l,r=tr[x].r;//简写左右儿子 tr[x].sz=tr[l].sz+tr[r].sz+1;//更新size for(int i=0;i&lt;=1;++i) &#123;//枚举方向，节省码量 /*---------更新mi[x],mx[x]---------*/ tr[x].mi[i]=tr[x].mx[i]=tr[x].tp.x[i]; if(l) &#123; tr[x].mi[i]=min(tr[x].mi[i],tr[l].mi[i]); tr[x].mx[i]=max(tr[x].mx[i],tr[l].mx[i]); &#125; if(r) &#123; tr[x].mi[i]=min(tr[x].mi[i],tr[r].mi[i]); tr[x].mx[i]=max(tr[x].mx[i],tr[r].mx[i]); &#125; /*---------更新mi[x],mx[x]---------*/ &#125;&#125; 然后呢，这里不待修改的，那么如果说要兹磁插入节点怎么办？ 需要兹磁插入节点的题目：[Violet]天使玩偶/SJY摆棋子 这道题因为允许离线，我们可以使用 $CDQ​$ ，但是如果强制在线的话就只能用 $K​$-$D \ Tree​$ 了。我们来讨论 $K​$-$D \ Tree​$ 的做法。 实际上 $K​$-$D \ Tree​$ 插入节点非常简单，就像普通的二叉搜索树那样找个位置插就好了。 Code-Insert-kdt12345678910void Insert(point tmp,int&amp;x,int wd) &#123;//tmp:当前需要插入的点,x:当前树中结点,wd:当前切割方向 if(!x) &#123;//找到要插入的位置了 x=new_node();//新建结点 tr[x].tp=tmp,tr[x].l=tr[x].r=0; pushup(x);return; &#125; if(tr[x].tp.x[wd]&lt;tmp.x[wd]) Insert(tmp,tr[x].r,wd^1);//应该往右插 else Insert(tmp,tr[x].l,wd^1); //否则往左插 pushup(x);//更新结点信息&#125; 但是呢，你会发现就像一般的二叉搜索树一样，这个插入很容易被卡，卡成一条链，这就很不舒服了。于是我们需要一些平衡树的思想，使得 $K$-$D \ Tree$ 保持平衡。 “我会 $Splay$ ！我会 无旋$Treap$ ！” 呸呸呸，今天我们讲的是替罪羊树，跟你俩没关系。 没错，就是用替罪羊树的思想，将 $K​$-$D \ Tree​$ 拍扁重建。差不多就是 $insert​$ 的时候，在 $insert​$ 的最后 $check​$ 一下子树是否平衡，如果当前结点的子树已经”不平衡”了，那么拍扁该结点以及该结点子树，重建。 这里的 $\alpha$ 的值一般定为 $0.75$ 左右，但是也不能确定，如果实在要掐得准的话就得看看询问多还是插入多了。不过一般用 $0.75$ 是没问题的。 Code-check&amp;pia-kdt:123456789void pia(int x,int num) &#123;//就是拍扁的意思,sto litble orz if(tr[x].l) pia(tr[x].l,num);//先拍左子树 p[num+tr[tr[x].l].sz+1]=tr[x].tp,trh[++top]=x;//再拍自己 if(tr[x].r) pia(tr[x].r,num+tr[tr[x].l].sz+1);//然后拍右子树&#125;void check(int&amp;x,int wd) &#123;//判断x的子树是否满足"平衡",wd记录当前切割方向,建树的时候有用 if(alph*tr[x].sz&lt;tr[tr[x].l].sz||alph*tr[x].sz&lt;tr[tr[x].r].sz)//判断 pia(x,0),x=build(1,tr[x].sz,wd);//拍扁 and 重新build建树&#125; 然后就是应用了，值得注意的是，如果维护的不是点而是矩形，那么有些地方(例如边界，$mi,mx​$ 都要注意)。 就像这道题：[APIO2018] Circle selection 选圆圈，注意一下细节就好。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>K-D Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SCOI2010]股票交易 单调队列优化DP luoguP2569]]></title>
    <url>%2F2019%2F03%2F24%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2569%2F</url>
    <content type="text"><![CDATA[我们一起来推一推。 设 $f[i][j]$ 表示：现在是第 $i$ 天，手上拥有的股票数为 $j$ 时赚到的最多的钱 我们考虑转移几个方向：空手买，不买不卖，之前买过了现在继续买，买过后需要卖 空手买空手买就是第一次买，显然不要考虑 “间隔 $w$ 天” 的限制，直接买就好。 那么很容易得到转移式： f[i][j]= - AP_i\times j因为是买入，所以是负数。 不买不卖很显然可以直接从 $f[i-1][j]$ 转移过来。 转移式： f[i][j]=f[i-1][j]之前买过了现在继续买很显然这次我们需要考虑 $w$ 的限制了，不过我们可以直接从 $i-w-1$ 天转移。 假设我们是从 $f[i-w-1][k]$ 转移过来的，那么这次转移我们多买了 $j-k$ 张股票，容易得到转移式： f[i][j]=max\{f[i-w-1][k]-(j-k)\times AP_i\}当然因为规定了一天最多买入 $AS_i$ 股，上面的式子必须满足 $j-AS_i\leq k \leq j$ 买过之后需要卖同样的有 $w$ 的限制，但是跟上面的第三种情况没什么两样，转移式： f[i][j]=max\{ f[i-w-1][k] + (k-j)\times BP_i\}因为 $BS_i$ 的限制条件，上面的式子必须满足 $j\leq k \leq j+BS_i$ 时间复杂度？枚举 $i,j$ 状态就需要 $n^2$ 的复杂度，在这个基础上转移的复杂度为： 空手买 ： $O(1)$ 不买不卖 ： $O(1)$ 之前买过了现在继续买 ：$O(n)$ 买过之后需要卖 ：$O(n)$ 会发现如果加上枚举状态的复杂度，后面两个转移的总复杂度为 $O(n^3)$ ！ 于是考虑优化。 我们观察第三个转移式： f[i][j]=max\{f[i-w-1][k]-(j-k)\times AP_i\}对于当前的 $i,j$ ，假设有 $a,b$ 作为 $k$ 的两个选项对 $f[i][j]$ 进行转移，我们算一算 $a$ 比 $b$ 优的条件是什么： f[i][j]=max\{f[i-w-1][k]-(j-k)\times AP_i\}=max\{f[i-w-1][k]+k\times AP_i-j\times AP_i\}这里我们会发现 $j\times AP_i$ 跟里面的式子没有任何关系，提出来不会产生仍和影响 =max\{f[i-w-1][k]+k\times AP_i\}-j\times AP_i​于是我们发现我们只需要得到最大的 $f[i-w-1][k]+k\times AP_i$ 就好了，这里我们可以用到单调队列优化DP 。 具体代码实现如下： 1234567l=1,r=0;for(int j=0;j&lt;=MaxP;++j) &#123;/*枚举所有的合法的j*/ while(l&lt;=r&amp;&amp;q[l]&lt;j-AS) ++l;/*淘汰掉过期的队头*/ while(l&lt;=r&amp;&amp;f[i-W-1][q[r]]+q[r]*AP&lt;=f[i-W-1][j]+j*AP) --r;/*淘汰掉不如当前决策优的队尾*/ q[++r]=j;/*当前决策进队*/ if(l&lt;=r) f[i][j]=max(f[i][j],f[i-W-1][q[l]]+q[l]*AP-j*AP);/*转移*/&#125; 因为每一个状态都只进队/出队了一次，所以可以证明时间复杂度现在变为 $O(n^2)$ 了。 第四个操作一样可以这样优化，可以尝试一下，不贴解释了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=2e3+2;const int inf=1e9+9;int T,MaxP,W,AP,BP,AS,BS,l,r;int q[N],f[N][N];int main() &#123; memset(f,128,sizeof(f));/*赋极小值*/ scanf("%d%d%d",&amp;T,&amp;MaxP,&amp;W); for(int i=1;i&lt;=T;++i) &#123; scanf("%d%d%d%d",&amp;AP,&amp;BP,&amp;AS,&amp;BS); for(int j=0;j&lt;=AS;++j) f[i][j]=-AP*j; for(int j=0;j&lt;=MaxP;++j) f[i][j]=max(f[i][j],f[i-1][j]); if(i&lt;=W)continue; l=1,r=0; for(int j=0;j&lt;=MaxP;++j) &#123; while(l&lt;=r&amp;&amp;q[l]&lt;j-AS) ++l; while(l&lt;=r&amp;&amp;f[i-W-1][q[r]]+q[r]*AP&lt;=f[i-W-1][j]+j*AP) --r; q[++r]=j; if(l&lt;=r) f[i][j]=max(f[i][j],f[i-W-1][q[l]]+q[l]*AP-j*AP); &#125; l=1,r=0; for(int j=MaxP;j&gt;=0;--j) &#123; while(l&lt;=r&amp;&amp;q[l]&gt;j+BS) ++l; while(l&lt;=r&amp;&amp;f[i-W-1][q[r]]+q[r]*BP&lt;=f[i-W-1][j]+j*BP) --r; q[++r]=j; if(l&lt;=r) f[i][j]=max(f[i][j],f[i-W-1][q[l]]+q[l]*BP-j*BP); &#125; &#125; int ans=0; for(int i=0;i&lt;=MaxP;++i)ans=max(ans,f[T][i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2009]植物大战僵尸 网络流 luoguP2805]]></title>
    <url>%2F2019%2F03%2F24%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2805%2F</url>
    <content type="text"><![CDATA[前置芝士：网络流-最大权闭合子图定义：对于一个图的子图，当且仅当这个子图中的任意一点都不会与该子图外的点联通时，称这个子图为该图的闭合子图。在该图所有的闭合子图中，点权和最大的那个我们称作最大权闭合子图。 那么最大权闭合子图怎么求呢？ 对于给出的图，如果要求将 $u,v$ 连一条边，那么从 $u$ 向 $v$ 连一条边权为 $inf$ 的边。 然后对于每个点如果该点的点权为正，那么从 $s$ 向该点连一条边权为该点点权的边，否则从该点向 $t$ 连一条边权为$-1\times$该点权的边。 跑最小割，这个时候最大权闭合子图的”最大权”为正点点权和-最小割。 最大权闭合子图跟这一题有什么关系呢？ 可以发现，对于一个植物，僵尸必须先吃掉它右边的植物和保护它的植物才能吃它，那么这个植物就像它右边的植物与保护它的植物连边，这个连好边的图的最大权闭合子图就是答案！ 但是值得注意的一点是，可能存在互相保护的关系，比如说样例中的 $(2,0)$ 保护 $(2,1)$ ，但是 $(2,1)$ 又作为 $(2,0)$ 右边的植物保护 $(2,0)$ ，然后这对关系怎么都是攻不破的，这是一个环！ 于是我们可以先建好图后拓扑一边，然后再在访问过的点之间连边(该点访问过意味着该点不在环内)，最后再跑最小割即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e5+7;const int inf=1e9+9;int Score[N],n,m,s,t;#define id(x,y) (((x)-1)*m+(y))template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;namespace Dinic &#123; queue&lt;int&gt; q; int head[N],dep[N],cnt=1; struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;4]; inline void add(int u,int v,int w) &#123; G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,0&#125;,head[v]=cnt; &#125; inline int bfs() &#123; memset(dep,0,sizeof(dep)); dep[s]=1;q.push(s); while(!q.empty()) &#123; int u=q.front(),v;q.pop(); for(int i=head[u];i;i=G[i].nxt) if(!dep[v=G[i].to]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,q.push(v); &#125;return dep[t]; &#125; int dfs(int u,int flow) &#123; if(!flow||u==t) return flow; int used=0,rlow; for(int i=head[u];i;i=G[i].nxt) &#123; int v=G[i].to; if(dep[v]==dep[u]+1&amp;&amp;G[i].val&gt;0) &#123; used+=(rlow=dfs(v,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[u]=-1; return used; &#125; inline int dinic() &#123; int maxflow=0; while(bfs()) maxflow+=dfs(s,inf); return maxflow; &#125;&#125;namespace Topology &#123; int vis[N],in[N]; vector&lt;int&gt; out[N]; queue&lt;int&gt; q; inline void topology()&#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(!in[id(i,j)]) q.push(id(i,j)),vis[id(i,j)]=true; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;out[u].size();++i) &#123; int v=out[u][i];--in[v]; if(!vis[v]&amp;&amp;!in[v]) &#123;vis[v]=true;q.push(v);&#125; &#125; &#125;return; &#125;&#125;using namespace Topology;using namespace Dinic;int main() &#123; // freopen("test.in","r",stdin); IN(n),IN(m);s=0,t=n*m+7; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; int tot,x,y; IN(Score[id(i,j)]),IN(tot); for(int k=1;k&lt;=tot;++k) &#123; IN(x),IN(y);++x,++y; out[id(i,j)].push_back(id(x,y)); ++in[id(x,y)]; &#125; if(j&lt;m) &#123; out[id(i,j+1)].push_back(id(i,j)); ++in[id(i,j)]; &#125; &#125; topology(); int sum=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(vis[id(i,j)])&#123; int u=id(i,j); if(Score[u]&lt;0) &#123;add(u,t,-Score[u]);&#125; else &#123;add(s,u,Score[u]);sum+=Score[u];&#125; for(int k=0;k&lt;out[u].size();++k) &#123; int v=out[u][k]; if(vis[v])add(v,u,inf); &#125; &#125; printf("%d\n",max(sum-dinic(),0)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [AH2017/HNOI2017]大佬 搜索+DP luoguP3724/bzoj4828]]></title>
    <url>%2F2019%2F03%2F21%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj4828%2F</url>
    <content type="text"><![CDATA[首先可以发现，刷水题跟打伤害是可以分开处理的。 我们先用 $DP$ 预处理出能打伤害的最大天数，其余的天数都只能用刷水题的方式恢复。 于是设 $dp[i][j]$ 表示前 $i$ 天，信心值还剩 $j$ 的能够打伤害的最大天数。 可以知道一天只有两种情况，我们枚举 $i,j​$ 然后进行转移： 如果可以坚持到下一天：dp[i+1][j-a[i+1]]=max(dp[i+1][j-a[i+1]],dp[i][j]+1) 如果是要刷水题：dp[i+1][j-a[i+1]+w[i+1]]=max(dp[i+1][j-a[i+1]+w[i+1]],dp[i][j]) 当然，如果要做第一个转移的话得先判断一下 j-a[i+1] 是否超了界，超界了的话当然就不能转移了。第二个转移也要注意，j-a[i+1]+w[i+1] 先要跟信心上界($mc$) 取 $min$ 。 最后在所有的状态中取一个最大值即可。 Code-DP12345678910111213141516inline void DP_maxday()&#123; memset(dp,-1,sizeof(dp));//初始化 dp[0][mc]=0; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;=mc;++j)&#123; if(dp[i][j]&lt;0)continue; int t1=j-a[i+1];if(t1&lt;0)continue; dp[i+1][t1]=max(dp[i+1][t1],dp[i][j]+1); int t2=min(t1+w[i+1],mc); dp[i+1][t2]=max(dp[i+1][t2],dp[i][j]); &#125; for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;=mc;++j) d=max(d,dp[i][j]); return;&#125; 这个 $d$ 就是我们能够打伤害的最大天数。 然后我们需要预处理出打出伤害的所有状态，这里我用广搜。 队列的结构体 $Node$ 由三个元素组成：$F,L,D$ ，表示在第 $D$ 天，你的 $F$ 的值为 $F$ ，$L$ 的值为 $L$ 。 然后就是转移，这里也是两种情况： 使讽刺能力乘上等级：F,L,D -&gt; F*L,L,D+1 (L&gt;0) 使等级加一：F,L,D -&gt; F,L+1,D+1 直接这样转移就好了，注意我们需要开个数组将这些打出伤害的方案记下来，当然，记录的时候不用记 $L$ ，因为后面打伤害的时候 $L$ 是没太多用的。 还有就是每次需要判断一下当前的天数，如果当前状态的天数已经大于了 $d$ 那么当前状态显然是不合法的。 最后就是需要用 $map$ 判个重，不然的话会爆炸，当然判重的时候也不要判 $L$ 。 Code-Bfs1234567891011121314151617181920map&lt;pair&lt;int,int&gt;,int&gt; vis;inline void BFS_maxhurt()&#123; q.push((Node)&#123;1,0,1&#125;);//初始化 while(!q.empty())&#123; Node x=q.front();q.pop(); if(x.D&gt;d)continue; else if(x.D==d)&#123;T[++cnt]=(Data)&#123;x.F,x.D&#125;;continue;&#125; else T[++cnt]=(Data)&#123;x.F,x.D&#125;; /*第一种转移*/ if(x.L&amp;&amp;(ll)x.F*x.L&lt;=1e8&amp;&amp;!vis[pair&lt;int,int&gt;(x.F*x.L,x.L)])&#123; q.push((Node)&#123;x.F*x.L,x.L,x.D+1&#125;); vis[pair&lt;int,int&gt;(x.F*x.L,x.L)]=x.D;//标记 &#125; /*第二种转移*/ if(!vis[pair&lt;int,int&gt;(x.F,x.L+1)])&#123; q.push((Node)&#123;x.F,x.L+1,x.D+1&#125;); vis[pair&lt;int,int&gt;(x.F,x.L+1)]=x.D;//标记 &#125; &#125;return;&#125; 抱歉我的英语真的不好 然后我们已经将所有可行的打伤害的方案记录到 $T​$ 数组里面了，接下来就是看看怎么用这些方案打大佬了。 首先还嘴是可以直接算的，这个是不用考虑的。我们唯一要处理的就是怼大佬，我们可以选择怼一次还是两次。可以发现怼一次的话直接枚举 $T​$ 数组中的方案即可，算上天数，剩下的天数当然是每天还嘴，看看这样可不可以干掉大佬： 1if(T[i].F&lt;=C&amp;&amp;T[i].D&lt;=d&amp;&amp;C-T[i].F&lt;=d-T[i].D)return true; ( $C$ 为当前大佬的信心值) 首先，T[i].F&lt;=C 是为了保证你不被虐飞，然后 T[i].D&lt;=d 当然就是你有足够的天数来实现这个方案，最后的 C-T[i].F&lt;=d-T[i].D 就是看看打完这个方案后剩下的天数能否通过仅剩的还嘴来干掉大佬。 那么如果是怼两次大佬呢？ 可以发现其实跟上面差不多，设两次中一次是第 $i$ 套方案，一次是第 $j$ 套方案。那么首先这两套方案的 $F$ 的和不能超过 $C$ ，然后就是要保证剩下的天数中可以通过还嘴干掉大佬，于是我们可以列出式子： T[i].F+T[j].F \leq C \ , \ T[i].F+T[j].F+(d-T[i].D-T[j].D) \geq C​然后前式很容易满足，我们来看看后式： T[i].F+T[j].F+d-T[i].D-T[j].D \geq CT[i].F-T[i].D+T[j].F-T[j].D+d \geq C我们枚举一个 $i$ ，寻找 $j$ 。既然 $i$ 已经确定，最优的 $j$ 一定满足 $T[j].F-T[j].D$ 最大，取 $max$ 就好。 至于代码的问题，我们先将 $T[i]$ 按照 $F$ 排序，然后按顺序寻找 $j$ ，代码实现就不是很难了。 Code-Solve:12345678910111213inline bool solve(int C)&#123; if(C&lt;=d)return true;//可以全程顶嘴干掉大佬，直接retrun int l=0,mx=-inf;//初始化 for(int i=cnt;i&gt;=1;--i)&#123; /*用第i方案怼一次可以干掉大佬，return*/ if(T[i].F&lt;=C&amp;&amp;T[i].D&lt;=d&amp;&amp;C-T[i].F&lt;=d-T[i].D)return true; /*按顺序扫描满足要求的 j*/ while(l&lt;cnt&amp;&amp;T[i].F+T[l+1].F&lt;=C) l++,mx=max(mx,T[l].F-T[l].D);//取max /*可以怼两次干掉大佬，return*/ if(T[i].F-T[i].D+mx+d&gt;=C)return true; &#125;return false;//干不掉大佬了&#125; 当然这个时间复杂度很玄学，大概是 $O($状态数$)$ 。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1.5e2+2;const int S=1e7+5;const int inf=1e9+9;int n,m,mc,a[N],w[N];int d,dp[N][N],cnt;struct Node&#123;int F,L,D;&#125;;struct Data&#123; int F,D; bool operator &lt; (const Data&amp;x)const&#123;return F&lt;x.F;&#125;&#125;T[S];map&lt;pair&lt;int,int&gt;,int&gt; vis;queue&lt;Node&gt; q;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline void DP_maxday()&#123; memset(dp,-1,sizeof(dp)); dp[0][mc]=0; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;=mc;++j)&#123; if(dp[i][j]&lt;0)continue; int t1=j-a[i+1];if(t1&lt;0)continue; dp[i+1][t1]=max(dp[i+1][t1],dp[i][j]+1); int t2=min(t1+w[i+1],mc); dp[i+1][t2]=max(dp[i+1][t2],dp[i][j]); &#125; for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;=mc;++j) d=max(d,dp[i][j]); return;&#125;inline void BFS_maxhurt()&#123; q.push((Node)&#123;1,0,1&#125;); while(!q.empty())&#123; Node x=q.front();q.pop(); if(x.D&gt;d)continue; else if(x.D==d)&#123;T[++cnt]=(Data)&#123;x.F,x.D&#125;;continue;&#125; else T[++cnt]=(Data)&#123;x.F,x.D&#125;; if(x.L&amp;&amp;(ll)x.F*x.L&lt;=1e8&amp;&amp;!vis[pair&lt;int,int&gt;(x.F*x.L,x.L)])&#123; q.push((Node)&#123;x.F*x.L,x.L,x.D+1&#125;); vis[pair&lt;int,int&gt;(x.F*x.L,x.L)]=x.D; &#125; if(!vis[pair&lt;int,int&gt;(x.F,x.L+1)])&#123; q.push((Node)&#123;x.F,x.L+1,x.D+1&#125;); vis[pair&lt;int,int&gt;(x.F,x.L+1)]=x.D; &#125; &#125;return;&#125;inline bool solve(int C)&#123; if(C&lt;=d)return true; int l=0,mx=-inf; for(int i=cnt;i&gt;=1;--i)&#123; if(T[i].F&lt;=C&amp;&amp;T[i].D&lt;=d&amp;&amp;C-T[i].F&lt;=d-T[i].D)return true; while(l&lt;cnt&amp;&amp;T[i].F+T[l+1].F&lt;=C) l++,mx=max(mx,T[l].F-T[l].D); if(T[i].F-T[i].D+mx+d&gt;=C)return true; &#125;return false;&#125;int main()&#123; IN(n),IN(m),IN(mc); for(int i=1;i&lt;=n;++i)IN(a[i]); for(int i=1;i&lt;=n;++i)IN(w[i]); DP_maxday(); BFS_maxhurt(); sort(T+1,T+cnt+1); for(int i=1;i&lt;=m;++i)&#123; int C;IN(C); if(solve(C))printf("1\n"); else printf("0\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [Violet]天使玩偶/SJY摆棋子 K-D Tree luoguP4169/bzoj2648]]></title>
    <url>%2F2019%2F03%2F21%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4169%2F</url>
    <content type="text"><![CDATA[$KDT$ 大法好！ 直接建 $KDT$ 维护一下所有的可能存在玩偶的结点，该插入的时候插入，查询的时候只需要沿着 $KDT$ 往下走，然后随时对 $ans$ 取 $min$ 即可。 注意这题有插入，这意味着 $KDT$ 到后面或许会不平衡，这个时候我们就需要用替罪羊树的思想——拍扁重建即可。注意这里判断是否平衡的 $check$ 函数需要放在 $insert$ 的最后，也就是还要在 $pushup$ 以后再 $check$ 即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e6+7;const int inf=1e9+9;#define alph (0.75)template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch=0;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int root,ans,WD,trh[N],top,cnt;struct point&#123;int x[2];&#125;p[N];struct node &#123; int mi[2],mx[2],l,r,sz; point tp;&#125;tr[N];int operator &lt; (point a,point b) &#123;return a.x[WD]&lt;b.x[WD];&#125;inline int new_node() &#123; if(top) return trh[top--]; else return ++cnt;&#125;inline void pushup(int x) &#123; int l=tr[x].l,r=tr[x].r; tr[x].sz=tr[l].sz+tr[r].sz+1; for(int i=0;i&lt;=1;++i) &#123; tr[x].mi[i]=tr[x].mx[i]=tr[x].tp.x[i]; if(l) &#123; tr[x].mi[i]=min(tr[x].mi[i],tr[l].mi[i]); tr[x].mx[i]=max(tr[x].mx[i],tr[l].mx[i]); &#125; if(r) &#123; tr[x].mi[i]=min(tr[x].mi[i],tr[r].mi[i]); tr[x].mx[i]=max(tr[x].mx[i],tr[r].mx[i]); &#125; &#125;&#125;int build(int l,int r,int wd) &#123; if(l&gt;r) return 0; int x=new_node(),mid=(l+r)&gt;&gt;1; WD=wd,nth_element(p+l,p+mid,p+r+1),tr[x].tp=p[mid]; tr[x].l=build(l,mid-1,wd^1); tr[x].r=build(mid+1,r,wd^1); return pushup(x),x;&#125;void pia(int x,int num) &#123; if(tr[x].l) pia(tr[x].l,num); p[num+tr[tr[x].l].sz+1]=tr[x].tp,trh[++top]=x; if(tr[x].r) pia(tr[x].r,num+tr[tr[x].l].sz+1);&#125;void check(int&amp;x,int wd) &#123; if(alph*tr[x].sz&lt;tr[tr[x].l].sz||alph*tr[x].sz&lt;tr[tr[x].r].sz) pia(x,0),x=build(1,tr[x].sz,wd);&#125;void Insert(point tmp,int&amp;x,int wd) &#123; if(!x) &#123; x=new_node(); tr[x].tp=tmp,tr[x].l=tr[x].r=0; pushup(x);return; &#125; if(tr[x].tp.x[wd]&lt;tmp.x[wd]) Insert(tmp,tr[x].r,wd^1); else Insert(tmp,tr[x].l,wd^1); pushup(x);check(x,wd);&#125;int getdist(point tmp,int x) &#123; int res=0; for(int i=0;i&lt;=1;++i) res+=max(0,tmp.x[i]-tr[x].mx[i])+max(0,tr[x].mi[i]-tmp.x[i]); return res;&#125;int dist(point a,point b) &#123; return abs(a.x[0]-b.x[0])+abs(a.x[1]-b.x[1]);&#125;void query(point tmp,int x) &#123; ans=min(ans,dist(tmp,tr[x].tp)); int disl=inf,disr=inf; if(tr[x].l) disl=getdist(tmp,tr[x].l); if(tr[x].r) disr=getdist(tmp,tr[x].r); if(disl&lt;disr) &#123; if(disl&lt;ans) query(tmp,tr[x].l); if(disr&lt;ans) query(tmp,tr[x].r); &#125; else &#123; if(disr&lt;ans) query(tmp,tr[x].r); if(disl&lt;ans) query(tmp,tr[x].l); &#125;&#125;int main() &#123; int n,m,op; IN(n),IN(m); for(int i=1;i&lt;=n;++i) IN(p[i].x[0]),IN(p[i].x[1]); root=build(1,n,0); for(int i=1;i&lt;=m;++i) &#123; point tmp; IN(op),IN(tmp.x[0]),IN(tmp.x[1]); if(op==1) Insert(tmp,root,0); else &#123; ans=inf;query(tmp,root); printf("%d\n",ans); &#125; &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>K-D Tree</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI/AHOI2018]转盘 线段树 luoguP4425]]></title>
    <url>%2F2019%2F03%2F20%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4425%2F</url>
    <content type="text"><![CDATA[首先再来讲明一下题意： 给定一个长度为 $n$ 的环，环上的每个点有一个权值 $T_i$ ，要求你从环上选中任意一个点为起点开始，每个时间可以顺时钟到下一个点，或者停留不动。对于一个点，如果到这个点的时间大于等于了 $T_i$ ，那么这个点将被标记，问最少什么时候可以让所有物品都被标记。 可以发现，这个问题的答案跟以下问题的答案是等价的： 给定一个长度为 $n​$ 的环，环上的每个点有一个权值 $T_i​$ ，要求你从环上选中任意一个点为起点开始，，开始的时间为 $t​$ ，每个时间可以逆时针到下一个点，或者停留不动。对于一个点，它将在 $T_i​$ 时间损坏 ，求一个最小的 $t​$ 使得我们能够在没有点损坏的情况下遍历所有点。 我们算一下每一个点离起点的距离，那么这个时候我们就可以在起点等，等一段时间后再出发，这样子我们转一圈就够了，这个方案显然是最优的。 我们断环为链，枚举起点 $s$ ，对于一个点 $i$ ，$s$ 到达 $i$ 的耗时显然是 $(i-s)$ ，那么我们如果想要等一段时间出发后正好标记该点，这一段等待的时间当然就是 $T_i-(i-s)$ 。我们对所有的点 $i$ 的 $T_i-(i-s)$ 取 $max$ ，最后的结果就是我们应该在 $s$ 等的时间。 那么很显然我们的答案为： Ans=min_{s \in [1,n]}\{ max_{i \in [s,s+n-1]}[T_i-(i-s)] \}+n-1$min_{s \in [1,n]}\{ max_{i \in [s,s+n-1]}[T_i-(i-s)] \}​$ 这显然是在选择一个最优的起点使得等待时间最小，$n-1​$ 就是等待完后转一圈的时间。 这个时候暴力枚举就可以得到 $30$ 分。 不过我们继续： Ans=min_{s \in [1,n]}\{ max_{i \in [s,s+n-1]}[T_i-i+s] \}+n-1我们设 $A_i$ 为 $T_i-i$ 。 Ans=min_{s \in [1,n]}\{ max_{i \in [s,s+n-1]}[A_i+s] \}+n-1假设现在有一对 $A_i,A_{i+n}$ ，我们可以发现 $A_{i+1}$ 是必然比 $A_i$ 小的，也就是说 $A_{s+n}$ 到 $A_{2n}$ 这一段数就算算进来也造不成影响。 也就是说原式跟这个式子是等价的： Ans=min_{s \in [1,n]}\{ max_{i \in [s,2n]}[A_i+s] \}+n-1发现 $max$ 里面 $s$ 并没有什么卵用，直接提出来。 Ans=min_{s \in [1,n]}\{ max_{i \in [s,2n]}A_i +s\}+n-1​这个的话……因为 $A_i$ 的值跟 $s$ 没有关系……所以……所以我们可以预处理一个 $ST$ 表……嗯……然后枚举 $s$ ……结果我们是 $O(n)$ 搞定？？？ 哦哦哦作者脑抽了，这题是待修改的。 不过没关系，我们还有出路。 现在考虑用线段树来维护，假设结点 $x$ 代表的区间为 $l,r$ ，维护一个 $val[x]$ 表示区间 $[l,r]$ 中 $A_i$ 的最大值，这个是线段树基本操作不再赘述，然后再维护一个 $ans[x]$ 表示区间 $min_{s \in [l,mid]}\{ max_{i \in [s,r]} \}$ 。$1$ 号结点的区间为 $1,2n$ ，我们的答案就是 $ans[1]$ 。 那么怎么上传 $ans$ 呢。 我们对于 $[mid,r]$ 区间的最大值 $A_x$ ，这个 $A_x$ 显然可以 $O(1)$ 求出，然后再找到一个 $A_y$ ，表示当 $s$ 为 $y$ 的时候，整个 $[s,r]$ 的 $A_i$ 的最大值为 $A_x$ 。在寻找 $y$ 的时候顺便更新一下 $s\in [l,y-1]$ 的区间的答案就好。 当 $s\in [y,r]​$ 的时候答案明显为 $A_x+s​$ ，要满足最小嘛。 有关这一部分的代码实现： 123456inline void calc(int k,int l,int r,int Ax)&#123; if(l==r)return l+max(val[k],Ax); int mid=(l+r)&gt;&gt;1; else if(val[k&lt;&lt;1|1]&gt;=Ax)return min(calc(k&lt;&lt;1|1,mid+1,r,Ax),ans[k&lt;&lt;1]); else return min(calc(k&lt;&lt;1,l,mid,Ax),(mid+1)+Ax);&#125; 我们来剖析一下代码。 1inline void calc(int k,int l,int r,int Ax)&#123; 这一句表示当前的结点为 $k$ ，$k$ 代表的区间为 $l,r$ ，$Ax$ 为上文中的 $A_x$ 。 1if(l==r)return l+max(val[k],Ax); 这个显然就是找到了 $y$ ，这个时候答案为 $A_x+s$ ，上文也讲了，这里的 $s$ 就是 $y$ 的位置，$A_x$ 已经在函数中了直接调用就好。但是为什么要取 $max$ 呢？因为怕 $A_y$ 是大于 $A_x$ 的! ，所以加个 $max$ 就好。 1else if(val[k&lt;&lt;1|1]&gt;=Ax)return min(calc(k&lt;&lt;1|1,mid+1,r,Ax),ans[k&lt;&lt;1]); 这个就是当前结点的右区间有比 $A_x$ 大的数，那么这个时候 $y$ 就不可能到左区间去了，不然的话 $[y,r]$ 中 $max\{A_i\}$ 就不是 $A_x$ 了，所以我们往右子树走。这个时候可以发现 $s$ 属于左区间的时候的答案为 $ans[k&lt;&lt;1]$ ，顺带更新一下。 1else return min(calc(k&lt;&lt;1,l,mid,Ax),(mid+1)+Ax); 这个时候 $y$ 就是在左区间了，那么我们往左区间走，右区间的答案呢？右区间为 $[mid,r]$ ，显然这一段的最大值肯定都为 $A_x$ ——包括 $mid+1$ ，所以不要跟 $mid+1$ 取一下 $max$ 了——尽管第一句是与 $A_y$ 取了 $max$ 的。 这个时候因为要 $s$ 尽量的小，所以就是右区间的左端点——$mid+1$ 了。 这个时候 $pushup$ 就应该这么写： 12345inline void pushup(int x,int l,int r)&#123; val[x]=max(val[x&lt;&lt;1],val[x&lt;&lt;1|1]); int mid=(l+r)&gt;&gt;1; ans[x]=calc(x&lt;&lt;1,l,mid,val[x&lt;&lt;1|1]);&#125; Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define min(x,y) ((x)&lt;(y)?(x):(y))#define max(x,y) ((x)&gt;(y)?(x):(y))typedef long long ll;const int N=4e5+2;const int inf=1e9+9;int n,m,p,lastans,a[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct Seg_Tree&#123; #define mid ((l+r)&gt;&gt;1) int ans[N&lt;&lt;2],val[N&lt;&lt;2]; int calc(int x,int l,int r,int Mx)&#123; if(l==r)return l+max(val[x],Mx); if(val[x&lt;&lt;1|1]&gt;=Mx)return min(calc(x&lt;&lt;1|1,mid+1,r,Mx),ans[x]); else return min(calc(x&lt;&lt;1,l,mid,Mx),mid+1+Mx); &#125; inline void pushup(int x,int l,int r)&#123; val[x]=max(val[x&lt;&lt;1],val[x&lt;&lt;1|1]); ans[x]=calc(x&lt;&lt;1,l,mid,val[x&lt;&lt;1|1]); &#125; inline void build(int x,int l,int r)&#123; if(l==r)&#123;val[x]=a[l],ans[x]=a[l]+l;return;&#125; build(x&lt;&lt;1,l,mid),build(x&lt;&lt;1|1,mid+1,r); pushup(x,l,r);return; &#125; inline void updata(int x,int l,int r,int pos)&#123; if(l==r)&#123;val[x]=a[l],ans[x]=a[l]+l;return;&#125; if(pos&lt;=mid)updata(x&lt;&lt;1,l,mid,pos); else if(pos&gt;mid)updata(x&lt;&lt;1|1,mid+1,r,pos); pushup(x,l,r); &#125;&#125;T;int main()&#123; IN(n),IN(m),IN(p); for(int i=1;i&lt;=n;++i)IN(a[i]),a[i+n]=a[i]; for(int i=1;i&lt;=(n&lt;&lt;1);++i)a[i]-=i; T.build(1,1,(n&lt;&lt;1)); lastans=T.ans[1]+n-1,printf("%d\n",lastans); for(int i=1;i&lt;=m;++i)&#123; int x,y;IN(x),IN(y); if(p)x^=lastans,y^=lastans; a[x]=y-x,a[x+n]=y-x-n; T.updata(1,1,(n&lt;&lt;1),x),T.updata(1,1,(n&lt;&lt;1),x+n); printf("%d\n",lastans=T.ans[1]+n-1); &#125; return 0;&#125; 但是这份代码是 TLE 的。 这玩意坑了我好久，你知道为什么 TLE 吗？ 就是这个鬼东西！： 12#define min(x,y) ((x)&lt;(y)?(x):(y))#define max(x,y) ((x)&gt;(y)?(x):(y)) 这里的 $x$ 和 $y$ 是调用了两次的，然后我们发现 $calc$ 函数…… 12345int calc(int x,int l,int r,int Mx)&#123; if(l==r)return l+max(val[x],Mx); if(val[x&lt;&lt;1|1]&gt;=Mx)return min(calc(x&lt;&lt;1|1,mid+1,r,Mx),ans[x]); else return min(calc(x&lt;&lt;1,l,mid,Mx),mid+1+Mx);&#125; $min$ 里面有 $calc$ 函数………..然后 $calc$ 函数调用了两次……….然后………..爆炸！ 所以 $Qiuly$ 提醒您：代码千万条，时间第一条，$define$ 不规范，$OIer$ 两行泪 。 还是跟着 $std$ 走好嘿嘿嘿，$using\ namespace\ std$ 万岁！ 最终 $AC$ 的代码。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N=4e5+2;const int inf=1e9+9;int n,m,p,lastans,a[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct Seg_Tree&#123; #define mid ((l+r)&gt;&gt;1) int ans[N&lt;&lt;2],val[N&lt;&lt;2]; int calc(int x,int l,int r,int Mx)&#123; if(l==r)return l+max(val[x],Mx); if(val[x&lt;&lt;1|1]&gt;=Mx)return min(calc(x&lt;&lt;1|1,mid+1,r,Mx),ans[x]); else return min(calc(x&lt;&lt;1,l,mid,Mx),mid+1+Mx); &#125; inline void pushup(int x,int l,int r)&#123; val[x]=max(val[x&lt;&lt;1],val[x&lt;&lt;1|1]); ans[x]=calc(x&lt;&lt;1,l,mid,val[x&lt;&lt;1|1]); &#125; inline void build(int x,int l,int r)&#123; if(l==r)&#123;val[x]=a[l],ans[x]=a[l]+l;return;&#125; build(x&lt;&lt;1,l,mid),build(x&lt;&lt;1|1,mid+1,r); pushup(x,l,r);return; &#125; inline void updata(int x,int l,int r,int pos)&#123; if(l==r)&#123;val[x]=a[l],ans[x]=a[l]+l;return;&#125; if(pos&lt;=mid)updata(x&lt;&lt;1,l,mid,pos); else if(pos&gt;mid)updata(x&lt;&lt;1|1,mid+1,r,pos); pushup(x,l,r); &#125;&#125;T;int main()&#123; IN(n),IN(m),IN(p); for(int i=1;i&lt;=n;++i)IN(a[i]),a[i+n]=a[i]; for(int i=1;i&lt;=(n&lt;&lt;1);++i)a[i]-=i; T.build(1,1,(n&lt;&lt;1)); lastans=T.ans[1]+n-1,printf("%d\n",lastans); for(int i=1;i&lt;=m;++i)&#123; int x,y;IN(x),IN(y); if(p)x^=lastans,y^=lastans; a[x]=y-x,a[x+n]=y-x-n; T.updata(1,1,(n&lt;&lt;1),x),T.updata(1,1,(n&lt;&lt;1),x+n); printf("%d\n",lastans=T.ans[1]+n-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 历史研究 回滚莫队 luoguAT1219]]></title>
    <url>%2F2019%2F03%2F20%2F%5B%E9%A2%98%E8%A7%A3%5DluoguAT1219%2F</url>
    <content type="text"><![CDATA[回滚莫队板子题，在此不再赘述。 关于回滚莫队的文章戳这 $QwQ$ :[算法]浅谈4种莫队及例题 可以算作一个回滚莫队的板子来参考。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;const int N=1e5+2;const int inf=1e9+9;int n,m,block,a[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(flag)x=-x; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace MO&#123; ll ans,Ans[N]; int v[N],b[N],blo[N],cnt[N],hep[N]; struct Query&#123;int l,r,id;&#125;q[N]; bool cmp(Query x,Query y)&#123; return blo[x.l]==blo[y.l]?x.r&lt;y.r:blo[x.l]&lt;blo[y.l]; &#125; inline void roll(int pos)&#123;--cnt[b[pos]];&#125; inline void add(int pos)&#123; ++cnt[b[pos]]; ans=max(ans,1ll*a[pos]*cnt[b[pos]]); &#125; inline ll query(int l,int r)&#123; ll res=0; for(int i=l;i&lt;=r;++i)hep[b[i]]=0; for(int i=l;i&lt;=r;++i)&#123; ++hep[b[i]]; res=max(res,1ll*a[i]*hep[b[i]]); &#125;return res; &#125; inline int solve(int num,int bloid)&#123; int L=min(block*bloid,n); int i=num,l=L+1,r=l-1; for(int k=1;k&lt;=n;++k)cnt[k]=0; ans=0; for(;blo[q[i].l]==bloid;++i)&#123; if(blo[q[i].l]==blo[q[i].r])&#123; Ans[q[i].id]=query(q[i].l,q[i].r); continue; &#125; while(r&lt;q[i].r)add(++r); ll tmp=ans; while(l&gt;q[i].l)add(--l); Ans[q[i].id]=ans; while(l&lt;L+1)roll(l++); ans=tmp; &#125;return i; &#125; inline void Main()&#123; sort(v+1,v+1+n); int tot=unique(v+1,v+1+n)-(v+1); for(int i=1;i&lt;=n;++i) b[i]=lower_bound(v+1,v+1+tot,a[i])-v; sort(q+1,q+1+m,cmp); int num=1; for(int i=1;i&lt;=blo[n];++i)num=solve(num,i); for(int i=1;i&lt;=m;++i)printf("%lld\n",Ans[i]); return; &#125;&#125;using namespace MO;int main()&#123; IN(n),IN(m);block=sqrt(n); for(int i=1;i&lt;=n;++i)IN(a[i]),v[i]=a[i]; for(int i=1;i&lt;=n;++i)blo[i]=(i-1)/block+1; for(int i=1;i&lt;=m;++i)&#123; IN(q[i].l),IN(q[i].r); q[i].id=i; &#125;return Main(),0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [AH2017/HNOI2017]单旋 线段树 luoguP3721/bzoj4825]]></title>
    <url>%2F2019%2F03%2F15%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj4825%2F</url>
    <content type="text"><![CDATA[$Spaly​$ 是不会用的，这辈子也不会用的。 这道题当然可以用 $Splay​$ 做，然而不会。 于是考虑怎么来做这道题，我们先来观察一下所有的操作： 1.插入操作：很普通的插入操作……2.单旋最小值： 结点的深度的变化如下： 需要旋转的结点 $(4)$ ：变为 $root$ ，深度变为 $1$ 。 需要旋转的结点的子树 $(7)$ ：深度不变。 其他结点 $(1,2,3,5,6)$ ：深度加 $1$ 。 3.单旋最大值：变化和上面的 “单旋最小值” 一样。 4.5 删除最大/最小值先将需要删除的 最大/最小值 转到树根，这个时候我们将树根删掉，可以发现整棵树的深度全部都减了 $1$ ，一起计算上旋转造成的深度的影响会得到： 删掉的结点的子树 $(7)$ ：深度减 $1$ 其他节点 $(1,2,3,5,6)$ ：深度不变 发现深度的变化也不是很大，于是我们考虑用线段树维护每一个节点的深度。线段树不易寻找最大/最小值，这个地方我们用 $set$ 来辅助即可，操作的时候更新一下 $set$ 中树的形态就好。 线段树的要求很低，一个很普通的兹磁区间修改的线段树即可： 123456789101112131415161718192021222324252627struct Segment_Tree&#123; #define mid ((l+r)&gt;&gt;1) int dep[N&lt;&lt;2]; inline void pushdown(int x,int l,int r)&#123; if(dep[x])&#123; dep[x&lt;&lt;1]+=dep[x],dep[x&lt;&lt;1|1]+=dep[x],dep[x]=0; &#125;return; &#125; void add(int x,int l,int r,int L,int R,int res)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;dep[x]+=res;return;&#125; pushdown(x,l,r); if(L&lt;=mid)add(x&lt;&lt;1,l,mid,L,R,res); if(R&gt;mid)add(x&lt;&lt;1|1,mid+1,r,L,R,res); &#125; void change(int x,int l,int r,int pos,int res)&#123; if(l==r)&#123;dep[x]=res;return;&#125; pushdown(x,l,r); if(pos&lt;=mid)change(x&lt;&lt;1,l,mid,pos,res); else change(x&lt;&lt;1|1,mid+1,r,pos,res); &#125; int query(int x,int l,int r,int pos)&#123; if(l==r)return dep[x]; pushdown(x,l,r); if(pos&lt;=mid)return query(x&lt;&lt;1,l,mid,pos); else return query(x&lt;&lt;1|1,mid+1,r,pos); &#125;&#125;T; 1.插入操作的实现：12345678910111213141516std::set&lt;int&gt; Spaly;inline int Insert(int x)&#123; std::set&lt;int&gt;::iterator it=Spaly.insert(x).first; if(!root)&#123;//还没有树根 T.change(1,1,tmp,x,1);//修改x的深度 root=x;return 1;//深度为1 &#125; if(it!=Spaly.begin())&#123;//不是最小值，所以可能成为其他结点的右儿子 if(!ch[*--it][1])ch[fa[x]=*it][1]=x;//成为右儿子 *it++;//维持it不变 &#125; if(!fa[x])ch[fa[x]=*++it][0]=x;//成为右儿子失败，于是成为左儿子 int dep_x=T.query(1,1,tmp,fa[x])+1;//x的深度就是它父节点的深度加1 T.change(1,1,tmp,x,dep_x);//在线段树中修改x的深度 return dep_x;//题目要求&#125; 2.单旋最小/最大值的实现：1234567891011121314151617181920inline int Rotate_min()&#123; int x=*Spaly.begin(),ans=T.query(1,1,tmp,x);//获取当前的最小值和需要返回的答案 if(x==root)return 1;//是根就直接返回 if(x+1&lt;fa[x])T.add(1,1,tmp,x+1,fa[x]-1,-1);//x有子树，先给x的子树的深度整体减1 T.add(1,1,tmp,1,tmp,1);//整棵树深度加1，这个时候x的子树深度不变了 ch[fa[x]][0]=ch[x][1],fa[ch[x][1]]=fa[x];//将x的子树接到x的父亲上 ch[x][1]=root,fa[root]=x,root=x;//更新root T.change(1,1,tmp,x,1);//修改x的深度，变为1 return ans;//题目要求&#125;inline int Rotate_max()&#123;//与上面的Rotate_min操作同理 int x=*Spaly.rbegin(),ans=T.query(1,1,tmp,x); if(x==root)return 1; if(x-1&gt;fa[x])T.add(1,1,tmp,fa[x]+1,x-1,-1); T.add(1,1,tmp,1,tmp,1); ch[fa[x]][1]=ch[x][0],fa[ch[x][0]]=fa[x]; ch[x][0]=root,fa[root]=x,root=x; T.change(1,1,tmp,x,1); return ans;&#125; 3.删除最小/最大值的实现：12345678910inline void Delete_min()&#123; printf("%d\n",Rotate_min());//先旋上来，按照题目要求输出 T.add(1,1,tmp,1,tmp,-1);//整棵树的深度发生变化 Spaly.erase(root),root=ch[root][1],fa[root]=0;//更新root&#125;inline void Delete_max()&#123;//与上面的Delete_min操作同理 printf("%d\n",Rotate_max()); T.add(1,1,tmp,1,tmp,-1); Spaly.erase(root),root=ch[root][0],fa[root]=0;&#125; Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;set&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int N=1e5+2;const int inf=1e9+9;int m,tmp,v[N],a[N],op[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct Segment_Tree&#123; #define mid ((l+r)&gt;&gt;1) int dep[N&lt;&lt;2]; inline void pushdown(int x,int l,int r)&#123; if(dep[x])&#123; dep[x&lt;&lt;1]+=dep[x],dep[x&lt;&lt;1|1]+=dep[x],dep[x]=0; &#125;return; &#125; void add(int x,int l,int r,int L,int R,int res)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;dep[x]+=res;return;&#125; pushdown(x,l,r); if(L&lt;=mid)add(x&lt;&lt;1,l,mid,L,R,res); if(R&gt;mid)add(x&lt;&lt;1|1,mid+1,r,L,R,res); &#125; void change(int x,int l,int r,int pos,int res)&#123; if(l==r)&#123;dep[x]=res;return;&#125; pushdown(x,l,r); if(pos&lt;=mid)change(x&lt;&lt;1,l,mid,pos,res); else change(x&lt;&lt;1|1,mid+1,r,pos,res); &#125; int query(int x,int l,int r,int pos)&#123; if(l==r)return dep[x]; pushdown(x,l,r); if(pos&lt;=mid)return query(x&lt;&lt;1,l,mid,pos); else return query(x&lt;&lt;1|1,mid+1,r,pos); &#125;&#125;T;struct Spaly_Tree&#123; std::set&lt;int&gt; Spaly; int root,fa[N],ch[N][2]; inline int Insert(int x)&#123; std::set&lt;int&gt;::iterator it=Spaly.insert(x).first; if(!root)&#123; T.change(1,1,tmp,x,1); root=x;return 1; &#125; if(it!=Spaly.begin())&#123; if(!ch[*--it][1])ch[fa[x]=*it][1]=x; *it++; &#125; if(!fa[x])ch[fa[x]=*++it][0]=x; int dep_x=T.query(1,1,tmp,fa[x])+1; T.change(1,1,tmp,x,dep_x); return dep_x; &#125; inline int Rotate_min()&#123; int x=*Spaly.begin(),ans=T.query(1,1,tmp,x); if(x==root)return 1; if(x+1&lt;fa[x])T.add(1,1,tmp,x+1,fa[x]-1,-1); T.add(1,1,tmp,1,tmp,1); ch[fa[x]][0]=ch[x][1],fa[ch[x][1]]=fa[x]; ch[x][1]=root,fa[root]=x,root=x; T.change(1,1,tmp,x,1); return ans; &#125; inline int Rotate_max()&#123; int x=*Spaly.rbegin(),ans=T.query(1,1,tmp,x); if(x==root)return 1; if(x-1&gt;fa[x])T.add(1,1,tmp,fa[x]+1,x-1,-1); T.add(1,1,tmp,1,tmp,1); ch[fa[x]][1]=ch[x][0],fa[ch[x][0]]=fa[x]; ch[x][0]=root,fa[root]=x,root=x; T.change(1,1,tmp,x,1); return ans; &#125; inline void Delete_min()&#123; printf("%d\n",Rotate_min()); T.add(1,1,tmp,1,tmp,-1); Spaly.erase(root),root=ch[root][1],fa[root]=0; &#125; inline void Delete_max()&#123; printf("%d\n",Rotate_max()); T.add(1,1,tmp,1,tmp,-1); Spaly.erase(root),root=ch[root][0],fa[root]=0; &#125;&#125;S;int main()&#123; IN(m); for(int i=1,x;i&lt;=m;++i)&#123; IN(op[i]); if(op[i]==1)IN(x),v[++tmp]=a[i]=x; &#125; std::sort(v+1,v+1+tmp); for(int i=1;i&lt;=m;++i) if(op[i]==1)a[i]=std::lower_bound(v+1,v+1+tmp,a[i])-v; for(int i=1;i&lt;=m;++i)&#123; if(op[i]==1)printf("%d\n",S.Insert(a[i])); if(op[i]==2)printf("%d\n",S.Rotate_min()); if(op[i]==3)printf("%d\n",S.Rotate_max()); if(op[i]==4)S.Delete_min(); if(op[i]==5)S.Delete_max(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [AH2017/HNOI2017]礼物 FFT luoguP3723/bzoj4827]]></title>
    <url>%2F2019%2F03%2F15%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj4827%2F</url>
    <content type="text"><![CDATA[题目背景有些……………通过题目我们可以知道最终我们要求的式子就是： \sum_{i=1}^{n}(a_i+c-b_i)^2于是我们将式子拆开： (a_i+c-b_i)^2=a_i^2+b_i^2+c^2+2a_ic-2b_ic-2a_ib_i \sum_{i=1}^{n}(a_i+c-b_i)^2=\sum_{i=1}^{n}a_i^2+\sum_{i=1}^{n}b_i^2+nc^2+2c(\sum_{i=1}^{n}a_i-\sum_{i=1}^{n}b_i)-2\sum_{i=1}^{n}a_ib_i​前面的这些都很容易求出，但是最后的 $\sum_{i=1}^{n}a_ib_i​$ 无法很快算出，我们算答案的时候枚举 $c​$ 以及手环旋转了多少，这个时候如果在里面直接大力计算 $\sum_{i=1}^{n}a_ib_i​$ 可以拿到 $30​$ 分。如果将这个式子在之前拿出来预处理一下，将会拿到 $70​$ 分。 这个时候将 $a_i$ 反向，式子变为：$\sum_{i=1}^{n}a_{n-i+1}b_i$ ，可以发现这是一个卷积，是可以用 $FFT$ 跑的，众所周知 $FFT$ 的复杂度是 $O(nlogn)$ ，是能跑过的。 具体实现的时候我们需要将 $a​$ 拉成两倍长，或者说是断环为链？至于为什么的话，是因为题目要求了这个数列是可以旋转的。然后按照上式将 $b​$ 反向就好了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define PI 3.1415926535898#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))typedef long long ll;const int N=5e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; struct complex&#123;complex(double a=0,double b=0)&#123;x=a,y=b;&#125;double x,y;&#125;;complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125;complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125;complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;int n,m,limit=1,a[N],b[N],filp[N];ll a1=0,a2=0,b1=0,b2=0;complex A[N],B[N];inline void FFT(complex *f,short inv)&#123; for(int i=0;i&lt;limit;++i) if(i&lt;filp[i])&#123;complex tmp=f[i];f[i]=f[filp[i]];f[filp[i]]=tmp;&#125; for(int p=2;p&lt;=limit;p&lt;&lt;=1)&#123; int len=p/2; complex tmp=complex(cos(PI/len),inv*sin(PI/len)); for(int k=0;k&lt;limit;k+=p)&#123; complex buf=complex(1,0); for(int l=k;l&lt;k+len;++l)&#123; complex t=buf*f[len+l]; f[len+l]=f[l]-t,f[l]=f[l]+t,buf=buf*tmp; &#125; &#125; &#125;return;&#125;int main()&#123; IN(n),IN(m); for(int i=1;i&lt;=n;++i) IN(a[i]),a1+=a[i]*a[i],a2+=a[i]; for(int i=1;i&lt;=n;++i) IN(b[i]),b1+=b[i]*b[i],b2+=b[i]; for(int i=1;i&lt;=n;++i) A[i].x=A[i+n].x=a[i],B[i]=b[n-i+1]; while(limit&lt;=(3*n))limit&lt;&lt;=1; for(int i=0;i&lt;limit;++i)filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?limit&gt;&gt;1:0); FFT(A,1),FFT(B,1); for(int i=0;i&lt;=limit;++i)A[i]=A[i]*B[i]; FFT(A,-1); for(int i=0;i&lt;=limit;++i)A[i].x=(ll)(A[i].x/limit+0.5); ll ans=inf; for(int i=1;i&lt;=n;++i) for(int j=-m;j&lt;=m;++j) ans=min(ans,a1+b1+1ll*j*j*n+2ll*j*(a2-b2)-2ll*(ll)A[i+n].x); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [AH2017/HNOI2017]影魔 线段树 luoguP3722/bzoj4826]]></title>
    <url>%2F2019%2F03%2F15%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj4826%2F</url>
    <content type="text"><![CDATA[真心巧妙，不看题解准做不出(之前题解都看不懂QwQ) 这道题貌似有许多的做法，都不费，主席树的话不知道怎么搞，于是建了 $3$ 棵线段树，实测是不会炸的。 30分做法： 小学生都能轻易想出来的解法，对于一个询问的区间，暴力枚举其子区间，然后按照题面的要求算贡献，区间最大值可以用 $ST$ 表预处理，复杂度爆炸，但是仍然可以拿到 $30$ 暴力分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e5+2;const int LogN=23;const int inf=1e9+9; int v[N],n,m,p1,p2;struct ST&#123; int logs[N],f[N][LogN+2]; inline void make()&#123; logs[0]=-1; for(int i=1;i&lt;=n;++i) f[i][0]=v[i],logs[i]=logs[i&gt;&gt;1]+1; for(int j=1;j&lt;=LogN;++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; inline int query(int x,int y)&#123; int ans=logs[y-x+1]; return max(f[x][ans],f[y-(1&lt;&lt;ans)+1][ans]); &#125;&#125;T;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; int main()&#123; IN(n),IN(m),IN(p1),IN(p2); for(int i=1;i&lt;=n;++i)IN(v[i]); T.make(); for(int i=1;i&lt;=m;++i)&#123; int l,r,ans=0; IN(l),IN(r); for(int a=l;a&lt;=r;++a) for(int b=a+2;b&lt;=r;++b)&#123; int sum=T.query(a+1,b-1); if(v[a]&gt;=sum&amp;&amp;v[b]&gt;=sum)ans+=p1; if((v[a]&lt;sum&amp;&amp;sum&lt;v[b])||(v[b]&lt;sum&amp;&amp;sum&lt;v[a]))ans+=p2; &#125; printf("%d\n",ans+(r-l)*p1); &#125; return 0;&#125; 100分做法 对于一个点 $i$ ，我们设 $lmax[i]$ 为 $i$ 向左走遇到的第一个大于自己的数(没有的话为 $0$) ，同样的，设 $rmax[i]$ 为 $i$ 向右走遇到的第一个大于自己的数(没有的话为 $n+1$) 。这两个数组比较容易求出，搞个单调栈求就好。 12345678910top=0,stack[0]=0;for(int i=1;i&lt;=n;++i)&#123; while(top&amp;&amp;k[stack[top]]&lt;k[i])--top; lmax[i]=stack[top],stack[++top]=i;&#125;top=0,stack[0]=n+1;for(int i=n;i&gt;=1;--i)&#123; while(top&amp;&amp;k[stack[top]]&lt;k[i])--top; rmax[i]=stack[top],stack[++top]=i;&#125; 然后可以发现，如果枚举点 $i$ 的话，有了上面的两个数组后有关 $i$ 的贡献就好求些了，首先我们可以知道 $i$ 是区间 $[lmax[i]+1,rmax[i]-1]$ 的最大值，那么对于每种贡献： 如果 $lmax[i]$ 和 $rmax[i]$ 都在当前询问区间内，那么就可以做出 $p_1$ 的贡献。 如果 $lmax[i]$ 在当前询问区间中，那么显然 $lmax[i]$ 为区间 $[lmax[i],rmax[i]-1]$ 的最大值，这个时候右端点如果在 $[i+1,rmax[i]-1]$ 区间中，那么可以保证右端点不是 $[lmax[i],rmax[i]-1]$ 的次大值，这个时候可以产生多个 $p_2$ 的贡献。 如果 $rmax[i]$ 在当前询问区间中，那么显然当左端点为 $[lmax[i]+1,i-1]$ 的时候该子区间均能产生 $p_2$ 的贡献，原因跟上面一样的。 但是这样的话复杂度依旧是 $O(n^2)$ 的，所以还要优化。 考虑用线段树维护，我们离线处理询问，把每个询问按左端点排个序，然后反着扫一遍，如果遇到了一个点 $x$ ，它是 某个点/某些点 的 $lmax$ ，假设 $x$ 是 $i$ 的 $lmax$ ，那么我们依次在第一颗线段树中实现区间加：将 $[i+1,rmax[i]-1]$ 区间正题加上 $p_2$ ，因为当前的左端点为 $x$ ，这个时候我们将要计算的是所有的左端点为 $x$ 的区间对答案的贡献，因为对于 $i$ 来说右端点的范围就是 $[i+1,rmax[i]-1]$，这些区间均可以做出贡献，于是都在线段树中加上。当然在做贡献的之前不要忘记判断 $i+1&lt;rmax[i]$ ，如果不满足的话就没有右端点了…… 那么接下来讨论怎么计算 $p_1$ 的贡献，对于询问区间来说，现在我们确定了左端点为 $x$ ，这个时候当右端点落在 $[rmax[i],n+1]$ 的时候询问区间都可以算上 $[lmax[i],rmax[i]]$ 区间的贡献，也就是 $p_1$ 的贡献，于是我们可以在另一个线段树中将 $[rmax[i],n+1]$ 全都加上 $p_1$ 即可。 按照上面的方法，再正着扫一遍计算 $rmax$ 的情况就好，当然反着扫的时候就不要算 $p_1$ 的贡献了，不然就会重复了，想想就可以明白。最后就是一定要开 $longlong$ 。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define swap(x,y) ((x)^=(y)^=(x)^=(y))typedef long long ll;const int N=2e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; struct Seg_Tree&#123;//线段树板子 #define mid ((l+r)&gt;&gt;1) ll v[N&lt;&lt;2];int tag[N&lt;&lt;2]; inline void pushdown(int x,int l,int r)&#123; if(tag[x])&#123; tag[x&lt;&lt;1]+=tag[x],tag[x&lt;&lt;1|1]+=tag[x]; v[x&lt;&lt;1]+=tag[x]*(mid-l+1),v[x&lt;&lt;1|1]+=tag[x]*(r-mid); &#125;tag[x]=0;return; &#125; inline void updata(int x,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;v[x]+=r-l+1,++tag[x];return;&#125; pushdown(x,l,r); if(L&lt;=mid)updata(x&lt;&lt;1,l,mid,L,R); if(R&gt;mid)updata(x&lt;&lt;1|1,mid+1,r,L,R); v[x]=v[x&lt;&lt;1]+v[x&lt;&lt;1|1]; &#125; inline ll query(int x,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return v[x]; pushdown(x,l,r); ll ans=0; if(L&lt;=mid)ans+=query(x&lt;&lt;1,l,mid,L,R); if(R&gt;mid)ans+=query(x&lt;&lt;1|1,mid+1,r,L,R); return ans; &#125;&#125;st1,st2,st3;//三棵线段树[滑稽]int n,m,k[N];ll p1,p2;struct Query&#123;int l,r;ll ans;&#125;q[N];int lmax[N],rmax[N],stack[N],top;std::vector&lt;int&gt; li[N],ri[N],lq[N],rq[N];inline void _Pre_lmax_rmax()&#123; top=0,stack[0]=0; for(int i=1;i&lt;=n;++i)&#123; while(top&amp;&amp;k[stack[top]]&lt;k[i])--top; lmax[i]=stack[top],li[stack[top]].push_back(i);//统计上文中的x stack[++top]=i; &#125; top=0,stack[0]=n+1; for(int i=n;i&gt;=1;--i)&#123; while(top&amp;&amp;k[stack[top]]&lt;k[i])--top; rmax[i]=stack[top],ri[stack[top]].push_back(i); stack[++top]=i; &#125;&#125;int main()&#123; //freopen("code.in","r",stdin); IN(n),IN(m),IN(p1),IN(p2); for(int i=1;i&lt;=n;++i)IN(k[i]); _Pre_lmax_rmax(); for(int i=1;i&lt;=m;++i)&#123; IN(q[i].l),lq[q[i].l].push_back(i); IN(q[i].r),rq[q[i].r].push_back(i); &#125; for(int i=n;i&gt;=1;--i)&#123; for(int j=0;j&lt;li[i].size();++j)&#123;//计算左端点在i的区间的贡献 if(li[i][j]+1&lt;rmax[li[i][j]]) st1.updata(1,0,n+1,li[i][j]+1,rmax[li[i][j]]-1); st3.updata(1,0,n+1,rmax[li[i][j]],n+1); &#125; for(int j=0;j&lt;lq[i].size();++j)&#123;//统计左端点在i的询问区间的答案 q[lq[i][j]].ans+=st1.query(1,0,n+1,i,q[lq[i][j]].r)*p2; q[lq[i][j]].ans+=st3.query(1,0,n+1,q[lq[i][j]].r,q[lq[i][j]].r)*p1; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=0;j&lt;ri[i].size();++j) if(ri[i][j]-1&gt;lmax[ri[i][j]]) st2.updata(1,0,n+1,lmax[ri[i][j]]+1,ri[i][j]-1); for(int j=0;j&lt;rq[i].size();++j) q[rq[i][j]].ans+=st2.query(1,0,n+1,q[rq[i][j]].l,i)*p2; &#125; for(int i=1;i&lt;=m;++i)//输出答案，不要忘了漏统计的长度为2的区间 printf("%lld\n",q[i].ans+1ll*(q[i].r-q[i].l)*p1); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2016]序列 莫队+ST表 luoguP3246]]></title>
    <url>%2F2019%2F03%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3246%2F</url>
    <content type="text"><![CDATA[一道莫队………. 最主要的就是怎么从当前区间推到相邻区间。 假设当前区间为 $[l,r]$ ，目标区间为 $[l,r+1]$ 。那么很显然这样子就会增加： [l,r+1],[l+1,r+1],[l+2,r+1]\cdots \cdots这些区间，现在我们要做的就是尽快的算出这些区间的答案。 假设 $p$ 为区间 $[l,r+1]$ 的最小值的位置，那么在上面的区间中，$[l,r+1] \cdots [p,r+1]$ 这些区间显然都包含了 $p$ ，也就是说这些区间的最小值都为 $p$ ，那么这一段区间的贡献显然为 $a[p]\cdot (p-l+1)$ ，其中 $a[p]$ 为 $p$ 位置上的权值。 很显然我们可以预处理一个 $ST$ 表，通过 $ST$ 表上面的 $p$ 就可以 $O(1)$ 求出。 然后接下来考虑剩下的 $[p+1,r+1]\cdots [r+1,r+1]$ 这些区间。 我们设 $f[i][j]$ 表示右端点为 $j$ ，左端点的位置在 $[i,j]$ 范围内的所有区间所造成的贡献。 我们可以用单调栈预处理出位置 $i$ 的 $lmin$ 和 $rmin$ ，$lmin[i]$ 表示 $i$ 往左走遇到的第一个比 $i$ 小的数的位置，$rmin$ 同理。 那么我们很轻易的可以得到： f[i][j]=f[i][lmin_j-1]+a[lmin_j]\cdot (j-lmin_j)发现 $i$ 是没有影响的，于是我们将 $i$ 丢掉。 f[j]=f[lmin_j-1]+a[lmin_j]\cdot (j-lmin_j)这个式子 $DP$ 与处理一下就好了。 那么最后我们从 $[l,r]$ 移向 $[l,r+1]$ 产生的贡献为： a[p]\cdot (p-l+1) + f[r+1]-f[p]至于为什么要减去 $f[p]$ ，差不多是容斥的道理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))typedef long long ll;const int N=1e5+2;const int inf=1e9+9;int n,m,block,a[N];struct MO&#123;int l,r,id;&#125;q[N];int top,stack[N],lmin[N],rmin[N];ll res,Ans[N],fl[N],fr[N];bool cmp(MO a,MO b)&#123; return a.l/block==b.l/block?a.l/block&amp;1?a.r&lt;b.r:a.r&gt;b.r:a.l/block&lt;b.l/block;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; namespace ST&#123; const int LogN=23; int logs[N],f[N][LogN+2]; inline void Make()&#123; logs[0]=-1; for(int i=1;i&lt;=n;++i) f[i][0]=i,logs[i]=logs[i&gt;&gt;1]+1; for(int j=1;j&lt;=logs[n];++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) f[i][j]=a[f[i][j-1]]&lt;a[f[i+(1&lt;&lt;(j-1))][j-1]]?f[i][j-1]:f[i+(1&lt;&lt;(j-1))][j-1]; &#125; inline ll query(int x,int y)&#123; int ans=logs[y-x+1]; return a[f[x][ans]]&lt;a[f[y-(1&lt;&lt;ans)+1][ans]]?f[x][ans]:f[y-(1&lt;&lt;ans)+1][ans]; &#125;&#125;inline void __Pre_lmin_rmin()&#123; for(int i=1;i&lt;=n;++i)&#123; while(top&amp;&amp;a[stack[top]]&gt;a[i]) rmin[stack[top--]]=i; lmin[i]=stack[top],stack[++top]=i; &#125;while(top)lmin[stack[top]]=stack[top-1],rmin[stack[top--]]=n+1;&#125;inline ll left(int l,int r)&#123; int p=ST::query(l-1,r); return (ll)a[p]*(r-p+1)+fl[l-1]-fl[p];&#125;inline ll right(int l,int r)&#123; int p=ST::query(l,r+1); return (ll)a[p]*(p-l+1)+fr[r+1]-fr[p];&#125; int main()&#123; IN(n),IN(m);block=sqrt(n); a[0]=a[n+1]=inf; for(int i=1;i&lt;=n;++i)IN(a[i]); __Pre_lmin_rmin(); ST::Make(); for(int i=1;i&lt;=n;++i)fr[i]=(ll)a[i]*(i-lmin[i])+fr[lmin[i]]; for(int i=n;i&gt;=1;--i)fl[i]=(ll)a[i]*(rmin[i]-i)+fl[rmin[i]]; for(int i=1;i&lt;=m;++i) IN(q[i].l),IN(q[i].r),q[i].id=i; std::sort(q+1,q+1+m,cmp); int L=q[1].l,R=L-1;res=0; for(int i=1;i&lt;=m;++i)&#123; int x=q[i].l,y=q[i].r; while(L&gt;x)res+=left(L,R),L--; while(R&lt;y)res+=right(L,R),R++; while(L&lt;x)res-=left(L+1,R),++L; while(R&gt;y)res-=right(L,R-1),--R; Ans[q[i].id]=res; &#125; for(int i=1;i&lt;=m;++i) printf("%lld\n",Ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>ST表</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 货车运输 最大生成树+倍增Lca luoguP1967]]></title>
    <url>%2F2019%2F03%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1967%2F</url>
    <content type="text"><![CDATA[题目大意就是，有多组询问，每组询问包含两个整数 $x,y​$ ，求出 $x​$ 到 $y​$ 的一条路径，满足这条路径在所有的 $x​$ 到 $y​$ 的路径中，边权最小的边权值最大。 这个很显然我们可以先求出图的最大生成树，那么 $x$ 到 $y$ 的目标路径肯定在最大生成树上，也只能在最大生成树上。 那么我们需要在最大生成树上找到这条路径，最大生成树是一棵树，很显然的我们可以想到在这棵树上做 $Lca$ ，那么这样就超级简单了。 我们在求 $lca$ 的时候顺带维护一下 $sum$ 数组，$sum[x][i]$ 表示在最大生成树 $x$ 到 $fa[x][i]$ 这条路径上的所有边的边权最小值。转移的方法也很简单：$sum[x][i]=min(sum[x][i-1],sum[fa[x][i-1]][i-1])$ 。 对于不能到达的情况特判一下就好了。 于是这题就做完了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt; #define ll long long#define A printf("A")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define swap(x,y) ((x)^=(y)^=(x)^=(y))const int N=1e5+2;const int log=30;const int inf=1e9+9;int n,m,q,cnt,f[N];int dep[N],fa[N][log+2],sum[N][log+2];struct Edge&#123;int from,to,val;&#125;G[N&lt;&lt;1];std::vector&lt;int&gt; E[N],V[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;bool cmp(Edge a,Edge b)&#123;return a.val&gt;b.val;&#125;int find(int x)&#123;return f[x]==x?x:f[x]=find(f[x]);&#125;void dfs(int u,int f,int dis)&#123; dep[u]=dep[f]+1, fa[u][0]=f,sum[u][0]=dis; for(int i=1;i&lt;log;++i) fa[u][i]=fa[fa[u][i-1]][i-1], sum[u][i]=min(sum[u][i-1],sum[fa[u][i-1]][i-1]); int size=E[u].size(); for(int i=0;i&lt;size;++i)&#123; int v=E[u][i]; if(v!=f)dfs(v,u,V[u][i]); &#125;return;&#125;inline int solve(int x,int y)&#123; int ans=inf; if(dep[x]&lt;dep[y])swap(x,y); for(int i=log-1;i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) ans=min(ans,sum[x][i]),x=fa[x][i]; if(x==y)return ans; for(int i=log-1;i&gt;=0;--i) if(fa[x][i]!=fa[y][i])&#123; ans=min(ans,min(sum[x][i],sum[y][i])); x=fa[x][i],y=fa[y][i]; &#125; ans=min(ans,min(sum[x][0],sum[y][0])); if(fa[x][0]==0)return -1; else return ans;&#125;int main()&#123; IN(n),IN(m); for(int i=1;i&lt;=n;++i)f[i]=i; for(int i=1;i&lt;=m;++i) IN(G[i].from),IN(G[i].to),IN(G[i].val); std::sort(G+1,G+1+m,cmp); for(int i=1;i&lt;=m;++i)&#123; int fx=find(G[i].from),fy=find(G[i].to); if(fx!=fy)&#123; f[fy]=fx;++cnt; E[G[i].from].push_back(G[i].to),V[G[i].from].push_back(G[i].val); E[G[i].to].push_back(G[i].from),V[G[i].to].push_back(G[i].val); if(cnt==n-1)break; &#125; &#125; for(int i=1;i&lt;=n;++i) if(!dep[i])dfs(i,0,0); IN(q); for(int i=1;i&lt;=q;++i)&#123; int x,y;IN(x),IN(y); printf("%d\n",solve(x,y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>lca</tag>
        <tag>倍增</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [CQOI2015]网络吞吐量 网络流 luoguP3171]]></title>
    <url>%2F2019%2F03%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3171%2F</url>
    <content type="text"><![CDATA[题目要求你做什么就做什么呗。 我们先跑最短路，然后按照最短路的边连网络流的边就好了。 这里我选择跑堆优 $Dij$ ，然后我们枚举每一条边，判断着一条边是否为最短路的边，判断的方式很显然，就是看这条边的起点的 $dis$ 加上边权是否等于终点的 $dis$ 就好。 网络流要拆点，除了拆了的点之间连一条该点的权值的边之外，其余的边全部都是 $inf$ ，当然第一个点和第 $n$ 个点拆点后连边也是 $inf$ 而非点权。连完边之后跑最大流即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long long#define A printf("A")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e5+2;const ll inf=1e18+9;int n,m,s,t;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace Dinic&#123; std::queue&lt;int&gt; q; struct Edge&#123;int nxt,to;ll val;&#125;G[N&lt;&lt;1]; int cnt(1),dep[N],head[N]; inline void add(int u,int v,ll w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt; &#125; inline bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]||G[i].val&lt;=0)continue; dep[y]=dep[x]+1,q.push(y); &#125; &#125;return dep[t]; &#125; inline ll dfs(int x,ll flow)&#123; if(x==t||!flow)return flow; ll used=0,rlow; for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used; &#125; inline ll dinic()&#123; ll maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow; &#125;&#125;namespace Dijstra&#123; #define P std::pair&lt;int,int&gt; std::priority_queue&lt;P,std::vector&lt;P&gt;,std::greater&lt;P&gt; &gt; q; int vis[N],head[N],cnt; ll dis[N]; struct Edge&#123;int nxt,to;ll w;&#125;G[N&lt;&lt;1]; inline void add(int u,int v,ll w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].w=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].w=w,head[v]=cnt; &#125; inline void dijstra(int s)&#123; for(int i=1;i&lt;=n;++i)dis[i]=inf; memset(vis,false,sizeof(vis)); dis[s]=0; q.push(std::make_pair(dis[s],s)); while(!q.empty())&#123; int x=q.top().second; q.pop();if(vis[x])continue;vis[x]=true; for(int i=head[x];i;i=G[i].nxt) if(dis[G[i].to]&gt;dis[x]+G[i].w)&#123; dis[G[i].to]=dis[x]+G[i].w; if(!vis[G[i].to])q.push(std::make_pair(dis[G[i].to],G[i].to)); &#125; &#125; for(int x=1;x&lt;=n;++x) for(int i=head[x];i;i=G[i].nxt) if(dis[x]+G[i].w==dis[G[i].to]) Dinic::add(x+n,G[i].to,inf); return; &#125;&#125;int main()&#123; IN(n),IN(m),s=1,t=n&lt;&lt;1; for(int i=1;i&lt;=m;++i)&#123; int u,v,w;IN(u),IN(v),IN(w); Dijstra::add(u,v,w); &#125; Dijstra::dijstra(1); for(int i=1,x;i&lt;=n;++i) IN(x),Dinic::add(i,i+n,(i!=1&amp;&amp;i!=n)?x:inf); printf("%lld\n",Dinic::dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [ZJOI2009]狼和羊的故事 网络流 luoguP2598]]></title>
    <url>%2F2019%2F03%2F11%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2598%2F</url>
    <content type="text"><![CDATA[这题真的是裸的网络流……连我这种制杖都可以立刻想到正解。 如果不考虑领地问题的话，这显然是一道很裸的最小割———割断最少的边使 $S$ 和 $T​$ 不连通。 但是现在有了领地的问题……就是说限制了有些格子是一起的，不能被割开。 既然不能被割开，就连一条 $inf$ 的边啊，这样就割不开了啊。 于是我们可以让 $S$ 向所有的狼的领地连一条边权为 $inf$ 的边，然后所有的羊的领地向 $T$ 连一条边权为 $inf$ 的边。然后就是网格边连边了…… Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define A printf("A")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define id(x,y) (((x)-1)*m+(y))const int N=1e5+2;const int inf=1e9+9;const int dx[4]=&#123;0,0,-1,1&#125;;const int dy[4]=&#123;-1,1,0,0&#125;;int n,m,s,t;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace Dinic&#123; std::queue&lt;int&gt; q; struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;1]; int cnt(1),dep[N],head[N]; inline void add(int u,int v,int w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt; &#125; inline bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]||G[i].val&lt;=0)continue; dep[y]=dep[x]+1,q.push(y); &#125; &#125;return dep[t]; &#125; inline int dfs(int x,int flow)&#123; if(x==t||!flow)return flow; int used=0,rlow; for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used; &#125; inline int dinic()&#123; int maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow; &#125;&#125;int main()&#123; IN(n),IN(m);s=n*m+1,t=n*m+2; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; int a;IN(a); if(a==1)Dinic::add(s,id(i,j),inf); if(a==2)Dinic::add(id(i,j),t,inf); &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) for(int k=0;k&lt;4;++k)&#123; int tx=i+dx[k],ty=j+dy[k]; if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;m)continue; Dinic::add(id(i,j),id(tx,ty),1); &#125; printf("%d\n",Dinic::dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 Willem, Chtholly and Seniorious 珂朵莉树 luoguCF896C]]></title>
    <url>%2F2019%2F03%2F11%2F%5B%E9%A2%98%E8%A7%A3%5DluoguCF896C%2F</url>
    <content type="text"><![CDATA[神奇的珂朵莉树，优雅的暴力。 珂朵莉树的主要思想就是对于一段连续的值相同的区间，将其缩为一个结点，然后丢到 $set$ 里面，主要的操作有拆分区间操作…….这货很强大，码量不短但极好写，而且一般不会出什么问题，调试也很方便。 但是珂朵莉树的思想很暴力，比如说区间第 $K$ 大，珂朵莉树的做法就是直接将区间拿出来排一波序！当然，这样暴力的东西只能在随机数据的情况下食用，或者数据水的情况下，不然分分钟给你 $T$ 飞！ 好吧来看看这道题的操作该怎么办： 第一个操作的话属于傻逼操作，珂朵莉树，先 $split$ 提取 $l,r$ 区间，然后直接暴力访问，加上 $x$ 即可。 第二个操作完全就是珂朵莉树的基本操作，跟上面一样，暴力访问然后直接将权值改为 $x$ 即可，更简单的方法就是删除 $l,r$ 区间，然后把权值统一为 $x$ 后再插入 $l,r$ 。 第三个操作第 $K$ 大，上面说了，直接拿出来排个序就好了，炒鸡暴力。 第四个操作……仍然是暴力，可以参考第一二个操作，注意 $longlong$ 的问题，不要爆 $long long$ 了。 对于初始的序列，我们先用题目要求的随机化函数得到序列中每一个位置的值，然后插入到 $set$ 中，这个时候第 $i$ 个元素区间是 $i,i$ 。 还有一个需要注意的地方，就是在插入完整个序列后还要在最后面插入一个边界的哨兵结点，当然哨兵结点的权值为 $0$ 。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;set&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))typedef long long ll;const int N=1e5+7;const int inf=1e9+9;ll seed,vmax;inline ll rnd()&#123; ll ret=seed; seed=(seed*7+13)%1000000007; return ret;&#125;struct ODT&#123; struct Node&#123; int l,r; mutable ll v; Node(int L,int R=-1,ll V=0):l(L),r(R),v(V) &#123;&#125; bool operator &lt; (const Node&amp;x) const &#123;return l&lt;x.l;&#125; &#125;; std::set&lt;Node&gt; s; #define IT std::set&lt;Node&gt;::iterator inline IT split(int pos)&#123; IT it=s.lower_bound(Node(pos)); if(it!=s.end()&amp;&amp;it-&gt;l==pos)return it; else --it; int L=it-&gt;l,R=it-&gt;r;ll V=it-&gt;v; s.erase(it); return s.insert(Node(L,pos-1,V)),s.insert(Node(pos,R,V)).first; &#125; inline void assign(int l,int r,ll val)&#123; IT itr=split(r+1),itl=split(l); s.erase(itl,itr); s.insert(Node(l,r,val)); &#125; inline void add(int l,int r,ll val)&#123; IT itr=split(r+1),itl=split(l); for(;itl!=itr;++itl)itl-&gt;v+=val; &#125; inline ll rank(int l,int r,int k)&#123; std::vector&lt;std::pair&lt;ll,int&gt; &gt; hep; IT itr=split(r+1),itl=split(l); for(;itl!=itr;++itl) hep.push_back(std::make_pair(itl-&gt;v,itl-&gt;r-itl-&gt;l+1)); std::sort(hep.begin(),hep.end()); for(std::vector&lt;std::pair&lt;ll,int&gt; &gt;::iterator it=hep.begin();it!=hep.end();++it)&#123; k-=it-&gt;second; if(k&lt;=0)return it-&gt;first; &#125; &#125; inline ll pow(ll x,ll y,ll mod)&#123; ll res=1ll;x%=mod; for(;y;y&gt;&gt;=1,x=x*x%mod)if(y&amp;1)res=res*x%mod; return res%mod; &#125; inline ll sum(int l,int r,int ex,int mod)&#123; IT itr=split(r+1),itl=split(l); ll res=0; for(;itl!=itr;++itl) res=(res+(ll)(itl-&gt;r-itl-&gt;l+1)*pow(itl-&gt;v,ll(ex),ll(mod)))%mod; return res; &#125; inline void pre(int n)&#123; int a; for(int i=1;i&lt;=n;++i) a=(rnd()%vmax)+1,s.insert(Node(i,i,a)); s.insert(Node(n+1,n+1,0)); return; &#125;&#125;T;int main()&#123; int n,m; scanf("%d%d%lld%lld",&amp;n,&amp;m,&amp;seed,&amp;vmax); T.pre(n); for(int i=1;i&lt;=m;++i)&#123; int op=(rnd()%4)+1,l=(rnd()%n)+1,r=(rnd()%n)+1,x,y; if(l&gt;r)std::swap(l,r); if(op==3)x=(rnd()%(r-l+1))+1; else x=(rnd()%vmax)+1; if(op==4)y=(rnd()%vmax)+1; if(op==1)T.add(l,r,ll(x)); else if(op==2)T.assign(l,r,ll(x)); else if(op==3)printf("%lld\n",T.rank(l,r,x)); else if(op==4)printf("%lld\n",T.sum(l,r,x,y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [国家集训队]聪聪可可 树形DP luoguP2634]]></title>
    <url>%2F2019%2F03%2F10%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2634%2F</url>
    <content type="text"><![CDATA[别人都说，什么淀粉质啊之类的轻松水过，然而我有码量恐惧症，不适合如此数据结构(主要也是太弱了QvQ) 那就上树形DP吧！$f[i][j]$表示点i为根的子树中到i路径权值和%3=j的点数.状态转移：Dfs，直接从子树转移即可，具体看代码。 真是炒鸡简单的啦~~ CODE:1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int#define A printf("A")using namespace std;const int N=2e4+2;inline ll gcd(int x,int y)&#123;return y?gcd(y,x%y):x;&#125;struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;2];int n,cnt,head[N];ll f[N][3],ans;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline void add(int x,int y,int v)&#123; G[++cnt].nxt=head[x],G[cnt].to=y,G[cnt].val=v,head[x]=cnt; G[++cnt].nxt=head[y],G[cnt].to=x,G[cnt].val=v,head[y]=cnt;&#125;inline void Dfs(int x,int fa)&#123; f[x][0]=1; for(register int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to;if(y==fa)continue;Dfs(y,x); for(int j=0;j&lt;3;++j)ans+=(ll)(f[y][j]*f[x][(((3-j-G[i].val)%3)+3)%3]*2); //从子树转移过来，注意取模，看不懂的同学画图秒懂 for(int j=0;j&lt;3;++j)f[x][(G[i].val+j)%3]+=f[y][j]; //跟新 f[x] &#125;return;&#125;int main()&#123; IN(n);ll s=(ll)n*n,g; for(register int x,y,v,i=1;i&lt;n;++i) IN(x),IN(y),IN(v),add(x,y,v); Dfs(1,0);ans+=n,g=gcd(ans,s);//一定要是最简分数 printf("%lld/%lld\n",ans/g,s/g);//输出答案 return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 「网络流24题」餐巾计划问题 网络流 luoguP1251]]></title>
    <url>%2F2019%2F03%2F09%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1251%2F</url>
    <content type="text"><![CDATA[实际上这道题可以用贪心解的……但是码量惊人 $QwQ$ 。 于是上网络流吧……这题显然是费用流。 对于每一天，我们将其拆成两个点，一个表示这天的早晨，一个表示这天的晚上。 我们从源点向每一天的晚上连一条边权为 $x$ 费用为 $0​$ 的边，表示这一天我们需要处理的餐巾数，就是白天用掉的餐巾。 每一天的早晨，这些餐巾来自题目给出的地方，并且最终连向汇点，边权为 $x$ 费用为 $0$ 。 然后考虑每天早上餐巾的来源，现在题目给了四个操作： 买新的 丢到快洗店 丢到慢洗店 弃疗 对于买新的，我们只需要从源点连一条边权为 $inf$ 费用为 $p$ 的边到这一天的白天，我们餐巾的获取都来自源点。 丢到快洗店，也就是说第 $i$ 天晚上这些没有处理的毛巾丢到快洗店，那么第 $i+m$ 天将洗完，这个时候可以在早晨收到餐巾，于是从 $i$ 的晚上连一条边权为 $inf$ 费用为 $f$ 的边连向 $i+m$ 的白天。 丢到慢洗店，这个跟快洗店是一个道理。 关于弃疗，就是说放着不管了，可以理解为第 $i$ 天晚上的餐巾留到了第 $i+1$ 天，并且这些餐巾是不能用的，那么不会连向 $i+1$ 的早晨，于是从 $i$ 的晚上连一条边权为 $inf$ 费用为 $f$ 的边连向 $i+1$ 的晚上。 然后跑一边费用流板子就好了，注意要开 $long long$ 。 至于上面四个选项为什么边的容量都设为 $inf$ ，我们就拿买新的来说吧，题目又没有限制你最多买多少，所以就是允许你可以一直买，买无限条，就当成 $inf$ 啦。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define id(type,x) ((type)*n+x)#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y)) const int N=1e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int s,t,r[N],tot(1),head[N],vis[N],dist[N];struct Edge&#123;int nxt,to,val,cot;&#125;G[N&lt;&lt;8];struct Pre&#123;int last,edge;&#125;pre[N];inline void add(int u,int v,int val,int cot)&#123; G[++tot].nxt=head[u],G[tot].to=v,G[tot].val=val,G[tot].cot=cot,head[u]=tot; G[++tot].nxt=head[v],G[tot].to=u,G[tot].val=0,G[tot].cot=-cot,head[v]=tot;&#125; inline bool Spfa()&#123; memset(pre,0,sizeof(pre)); memset(dist,0x3f,sizeof(dist)); memset(vis,0,sizeof(vis)); std::queue&lt;int&gt; q; q.push(s),vis[s]=1,dist[s]=0; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i;i=G[i].nxt)&#123; int v=G[i].to; if(G[i].val&gt;0&amp;&amp;dist[v]&gt;dist[u]+G[i].cot)&#123; dist[v]=dist[u]+G[i].cot; pre[v].last=u,pre[v].edge=i; if(!vis[v])&#123;q.push(v),vis[v]=1;&#125; &#125; &#125;vis[u]=0; &#125;return dist[t]!=0x3f3f3f3f;&#125;inline ll EK()&#123; ll maxflow=0; ll cost=0; int min_flow; while(Spfa())&#123; min_flow=inf; for(int i=t;i!=s;i=pre[i].last) min_flow=min(min_flow,G[pre[i].edge].val); for(int i=t;i!=s;i=pre[i].last)&#123; G[pre[i].edge].val-=min_flow; G[pre[i].edge^1].val+=min_flow; &#125; maxflow+=min_flow; cost+=min_flow*dist[t]; &#125;return cost; &#125;int main()&#123; int n,_n,_p,_m,_f,_s; IN(n);s=0,t=n*2+1; for(int i=1;i&lt;=n;++i)&#123; int x;IN(x); add(s,id(1,i),x,0),add(id(0,i),t,x,0); &#125; IN(_p),IN(_m),IN(_f),IN(_n),IN(_s); for(int i=1;i&lt;=n;++i)&#123; if(i+1&lt;=n)add(id(1,i),id(1,i+1),inf,0); if(i+_m&lt;=n)add(id(1,i),id(0,i+_m),inf,_f); if(i+_n&lt;=n)add(id(1,i),id(0,i+_n),inf,_s); add(s,id(0,i),inf,_p); &#125; printf("%lld\n",EK()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈4种莫队及例题]]></title>
    <url>%2F2019%2F03%2F08%2F%5B%E7%AE%97%E6%B3%95%5D%E8%8E%AB%E9%98%9F%26%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[关于莫队，实际上是去年就接触的，大概是 $1$2 月份，当时感觉莫队是个很高大上的东西，不过的确也很高大上。当时评判知识点的标准就是这个知识点的题目一般难度是多少。看大米饼的博客，第一道例题就是洛谷上的紫题，于是跟着题解，将题目切掉了。 $AC$ 第一道例题的那一天是 $2018.12.08$ ，那题是一个普通莫队的例题。恰好在今天，$2019.3.8$ ，我切掉了糖果公园，这题是一个树上待修莫队的例题。从普通莫队到树上待修莫队已经时隔 $4$ 月………..不得不说时间过得真快，终于在这个时候我有资格浅谈莫队了，但也仅仅是浅谈而已。 0XFF 前言 老规矩，有问题的话直接联系就好，$QQ$ 号：$2641450959$ 由于本人的水平问题，文章或许会有些纰漏，还请大佬们指教 0X1F 莫队是什么 莫队，用于解决一些奇怪的区间问题，例如询问区间内有多少个不相同的数，这个时候平衡树和线段树都显得有些不好维护，但是莫队却可以以优秀的 $O(\sqrt{n})$ 的复杂度快速得到答案，并且莫队短小精悍，如果单纯的就是询问区间内有多少个不相同的数的话，莫队的核心代码仅有 $4$ 行。 莫队的思想，就是有两个指针 $l,r$ ，然后根据这两个指针的移动来计算答案。 莫队是离线算法，并且不支持区间修改操作，单点修改操作勉强可以支持。 莫队是一种很强大的算法，在面对不强制在线的区间问题时可以考虑莫队。 0X2F 几种莫队 0X2F—1 普通莫队我们先来具体探讨一下上面的那个 “区间不相同数的个数” 的问题。 假设我们的整个区间是这样的： 很显然，我们当前区间有四种不同的颜色，我们设绿为 $1$ ，黄为 $2$ ，蓝为 $3$ ，红为 $4$ 。这个时候我们开一个 $cnt$ 数组，$cnt[x]$ 表示 $x$ 颜色在当前区间的出现次数。然后我们记录一个 $ans$ ，表示当前区间的答案。 假设现在我们要将 $l,r$ 移动至下一个询问。对，就是裸的移动，就是 $l,r$ 一个一个格子的移动，因为移动一次(即移动一下 $l$ 或 $r$ )后的区间就是原区间的相邻区间，一般 $O(1)$ 就可以退出来相邻区间的贡献，那么这一个一个的小贡献叠加起来，最终就是目标区间的贡献。 我们还是来模拟一下，假设我们下一个询问的区间如下： 我们先来考虑 $r$ 的移动所产生的贡献。 首先，$r$ 是往右移的，因此我们可以确定 $r$ 的移动是会增加贡献而非减少贡献。然后看看 $r$ 的移动带来了什么贡献呢？一个蓝色方块！，蓝色的编号为 $3$ ，那么很显然，我们的 $cnt[3]$ 就要加 $1$ 。 这个移动的代码我们也可以快速写出： 1while(r&lt;q[i].r)add(++r); 其中 $r$ 为当前的 $r$ 指针，$q[i].r$ 为当前询问区间的 $r$ 。 为什么是 ++$r$ 而不是 $r$++ 呢？很显然，++$r$ 是先移开再算贡献，$r$++ 是算完贡献再移开，我们黄色格子的贡献已经计算完了，所以是 ++$r$ 。 那么怎么更新 $ans$ 呢？ 我们来考虑，如果这个新加入的格子不是现在区间内已经有的蓝色，而是另一种没出现过的颜色怎么办呢？显然 $ans$ 要 +$1$ ，不过如果是蓝色就不要加了，这个时候我们判断一下就可以了。 12345inline void add(int x)&#123; if(!tot[c[x]])++ans; /*之前没有这个颜色，现在加进来，不同颜色数又多了1，故ans++*/ ++tot[c[x]];/*这个颜色的出现次数+1*/&#125; 其中 $c[x]$ 表示位置 $x$ 上的颜色，$tot[x]$ 表示颜色 $x$ 的出现次数。(实际上上面的代码可以压成一行的)： 1inline void add(int x)&#123;if(!tot[c[x]]++)++ans;&#125; 那么现在来考虑 $l$ ，这个时候 $l$ 往右移，但是这次不是增加贡献了，是减少了！ 但是减少的代码跟增加的没什么区别： 1while(l&lt;q[i].l)del(l++);/*当前l所在的格子也要del掉，所以是l++*/ 12345inline void del(int x)&#123; if(tot[c[x]]==1)--ans; /*颜色只剩下一个了，这次del掉，这个颜色就没有了，故ans--*/ --tot[c[x]];/*颜色数少1*/&#125; 压行后： 1inline void del(int x)&#123;if(!--tot[c[x]])--ans;&#125; 如果还有些没明白可以画一下，然后顺便理解一下 $l$ 往左移的时候是什么样，$r$ 往左移的时候是什么样。 然后这就是普通队列的基本的移动了，这个是可以在线完成，但是你会发现………. 询问的 $l,r$ 的毒瘤顺序或许会让指针到处乱跳！复杂度将爆炸！ 所以我们要离线操作，将所有的询问排个序。但是具体怎么排序呢？当然不能瞎排，不然的话复杂度依旧爆炸。 所以，这个时候我们借助分块来排序。 块的大小一般是 $\sqrt{n}​$ ，对于第 $x​$ 个询问，我们计算一下 $q[x].l​$ 在哪个块中，$q[x].r​$ 又在哪个块中，排序的时候以 $l​$ 为第一关键字，$r​$ 为第二关键字排序。假定我们要给两个询问 $a,b​$ 排序。那么我们首先判断 $q[a].l​$ 所在的块是否跟 $q[b].l​$ 所在的块一样，一样的话就直接按照 $r​$ 排序，不一样的话排序 $l​$ 。 $cmp$ 代码： 1bool cmp(MO a,MO b)&#123;return Be[a.l]==Be[b.l]?a.r&lt;b.r:a.l&lt;b.l;&#125; 其中 $Be[x]$ 为 $x$ 所在的块的编号。 当然，块的大小以及排序方法确定了莫队算法的复杂度。值得一提的是，在一次考试中，有一道莫队的题，别人用 $\sqrt{n}$ 的块大小，就是按照上面的方法排序，每个点的时间均大于 $0.97ms$ ，但是我用的另外一种方法，使得平均速度不超过 $0.52ms$ 。 我的块大小是 $\frac{n}{\sqrt{\frac{m\cdot 2}{3}}}​$ ，其余的都差不多。 但是建议大家还是用 $\sqrt{n}$ 的块大小吧，跑得也不慢。 0X2F—2 带修改莫队上面的莫队是两个关键字排序，那么这个时候又了修改，也就是说序列在不同的时间或许状态就会不一样了，这个时候直接移动区间是会得到错误的答案的。 假设现在的 $l,r$ 所在的区间是第四次修改后的询问，下一个将要移动到的区间是第一次修改后的询问，怎么移动？ 这个时候就有一种想法，我们可以建立时间戳，然后一上面的为例子，既然时间不同，我们就暴力修改时间！具体怎么搞呢？我们几下每次修改点的位置，原来权值及修改后的权值。然后暴力还原，以上面的询问为例，我们暴力还原的就是中间差了的这三个修改，那么我们将这三个修改点的权值都变为 “原来权值” ，变的时候需要注意，假设当前变了的点在 $l,r$ 区间内，我们需要维护一下 $ans$ ，就像上面那样维护。 0X2F—3 树上莫队听说过 $dfs$ 序列吗？ 假设我们现在有一颗树，如下： 那么它的 $dfs$ 序列为： 1\ 2\ 4\ 7\ 7\ 4\ 5\ 5\ 2\ 3\ 6\ 6\ 3\ 1​怎么获取它的 $dfs$ 序列呢？一个简单的 $dfs$ 就可以完成。 1234567void Dfs(int u,int fa)&#123; id[++tot]=u; for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=fa)Dfs(G[i].to,u);/*去往儿子*/ id[++tot]=u; return;&#125; 我们记 $in[x]$ 为 $x$ 第一次出现的位置，也就是 $dfs$ 进入 $x$ 的时候，$out[x]$ 为 $x$ 第二次出现的位置，也就是 $dfs$ 退出 $x$ 结点的时候。 所谓树上莫队，就是在这棵树的 $dfs$ 序列上做莫队。 这个时候分以下几种种情况： 1.询问的两个点 $x,y$ 为同一个点很好解决，即：$q[i].l=in[x],q[i].r=in[x]$ 2.询问的两个点 $x,y$ 的 $lca$ 为 $x$ 或 $y$这个时候我们来观察 $dfs​$ 序列，就以上图的 $x=7,y=2​$ 为例： 1\ 2\ 4\ 7\ 7\ 4\ 5\ 5\ 2\ 3\ 6\ 6\ 3\ 1​在原树中 $7,2​$ 之间有一个 $4​$ ，可以发现在序列中 $in[2]​$ 和 $in[7]​$ 之间也有一个 $4​$ 。 不难发现，这种情况下的询问区间中的点就在 $in[x]-in[y]$ 或 $in[y]-in[x]$ 之间！ 3.询问的两个点 $x,y$ 不存在父子关系我们以上图的 $x=2,y=3$ 为例。 观察 $dfs​$ 序列： 1\ 2\ 4\ 7\ 7\ 4\ 5\ 5\ 2\ 3\ 6\ 6\ 3\ 1欸，中间不是有一个 $1​$ 吗？怎么没算进来呢？ 因为 $dfs$ 序列的构造方式使得 $in[1]$ 永远在它们前面，$out[1]$ 永远在它们后面，所以这个是不会算进来的。 当然我们会发现，中间的节点在 $out[2]-in[3]$ 之间，我们的询问区间就是 $out[2],in[3]$ 。 只是我们要多加上一个 $1$ 的贡献，也就是 $lca(2,3)$ 的贡献，$lca$ 计算就好。 但是对于编号来讲，$dfs$ 序列中一个节点的编号出现了两次啊，这怎么办呢？我们记一个 $vis[x]$ 表示 $x$ 的出现情况，然后计算贡献就好办了。假设现在莫队移动的时候遇到了 $x$ ，那么如果这个时候 $vis[x]$ 为 $true$ ，也就是说 $x$ 之前计算过，我们就减去这个贡献，否则加上，然后反转 $vis[x]$ 的值。 为什么要这样做？ 我们假设： $l\leq q[i].l\leq in[x]\leq r \leq out[x]\leq q[i].r$ 如图： 这个时候 $vis[x]$=$1$ ，那么 $r$ 经过 $out[x]$ 到达 $q[i].r$ 的时候会将 $x$ 的贡献丢掉，也就是说 $x$ 没有产生任何贡献。 为什么这样做？可以肯定询问区间不包含 $x$ ，所以这样是对的。 我们举个例子，对于上面的那棵树，假设我们的询问区间为 $4,3$ ，$dfs$ 序列： 1\ 2\ 4\ 7\ 7\ 4\ 5\ 5\ 2\ 3\ 6\ 6\ 3\ 1$4,3$ 显然属于上面的第三种情况，但是我们发现 $out[4]$ 和 $in[3]$ 之间有 $5$ ……….显然我们的询问的区间中没有 $5$ ，但是发现了吗？$5$ 是出现了两次的，也就是说最终我们没有计算 $5$ 的贡献，而 $2$ 出现了一次，我们记上了 $2$ 的贡献，很显然 $2$ 在询问范围内。 对于其他的情况也是类似，总的来说就是，当一个询问区间内出现了两遍或零遍 $x$ ，那么根据 $dfs$ 序列的性质可以知道 $x$ 肯定不在当前询问的区间中。如果是出现了一次，那么肯定就在询问区间当中，我们便记上 $x$ 所产生的贡献即可。 0X2F—4 回滚莫队———$update - 2019.3.20$——— 回滚莫队，也是一个很神奇的东西。 现在问题来了，让你找一个区间 $l,r$ 的 元素的值 $\times$ 元素在 $l,r$ 中的出现次数 的最大值。 这个时候我们发现莫队可以 $add$ ，但是 $del$ 就不好办了…………………………….. 于是回滚莫队出现了。 回滚莫队是按照一个一个块来处理的，每处理一个块，就会解决所有左端点 $l$ 在当前块中的询问，我们要保证这些左端点属于一个同块的询问的右端点是要升序排好的。 这个对询问排序的时候就可以解决。 于是现在可以得到一下框架： 1234567891011inline void solve(int num,int i)&#123;//当前要从第几个询问开始处理&amp;当前的块 for(int i=1;i&lt;=n;++i)cnt[i]=0;//清空cnt数组 \*......*\&#125;int main()&#123; \*......*\ int num=1;//要处理第几个询问 for(int i=1;i&lt;=blo[n];++i)//枚举所有的块 num=solve(num,i);//下一个块的询问要从num开始。&#125; 现在右端点都是升序的我们不用担心了。 但是左端点怎么办？现在有一种办法，我们设 $L$ 为当前块的最后一个对于每一个询问，我们先移动右端点，并将左端点设为 $L+1$ ，右端点移动到位后，这个时候 $ans$ 记录的区间为 $L+1,q[i].r$ ，这个时候记录一下 $ans$ ，然后将左端点移动至 $q[i].l$ 。 移动完成之后，我们得到了这个询问的 $Ans$ ，现在直接更新答案数组： $Ans[q[i].id]=ans$ 接下来，我们要将位于 $q[i].l$ 的左端点”滚回去”，”滚回”到 $L+1$ 。 这很简单了，我们移过来的时候改变了 $cnt$ 数组，”滚回去” 的时候再改回来就好了。至于 $ans$ 怎么更新的话，直接变为之前记录的值就好了。 跟普通莫队差不太多，或许常数大些。 值得注意的是，如果 $q[i].l$ 和 $q[i].r$ 处于同一个块的话，直接暴力处理就好了。 0X3F 一些题目水表水表，欢迎来刷水题，这里的都是我做过的，只是有些没有写题解而已。 洛谷—-P1494 [国家集训队]小Z的袜子 (普通莫队入门题) 洛谷—-P2709 小B的询问 (普通莫队入门题) 洛谷—-P1972 [SDOI2009]HH的项链 (本文普通莫队例题) 洛谷—-CF86D Powerful array (普通莫队练手题) 洛谷—-P3674 小清新人渣的本愿 (普通莫队技巧题) {题解} 洛谷—-P1903 [国家集训队]数颜色/维护队列 (带修改莫队板子题,有些毒瘤) 洛谷—-P4074 [WC2013]糖果公园 (树上带修改莫队板子题,超级毒瘤) {题解} 洛谷—-AT1219 歴史の研究 (回滚莫队板子题) 题解]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [WC2013]糖果公园 树上带修改莫队 luoguP4074/Uoj58]]></title>
    <url>%2F2019%2F03%2F08%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4074%2F</url>
    <content type="text"><![CDATA[毒瘤题目，树上带修改莫队板子题。 关于树上莫队和带修改莫队的文章戳这 $QwQ​$ :[算法]莫队&amp;树上莫队 然后就是将其结合在一起了，结合的话炒鸡简单，就是码量增大… 可以算作一个树上莫队/树上带修改莫队的板子来看。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cctype&gt;#include&lt;bitset&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define swap(x,y) ((x)^=(y)^=(x)^=(y))const int N=1e5+24;const int LogN=20;const int inf=1e9+9;inline int IN()&#123; int x=0;char ch;bool flag=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return flag?-x:x;&#125;int n,m,q,v[N],w[N],c[N];/*test*/int id[N&lt;&lt;1],in[N],out[N],dep[N],f[N][LogN],sequencelong;/*dfs&amp;lca*/int head[N],cnt;/*Tree Edge*/struct Edge&#123;int nxt,to;&#125;G[N&lt;&lt;1];/*Tree Edge*/int c0,c1,block,tot[N],cl[N],cr[N],vis[N],modify[N];/*MO*/struct MO&#123;int l,r,lbe,rbe,time,id,lca,ans;&#125;Q[N];/*MO*/ll now,Ans[N];bool cmp(MO a,MO b)&#123; if(a.lbe^b.lbe)return a.lbe&lt;b.lbe; if(a.rbe^b.rbe)return a.rbe&lt;b.rbe; if(a.time^b.time)return a.time&lt;b.time;&#125;inline void add(int u,int v)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,head[v]=cnt;&#125;void Get_Lca_and_sequence(int u,int fa)&#123; dep[u]=dep[fa]+1,f[u][0]=fa; for(int i=1;i&lt;20;++i)f[u][i]=f[f[u][i-1]][i-1]; id[in[u]=++sequencelong]=u; for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=fa)Get_Lca_and_sequence(G[i].to,u); id[out[u]=++sequencelong]=u; return;&#125;int Lca(int u,int v)&#123; if(dep[u]&lt;dep[v])swap(u,v); for(int i=19;~i;--i) if(dep[u]-(1&lt;&lt;i)&gt;=dep[v])u=f[u][i]; for(int i=19;~i;--i) if(f[u][i]!=f[v][i])u=f[u][i],v=f[v][i]; return u==v?u:f[u][0];&#125;inline void _Main_input()&#123; n=IN(),m=IN(),q=IN();/*line 1*/ for(int i=1;i&lt;=m;++i)v[i]=IN();/*line 2*/ for(int i=1;i&lt;=n;++i)w[i]=IN();/*line 3*/ for(int i=1;i&lt;n;++i)add(IN(),IN());/*line 4 to n+2*/ for(int i=1;i&lt;=n;++i)c[i]=IN();/*line n+3*/ Get_Lca_and_sequence(1,0); block=std::ceil(std::pow(sequencelong,0.66666)); for(int i=1;i&lt;=q;++i)&#123;/*line n+4 to n+4+q*/ int Type=IN(),x=IN(),y=IN(); if(Type==1)&#123; Q[++c1].id=c1,Q[c1].time=c0; if(x==y)&#123; Q[c1].lbe=(Q[c1].l=in[x])/block; Q[c1].rbe=(Q[c1].r=in[x])/block; &#125;else&#123; if(in[x]&lt;in[y]&amp;&amp;out[y]&lt;out[x])&#123; Q[c1].lbe=(Q[c1].l=in[x])/block; Q[c1].rbe=(Q[c1].r=in[y])/block; &#125; else if(in[y]&lt;in[x]&amp;&amp;out[x]&lt;out[y])&#123; Q[c1].lbe=(Q[c1].l=in[y])/block; Q[c1].rbe=(Q[c1].r=in[x])/block; &#125; else&#123; if(out[x]&lt;in[y])&#123; Q[c1].lbe=(Q[c1].l=out[x])/block; Q[c1].rbe=(Q[c1].r=in[y])/block; Q[c1].lca=Lca(x,y); &#125; else if(out[y]&lt;in[x])&#123; Q[c1].lbe=(Q[c1].l=out[y])/block; Q[c1].rbe=(Q[c1].r=in[x])/block; Q[c1].lca=Lca(x,y); &#125; &#125; &#125; &#125;else modify[++c0]=x,cl[c0]=c[x],cr[c0]=y,c[x]=y; &#125;return;&#125;inline void work(int x)&#123; if(vis[x])now-=1ll*v[c[x]]*w[tot[c[x]]--]; else now+=1ll*v[c[x]]*w[++tot[c[x]]]; vis[x]^=1;return;&#125;inline void add(int x)&#123; if(vis[modify[x]])&#123;work(modify[x]);c[modify[x]]=cr[x];work(modify[x]);&#125; else c[modify[x]]=cr[x];&#125;inline void del(int x)&#123; if(vis[modify[x]])&#123;work(modify[x]);c[modify[x]]=cl[x];work(modify[x]);&#125; else c[modify[x]]=cl[x];&#125;inline void _Main_Mo_Solve()&#123; std::sort(Q+1,Q+c1+1,cmp); int l=1,r=0,nowtime=c0; for(int i=1;i&lt;=c1;++i)&#123; while(nowtime&gt;Q[i].time)del(nowtime--); while(nowtime&lt;Q[i].time)add(++nowtime); while(l&lt;Q[i].l)work(id[l++]); while(l&gt;Q[i].l)work(id[--l]); while(r&lt;Q[i].r)work(id[++r]); while(r&gt;Q[i].r)work(id[r--]); if(Q[i].lca)work(Q[i].lca); Ans[Q[i].id]=now; if(Q[i].lca)work(Q[i].lca); &#125;&#125;inline void _Main_output()&#123; for(int i=1;i&lt;=c1;++i) printf("%lld\n",Ans[i]);&#125;int main()&#123; _Main_input(); _Main_Mo_Solve(); _Main_output(); return 0;&#125; 当然，尽管再毒瘤，这个也只是入门的树上带修改莫队的题目。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SCOI2007]蜥蜴 网络流 luogu2472]]></title>
    <url>%2F2019%2F03%2F06%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2472%2F</url>
    <content type="text"><![CDATA[网络流……..题目要求我们求出能逃离的蜥蜴数量的最大值，不就是最大流吗？ 然后考虑怎么建模。 首先来看看蜥蜴，我们将这些蜥蜴的点跟 $s$ 连边，边权是多少呢？想一想，由于一个位置只有一只蜥蜴，那么边权就当然是 $1$ 了。 然后考虑逃离的这些柱子，题目说什么石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减 $1$ ，看似很不好办，但是这恰恰就是网络流。对于柱子间的一条边，从 $s$ 经过蜥蜴的点的时候，流量就只有 $1$ 了，这个 $1$ 的流量流过柱子中的边的时候就会让这条边的边权减 $1$ ，减到 $0$ 当然就不能流了。 那么柱子之间怎么连边呢？ 对于一个柱子，我们将它拆成两个点，一个入点，一个出点。其中入点向出点连一条边，边权为这个柱子的高度。如果一个柱子，判断一下，发现从它这里可以跳出去，那么就将这个柱子的出点向 $t$ 连一条边，这条边仅仅是代表找到了答案，对答案没有影响，边权为 $inf$ 。 然后我们再看一下，这个柱子能到达的柱子有哪些，这里直接算曼哈顿距离就好了。然后由这条柱子的出点向能到达的柱子的入点连一条边，边权呢？还是为 $inf$ 。因为我们对一个柱子的影响就是入点到出点的那一条边，那一条边的边权已经限制了这个柱子的使用量，所以中间的边权为 $inf$ 。 注意数组大小，要开大一点。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/*---[SCOI2007]蜥蜴.网络流-最大流 毒瘤题目*/#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define ID(ty,x,y) ((ty)*r*c+id[(x)][(y)])const int N=55;const int S=1e5+2;const int inf=1e9+9;std::queue&lt;int&gt; q;std::vector&lt;std::pair&lt;int,int&gt; &gt; lizard;std::vector&lt;std::pair&lt;int,int&gt; &gt; Pillar;int r,c,d,s,t;int dep[S],head[S],cnt=1;int val[N][N],id[N][N],tot=0,total=0;char str;struct Edge&#123;int nxt,to,val;&#125;G[N*N*8];inline void add(int u,int v,int w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int bfs()&#123; std::memset(dep,0,sizeof(dep)); dep[s]=1;q.push(s); while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i;i=G[i].nxt)&#123; int v=G[i].to; if(!dep[v]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,q.push(v); &#125; &#125;return dep[t];&#125;int dfs(int u,int flow)&#123; if(u==t||!flow)return flow; int used=0,rlow; for(int i=head[u];i;i=G[i].nxt)&#123; int v=G[i].to; if(dep[v]==dep[u]+1&amp;&amp;G[i].val&gt;0)&#123; used+=(rlow=dfs(v,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[u]=-1; return used;&#125;int dinic()&#123; int maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow;&#125;void _pre_in()&#123; IN(r),IN(c),IN(d); s=0,t=r*c*2+1; Pillar.clear();//柱子 lizard.clear();//蜥蜴 for(int i=1;i&lt;=r;++i) for(int j=1;j&lt;=c;++j)&#123; std::cin&gt;&gt;str; id[i][j]=++tot,val[i][j]=str-'0'; if(val[i][j]&gt;0)Pillar.push_back(std::make_pair(i,j)); &#125; for(int i=1;i&lt;=r;++i) for(int j=1;j&lt;=c;++j)&#123; std::cin&gt;&gt;str; if(str=='L')++total,lizard.push_back(std::make_pair(i,j)); &#125; return;&#125;void _pre_add_line()&#123;//连边 for(int i=0;i&lt;Pillar.size();++i)&#123; int x=Pillar[i].first,y=Pillar[i].second; add(ID(0,x,y),ID(1,x,y),val[x][y]); if(x&lt;=d||y&lt;=d||x+d&gt;r||y+d&gt;c)add(ID(1,x,y),t,inf);//可以逃出去 &#125; for(int i=0;i&lt;Pillar.size();++i) for(int j=0;j&lt;Pillar.size();++j)&#123; if(i==j)continue; int xi=Pillar[i].first,yi=Pillar[i].second; int xj=Pillar[j].first,yj=Pillar[j].second; if((xi-xj)*(xi-xj)+(yi-yj)*(yi-yj)&lt;=d*d) add(ID(1,xi,yi),ID(0,xj,yj),inf);//柱子之间可以互相到达 &#125; for(int i=0;i&lt;lizard.size();++i)&#123; int x=lizard[i].first,y=lizard[i].second; add(s,ID(0,x,y),1);//源点向蜥蜴连边 &#125;return;&#125;int main()&#123; _pre_in(); _pre_add_line(); printf("%d\n",total-dinic()); /*注意最终要算的是最少的未逃离的数，不是逃离的最大数*/ return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2013]切糕 网络流 bzoj3144]]></title>
    <url>%2F2019%2F03%2F04%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj3144%2F</url>
    <content type="text"><![CDATA[话说切糕有很多细菌，并且高价，现在不让买了，也不让卖了…….. 好吧我们来解决一下这题吧。 额……感觉题意有点不可读，实际上题目就是说给你一个立方体，然后立方体中的每一个点都有一个权值，表示如果要切这个点的话所花费的代价，那么这时需要让你横着切，将这个立方体切成两半，求最小代价。 这就是很明显的最小割了，切成两半使得 $s$ 和 $t$不连通嘛。 于是我们可以考虑这样建边：对于这个立方体，我们建一个虚拟层—第 $0$ 层，对于第 $0$ 层的每一个点，我们用 $s$ 与其相连，这个连接的边是不能被割掉的，所以边权为 $inf$ 。然后对于第 $R$ 层的所有点，我们都将其与 $t$ 相连，同样的道理，边权为 $inf$ 。然后中间的点的话，考虑一个点 $(x,y,z)$ ，我们连一条 $(x−1,y,z)$ 到 $(x,y,z)$ 的边，权值为 $v(x,y,z)$ (即点 $(x,y,z)$ 的权值) 。 这个就是基本的了，如果没有第二个光滑性的限制，直接跑 $Dinic$ 就好了。 但是现在有了这个限制，怎么办呢？ 对于一个竖轴，假设这个竖轴的横竖坐标为 $(x,y)$ ，现在在这个竖轴上有一个高度为 $z$ 的点，这个点的坐标显然为 $(x,y,z)$ ，那么现在的情况就是，如果选了 $z$ ，那么相邻竖轴上的 $z−d,z+d$ 都必须选。 于是我们考虑，从 $(x,y,z)$ 向相邻数轴的 $z−d,z+d$ 连一条 $inf$ 的边，这样就可以保证正确性了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define A printf("A")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int dx[5]=&#123;0,0,0,-1,1&#125;;const int dy[5]=&#123;0,-1,1,0,0&#125;;const int N=8e4+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int P,Q,R,D,s,t,pointval[42][42][42];inline int point(int x,int y,int z)&#123;return x*P*Q+y*Q+z;&#125;namespace Dinic&#123; std::queue&lt;int&gt; q; struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;2]; int cnt(1),dep[N],head[N]; inline void add(int u,int v,int w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt; &#125; inline bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]||G[i].val&lt;=0)continue; dep[y]=dep[x]+1,q.push(y); &#125; &#125;return dep[t]; &#125; inline int dfs(int x,int flow)&#123; if(x==t||!flow)return flow; int used=0,rlow; for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used; &#125; inline int dinic()&#123; int maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow; &#125;&#125;int main()&#123; IN(P),IN(Q),IN(R),IN(D);s=0,t=N-1; for(int i=1;i&lt;=R;++i) for(int j=1;j&lt;=P;++j) for(int k=1;k&lt;=Q;++k) IN(pointval[i][j][k]); for(int j=1;j&lt;=P;++j) for(int k=1;k&lt;=Q;++k) Dinic::add(s,point(0,j,k),inf); for(int i=1;i&lt;=R;++i) for(int j=1;j&lt;=P;++j) for(int k=1;k&lt;=Q;++k) Dinic::add(point(i-1,j,k),point(i,j,k),pointval[i][j][k]); for(int j=1;j&lt;=P;++j) for(int k=1;k&lt;=Q;++k) Dinic::add(point(R,j,k),t,inf); for(int i=D;i&lt;=R;++i) for(int j=1;j&lt;=P;++j) for(int k=1;k&lt;=Q;++k) for(int l=0;l&lt;5;++l)&#123; int tx=dx[l]+j,ty=dy[l]+k; if(tx&lt;1||tx&gt;P||ty&lt;1||ty&gt;Q)continue; Dinic::add(point(i,j,k),point(i-D,tx,ty),inf); &#125; printf("%d\n",Dinic::dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [国家集训队]Crash的数字表格 莫比乌斯反演 luoguP1829]]></title>
    <url>%2F2019%2F03%2F01%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1829%2F</url>
    <content type="text"><![CDATA[吐槽一下Typora这个编辑器：码了一上午的题解，居然突然卡机，并且自动关掉了，然后重新打开，发现保存的也没了。然后弹出一个“Typora意外关闭”的窗口，真想一拳上去。 只好重新自己码了……。(以上是吐槽，请不要在意) 算了算了，重新写吧。所以你看到的这是第二份稿子。 仍然上莫比乌斯反演。 众所周知： lcm(i,j)=\frac{ij}{gcd(i,j)}​那么我们将这个带进原式： \sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j) = \sum_{i=1}^{n}\sum_{j=1}^{m}\frac{ij}{gcd(i,j)}​我们枚举 $gcd(i,j)$ 的值： \sum_{d=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]\frac{ij}{d}=\sum_{d=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]ijd=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]ij设： f(x)=\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=x]ijg(x)=\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[x|gcd(i,j)]ij可得： g(x)=\sum_{x|d}f(d)考虑怎么计算 $g(x)$ ： g(x)=\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[x|gcd(i,j)]ijg(x)=\sum_{i=1}^{\lfloor\frac{n}{dx}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{dx}\rfloor}ij \cdot x^2g(x)=x^2\sum_{i=1}^{\lfloor\frac{n}{dx}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{dx}\rfloor}ij这个显然是可以 $O(1)$ 算出的。 继续： ans=\sum_{d=1}^{n}d\cdot f(1)f(1)=\sum_{d=1}^{\lfloor\frac{n}{}\rfloor}\mu(d)g(d)这个时候的复杂度只是 $O(n^2)$ ，继续优化。 将 $ans$ 写出： ans=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]ij发现后面可以整除分块！ 继续，将 $f(1)$ 写出： f(1)=\sum_{i=1}^{n}\mu(i)g(i)f(1)=\sum_{i=1}^{n}\mu(i)i^2\sum_{a=1}^{\lfloor\frac{n}{di}\rfloor}\sum_{b=1}^{\lfloor\frac{m}{di}\rfloor}ab将 $g$ 拆开后，我们可以发现后面又可以整除分块！ 那么现在就是 $O(n)$ 了，可以过。 Code-$O(n)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define MOD 20101009#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e7+2;const int inf=1e9+9;int mui[N],sum[N];int vis[N],prime[N],cnt;inline void _pre_mui(int n)&#123; mui[1]=1; for(int i=2;i&lt;=n;++i)&#123; if(!vis[i])prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;n)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;mui[i*prime[j]]=0;break;&#125; mui[id*prime[j]]=-mui[i]; &#125; &#125;return;&#125;inline int solve(int n,int m)&#123; ll ans=0; for(int l=1,r=0;l&lt;=n;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); int res=1ll*(1ll*(n/l)*(n/l+1)/2%MOD)*(1ll*(m/l)*(m/l+1)/2%MOD)%MOD; ans+=1ll*(sum[r]-sum[l-1])%MOD*res%MOD; ans%=MOD; &#125;return (ans+MOD)%MOD;&#125;int main()&#123; int n,m,ans=0; scanf("%d%d",&amp;n,&amp;m); if(n&gt;m)n^=m^=n^=m; _pre_mui(n); for(int i=1;i&lt;=n;++i) sum[i]=(sum[i-1]+1ll*i*i%MOD*mui[i]%MOD+MOD)%MOD; for(int l=1,r=0;l&lt;=n;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); int res=1ll*(l+r)*(r-l+1)/2%MOD; ans=(ans+1ll*solve(n/l,m/l)*res%MOD)%MOD; &#125; printf("%d\n",ans); return 0;&#125; 毒瘤出题人不会放过我们，这个毒瘤更改了数据： $n,m \leq 10^{10}$ 。 “哇咔咔咔卡掉你们的 O(n) !” 真想一拳上去这个智障。 $O(\sqrt{n})$ 是过的了的，故考虑向着这个方向前进。 继续推式子： ans=\sum_{d=1}^{n}d\sum_{i=1}^{n}\mu(i)i^2\sum_{a=1}^{\lfloor\frac{n}{di}\rfloor}\sum_{b=1}^{\lfloor\frac{m}{di}\rfloor}ab看见这个 $di$ 了吗？我们令 $T=di$ ，然后将 $T$ 扔到前面去枚举一下。 然后就是后面的两个 $\sum$ ，这玩意跟 $i,d$ 没关系，一起扔到前面去。 于是就变成了： ans=\sum_{T=1}^{n}\sum_{a=1}^{\lfloor\frac{n}{T}\rfloor}\sum_{b=1}^{\lfloor\frac{m}{T}\rfloor}ab\sum_{i|T}i^2\frac{T}{i}\mu(i)？？？？？？？ 首先前面的这段是没有问题的对吧，那么后面的呢？ 后面的原来是不是： \sum_{d=1}^{n}d\sum_{i=1}^{n}\mu(i)i^2那么……现在我们枚举的 $T$ 是 $i \cdot d$ ，我们枚举了一下可能的 $i$ ，成为 $i$ 的必备条件肯定是能被 $T$ 整除对吧？那么这个时候的 $d$ 呢？很显然是 $\frac{T}{i}$ 对吧？ 所以啊……就是这么写了。 但是这样写有什么用啊 $QwQ$ 首先，我们来看，$i^2$ 是个什么鬼？我们设一个函数 $Q(i)=i^2$ ，于是我们可以发现，这个东西是个完全积性函数，然后看 $\frac{T}{i}$ ，显然是 $id(\frac{T}{i})$ ，也是完全积性函数。于是两个完全积性函数用狄利克雷卷积卷起来，它们的狄利克雷卷积是一定可以筛出来的。后面的 $\mu$ 是积性函数，然后呢？后面的那一坨都可以筛出来！ 于是美滋滋。 我们设 $sum[k]$ 表示当 $T$ 为 $k$ 的时候后面那一坨的值。 那么现在分三种情况： $k$ 是质数，这下子后面的 $i$ 只能是 $1$ 和 $k$ ，$1$ 的时候的值就是 $k$ ，$k$ 的时候的值是 $k^2\cdot \frac{k}{k}\cdot \mu(k)$ ，很显然这个时候的 $\mu(k)$ 的值是 $-1$ ，于是这个时候的值是 $-k^2$ ，那么这个时候 $sum[k]$ 的值是 $k-k^2$ 。 $\mu(k)$ 为 $0$ ，这下子的话就肯定有一个 $j$ ，使得 $k$ 可以整除 $j^2$ ，这个时候假设就只能整除 $j^2$ ，也就是说 $\mu(k/j)$ 的值非 $0$ 。那么我们看看，在 $sum$ 所计算的式子中，只有 $T$ 的因子对 $T$ 产生贡献。考虑 $k/j$ 到 $k$ 多了什么因子。这个时候多的因子有两类，一类是包含了 $j^2$ 的，一类是只包含了 $j$ 的。第二类的可以先不管，因为之前 $k/j$ 中有了一个 $j$ ，这类因子的贡献已经算过了。那么对于第一类因子，因为包含了 $j^2$ ，所以 $\mu$ 值为 $0$ ，对答案没有任何贡献。 那么这个时候对答案有贡献的还是 $k/j$ 的因子，乘上一个 $j$ 后没有更多的对答案造成贡献的因子。 但是我们发现上限 $T$ 变了，增大了 $j$ 倍，对于原来的每份贡献的值也增大了 $j$ 倍。由于没有其他的贡献，$k$ 的所有的贡献都来自 $k/j$ ，那么直接转移就好。 所以是$sum[k]=sum[k/j]\cdot j$ 对于剩下的情况，我们发现，这个可以直接转移了。当我们枚举 $k$ 的时候，考虑怎么用 $k$ 来转移 $k\cdot j$ ，这个时候 $j$ 是质数，并且 $k$ 中不包含 $j$ ，也就是说 $k$ 与 $j$ 互质。于是根据积性函数的性质，$sum[k]=sum[k/j]\cdot sum[j]$ 就好。 于是这个时候前面再整出分块一下，复杂度 $O(\sqrt{n})$ 。 听说有人被卡住 $O(n)$ 后没有推式子了，直接上了个杜教筛，这人一看就是杜教士了，并且也说明不珂学的上杜教筛是布星的 Code-$O(\sqrt{n})$123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; #define ll long long#define MOD 20101009#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y)) const int N=1e7+3;const int inf=1e9+9; int sum[N],vis[N],prime[N],cnt; inline void _pre_mui_sum()&#123; vis[1]=sum[1]=1; for(int i=2;i&lt;=N;++i)&#123; if(!vis[i])prime[++cnt]=i,sum[i]=(i-1ll*i*i%MOD+MOD)%MOD; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;=N)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;sum[i*prime[j]]=1ll*sum[i]*prime[j]%MOD;break;&#125; else sum[i*prime[j]]=1ll*sum[i]*sum[prime[j]]%MOD; &#125; &#125; for(int i=1;i&lt;=N;++i) sum[i]=(sum[i-1]+sum[i])%MOD;&#125; int main()&#123; int n,m; _pre_mui_sum(); scanf("%d%d",&amp;n,&amp;m); if(n&gt;m)std::swap(n,m); long long ans=0; for(int l=1,r=0;l&lt;=n;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); int res=(1ll*(1+n/l)*(n/l)/2%MOD)*(1ll*(1+m/l)*(m/l)/2%MOD)%MOD; ans+=1ll*(sum[r]-sum[l-1]+MOD)%MOD*res%MOD; ans%=MOD; &#125; printf("%lld\n",(ans+MOD)%MOD); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2015]约数个数和 莫比乌斯反演 luoguP3327]]></title>
    <url>%2F2019%2F03%2F01%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3327%2F</url>
    <content type="text"><![CDATA[又是一道神奇的题目。 一句话题意：给定 $n,m$ 求 $\sum_{i=1}^{n}\sum_{j=1}^{m}d(ij)$ 于是开始推式子： 有这么一条公式： d(ij)=\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]这个非常重要，至于证明的话，本人太弱，留个坑，到时候再填，请大家谅解 $QwQ$ 。 然后呢？发现题目求的式子后面正好是 $d(ij)$ ，于是美滋滋的套进去。 \sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x|i}\sum_{y|j}[gcd(i,j)=1]$x$ 和 $y$ 我们扔到前面去枚举，后面来计算它们对它们的倍数做出的贡献。 可以知道前面的 $x$ 在 $n$ 以内的倍数有 $\lfloor\frac{n}{x}\rfloor$ 个，$y$ 在 $m$ 以内的倍数有 $\lfloor\frac{m}{y}\rfloor$，于是： \sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x|i}\sum_{y|j}[gcd(i,j)=1]=\sum_{x=1}^{n}\sum_{y=1}^{m}\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor\cdot[gcd(i,j)=1]按照套路，我们设： f(x)=\sum_{x=1}^{n}\sum_{y=1}^{m}\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor\cdot[gcd(i,j)=k]g(k)=\sum_{x=1}^{n}\sum_{y=1}^{m}\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor\cdot[k|gcd(i,j)]那么显然有： g(k)=\sum_{k|d} f(d)这个式子很有熟悉的味道，显然是反演常见的第二种形式。 所以就有： f(k)=\sum_{k|d}\mu(\frac{d}{k})g(d)我们的答案是$f(1)$，那么就是： f(1)=\sum_{d=1}^{n}\mu(d)g(d)现在来考虑怎么计算 $g$ 。 g(k)=\sum_{x=1}^{n}\sum_{y=1}^{m}\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor\cdot[k|gcd(i,j)]后面的 $k$ 很碍眼，消掉他。 g(k)=\sum_{x=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{y=1}^{\lfloor\frac{m}{k}\rfloor}\lfloor\frac{n}{xk}\rfloor\lfloor\frac{m}{yk}\rfloor于是我们预处理一个函数 $s$ ： s(k)=\sum_{i=1}^{k}\lfloor\frac{k}{i}\rfloor那么 $g(k)$ 就很好算了： g(k)=s(n/k) \cdot s(m/k)复杂度的话还好，预处理 $s$ 时可以整出分块，$O(\sqrt{n})$ 爽歪歪。然后的话，发现统计答案的时候 $g$ 函数也可以整出分块，$O(\sqrt{n})$ 。最后总时间复杂度 $O(T\sqrt{n})$ (???)反正过了就行，我也不会算 $QwQ$ 。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=5e4+2;const int inf=1e9+9;int T,n,m,cnt;int mui[N],vis[N],prime[N];ll s[N]; inline void _pre_mui()&#123; mui[1]=1; for(int i=2;i&lt;=N;++i)&#123; if(!vis[i])prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;5e4)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;mui[i*prime[j]]=0;break;&#125; mui[i*prime[j]]=-mui[i]; &#125; &#125; for(int i=1;i&lt;=N;++i)mui[i]+=mui[i-1]; for(int x=1;x&lt;=N;++x)&#123;//实际上这里是O(n sqrt(n))，不过影响不大。 ll res=0; for(int l=1,r=0;l&lt;=x;l=r+1) r=(x/(x/l)),res+=1ll*(r-l+1)*(x/l); s[x]=res; &#125;return;&#125;inline ll solve(int n,int m)&#123; ll ans=0; if(n&gt;m)n^=m^=n^=m; for(int l=1,r=0;l&lt;=n;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); ans+=1ll*(mui[r]-mui[l-1])*s[n/l]*s[m/l]; &#125;return ans;&#125;int main()&#123; _pre_mui(); scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",solve(n,m)); &#125;return 0;&#125; =\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]ij]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 士兵占领 网络流 luogu4311]]></title>
    <url>%2F2019%2F03%2F01%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4311%2F</url>
    <content type="text"><![CDATA[讨厌死权限题了，然而这题又是 $bzoj$ 的权限题。 $QwQ$ 只好去洛谷上做了，幸好洛谷收的题目比较多。 这题就是网络流，我们先假设棋盘上摆满了士兵，这个时候需要拿走一些士兵，使得棋盘仍然是合法的，求拿走的最多数。 额……最多数让我想起了最大流，不过现在还是先来考虑怎么建图。 我们建两排点，第一排表示行，一共 $M$ 个点，第二排表示列，一共 $N$ 个点。对于一个点 $(x,y)$ ，就像从第一排的第 $x$ 号点向第二排的第 $y$ 号点连一条边权为 $1$ 的边。 这个显然是没有问题的。 然后就是限制，对于第 $k$ 行，至少要有 $L_k$ 个士兵，于是我们从 $s$ 连一条边权为 $L_k$ 的边，连向第一排的第 $k$ 号点。同样的道理，对于第二排的点，我们也像这样连边，连向 $t$ 。 然后就是跑 $dinic$ 了，别忘了跑出来的不是答案，而是最多拿走的士兵数，这个时候用整个棋盘的空位置的个数减去跑出来的 $maxflow$ 才是答案。 需要注意几个点： 当我们在看到了一个行/列的时候，需要判断一下。假设这个是行，那么这行的位置显然有 $n$ 个，如果 $n$ 减去这行障碍的个数，再减去最少要放的士兵数后为负数，那么显然就怎么也不可能有合法的方案，于是直接输出 “JIONG” 就好了。 注意整个棋盘的空位置不是 $N\cdot M$ ，而是 $N\cdot M-K$! 数组大小的话只需要开到 $2n$ ，并不需要开到 $n^2$ ，因为只有两排点。但是边的数组大小需要开到 $n^2$ ，因为我们对于棋盘上的一个点就要连一条边表示它！ Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define A printf("A")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=2e2+5;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;std::queue&lt;int&gt; q;struct Edge&#123;int nxt,to,val;&#125;G[N*N];int n,m,k,s,t,cnt(1),dep[N],head[N];int map[N][N],Li[N],Ci[N],Lm[N],Cm[N];inline void add(int u,int v,int w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt; &#125;inline bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]||G[i].val&lt;=0)continue; dep[y]=dep[x]+1,q.push(y); &#125; &#125;return dep[t];&#125; inline int dfs(int x,int flow)&#123; if(x==t||!flow)return flow; int used=0,rlow; for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow;&#125;int main()&#123; IN(m),IN(n),IN(k); s=1,t=n+m+1; int atot=n*m-k; for(int i=1;i&lt;=m;++i)IN(Li[i]); for(int i=1;i&lt;=n;++i)IN(Ci[i]); for(int i=1;i&lt;=k;++i)&#123; int x,y;IN(x),IN(y); map[x][y]=1,Lm[x]++,Cm[y]++; &#125; for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=n;++j) if(!map[i][j])add(i,j+m,1); for(int i=1;i&lt;=m;++i)&#123; int flow=n-Li[i]-Lm[i]; if(flow&lt;0)&#123;printf("JIONG!");exit(0);&#125; else add(s,i,flow); &#125; for(int i=1;i&lt;=n;++i)&#123; int flow=m-Ci[i]-Cm[i]; if(flow&lt;0)&#123;printf("JIONG!");exit(0);&#125; else add(i+m,t,flow); &#125; printf("%d\n",atot-dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 YY的GCD 莫比乌斯反演 luogu2257]]></title>
    <url>%2F2019%2F02%2F28%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2257%2F</url>
    <content type="text"><![CDATA[又是一道反演题，显然，题目要求我们求出下式： \sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)\in prime]​这个不好求，我们来推式子。 设 $n \leq m$ \sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)\in prime]=\sum_{k=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=k] \cdot[k \in prime]​=\sum_{k=1}^{n}\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{k} \rfloor}[gcd(i,j)=1]\cdot[k \in prime]我们知道 $\mu$ 函数的一个性质： [n=1]=\sum_{d|n} \mu(d)将 $n$ 换为 $gcd(i,j)$ ，然后扔回原式。 [n=1]=\sum_{d|n} \mu(d) \ \Rightarrow \ [gcd(i,j)=1]=\sum_{d|gcd(i,j)} \mu(d)\sum_{k=1}^{n}\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{k} \rfloor}\sum_{d|gcd(i,j)}\mu(d) \ \ \ (k \in prime)​=\sum_{k=1}^{n}\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{k} \rfloor}[d|gcd(i,j)]\cdot \mu(d) \ \ \ (k \in prime)=\sum_{k=1}^{n}\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{kd} \rfloor}[1|gcd(i,j)]\cdot \mu(d) \ \ \ (k \in prime)=\sum_{k=1}^{n}\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{kd} \rfloor}\mu(d) \ \ \ (k \in prime)我们知道，这里的 $\sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{kd} \rfloor}​$ 可以变成 $\lfloor \frac{n}{kd} \rfloor \lfloor \frac{m}{kd} \rfloor​$ 的，这是等价的。于是： =\sum_{k=1}^{n}\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\mu(d)\cdot \lfloor \frac{n}{kd} \rfloor \lfloor \frac{m}{kd} \rfloor \ \ \ (k \in prime)​这个式子依旧不可做，因为会超时，考虑如何再一步优化。 设 $T=kd$ ，那么我们枚举 $T$ ： =\sum_{T=1}^{n}\sum_{k|T,k\in prime}\mu(\frac{T}{k})\cdot \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$QvQ​$ 我们将 $\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor​$ 扔到前面去。 =\sum_{T=1}^{n}\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor\sum_{k|T,k\in prime}\mu(\frac{T}{k}) ​显然后面的可以预处理，预处理好了后，我们所需要计算的就是这一块： \sum_{T=1}^{n}\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T}\rfloor这个特别好处理，整除分块优化一波，复杂度 $O(\sqrt(n))$ 。 开始居然感觉这题不可做，然后想要不要用毒教筛来筛 $\mu$ 的前缀和，不过显然我是不会这种黑科技的 $QwQ$ Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e7+2;const int inf=1e9+9;int vis[N],sum[N],mui[N],f[N],prime[N],cnt;inline void _pre_mui()&#123; mui[1]=1; for(int i=2;i&lt;=N;++i)&#123; if(!vis[i])prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;N)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;mui[i*prime[j]]=0;break;&#125; else mui[i*prime[j]]=-mui[i]; &#125; &#125; for(int i=1;i&lt;=cnt;++i) for(int j=1;prime[i]*j&lt;=N;++j) f[j*prime[i]]+=mui[j]; for(int i=1;i&lt;=N;++i)sum[i]=sum[i-1]+f[i]; return;&#125;inline ll solve(int n,int m)&#123; ll ans=0; for(int l=1,r=0;l&lt;=n;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); ans+=(ll)(sum[r]-sum[l-1])*(ll)(n/l)*(ll)(m/l); &#125;return ans;&#125;int main()&#123; _pre_mui(); int n,m,T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); if(n&gt;m)std::swap(n,m); printf("%lld\n",solve(n,m)); &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数论】从狄利克雷卷积到莫比乌斯反演]]></title>
    <url>%2F2019%2F02%2F27%2F%5B%E6%95%B0%E8%AE%BA%5DDirichley%E5%88%B0Mobius%2F</url>
    <content type="text"><![CDATA[前面一直搞不懂，于是找到了一些不错的文章，跟着文章推一推式子，居然豁然开朗了。 现在还在尝试着看毒教筛，毒教筛的总结后面再说吧。 由于本人的水平问题，文章或许会有些纰漏，还请大佬们指教 $Qiuly$ 的 $QQ$ 号：$2641450959$($Qiuly=monlights$ 一个人 ) 本文不用十六进制标题，换了种形式 因为公式量较大，所以加载速度较慢，需要等待几秒方可食用 前置技能：积性函数积性函数的定义：$1.$ 若 $f(n)$ 的定义域为正整数域，值域为复数，则称 $f(n)$ 为数论函数。 $2.​$ 若 $f(n)​$ 是一个数论函数，且 $f(1)=1​$ ，并且对于一对互质的数 $p,q​$ ，有 $f(p) \cdot f(q)=f(p \cdot q)​$，那么称 $f​$ 为积性函数。 $3.$ 若 $f(n)$ 是一个积性函数，并且对于任意的整数 $p,q$ ，都有 $f(p) \cdot f(q)=f(p \cdot q)$，那么称 $f$ 为完全积性函数。 常见的积性函数：$1.​$ 约数和函数 $\sigma​$ ，$\sigma(n)=\sum_{d|n} d​$ ，为 $n​$ 的所有约数之和，积性函数。 $2.​$ 欧拉函数 $\varphi​$ ，$\varphi(n)=\sum_{i=1}^{n} [gcd(n,i)=1] \cdot1​$，表示不大于 $n​$ 且与 $n​$ 互质的数的个数，积性函数。 $3.​$ 莫比乌斯函数 $\mu​$ ，$\mu(1)=1​$，对于一个 $n=\prod_{i=1}^{s} p_i​$，$\mu(n)=(-1)^s​$，其余情况 $\mu(n)=0​$，积性函数。 $4.$ 元函数 $e$ ，$e(n)=[n=1]$ ，完全积性函数，狄利克雷卷积单位元函数。 $5.$ 恒等函数 $I$，$I(n)$ =1，完全积性函数。 $6.$ 单位函数 $id$ ，$id(n)=n​$，完全积性函数。 关于一些积性函数的基本性质：$1.​$ $[n=1]=\sum_{d|n} \mu(d)​$ $2.​$ $\sum_{i=1}^{n} [gcd(n,i)=1] \cdot i=\frac{n \cdot \varphi(n)+[n=1]}{2}​$ $3.​$ $n=\sum_{d|n} \varphi(d)​$ 狄利克雷卷积定义：现有数论函数 $f$ 和 $g$，其狄利克雷卷积为 $(fg)(n)=\sum_{d|n} f(d) \cdot g(\frac{n}{d})$ 。狄利克雷卷积对于乘法满足交换律、结合律、分配律，对于单位元函数 $e(n)=[n=1]$ ，有 $fe=f=ef$ 。若 $f,g$ 为积性函数，那么 $(fg)$ 也为积性函数。 公式 ：当 $f​$ 为积性函数的时候，设 $n=\prod_{i=1}^{s} p_i^{k_i}​$ ，$g(n)=\sum_{d|n}f(d)​$ ，则有 $g(n)=\prod_{i=1}^{s} \sum_{j=0}^{k_i}f(p_i^j)​$ 。 举个例子，假设 $n=6$ 。 p1=2,p2=3,k1=1,k2=1,s=2​g(n)=\sum_{d|n}f(d) :\\= g(6)=\sum_{d|n} f(d)=f(1)+f(2)+f(3)+f(6)那么可以得知，按照 $g(n)=\sum_{d|n}f(d)​$ 来计算，$g(6)​$ 的值为 $f(1)+f(2)+f(3)+f(4)​$ g(n)=\prod_{i=1}^{s} \sum_{j=0}^{k_i}f(p_i^j):\\=g(6)=\prod_{i=1}^{s} \sum_{j=0}^{k} f(p_i^j)=g(6)=\prod_{i=1}^{s} (f(1)+f(p_i))=g(6)=(f(1)+f(2)) \times (f(1)+f(3))=g(6)=f(1)f(1)+f(1)f(3)+f(2)f(1)+f(2)f(3)因为 $f​$ 是积性函数，所以： 因为 $1$ 与 $1$ 互质，所以 $f(1) \cdot f(1)=f(1 \cdot1)=f(1)$ 因为 $1​$ 与 $3​$ 互质，所以 $f(1)\cdot f(3)=f(1 \cdot 3)=f(3)​$ 因为 $2$ 与 $1$ 互质，所以 $f(2) \cdot f(1)=f(2\cdot1)=f(2)$ 因为 $2​$ 与 $3​$ 互质，所以 $f(2) \cdot f(3) = f(2 \cdot 3)=f(6)​$ g(6)=f(1)+f(3)+f(2)+f(6)上下两式相同，因此式子的正确性可以保证。 莫比乌斯反演莫比乌斯反演的基本形式一般如下： g(n)=\sum_{d|n} f(d)​式子中不要求 $f$ 是积性函数。 那么莫比乌斯反演解决的问题一般先是给定 $g$ 函数或是可以很简单的算出 $g$ 函数的情况下，要求推出 $f$ 函数，这个时候 $n$ 的范围一般为 $10^7$ 甚至更高，我们不可能直接从上式暴力推 $f$ 函数，这个时候就需要用到 $\mu$ 函数了。 可以发现，$I$ 函数总是有着奇特的性质，可以使得 $g=f*I$ 。 怎么证明呢？推式子。 $f$ 和 $I$ 的狄利克雷卷积： (f*I)(n)=\sum_{d|n} f(d) \cdot I(\frac{n}{d})​由于 $I(n)=1$ ，那么后面的 $I(\frac{n}{d})$ 的值为 $1$ ，可以将其无视，则： (f*I)(n)=\sum_{d|n} f(d)=g(n)但是这还不能满足，于是我们又发现，$\mu$ 函数有奇效，可以使得 $I*\mu=e$ 怎么证明呢？任然推式子。 $I$ 和 $\mu$ 的狄利克雷卷积： $(I*\mu)(n)=\sum_{d|n}I(d)\cdot \mu(\frac{n}{d})$ 显然 $I(d)=1$ ，可以将其无视，那么就有： $(I*\mu)(n)=\sum_{d|n} \mu(\frac{n}{d})=\sum_{d|n}\mu(d)=e(n)​$ 可以看到，当且仅当 $n=1​$ 的时候 $\sum_{d|n}\mu(\frac{n}{d})​$ 才是有值的，否则所在所有计算的 $\mu​$ 中， $-1​$ 和 $1​$ 的出现次数一定是一样的。 继续推式子。 f*I=g=f*I*\mu=g*\mu=f*(I*\mu)=f*e=g*\mu于是计算 $f*e​$ ： (f*e)(n)=\sum_{d|n} f(d) \cdot e(\frac{n}{d})由于 $e(n)=[n=1]​$ ，只有 $n=1​$ 的时候函数才有值。那么显然 $n\neq d​$ 的时候 $e(\frac{n}{d})​$ 为 $0​$ ，这对答案完全没有贡献。只有在 $n=d​$ 的时候才对答案有贡献。这个时候我们所加上的就是 $f(n)​$ ，这也证明了上面写的 “$fe=f=ef​$”。 于是： f*e=f=g*\muf(n)=(g*\mu)(n)然后计算 $(g*\mu)(n)$ 的狄利克雷卷积。 (g*\mu)(n)=\sum_{d|n} g(d) \cdot \mu(\frac{n}{d})那么最后可以得到式子： $f(n)=\sum_{d|n} g(d) \cdot \mu(\frac{n}{d})​$ 这只是常见形式的一种，一共有两种常见的形式(包括此形式)： g(n)=\sum_{d|n}f(d) \ \Rightarrow \ f(n)=\sum_{d|n} g(d) \cdot \mu(\frac{n}{d})​g(n)=\sum_{n|d} f(n) \ \Rightarrow \ f(n)=\sum_{n|d}g(n) \cdot \mu(\frac{d}{n})​莫比乌斯函数与欧拉函数的关系实际上莫比乌斯函数与欧拉函数是有关系的，接下来我们来推出这种关系。 从上面的章节中可以知道，$n=\sum_{d|n} \varphi(d)​$。 n=\sum_{d|n} \varphi(d) \ \Rightarrow \ id(n)=\sum_{d|n} \varphi(d)​\sum_{d|n} \varphi(d) = \sum_{d|n} \varphi(\frac{n}{d})​从上面我们将 $\mu​$ 与 $I​$ 用狄利克雷卷积卷起来的时候会发现答案为 $\sum_{d|n}\mu(d)​$，也就是说对于一个积性函数 $f​$ ，将 $f​$ 和 $I​$ 用狄利克雷卷积卷起来时，可以得到： (f*I)(n)=\sum_{d|n} f(d)​很显然，$\varphi$ 也是积性函数，如果我们将上式的 $f$ 函数改为 $\varphi$ 函数，形式是不变的，那么式子就会变成： (\varphi*I)(n)=\sum_{d|n} \varphi(d)​居然跟上面的式子对上了，于是我们将上面的式子中的 $\sum_{d|n} \varphi(d)​$ 替换为 $(\varphi*I)(n)​$，版上面的式子就变成这样： (\varphi*I)(n)=id(n) \ \Rightarrow \ \varphi*I=id=\varphi*I*\mu=id*\mu​= \varphi*e=id*\mu我们在上面也知道，积性函数 $f​$ 卷上 $e​$ 后的结果任然是 $f​$ ，$\varphi​$ 为积性函数，那么： \varphi=id*\mu我们来计算 $id*\mu$ ： (id*\mu)(n)=\sum_{d|n} id(d)\cdot \mu(\frac{n}{d})​\sum_{d|n} id(d)\cdot \mu(\frac{n}{d})=\sum_{d|n} id(\frac{n}{d})\cdot \mu(d)=\sum_{d|n} \mu(d)\cdot \frac{n}{d}​最终： \varphi(n)=\sum_{d|n} \mu(d)\cdot \frac{n}{d}​=\frac{\varphi(n)}{n}=\sum_{d|n} \frac{\mu(d)}{d}​至此，我们得到了莫比乌斯函数与欧拉函数的关系。 莫比乌斯函数预处理代码直接用线性筛就好，如果数据范围大的话也可以用杜教筛。 12345678910111213inline int _Pre_mui()&#123; mui[1]=1; for(int i=2;i&lt;=N;++i)&#123; if(!vis[i])prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;=N)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;mui[i*prime[j]]=0;break;&#125; else mui[i*prime[j]]=-mui[i]; &#125; &#125;for(int i=1;i&lt;=N;++i)sum[i]=sum[i-1]+mui[i]; return 0;&#125; 莫比乌斯反演题目选讲1. [POI2007] ZAP-Queries传送门：luogu题解：Qiuly’s blog2. YY的GCD传送门：luogu题解：Qiuly’s blog更多详情见 $9012.x.xx$ 完成的杜教筛小结，预计 $x$ 将会是 $4$ $QAQ$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>总结</tag>
        <tag>莫比乌斯反演</tag>
        <tag>狄利克雷卷积</tag>
        <tag>莫比乌斯函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [POI2007]ZAP-Queries 莫比乌斯反演 luogu3455]]></title>
    <url>%2F2019%2F02%2F27%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3455%2F</url>
    <content type="text"><![CDATA[很显然是让我们求出下式： ans=\sum_{i=1}^{A}\sum_{j=1}^{B}[gcd(i,j)=K]根据性质可以得到： ans=\sum_{i=1}^{\lfloor\frac{A}{K}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{K}\rfloor}[gcd(i,j)=1]我们设两个函数： 函数 $f$，$f(x)$ 表示 $\sum_{i=1}^{\lfloor\frac{A}{K}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{K}\rfloor}[gcd(i,j)=x]$ 函数 $g$ ，$g(x)$ 表示 $\sum_{i=1}^{\lfloor\frac{A}{K}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{K}\rfloor}[x|gcd(i,j)]$ 我们可以得到： g(x)=\sum_{x|d} f(x)这是莫比乌斯反演的第二个形式： g(n)=\sum_{n|d} f(n) \ \Rightarrow \ f(n)=\sum_{n|d}g(d) \cdot \mu(\frac{d}{n})于是： g(x)=\sum_{x|d} f(x) \ \Rightarrow \ f(x)=\sum_{x|d}g(x) \cdot \mu(\frac{d}{x})=g(x)=\sum_{x|d} f(x) \ \Rightarrow \ f(x)=\sum_{x|d}g(\frac{d}{x}) \cdot \mu(x)设 $n=\lfloor\frac{A}{K}\rfloor\ ,\ m=\lfloor\frac{B}{K}\rfloor$ 那么： g(x)=\sum_{i=1}^{n}\sum_{i=1}^{m} [x|gcd(i,j)]=\sum_{i=1}^{\lfloor\frac{n}{K}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{K}\rfloor}[1|gcd(i,j)]=\sum_{i=1}^{\lfloor\frac{n}{K}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{K}\rfloor}[1|gcd(i,j)]=\lfloor\frac{A}{K}\rfloor \times\lfloor\frac{B}{K}\rfloorans=f(1)f(1)=\sum_{i=1}^{n}\mu(i)*g(i)=\sum_{i=1}^{n}\mu(i)*\lfloor\frac{A}{K}\rfloor *\lfloor\frac{B}{K}\rfloor这个式子是 $O(n)$ 的。 发现 $\lfloor\frac{A}{K}\rfloor \times\lfloor\frac{B}{K}\rfloor$ 可以整除分块，于是我们便可以做到 $O(\sqrt{x})$ Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int N=1e5+2;const int inf=1e9+9;int T,cnt;int prime[N],mui[N],vis[N];long long sum[N];inline int _Pre_mui()&#123; mui[1]=1; for(int i=2;i&lt;=N;++i)&#123; if(!vis[i])prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;=N)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;mui[i*prime[j]]=0;break;&#125; else mui[i*prime[j]]=-mui[i]; &#125; &#125;for(int i=1;i&lt;=N;++i)sum[i]=sum[i-1]+mui[i]; return 0;&#125;#define min(x,y) ((x)&lt;(y)?(x):(y))inline void solve(int n,int m,int k)&#123; long long ans=0; n/=k,m/=k; int lim=min(n,m); for(int i=1;i&lt;=lim;)&#123; long long j=min(n/(n/i),m/(m/i)); ans+=1ll*(sum[j]-sum[i-1])*(n/i)*(m/i); i=j+1; &#125;printf("%lld\n",ans); return;&#125;int main()&#123; _Pre_mui(); scanf("%d",&amp;T); while(T--)&#123; int n,m,k; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); solve(n,m,k); &#125;return 0; &#125; 所以就没了。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 tower 网络流 bzoj4657]]></title>
    <url>%2F2019%2F02%2F26%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj4657%2F</url>
    <content type="text"><![CDATA[考试的时候正好考了这道题，全场仅有 $lys$ 大佬 $AC$ 。 都 $GG$ 了（当然我最惨，暴力分居然被卡了，只有 $10$ 分 $QwQ$）。 我们来看一下题目： 题目的阶梯数据真良心！ 20分做法很显然，$n,m \le 5$ ，分明是摆着让我们爆搜，那么直接暴力枚举打那个，处理一下路线的交叉问题就好了。 然而我菜爆了，这个居然打挂了，然后就只剩下 $10$ 分了 $QvQ$。 40分做法可以加一个剪枝，怎么剪呢？ 对于一个炮塔，假设我们之前在其打击范围内已经找到了一个点，该点跟该炮塔的曼哈顿距离是 $x$ ，其权值为 $a$ ,然后现在我们继续 $dfs$ ，发现又找到了一个点也在打击范围内，该点的与该炮的曼哈顿距离是 $y$ ，其权值是 $b$ 。 那么现在我们假设 $xb$ ，那么显然，对于最优的方案，该炮塔肯定不会打 $b$ 权值的点。也就是说，$b$ 权值的点没有 $a$ 权值的点优，因为权值少了，收益没那么大，并且风险(距离)(指容易被打断的风险)增加了。这时我们便可以放弃 $b$ 点，这就是一个小小的剪枝优化。 100分做法考虑最小割。 对于每一个炮塔，我们将其能打出去的范围的所有点连成一条链，这条链的两端分别连着 $s$ 和 $t$ 。 这个时候的 “割” 就是说你这个炮打到哪里结束。 如下图： 那么网络流的图中，这条链中 $3-4$ 的这条边被切断了。 所以我们每一个炮有一个打到的地方(当然可以不打)，这个时候每一条链都断了，所以图就断了。 但是关系并没有那么简单，假设现在又有一个炮塔，其轨迹跟现在的炮相交了，如果相交的点的编号 $&lt;3$，显然这个红炮是不可以打到小蓝点( $3$ 号点)的，我们该如何表示这种关系呢？ 现在所表示的状况： 现在的状况就是，相交点上面的点都打不到了(红炮)，相交点右边的点都打不到了(蓝炮)。 但是我们一定要保证 $S$ 到 $T$ 的联通。 那么就可以确定，如果红炮所在的点连接 $S$ ，那么蓝炮就连 $T$，这样才可以使 $S$ 和 $T$ 连通。 然后来解决怎么处理相交点的连边问题。 但是，如果按照上面的 “红炮连 $S$ ，蓝炮连 $T$” 的话，直接这样连不就好了吗？ 仔细想一想，这其实是布星的，因为我们要保证这个相交点的关系不会被割掉，那么就因该将边值设为 $inf$，但是设哪条边呢？这里所有的边的值都是这个点的权值，我们不可能直接改点的权值吧？ 那么很显然，我们将相交点拆成两个点，这两个点中间连有一条边权为 $inf$ 的边，这时无论如何都割不掉这个点了。 最后就是，既然要求最小割，对于如果炮不启动的话边权是 $0$ ，那么就达成了 “最小” 的效果，这是错的。所以我们设一个常量 $T$ ，将每条边的边权都设为 $T-v_i$ 就好。 然后就是板子 $Dinic$。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; #define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define id(i,j,type) type*n*m+(i-1)*m+j const int N=5e1+6;const int inf=1e9+9;const int dx[4]=&#123;-1,1,0,0&#125;;const int dy[4]=&#123;0,0,-1,1&#125;; int map[N][N],ans,n,m,s,t;int cnt(1),head[N*N*2],dep[N*N*2];struct Edge&#123;int nxt,to,val;&#125;G[N*N&lt;&lt;2];std::queue&lt;int&gt; q; bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i;i=G[i].nxt)&#123; int v=G[i].to; if(!dep[v]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,q.push(v); &#125; &#125;return dep[t];&#125;int dfs(int u,int flow)&#123; if(u==t||!flow)return flow; int used=0,rlow; for(int i=head[u];i;i=G[i].nxt)&#123; int v=G[i].to; if(dep[v]==dep[u]+1&amp;&amp;G[i].val&gt;0)&#123; used+=(rlow=dfs(v,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[u]=-1; return used;&#125; int Dinic()&#123; int maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow;&#125; void add(int u,int v,int w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) scanf("%d",&amp;map[i][j]); s=0,t=n*m*2+1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; if(map[i][j]&lt;0)&#123; int direction=-map[i][j]-1; int x=i,y=j,Mx_val=0; while(true)&#123; x+=dx[direction],y+=dy[direction]; if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)break; Mx_val=max(Mx_val,map[x][y]); &#125;ans+=Mx_val; if(direction&lt;2)add(s,id(i,j,0),inf); else add(id(i,j,1),t,inf); x=i,y=j; while(true)&#123; int tx=x,ty=y; x+=dx[direction],y+=dy[direction]; if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)break; if(direction&lt;2)add(id(tx,ty,0),id(x,y,0),Mx_val-max(0,map[tx][ty])); else add(id(x,y,1),id(tx,ty,1),Mx_val-max(0,map[tx][ty])); &#125; &#125;else add(id(i,j,0),id(i,j,1),inf); &#125; printf("%d\n",ans-Dinic()); return 0;&#125; 为什么之前没想出来呢？]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2009]诗人小G 四边形不等式/决策单调性优化DP luoguP1912]]></title>
    <url>%2F2019%2F02%2F25%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1912%2F</url>
    <content type="text"><![CDATA[神奇的题目 $QvQ$ ，卡了我好久。 哎，主要是细节要处理到位，否则就会 WA 声满片。 记录一下我壮观的提交记录： 太杯具了 $QvQ$ (扯谈扯不下去了…….) 进入正题吧。 路人甲：$bzoj$ 上居然没有这道题？导演：赶紧走开，不管你的事 这题明显是 $DP$，我们可以很简单的得到 $DP$ 方程： 设 $f[i]$ 表示对前 $i$ 句诗排版后的最小不协调度，那么很显然，对于一个现在我们需要转移的 $i$，我们会找到一个最优的 $j$ ，使得第 $j+1$ 句到第 $i$ 句组成一个新的行。那么之前的行的总共的最小不协调度显然是 $f[j]$，现在我们就来计算一下 $f[i]$ 的最小不协调度。 显然，是下式(其中 $sum$ 是句子长度的前缀和)： f[i]=f[j]+{|sum[i]-sum[j]-L-1|}^P这就是状态转移方程，的确很好理解。但是……这样子做是 $O(N^2)$ 的复杂度，只能拿 $30$ 分。 而按照题目的数据范围，正解的复杂度因该是 $O(n log n)$ 左右。接下来考虑怎么优化。 经打表观察发现，如果我们将每次用作转移 $i$ 的最优的 $j$ 存起来，输出时会发现，$j$ 是单调递增的。 证明的话的确不好证，可以看看 $lyd$ 的书。但是按照实际理解一下是可以的，我们将 $j$ 后面的一直到 $i$ 的句子组成了新的一行，那么如果 $j$ 不单调上升的话，新的一句将会变的很长很长很长，那么这时这句造成的不协调度将会以几何数的形式疯狂增长，那么唯一的方法就是将这句长句断句，这样子 $j$ 就会变大，可以感性理解一下 $QvQ$。 但是我们知道了 $j$ 是单调上升的这条性质有什么用呢？ 很显然，每一次转移的时候不必往前找了，直接往后找。 我们维护一个队列，队列里的每一个元素有三个变量：$l,r,c$ ，其中 $l$ 和 $r$ 表示 $c$ 这个决策的适用范围，并且在这个范围中 $c$ 是最优的 $j$。 那么现在有了一个新的 $i$，考虑怎么维护这个队列。 我们可以先找到 $i$ 所在的范围的最优的 $j$，那么这时我们检查队头，如果队头的范围已经不包括 $i$ 了，那么直接弹出，因为既然队头的范围不包括 $i$ 了，那么这个队头对 $i+1$ 及后面的元素都不能产生贡献，故直接弹出。 弹出无用的队头后，转移的话就是 $O(1)$ 了：直接取队头转移不就好了吗？ 那么现在考虑怎么将 $i$ 加入这个队列，或许这个 $i$ 也会对后面的元素产生贡献。 我们检查当前的队尾，怎么判断这个队尾是否比 $i$ 更优呢？现在队尾的范围是 $l,r$ ，如果 $i$ 更新 $l$ 比 $c$ 更新 $l$ 更优，显然 $i$ 会比当前 $l,r$ 范围类的所有的 $c$ 更优，故弹出队尾。 那么，假设现在我们碰到了一个队尾，其中 $i$ 更新 $r$ 更优， $c$ 更新 $l$ 更优，怎么办呢？也就是说这个元素的范围中分成两半，前一半 $c$ 更新更优，后一半 $i$ 更新更优，显然要拆成两个队列元素。那么我们怎么知道这个位置呢？二分！ 那么这个时候我们可以得到答案了，只是输出怎么办呢？ 很简单，每次转移的时候记录一下转移自哪里，这就是分行，然后输出即可。 最后就是精度问题。 题目要求，如果 $f[n]$ (即所有句子排版后的最小不协调度) 还是大于了 $1e18$ ，那么输出 “$Too \ hard\ to\ arrange$”，但是如果在 $DP$ 的过程中就炸了 $long \ long$，那就 $GG$ 了。所以我们使用 $long \ double$ ，精度更高，(不会 $int$ 的，这辈子也不会用 $int$ 的)。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll;typedef long double ld;const int NS=1e5+2;const int inf=1e9+9;int T,N,L,P;int head,tail;int last[NS],ans[NS],Next[NS];struct Node&#123;int c,l,r;&#125;q[NS];char s[NS][35];ld sum[NS],f[NS];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;void clear()&#123; memset(last,0,sizeof(last)); memset(sum,0,sizeof(sum)); memset(q,0,sizeof(q)); memset(s,0,sizeof(s)); memset(f,0,sizeof(f));&#125;ld pows(ld x,int y)&#123;//快速幂 ld ans=1; for(;y;y&gt;&gt;=1,x*=x)if(y&amp;1)ans*=x; return ans;&#125;ld val(int j,int i)&#123;//转移函数 return f[j]+pows(abs(sum[i]-sum[j]-L-1),P);&#125;void half(int i)&#123;//二分过程 int now=q[tail].c,ls=q[tail].l,rs=q[tail].r;//当前队尾范围 int ret=q[tail].r+1; while(ls&lt;=rs)&#123; int mid=(ls+rs)&gt;&gt;1; if(val(i,mid)&lt;=val(now,mid))rs=mid-1,ret=mid;//i更优 else ls=mid+1;//c更优 &#125; if(ret!=q[tail].l)q[tail].r=ret-1;//分成了两半 else --tail;//整个元素都比不过i if(ret&lt;=N)q[++tail]=(Node)&#123;i,ret,N&#125;;//i分了一个区间时，加入新元素&#125;void output()&#123;//值得拥有的鬼畜输出 if(f[N]&gt;1e18)puts("Too hard to arrange");//无解，放心判1e18 else&#123; printf("%lld\n",(ll)(f[N]+0.5));//注意精度问题 for(int i=N;i;i=last[i])Next[last[i]]=i;//输出 int now=0; for(int i=1;i&lt;=N;++i)&#123; now=Next[now]; for(int j=i;j&lt;now;++j)printf("%s ",s[j]); printf("%s\n",s[now]); i=now; &#125; &#125; puts("--------------------");//注意 return;&#125;int main()&#123; IN(T); while(T--)&#123; clear(); IN(N),IN(L),IN(P); for(int i=1;i&lt;=N;++i)&#123; scanf("%s",s[i]); sum[i]=sum[i-1]+strlen(s[i])+1;//做前缀和 /*因为输出是有空格的，所以加上一个1*/ &#125; q[head=tail=1]=(Node)&#123;0,1,N&#125;;//初始元素 for(int i=1;i&lt;=N;++i)&#123; while(head&lt;tail&amp;&amp;q[head].r&lt;i)++head;//淘汰无用队头 ++q[head].l; f[i]=val(q[head].c,i);//O(1) 转移 last[i]=q[head].c;//记录“转移自哪里” while(head&lt;tail&amp;&amp;val(i,q[tail].l)&lt;=val(q[tail].c,q[tail].l))tail--;//弹出劣质队尾 half(i);//二分 &#125; output();//鬼畜输出 &#125; return 0;//终于结束&#125; 最后，我有个问题。 这是写的什么文章啊 $QvQ$ ，让我们来猜测一下。 白日依山尽，黄河入海流，欲穷千里目，更上一层楼。 这是 小 $G$ 写的？作者明明不是小 $G$ 好不好。 $QvQ$ 有毒啊……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>四边形不等式</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [USACO4.4]Pollutant Control 网络流 luoguP1344]]></title>
    <url>%2F2019%2F02%2F24%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1344%2F</url>
    <content type="text"><![CDATA[有必要么……直接打个电话给零售商：”我的牛奶不对，不要收牛奶！”不久可以了吗…… (好了好了这是扯淡) 显然这个运输图的 $1$ 号点就是公司发送牛奶的地方，$n$ 号点就是零售商，然后每一条边就是这个货车的出发点与到达点，边权即为拦截这个货车的代价。 然后呢？ 最小的损失……使 $1$ 到不了 $n$ ，这显然就是最小割啊 $QwQ$ 那么这样损失数就很容易得到了，那么最少要停的卡车数怎么求呢？很显然，我们任然跑最小割，那么这个图我们将所有边都设为 $1$ ，显然现在的最小割就是最少要停的卡车数。 很显然，时间爆炸，满屏惊喜！ 这里有一种方法！我们设一个常数 $T$ ，假设当前边的边权是 $w$ ，那么我们实际连一条边权为 $w \times T+1$ 的边，其中最小损失数显然为 $maxflow/T$ ，那么最少要停的卡车数呢？显然就是 $maxflow\ \%\ T$。 这里的 $T$ 要足够大，否则如果每条边后面的 $+1$ 乘上割的边数大于了 $T$ ，然后 $\%$ 一下，恭喜你！你 $GG$ 了。实际上 “足够大” 只要大于边数就好了，显然这样子建边是要开 $long long$ 的，否则会炸。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define A printf("A")#define ll long long#define RI register int#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const ll N=1e5+5;const ll inf=1e9+9;const ll T=2019;//2019新年快乐(尽管现在不是时候了)template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;std::queue&lt;int&gt; q;struct Edge&#123;ll nxt,to,val;&#125;G[N];ll n,m,s,t,cnt(1),dep[N],head[N];inline void add(ll u,ll v,ll w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt; &#125;inline bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; ll x=q.front();q.pop(); for(ll i=head[x];i;i=G[i].nxt)&#123; ll y=G[i].to; if(dep[y]||G[i].val&lt;=0)continue; dep[y]=dep[x]+1,q.push(y); &#125; &#125;return dep[t];&#125; inline ll dfs(ll x,ll flow)&#123; if(x==t||!flow)return flow; ll used=0,rlow; for(ll i=head[x];i;i=G[i].nxt)&#123; ll y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used;&#125;int main()&#123; IN(n),IN(m);s=1,t=n; for(ll i=1;i&lt;=m;++i)&#123; ll u,v,w;IN(u),IN(v),IN(w); add(u,v,w*T+1); &#125; ll maxflow=0; while(bfs())maxflow+=dfs(s,inf); printf("%lld %lld\n",maxflow/T,maxflow%T); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2001]食物链 并查集 luoguP2024]]></title>
    <url>%2F2019%2F02%2F22%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2024%2F</url>
    <content type="text"><![CDATA[并不是很难。 首先，我们将一个点 $x$ 拆分成三个点：$x_{eat},x_{sim},x_{emy}$， $x_{eat}$ 表示 $x$ 的食物，$x_{sim}$ 表示 $x$ 的同类，$x_{emy}$ 表示 $x$ 的天敌。 然后，对于一句真话： 如果是表示 $x​$ 是 $y​$ 的同类，那么很显然，$x​$ 的食物就是 $y​$ 的食物， $x​$ 的天敌就是 $y​$ 的天敌，于是讲 $x_{sim}​$ 和 $y_{sim}​$ 所在的并查集合并，将 $x_{eat}​$ 和 $y_{eat}​$ 所在的并查集合并，最后将 $x_{emy}​$ 和 $y_{emy}​$ 所在的并查集合并即可。 如果这句表示 $x$ 吃 $y$ ，那么很显然，$x$ 的食物就是 $y$ 的同类，$x$ 的天敌就是 $y$ 的食物(因为是环形)，$x$ 的同类都是 $y$ 的天敌，故将这些关系的并查集一次合并即可。 怎么判断一句话的真假呢？ 显然，如果 $x&gt;n||y&gt;n$ 就是假话，对于两个操作： 如果表示 $x​$ 是 $y​$ 的同类，那么 $x_{eat}​$ 不能和 $y_{sim}​$ 在同一个并查集中，$x_{sim}​$ 不能和 $y_{eat}​$ 在同一个并查集中，否则就与前面的话冲突了。 如果表示 $x$ 吃 $y$ ，首先 $x$ 和 $y$ 不能是同类(即 $x_{sim}$ 不能和 $y_{sim}$ 在一个并查集中)，然后 $y_{eat}$ 不能和 $x_{sim}$ 在一个并查集中，显然违反了以上的就是假话。 然后码量极小： Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int N=5e4+2;const int inf=1e9+9;const int K=1e5+2;int fa[N*3],ans,n,k;inline int sim(int x)&#123;return x;&#125;;inline int eat(int x)&#123;return x+n;&#125;;inline int emy(int x)&#123;return x+n+n;&#125;;int find(int x)&#123;return x==fa[x]?x:fa[x]=find(fa[x]);&#125;;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n*3;++i)fa[i]=i; for(int i=1;i&lt;=k;++i)&#123; int op,x,y; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if(x&gt;n||y&gt;n)&#123;++ans;continue;&#125; if(op==1)&#123; if(find(eat(x))==find(sim(y))||find(sim(x))==find(eat(y)))&#123;++ans;&#125; else&#123; fa[find(sim(x))]=find(sim(y)); fa[find(eat(x))]=find(eat(y)); fa[find(emy(x))]=find(emy(y)); &#125; &#125;else&#123; if(find(sim(x))==find(sim(y))||find(sim(x))==find(eat(y)))&#123;++ans;&#125; else&#123; fa[find(eat(x))]=find(sim(y)); fa[find(emy(x))]=find(eat(y)); fa[find(sim(x))]=find(emy(y)); &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; 我绝对不会告诉你们，我有一处地方 $sim$ 写成了 $sin$ 而调了半个小时]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [BOI2007]Mokia CDQ分治 luogu4390]]></title>
    <url>%2F2019%2F02%2F22%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4390%2F</url>
    <content type="text"><![CDATA[BBQ烤翅，CDQ分治。 一道很裸的三位偏序，允许离线的话，就上CDQ分治，当然想当码农可以敲树套树。 很显然，三维就是 $x$ 轴，$y$ 轴，和时间。 然后将一个矩阵的询问拆成四个询问，按照容斥的方式搞，这显然是可以且简单的，但是询问数将会爆炸 $QvQ$ (但是没有炸，不舒服) $long long$ 也要开，不然会炸。 然后就这样了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const ll N=2e6+2;const ll inf=1e9+9;ll s,w,tot,c[N];struct Node&#123; ll x,y,ans,pos,type;&#125;q[N],hep[N];bool cmp(const Node&amp;x,const Node&amp;y)&#123;return x.pos&lt;y.pos;&#125;;struct BIT&#123; void add(ll x,ll v)&#123;for(;x&lt;=w;x+=(x&amp;-x))c[x]+=v;&#125;; ll sum(ll x)&#123;ll res=0;for(;x;x-=(x&amp;-x))res+=c[x];return res;&#125;; void clr(ll x)&#123;for(;x&lt;=w;x+=(x&amp;-x))c[x]=0;&#125;;&#125;T;void CDQ(ll l,ll r)&#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; CDQ(l,mid);CDQ(mid+1,r); ll i=l,j=mid+1,cnt=l; /*CDQ的主要流程*/ while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(q[i].x&lt;=q[j].x)&#123; /*注意这一题询问和修改是不一样的，不像陌上花开那题，每个元素即使修改对答案做贡献，也是询问*/ if(!q[i].type)T.add(q[i].y,q[i].ans);/*这是修改，树状数组标记一下*/ hep[cnt++]=q[i++];/*归并排序*/ &#125;else&#123; if(q[j].type)q[j].ans+=T.sum(q[j].y);/*询问，更新答案*/ hep[cnt++]=q[j++]; &#125; &#125; /*将剩下的元素排序好，更新好答案*/ while(i&lt;=mid)&#123; if(!q[i].type)T.add(q[i].y,q[i].ans); hep[cnt++]=q[i++]; &#125; while(j&lt;=r)&#123; if(q[j].type)q[j].ans+=T.sum(q[j].y); hep[cnt++]=q[j++]; &#125; for(ll o=l;o&lt;=mid;++o)/*清除本次操作在树状数组上留下的痕迹*/ if(!q[o].type)T.clr(q[o].y); for(ll o=l;o&lt;=r;++o)q[o]=hep[o];/*更新原数组*/&#125;int main()&#123; ll op; scanf("%lld%lld",&amp;s,&amp;w); while(scanf("%lld",&amp;op),op^3)&#123; ll x,y,z,x1,x2,y1,y2; if(op==1)&#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); q[++tot]=(Node)&#123;x,y,z,tot,0&#125;; &#125;else&#123; scanf("%lld%lld%lld%lld",&amp;x1,&amp;y1,&amp;x2,&amp;y2); /*四个询问*/ q[++tot]=(Node)&#123;x2,y2,0,tot,1&#125;; q[++tot]=(Node)&#123;x1-1,y2,0,tot,1&#125;; q[++tot]=(Node)&#123;x2,y1-1,0,tot,1&#125;; q[++tot]=(Node)&#123;x1-1,y1-1,0,tot,1&#125;; &#125; &#125; CDQ(1,tot); std::sort(q+1,q+tot+1,cmp); for(ll i=1;i&lt;=tot;++i) if(q[i].type)&#123; printf("%lld\n",q[i].ans-q[i+1].ans-q[i+2].ans+q[i+3].ans+s*(q[i].y-q[i+3].y)*(q[i].x-q[i+3].x)); i+=3; //printf("%lld\n",q[i].ans); &#125; return 0;&#125; 然而我还是太弱了，调半个小时的原因既然是 树状数组打错了$QvQ$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 陌上花开 CDQ分治 bzoj3262]]></title>
    <url>%2F2019%2F02%2F22%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj3262%2F</url>
    <content type="text"><![CDATA[陌上花开，可缓缓归矣 ——吴越王 每日一学语文[滑稽]。 当然这题 $KDT​$ 是可以做的，但是不费，所以用 $CDQ​$ 算了吧。 很显然这道题是 $CDQ$ 三维偏序的板子题(luogu上它本来就是板子题) $CDQ$ 分治的三维偏序怎么做？ 对于其中的第一维，$CDQ$之前直接 $sort$ 排好序，那么这就可以保证对于一个 $i&lt;j$ ，位置 $j$ 的元素一定是对位置 $i$ 的元素做不出贡献的，因为 $x_i &lt;x_j$ 。 然后第二维，进入 $CDQ$ ，很显然当前的区间 $l - r$ 是会分成两个子区间分别做 $CDQ$ 的，那么当两个子区间合并的时候，左子区间是可能会对右子区间做出贡献的，但是右子区间对左子区间做不出任何贡献，原因是我们在之前已经按 $x$ 排好了序，那么显然左子区间的元素的 $x$ 始终小于右子区间的元素的 $x$。 外面排好了第一维，那么我们就在 $CDQ$ 中排第二维，由于我们是分成了两个子区间递归处理，往上面合并的时候，正好可以归并排序。第三位只需要在树状数组中记录一下，然后统计答案的时候调用树状数组的查询，看看比当前元素小的有多少个即可。 1234567891011121314151617181920void CDQ(int l,int r)&#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; CDQ(l,mid);CDQ(mid+1,r);/*分成两个子区间*/ int i=l,j=mid+1,cnt=l; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;/*归并+统计答案*/ if(v[i].b&lt;=v[j].b)add(v[i].c,size[v[i].id]),hep[cnt++]=v[i++]; /*左子区间的当前元素可能会有贡献，记录一下*/ else ans[v[j].id]+=sum(v[j].c),hep[cnt++]=v[j++]; /*接下来的左子区间的b是比当前的j.b要大的了，没有贡献了*/ /*因为在子区间中使用了归并，所以两个子区间中b肯定是升序的*/ &#125; while(j&lt;=r)ans[v[j].id]+=sum(v[j].c),hep[cnt++]=v[j++]; /*将剩下的归并排序完*/ for(int h=l;h&lt;i;++h)add(v[h].c,-size[v[h].id]); /*清除树状数组留下的痕迹*/ while(i&lt;=mid)hep[cnt++]=v[i++]; for(int i=l;i&lt;=r;++i)v[i]=hep[i]; /*更新原数组*/&#125; $QvQ$ 就这样了，只是这题需要离散化一下，$Code$ 中的 $size$ 就是元素出现的个数。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longconst int N=1e5+2;const int K=2e5+2;int n,k;struct Node&#123;int a,b,c,id;&#125;v[N],hep[N];int tre[K],ans[N],num[N],size[N];inline void add(int x,int v)&#123;for(;x&lt;=k;x+=(x&amp;-x))tre[x]+=v;&#125;;inline ll sum(int x)&#123;ll res=0;for(;x;x-=(x&amp;-x))res+=tre[x];return res;&#125;;template&lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;bool cmp(Node x,Node y)&#123; if(x.a!=y.a)return x.a&lt;y.a; if(x.b!=y.b)return x.b&lt;y.b; return x.c&lt;y.c;&#125;void CDQ(int l,int r)&#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; CDQ(l,mid);CDQ(mid+1,r); int i=l,j=mid+1,cnt=l; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(v[i].b&lt;=v[j].b)add(v[i].c,size[v[i].id]),hep[cnt++]=v[i++]; else ans[v[j].id]+=sum(v[j].c),hep[cnt++]=v[j++]; &#125; while(j&lt;=r)ans[v[j].id]+=sum(v[j].c),hep[cnt++]=v[j++]; for(int h=l;h&lt;i;++h)add(v[h].c,-size[v[h].id]); while(i&lt;=mid)hep[cnt++]=v[i++]; for(int i=l;i&lt;=r;++i)v[i]=hep[i];&#125;int main()&#123; IN(n),IN(k); for(int i=1;i&lt;=n;++i) scanf("%d%d%d",&amp;v[i].a,&amp;v[i].b,&amp;v[i].c); std::sort(v+1,v+n+1,cmp); int tot=0; for(int i=1;i&lt;=n;++i)&#123; if(v[i].a!=v[i-1].a||v[i].b!=v[i-1].b||v[i].c!=v[i-1].c)hep[++tot]=v[i]; ++size[tot]; &#125; for(int i=1;i&lt;=tot;++i)v[i]=hep[i],v[i].id=i; CDQ(1,tot); for(int i=1;i&lt;=tot;++i) num[ans[v[i].id]+size[v[i].id]-1]+=size[v[i].id]; for(int i=0;i&lt;n;++i) printf("%d\n",num[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数论】 乘法逆元]]></title>
    <url>%2F2019%2F02%2F20%2F%5B%E6%95%B0%E8%AE%BA%5D%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[真的我也不知道标题怎么起 $QvQ……$ 本文将介绍两种求乘法逆元的方式。 0XFF 乘法逆元是什么？ 乘法逆元，一般用于求 \frac{a}{b} \ \ (mod \ p)的值 ($p$ 通常为质数) 。 对于加、减、乘法的取模直接取就好了，但是对于除法(上面的分数形式)取模的话，显然直接取模是错的，那么这个时候就需要用到乘法逆元。 如果 $a \times x \equiv 1 \ \ (mod \ p) $，且 $a$ 与 $p$ 互质，那么就可以定义 $p$ 为 $x$ 的逆元，记为 $a^{-1}$，所以我们也可以称 $x$ 为 $a$ 在 $mod \ p$ 意义下的倒数。 对于 $\frac{a}{b} \ \ (mod \ p)​$，这个分数的值就是 $(b^{-1} \times a) \ mod \ p​$，即 $b​$ 在 $mod \ p​$ 意义下的逆元乘上 $a​$ ，最后对 $p​$ 取模。 0X1F 求乘法逆元的两种方法(我只会这两种)…… 0X1F-1 费马小定理求乘法逆元费马小定理： 若 $p​$ 为质数，$a​$ 为正整数，且 $a​$ 与 $p​$ 互质。 那么 $a^{p-1} \equiv 1 \ \ (mod \ p)$。 我们将 $a^{p-1} \equiv 1 \ \ (mod \ p)$ 代入原式： a \times x \equiv 1 \ \ (mod \ p)a \times x\equiv a^{p-1} \ \ (mod \ p)x\equiv a^{p-2} \ \ (mod \ p)那么直接跑一遍快速幂即可。 Code:1234567891011#define ll long longll pow(ll x,ll y,ll p) &#123; x%=p; ll ans=1; for(;y;y&gt;&gt;=1,x=x*x%mod) if(power&amp;1)ans=ans*x%mod; return ans;&#125;int main()&#123; ll x=pow(a,p-2,p);&#125; 0X1F-2 线性求乘法逆元这个算法的时间复杂度是线性的：$O(n)$ 设 $p=s \times i + r$ ，$(1&lt;r&lt;i&lt;p)$. 将此式套入 $(mod \ p)​$ 意义下的式子就可以得到： s \times i +r \equiv 0 \ \ (mod \ p)​两边同时乘上 $i^{-1}$： s + r \times i^{-1} \equiv 0 \ \ (mod \ p)​然后再同时乘上 $r^{-1}​$： s \times r^{-1} + i^{-1} \equiv 0 \ \ (mod \ p)​移项得到： i^{-1} \equiv -s \times r^{-1} \ \ (mod \ p)很显然 $s$ 等于 $[\frac{p}{i}]$，$r$ 等于 $p \ mod \ i$，那么 $r^{-1}$ 就等于 $inv[p \ mod \ i]$ ($inv[i]$ 表示 $i$ 在 $mod \ p$ 意义下的乘法逆元) 然后代入公式： inv[i] \equiv - [\frac{p}{i}] \times inv[p \ mod \ i] \ \ (mod \ p)于是代码就很短了： 123inv[0]=0,inv[1]=1;for(int i=2;i&lt;=n;++i) inv[i]=(long long)(p-p/i)*inv[p%i]%p; 一般来说线性的或许会优秀些，建议使用线性的算法，而且代码也比较短，容易写，处理组乘法逆元的时候，第一种的复杂度为 $O(nlogn)$，第二种只需 $O(n)$。但是在处理单组乘法逆元的时候，第一种复杂度为 $O(logn)$，但是第二种因为要讲 $p \ mod \ i$ 求出来，复杂度…..或许还是 $O(n)$。(实际上我也不会证 $QvQ…$)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>乘法逆元</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [国家集训队]Tree LCT luogu1501/bzoj2631]]></title>
    <url>%2F2019%2F02%2F17%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1501%2F</url>
    <content type="text"><![CDATA[Link-Cut-Tree 的懒标记下传正确食用方法。 1：+ u v c：将$u$到$v$的路径上的点的权值都加上自然数$c$; 解决方法： 很显然，我们可以$split(u,v)$来提取u,v这一段区间,提取完了将$Splay(v)$,然后直接在v上打加法标记$add$即可。 代码： 1234567891011121314inline void pushadd(ll x,ll val)&#123;//打标记 s[x]+=sz[x]*val,v[x]+=val,add[x]+=val; s[x]%=MOD,v[x]%=MOD,add[x]%=MOD;&#125;inline void split(ll x,ll y)&#123;//LCT基本操作split,不再赘述 makeroot(x);Access(y);Splay(y);&#125;//(main函数中)：if(op[0]=='+')&#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;v);//输入信息 split(x,y);pushadd(y,v);//提取链条&amp;打标记&#125; 2：- u1 v1 u2 v2：将树中原有的边$(u1,v1)$删除，加入一条新边$(u2,v2)$，保证操作完之后仍然是一棵树； 解决方法： 删除边即$cut$操作，加边即$link$操作。 代码： 1234567891011121314inline void link(ll x,ll y)&#123; makeroot(x);if(findroot(x)!=y)f[x]=y;&#125;inline void cut(ll x,ll y)&#123; makeroot(x);split(x,y); if(findroot(y)==x&amp;&amp;f[x]==y&amp;&amp;!ch[x][1]) f[x]=ch[y][0]=0;return;&#125;//LCT基本操作link&amp;cut，不再赘述//(main函数中)：if(op[0]=='-')&#123; scanf("%lld%lld",&amp;x,&amp;y);cut(x,y);//删边 scanf("%lld%lld",&amp;x,&amp;y);link(x,y);//加边&#125; 3：* u v c：将$u$到$v$的路径上的点的权值都乘上自然数$c$； 解决方法： 很显然，我们可以$split(u,v)$来提取u,v这一段区间,提取完了将$Splay(v)$,然后直接在v上打乘法标记$mul$即可。(跟第一个操作基本同理) 代码： 12345678910inline void pushmul(ll x,ll val)&#123;//打标记 s[x]*=val,v[x]*=val,mul[x]*=val,add[x]*=val; s[x]%=MOD,v[x]%=MOD,mul[x]%=MOD,add[x]%=MOD;&#125;//(main函数中)：if(op[0]=='*')&#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;v); split(x,y);pushmul(y,v);&#125; 4：/ u v：询问$u$到$v$的路径上的点的权值和，求出答案对于51061的余数。 解决方法： $Splay(v)$时已经将所有节点更新过了(懒标记下传过了)，所以最后只需输出$s[v]$即可。 代码： 12345//(main函数中)：if(op[0]=='/')&#123; scanf("%lld%lld",&amp;x,&amp;y); split(x,y);printf("%lld\n",s[y]);&#125; Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register ll#define A printf("A")#define C printf(" ") #define MOD 51061using namespace std;const ll N=1e5+2;template&lt;typename _Tp&gt; inline void IN(_Tp&amp; dig)&#123; char c;bool flag=0;dig=0; while(c=getchar(),!isdigit(c))if(c=='-')flag=1; while(isdigit(c))dig=dig*10+c-'0',c=getchar(); if(flag)dig=-dig;&#125;ll f[N],s[N],v[N],sz[N],rev[N],mul[N],add[N],hep[N],ch[N][2];inline ll get(ll x)&#123;return ch[f[x]][0]==x||ch[f[x]][1]==x;&#125;inline ll chk(ll x)&#123;return ch[f[x]][1]==x;&#125;inline void pushfilp(ll x)&#123; swap(ch[x][0],ch[x][1]);rev[x]^=1;&#125;inline void pushup(ll x)&#123; s[x]=(s[ch[x][0]]+s[ch[x][1]]+v[x])%MOD; sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1;&#125;inline void pushmul(ll x,ll val)&#123; s[x]*=val,v[x]*=val,mul[x]*=val,add[x]*=val; s[x]%=MOD,v[x]%=MOD,mul[x]%=MOD,add[x]%=MOD;&#125;inline void pushadd(ll x,ll val)&#123; s[x]+=sz[x]*val,v[x]+=val,add[x]+=val; s[x]%=MOD,v[x]%=MOD,add[x]%=MOD;&#125;inline void pushdown(ll x)&#123; if(mul[x]!=1)pushmul(ch[x][0],mul[x]),pushmul(ch[x][1],mul[x]); if(add[x])pushadd(ch[x][0],add[x]),pushadd(ch[x][1],add[x]); if(rev[x])&#123; if(ch[x][0])pushfilp(ch[x][0]); if(ch[x][1])pushfilp(ch[x][1]); &#125;rev[x]=0,add[x]=0,mul[x]=1;return;&#125;inline void rotate(ll x)&#123; ll y=f[x],z=f[y],k=chk(x),v=ch[x][!k]; if(get(y))ch[z][chk(y)]=x;ch[x][!k]=y,ch[y][k]=v; if(v)f[v]=y;f[y]=x,f[x]=z;pushup(y),pushup(x);&#125;inline void Splay(ll x)&#123; ll y=x,top=0;hep[++top]=y; while(get(y))hep[++top]=y=f[y]; while(top)pushdown(hep[top--]); while(get(x))&#123; y=f[x],top=f[y]; if(get(y))rotate((ch[y][0]==x)^(ch[top][0]==y)?y:x); rotate(x); &#125;pushup(x);return;&#125;inline void Access(ll x)&#123; for(register ll y=0;x;x=f[y=x]) Splay(x),ch[x][1]=y,pushup(x);&#125;inline ll findroot(ll x)&#123; Access(x);Splay(x); while(ch[x][0])pushdown(x),x=ch[x][0]; return x;&#125;inline void makeroot(ll x)&#123; Access(x);Splay(x);pushfilp(x);&#125;inline void split(ll x,ll y)&#123; makeroot(x);Access(y);Splay(y);&#125;inline void link(ll x,ll y)&#123; makeroot(x);if(findroot(x)!=y)f[x]=y;&#125;inline void cut(ll x,ll y)&#123; makeroot(x);split(x,y); if(findroot(y)==x&amp;&amp;f[x]==y&amp;&amp;!ch[x][1]) f[x]=ch[y][0]=0;return;&#125;char op[2];int main()&#123; ll n,m,x,y;scanf("%lld%lld",&amp;n,&amp;m); for(register int i=1;i&lt;=n;++i) mul[i]=sz[i]=v[i]=1;ll v; for(register int i=1;i&lt;n;++i) scanf("%lld%lld",&amp;x,&amp;y),link(x,y); for(register int i=1;i&lt;=m;++i)&#123; scanf("%s",op); if(op[0]=='+')&#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;v); split(x,y);pushadd(y,v); &#125;else if(op[0]=='-')&#123; scanf("%lld%lld",&amp;x,&amp;y);cut(x,y); scanf("%lld%lld",&amp;x,&amp;y);link(x,y); &#125;else if(op[0]=='*')&#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;v); split(x,y);pushmul(y,v); &#125;else if(op[0]=='/')&#123; scanf("%lld%lld",&amp;x,&amp;y); split(x,y);printf("%lld\n",s[y]); &#125; &#125;return 0;&#125; 因为$51061 * 51061$是会越过$int$界限的，所以我开的$longlong$(当然也可以开无符号$int$)所以就没了。。。。。。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈后缀数组(SA)&学习笔记]]></title>
    <url>%2F2019%2F02%2F16%2F%5B%E7%AE%97%E6%B3%95%5D%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84SA%2F</url>
    <content type="text"><![CDATA[好吧写完了后缀自动机就写后缀数组吧 $QvQ$。 感觉这个东西比后缀自动机简单些欸 $QvQ$。 (够了不要 $QvQ$了 我们进入正题。 0XFF 前言 *如果本文有地方表达错误，可以通过QQ联系我，一定尽量改正！ 0X1F 后缀数组是什么？ 在字符串处理当中，后缀树和后缀数组都是非常有力的工具。其实后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能而时间复杂度也不太逊色，并且，它比后缀树所占用的空间小很多。可以说，在信息学竞赛中后缀数组比后缀树要更为实用。 ————百度百科 后缀数组主要由两个算法实现，一个是倍增算法($25$行码量左右)(炒鸡难)，另一个是$DC3$算法($40$行码量左右)(更加炒鸡难)，其中，倍增算法的时间复杂度为$O(nlogn)$，$DC3$算法的时间复杂度为 $O(n)$。今天我们就来稍微讨论一下倍增算法。 0X2F 倍增算法的实现过程0X2F-1 后缀是什么？ 定义：一个字符串 $S$，定义 $Suffix(x)$ 表示从 $S$ 的第 $x$ 个字符到最后一个字符所组成的字符串。 举例：假设现在字符串 $S$ 为 $abcdefg$，那么 $Suffix(3)$ 就是 $cdefg$，$Suffix(6)$ 就是 $fg$。 现在我们规定三个数组： $SA$ 数组：$SA[i]$ 表示第 $i$ 小的后缀的开始位置在母串的第几个位置。 $Rank​$ 数组：$Rank[i]​$ 表示 $Suffix(i)​$ 在所有后缀中的排名。 $Height$ 数组：$Height[i]$ 表示 $Suffix(sa[i])$ 和 $Suffix(sa[i-1])$ 的最长公共前缀的长度，特别的，$Height[0]=0$。 0X2F-2 倍增算法的思想前置芝士： 倍增思想 基数排序 我们将用一个字符串 $S$ 来举例/图解用： 我们倍增一个 $P$，从 $0$ 开始，每次乘 $2$ ，表示当前处理的长度。 假设当前的 $P$ 是 $4$，我们将比较所有串的前四位，进行基数排序。怎么个鸡排法呢？我们以第三个串为例，来加以解释。 很显然我们上一次 $P=2​$ 的时候就处理好了每一个串前两位的排名，我们将排名列出来： 这是对 $1-8$ 所有串，按照前两位排序排出来的结果，对于 $s$ 后面的 $，是一个极小的东西，因为 $s$ 后面没有东西了，所以这样子写(实际上并不要表示出来)。我们令 $mo=5/nl=6……ts=9$ 那么很显然，$nlig=63$，其中 $6$ 是十位，是第一关键字，$3$ 是个位，是第二关键字。那么现在所有的串的前四位表示的二位数如下： 于是我们开始基数排序。基数排序的过程就不再赘述了。 然后呢？还有吗？没了！ 0X3F 倍增算法的代码实现Code-SA:123456789101112131415161718192021222324252627282930313233343536char s[NS];/*字符串S*/int n,m,x[NS],y[NS],sa[NS],hep[NS];/*SA不解释，hep：堆，x:第一关键字，基数排序中的十位，y:第二关键字，基数排序中的个位*/inline void solve()&#123;/*倍增算法*/ m=75;/*当前堆的最大值(意会一下)*/ for(int i=1;i&lt;=n;++i)x[i]=s[i]-'0'+1; /*现在对长度为1的第一关键字进行排序，获取第一关键字*/ for(int i=0;i&lt;=m;++i)hep[i]=0;/*清空堆*/ for(int i=1;i&lt;=n;++i)++hep[x[i]];/*基数排序*/ for(int i=1;i&lt;=m;++i)hep[i]+=hep[i-1]; for(int i=n;i&gt;=1;--i)sa[hep[x[i]]--]=i;/*获取SA数组*/ for(int w=1,p=0;m=p,p&lt;n;w&lt;&lt;=1)&#123; p=0;//计数器 for(int i=1;i&lt;=w;++i)y[++p]=n-w+i； for(int i=1;i&lt;=n;++i)if(sa[i]&gt;w)y[++p]=sa[i]-w; /*获取当前第二关键字的排名，结合图片理解效果更佳*/ for(int i=0;i&lt;=m;++i)hep[i]=0; for(int i=1;i&lt;=n;++i)++hep[x[i]]; for(int i=1;i&lt;=m;++i)hep[i]+=hep[i-1]; for(int i=n;i&gt;=1;--i)sa[hep[x[y[i]]]--]=y[i]; /*基数排序过程*/ std::swap(x,y); x[sa[1]]=p=1; for(int i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+w]==y[sa[i]+w])?p:++p;/*计算当前的Rank数组*/ /*显然如果每个后缀都有唯一的排名时就退出循环了*/ &#125; for(int i=1;i&lt;=n;++i)printf("%d ",sa[i]); return;&#125; //main函数中scanf("%s",s+1);n=strlen(s+1);solve();return 0; 留个坑，到时候再补吧。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>后缀数组.SA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈后缀自动机(SAM)&学习笔记]]></title>
    <url>%2F2019%2F02%2F16%2F%5B%E7%AE%97%E6%B3%95%5D%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BASAM%2F</url>
    <content type="text"><![CDATA[教练前几天对我说，让我好好的搞一下什么 $ACM$($AC$自动机) 和 $SAM$(后缀自动机)，可以的话还要稍微梳理一下后缀数组，感觉鸭梨山大 $QvQ$。到网上找了 $AC$自动机 的文章，感觉都看不怎么懂。于是就来看看后缀自动机的文章，发现有些感觉。于是敲了几道板子题后匆匆的来写总结了（完成任务就好了）(逃 我们进入正题。 0XFF 前言 *如果本文有地方表达错误，可以通过QQ联系我，一定尽量改正！ *文中的”子串”,”前缀”,”后缀”没有特殊说明时均指母串的”子串”,”前缀”,”后缀”. 0X1F 后缀自动机是什么？后缀自动机($SAM$) 是一种 有限状态自动机($FSM$) ，它可以接受一个字符串的所有后缀。后缀自动机包含了两部分，一个是 有向无环单词图$DAWG$，一个是前缀树($prefix tree$)，后缀自动机的每一个节点都同时存在于这两个结构中。 对于一个字符串 $S$ ，我们对它进行构建 $SAM$。对于构建出来的 $SAM$ ，称 $S$ 是该 $SAM$ 的母串。 0X1F-1 DAWG$DAWG$ 是有向无环图。在 $DAWG$ 上面，除了起始节点以外，其余的节点都表示了一个或多个子串。点与点之间有转移边相连接，每条转移边也代表一个字符。 从起始节点沿着转移边走若干步，可以得到一个长度为步数子串。 对于 $DAWG​$ 上的从起始节点开始的任意一条路径，设这条路径的终点为 $x​$，如果这条路径得到的子串是母串的后缀，那么节点 $x​$ 就是可接受节点。 0X1F-1-1 DAWG上的节点 定义：对于一个 $DAWG$ 上的任意一个节点 $x$，$x$ 所表示的所有字符串都是母串的某个前缀的后缀，且 $x$ 所表示的所有的字符串的长度是连续的。 举例：假设现在的母串为 $leyxojdhqes​$，显然字符串 $leyxojd​$ 是母串的一个前缀，那么 $x​$ 里面存的字符串可能为：$xojd,ojd,jd,d​$。注意长度必须是连续的，如果 $x​$ 存的字符串为：$xojd,jd,d​$ ，显然长度没有连续，那么就错误了。 定义：对于一个节点 $x​$ ，$max(x)​$ 和 $min(x)​$ 分别表示 $x​$ 里面存的所有子串中最长的/最短的 举例：假设现在的母串为 $leyxojdhqes$，字符串 $leyxojd$ 是母串的一个前缀，有一个节点 $x$ 里面存的字符串为：$xojd,ojd,jd$，那么 $max(x)=xojd$ ，$min(x)=jd$。 定义：对于一个节点 $x$，$end-pos(x)$ 表示 $max(x)$ 在母串中出现的结束位置集合。 性质：任意两个节点的 $end-pos$集合不相同。 举例：假设现在的母串为 $acskdleaseccskdew​$，有一个节点 $x​$ 里面存的字符串为：$csk,sk​$，$max(x)=csk​$，显然字符串 $csk​$ 的结束位置有：{$4,14​$}，那么 $end-pos(x)=​${$4,14​$}。 如果有两个节点的 $end-pos$ 相同，那么它们是可以合并的。而 $SAM$ 正是要求最简化。 0X1F-1-1 DAWG上的转移边设节点 $u​$ 到 $v​$ 有一条转移边，转移边上的字符为 $c​$，那么 $u​$ 里面的所有字符串后面加上 $c​$ 后都可以由 $v​$ 表示，但是 $v​$ 的所有子串不一定都来自 $u​$! 0X1F-2 前缀树 定义：$u$ 的后缀链接指向 $v$，当且仅当 $min(u)=max(v)+1$， 并且 $v$ 中的所有字符串串均为 $u$ 中的字符串的后缀，记为：$next(u)=v$ 举例：假设现在的母串为 $leyxojdhqes$，字符串 $leyxojd$ 是母串的一个前缀，节点 $v$ 中的字符串为：$xojd,ojd,jd$，节点 $u$ 中的字符串为：$eyxojd,yxojd$，那么 $next(u)=v$。 以后缀链接为边，所组成的结构是一棵树，叫前缀树。 性质：前缀树中，对于任意一个节点 $x​$，都有 $end-pos(x) \subseteq end-pos(next(x))​$ 证明： $end-pos(x)$ 跟 $max(x)$ 有关，根据上面的定义，我们可以知道，$max(x)$ 出现的位置 $max(next(x))$ 一定也出现了，所以 $end-pos(x) \subseteq end-pos(next(x))$，但是 $end-pos(x) \neq end-pos(next(x))$ ，因为如果 $end-pos(x) = end-pos(next(x))$，那么 $x$ 和 $next(x)$ 就将合并为一个点，这个上面也讲了，所以 $end-pos(x) \subseteq end-pos(next(x))$。 显然，$end-pos(x)$ 等于所有 $end-pos(next(x))$ 的交集。 0X2F 后缀自动机的构造过程我们将插入一个长度为 $N$ 的字符串 $S$ ，后缀自动机将一个一个的插入字符，现在我们就来模拟一下插入 $V_7$ 的过程。 现在我们的后缀自动机的状态如下(黑色为前缀树上的后缀链接的边，灰色为$DAWG$上的转移边)： 现在我们将要插入 $V_7$，字符为 $c$ ，我们假设 $V_4$ 及之前的节点，在其后面插入一个字符后，该节点的字符串任然存在于母串中，假设 $V_5,V_6$ 后面插入一个字符就会有字符串不存在于母串中。 那么我们插入，很显然，现在 $V_5,V_6$ 后面插入了 $c$ 还是存在于新的母串之中，并且为新的母串的后缀。我们设现在插入 $c$ 后产生的原来没有的新字符串被 $V_7$ 表示，我们可以得到：$max(V_7)=max(V_6)+1,min(V_7)=min(V_5)+1$。 对于现在插入 $V_7​$ 后所产生的新的后缀，长的均可以被 $V_7​$ 表示，而短一点的，则可以被 $V_4​$ 及之前的节点表示了。这也说明 $V_4​$ 有 $c​$ 这个儿子，这也是为什么插入 $c​$ 的时候不用在往 $V_4​$ 及它前面的节点插入了，因为已经有 $V_4​$ 了。 这个时候，显然我们满足了 $DAWG$ 的性质，来考虑怎么满足前缀树的性质。 对于节点 $P$，如果 $max(P)=max(V_4)+c$ ，也就是说 $P$ 中最长的字符串由 $V_4$ 中最长的字符串后面加上一个字符 $c$ 转移而来，我们又知道 $|min(V_7)| = |min(V_5)| + 1$，根据前缀树的性质，又知道 $|max(V_4)| = |min(V_5)| - 1$，于是我们可以得到：$|max(d)| = (|min(V_2)| - 1) + 1 = |min(V_7)| - 1$，那么显然，$next(V_7)=d$，这个链接是满足条件的。 *注：所有的灰色边都是转移边，只有$V7-&gt;P$的那一条不是，颜色有误. 不过，如果 $max(P) \neq max(V_4)+c$ 的话，那么必然 $|max(P)| &gt; |max(V_4)|+1$。因为 $max(V_4)+c$ 一定存在于 $P$ 节点中，并且还有一个节点 $a$，满足 $next(a)=V_4$ 并且 $a$ 于 $P$ 连有一条转移边。 因为此时 $P​$ 中的字符串不全是 $V_7​$ ，所以我们不能将 $V_7​$ 的后缀链接连向 $P​$，不然就不合法了。我们来借助图片解释： 这里的每一个节点都是合法的，可以仔细的看一下。 我们发现，$P​$中的 “$iwhkshxzns​$” 是 $V_7​$ 的后缀，是可以链接的，但是 $P​$ 中的 “$kaiwhkshxzns​$” 不是 $V_7​$ 的后缀，所以 $V_7​$ 的后缀链接不能连向 $P​$。 那怎么办？将 $P$ 拆开! 我们将 $P​$ 拆成两个点：$P_1,P_2​$ 。其中 $P_1​$ 里面存的是长度小于等于 $|max(V_4)| + 1​$ 的子串，也就是 $iwhkshxzns​$，而 $P_2​$ 存的就是剩下的字符串，也就是例子中的 $kaiwhkshxzns​$，这个时候，我们将 $V_7​$ 的后缀链接连向 $P_1​$ ，可以证明这是对的。 对于 $V_3​$ 和 $V_4​$ ，我们将他们的转移边依然指向 $P_1​$，然后，我们将 $a​$ 的转移边连向 $P_2​$ ，然后在从 $P_2​$ 向 $P_1​$ 连一条转移边，最后不要忘记，要将 $V_7​$ 的后缀链接连向 $P_1​$，整个过程就大功告成了。 这张图显然同时满足了 $DAWG$ 和 前缀树 的性质。 0X3F 后缀自动机的代码实现有一个注意的地方：我们在开结构体记录每一个节点的时候，只需要记录其 $Max​$，不需要记录 $Min​$ ，因为即使不记录 $Min​$ 我们也可以用 $O(1)​$ 的时间算出 $Min​$，按照前缀树的性质，可以知道 $min(x)=max(next(x))+1​$。 还有就是，对于拆点的时候，需要先把原来的点的信息复制过来再进行操作。对于上图中的 $P_1​$ 就是新建的点，$P_2​$ 是原来的点，显然我们在拆点的时候只需要将 $P_2​$ 的信息复制到 $P_1​$，然后将 $P_1​$ 的 $Max​$ 改为 $|max(V_4)| + 1​$ ，最后将所有转移边原来指向 $P_2​$ 的点改为指向 $P_1​$ ，例如 $V_3,V_4​$。 将图贴在这里，可以借着图来意会意会。 Code-SAM:1234567891011121314151617181920212223242526272829303132333435363738394041struct SAM&#123; int last,cnt; /*上一次插入的节点(上面的V6)，当前节点个数*/ int ch[N][26],fa[N],len[N]; /*ch表示转移边，fa表示后缀链接，len(x)表示max(x)*/ SAM()&#123;cnt=last=1&#125;; /*初始化，根节点编号为1，我们插入的节点编号从2开始*/ inline void ins(int c)&#123;/*插入c*/ int p=last,np=++cnt; /*p为图中的V6,np为V7(新节点)*/ last=np,len[np]=len[p]+1; /*按照性质给V7的len复制*/ while(p&amp;&amp;!ch[p][c])ch[p][c]=np,p=fa[p]; /*给V5,V6安好一个新儿子，!ch[p][c]在V4时不满足，这时就停下来了*/ if(!p)fa[np]=1; /*到根节点了，之间将后缀链接连向根节点*/ else&#123; int q=ch[p][c]; //这个“ch[p][c]”就是上图的P if(len[q]==len[p]+1)fa[np]=q; /*显然是合法的，那么直接连边，可以参考上图*/ else&#123; /*需要拆点*/ int nq=++cnt;len[nq]=len[p]+1; //建好P1，然后给P1的len附值 memcpy(ch[nq],ch[q],sizeof(ch[q])); //复制儿子 fa[nq]=fa[q];fa[q]=fa[np]=nq; //连后缀链接 while(p&amp;&amp;ch[p][c]==q)ch[p][c]=nq,p=fa[p]; //改转移边 &#125; &#125;return; &#125;&#125;sam;//main函数中：scanf("%s",S);int slen=strlen(S);for(int i=0;i&lt;slen;++i) sam.ins(s[i]-'a'); 0X4F 后缀自动机的实际运用求一个字符串的所有子串中本质不同的子串个数？后缀自动机存储了所有的子串，我们只需要统计所有节点上的子串的个数的总和即可，这个就是答案。怎么统计呢？可以知道一个节点上面的所有字符串的长度一定是连续的，那么这个节点上面的子串个数就是 $|max(x)| - |min(x)| + 1$ (设该节点为 $x$)，也就是 $|max(x)| - |max(next(x))|$。 求两个字符串的最长公共子串？我们将第一个字符串建成后缀自动机，然后依次枚举第二个字符串的每一个字符 $c$，枚举的时候要记一个当前匹配长度($len$)，当前的最长公共字串的长度($ans$)，当前匹配到的节点($p$) 对于这个 $c$，有两种情况： $p$ 有字符 $c$ 的转移出边：直接转移即可，即 $p=ch[p][c]$，然后 ++$len$。 $p$ 没有字符 $c$ 的转移出边：那么开始循环，每一次 $p$ 跳到 $next(p)$，然后判断当前的 $p$ 有没有 $c$ 的出边，有的话直接 $len=max(p)+1$，$p=ch[p][c]$。没有的话继续跳，如果跳到了根节点那么 $len=0，p=1$ ，然后再继续匹配。 可以证明这种做法是对的，因为当前匹配不上了，所以调到 $next(p)$ ，舍弃最少的前缀，然后再尝试往下匹配。 0X5F 后缀自动机的一些例题题目：bzoj4516/luoguP4070 [SDOI2016]生成魔咒题目描述魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1,2$ 拼凑起来形成一个魔咒串 $[1,2]$。 一个魔咒串 $S​$ 的非空字串被称为魔咒串 $S​$ 的生成魔咒。 例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1]$、$[2]$、$[1,2]$、$[2,1]$、$[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1]$、$[1,1]$、$[1,1,1]$ 三种。最初 $S$ 为空串。共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。 输入输出格式输入格式： 第一行一个整数 $n​$。 第二行 $n$ 个数，第 $i$ 个数表示第 $i$ 次操作加入的魔咒字符。 输出格式： 输出 $n$ 行，每行一个数。第 $i$ 行的数表示第 $i$ 次操作后 $S$ 的生成魔咒数量 输入输出样例:输入样例#1： 1271 2 3 3 3 1 2 输出样例#1： 12345671369121722 说明对于%$10$的数据，$1 \le n \le 10$ 对于%$30$的数据，$1 \le n \le 100$ 对于%$60$的数据，$1 \le n \le 100$ 对于%$100$的数据，$1 \le n \le 100000$ 用来表示魔咒字符的数字 $x$ 满足 $1 \le n \le 10^9$ 题解 bzoj4516/luoguP4070 [SDOI2016]生成魔咒很显然是让我们求本质不同的子串个数。 后缀自动机裸题。 Code bzoj4516/luoguP4070 [SDOI2016]生成魔咒12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=2e5+2;const int inf=1e9+9;template&lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct SAM&#123; ll ans; std::map&lt;int,int&gt; ch[N]; int last,cnt,len[N],fa[N]; inline void Insert(int c)&#123; int p=last,now=last=++cnt; len[now]=len[p]+1; while(p&amp;&amp;!ch[p][c])ch[p][c]=now,p=fa[p]; if(!p)fa[now]=1; else&#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[now]=q; else&#123; int copy=++cnt; len[copy]=len[p]+1,ch[copy]=ch[q]; fa[copy]=fa[q],fa[q]=fa[now]=copy; while(p&amp;&amp;ch[p][c]==q)ch[p][c]=copy,p=fa[p]; &#125; &#125; ans+=len[now]-len[fa[now]]; return; &#125;&#125;sam;int main()&#123; int n;IN(n); sam.last=sam.cnt=1; for(int i=1;i&lt;=n;++i)&#123; int c;IN(c); sam.Insert(c); printf("%lld\n",sam.ans); &#125; return 0;&#125; 题目 luoguSP1811 LCS - Longest Common Substring题意翻译输入 $2$ 个长度不大于 $250000$ 的字符串，输出这 $2$ 个字符串的最长公共子串。如果没有公共子串则输出 $0$ 。 题目描述A string is finite sequence of characters over a non-empty finite set $\sum$. In this problem, $\sum$ is the set of lowercase letters. Substring, also called factor, is a consecutive sequence of characters occurrences at least once in a string. Now your task is simple, for two given strings, find the length of the longest common substring of them. Here common substring means a substring of two or more strings. 输入输出格式输入格式： The input contains exactly two lines, each line consists of no more than 250000 lowercase letters, representing a string. 输出格式： The length of the longest common substring. If such string doesn’t exist, print “0” instead. 输入输出样例输入样例#1： 12alsdfkjfjkdsalfdjskalajfkdsla 输出样例#1： 13 题解 luoguSP1811 LCS - Longest Common Substring依然是裸题，直接用后缀自动机求最长公共子串就好。 Code luoguSP1811 LCS - Longest Common Substring123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e6+2;const int inf=1e9+9; char s1[N],s2[N];struct SAM&#123; int last,cnt,ans; int ch[N][26],fa[N],len[N]; SAM()&#123;cnt=last=1,ans=0;&#125;; inline void ins(int c)&#123; int p=last,np=++cnt;last=np,len[np]=len[p]+1; while(p&amp;&amp;!ch[p][c])ch[p][c]=np,p=fa[p]; if(!p)fa[np]=1; else&#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else&#123; int nq=++cnt;len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[nq]=fa[q];fa[q]=fa[np]=nq; while(p&amp;&amp;ch[p][c]==q)ch[p][c]=nq,p=fa[p]; &#125; &#125;return; &#125; inline void solve(char *s)&#123; int p=1,slen=0,nlen=strlen(s); for(int i=0;i&lt;nlen;++i)&#123; int c=s[i]-'a'; if(ch[p][c])slen++,p=ch[p][c]; else&#123; while(p&amp;&amp;!ch[p][c])p=fa[p]; if(p)slen=len[p]+1,p=ch[p][c]; else slen=0,p=1; &#125;ans=max(ans,slen); &#125;return; &#125;&#125;sam;int main()&#123; scanf("%s%s",s1,s2); int nlen=strlen(s1); for(int i=0;i&lt;nlen;++i) sam.ins(s1[i]-'a'); sam.solve(s2); printf("%d\n",sam.ans); return 0;&#125; 后面的不会什么了，蒟蒻到时候再来填坑吧。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>后缀自动机.SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 Qtree3 LCT luoguP4116]]></title>
    <url>%2F2019%2F02%2F15%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4116%2F</url>
    <content type="text"><![CDATA[第一个操作显然是不要考虑的…… 考虑第二个操作怎么办(实际上是超级easy的) 每个节点维护一个值sum，表示 $Splay$ 中它子树的和，每个点的权值为1(黑)0(白)。 对于这个操作，我们可以先 $split(1,x)$ ，现在x是这个 $Splay$ 的根。我们将要找的就是这颗 $Splay$ 中深度最小且为黑点的节点。 找Answer之前先特判一下s[x]是否大于0，如果为0，直接跳过即可。 不然进入循环，分三种情况： 1.如果s[ch[x][0]]大于0，说明有更优的答案(左子树深度小于x)，x=ch[x][0]。 2.否则，如果x本身就是黑点，那么x就是答案了，直接break。 3.不然，如果x到1的节点都是白色，那就只能去x的右子树找了，x=ch[x][1]。 退出循环时x即为答案，输出即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int#define A printf("A") using namespace std;const int N=1e5+2;int n,m,f[N],s[N],v[N],r[N],ch[N][2];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline int chk(int x)&#123;return ch[f[x]][1]==x;&#125;inline int isroot(int x)&#123;return ch[f[x]][0]==x||ch[f[x]][1]==x;&#125;inline void pushup(int x)&#123;s[x]=s[ch[x][0]]+s[ch[x][1]]+v[x];&#125;inline void pushdown(int x)&#123; if(!r[x])return;r[x]=0; r[ch[x][0]]^=1,r[ch[x][1]]^=1,swap(ch[x][0],ch[x][1]);&#125;inline void Splay_push(int x)&#123;if(isroot(x))Splay_push(f[x]);pushdown(x);&#125;inline void rotate(int x)&#123; int y=f[x],z=f[y],k=chk(x),v=ch[x][!k]; if(isroot(y))ch[z][chk(y)]=x;ch[x][!k]=y,ch[y][k]=v; if(v)f[v]=y;f[y]=x,f[x]=z;pushup(y);&#125;inline void Splay(int x)&#123; int y=x;Splay_push(x); while(isroot(x))&#123; if(isroot(y=f[x])) rotate((ch[y][0]==x)^(ch[f[y]][0]==y)?x:y); rotate(x); &#125;pushup(x);return;&#125;inline void Access(int x)&#123; for(register int y=0;x;x=f[y=x]) Splay(x),ch[x][1]=y,pushup(x); &#125;inline int findroot(int x)&#123; Access(x);Splay(x); while(ch[x][0])pushdown(x),x=ch[x][0]; Splay(x);return x;&#125;inline void makeroot(int x)&#123;Access(x);Splay(x);r[x]^=1;&#125;inline void split(int x,int y)&#123;makeroot(x);Access(y);Splay(y);&#125;inline void link(int x,int y)&#123;makeroot(x);if(findroot(x)!=findroot(y))f[x]=y;&#125;inline void cut(int x,int y)&#123;split(x,y);if(findroot(y)==x&amp;&amp;f[x]==y&amp;&amp;!ch[x][1])f[x]=ch[y][0]=0;&#125;int main()&#123; IN(n),IN(m); for(register int x,y,i=1;i&lt;n;++i) &#123;IN(x),IN(y);link(x,y);&#125; for(register int op,x,i=1;i&lt;=m;++i)&#123; IN(op),IN(x); if(op==0)&#123; makeroot(x);v[x]^=1;pushup(x); &#125;else if(op==1)&#123; split(1,x); if(!s[x])&#123;printf("-1\n");continue;&#125; while(s[x])&#123; pushdown(x); if(s[ch[x][0]])x=ch[x][0]; else if(v[x])break; else x=ch[x][1]; &#125;printf("%d\n",x); &#125; &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2010]地精部落 线性DP luogu2467]]></title>
    <url>%2F2019%2F02%2F15%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2467%2F</url>
    <content type="text"><![CDATA[好巧的一道思维题啊！ 思维量极大但是码量极小，真的好巧妙啊！(好了不废话进入主题) 在下文，因为为了方便代码的理解同步，所以应用了百度翻译： summit: 顶点 valley: 流域; 山谷，溪谷，峡谷，谷地，深谷; 这显然是道 $DP$ 题(又是废话) 可以知道题目要求的合法山脉其实是一个波动数列。 很容易的可以想到，设 $summit[i][j]$ 表示长度为 $j$ 的波动数列，此波动数列的第一个数为 $i$，且在题目中，$i$ 为山峰，这样状态下的方案总数。 同样的，我们同时设 $valley[i][j]$ 表示长度为 $j$ 的波动数列，此波动数列的第一个数为 $i$，且在题目中，$i$ 为山谷，这样状态下的方案总数。 那么答案是多少呢？由于数列中的每一个元素都可以做第一个元素，且都有可能做”山峰”或者是”山脉”，所以我们的答案应该是： $\sum_{i=1}^{n} summit[i][n]+valley[i][n]$现在来考虑怎么转移。 以 $summit$ 的转移为例子，假设现在需要转移 $summit[i][n]$. 那么这个波动数列的第二项肯定严格小于 $i$ ，而第三项又严格大于第二项，所以如果不看第一项的话，这个数列就变成了由第二项起头，并且第二项是”山谷”，设第二项的数为 $j$ ，那么其方案数可以用 $valley[j][n-1]$ 来表示。 由于第二项可以是数列中严格小于 $i$ 的任何数，因此我们可以列出转移式： $summit[i][n] = \sum_{k=1}^{i-1} valley[k][n-1]$因为题目说了是严格小于，所以可以这样子统计，亲，放心哦！这样子不会出锅！ 同样的，$valley[i][j]$ 也是这样转移： $valley[i][n] = \sum_{k=i}^{n-1} summit[k][n-1]$我们现在可以很轻易的打出正解了，但是想象一下，我们有那么大的空间吗？$242004200$？貌似很紧诶(虽然我是踩线没有 $MLE$) 那就使用滚动数组！还有，这样子统计，复杂度将会是 $O(n^3)$ ！怎么优化呢？ 前缀和就好了呀！然后……然后就没有然后了…… Code:12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define ll long long#define RI register int #define A printf("A")using namespace std;const int N=4205;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int summit[N][2],valley[N][2],ans,sum,p;int main()&#123; scanf("%d%d",&amp;sum,&amp;p); summit[2][0]=1,valley[1][0]=1,valley[2][0]=1; for(int n=3;n&lt;=sum;++n) for(int i=1;i&lt;=n;++i)&#123; int sum_val,sum_sum; sum_val=(summit[n-1][(n-1)&amp;1]-summit[i-1][(n-1)&amp;1]+p)%p; valley[i][n&amp;1]=(valley[i-1][n&amp;1]+sum_val)%p; sum_sum=valley[i-1][(n-1)&amp;1]%p; summit[i][n&amp;1]=(summit[i-1][n&amp;1]+sum_sum)%p; &#125; ans=(valley[sum][sum&amp;1]+summit[sum][sum&amp;1])%p; printf("%d\n",ans); return 0; &#125; 注意取模，不然会出锅!]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈FFT&学习笔记]]></title>
    <url>%2F2019%2F02%2F15%2F%5B%E7%AE%97%E6%B3%95%5DFFT%2F</url>
    <content type="text"><![CDATA[$QvQ​$ 之前就对这个东西感兴趣，然后被一堆公式踩爆，这样高逼格的名字简直让人无法靠近。终于在 $1​$ 月的时候，教练扯着我搞这个，没想到一天左右就会了。 我们进入正题。 0XFF—-FFT是啥? FFT是一种DFT的高效算法，称为快速傅立叶变换（fast Fourier transform），它根据离散傅氏变换的奇、偶、虚、实等 特性，对离散傅立叶变换的算法进行改进获得的。 —-百度百科 对于两个多项式 $F(x)$ 和 $G(x)$ ，要求你将他们乘起来。 那还不简单？直接暴力相乘啊： 设 $F(x)$ 的系数数列为 $C$。 $F(x) \times G(x) = C_nx^nG(x) + C_{n-1}x^{n-1}G(x) + C_{n-2}x^{n-2}G(x) \cdots C_2x^2G(x) + C_1x^1G(x) + C_0G(x)$ 这样下来需要做做 $n$ 次单项式乘多项式，每次的时间复杂度 $O(n)$ ，则总复杂度高达 $O(n^2)$ 基本上 $n$ 上了$4000$ 就会被卡吧……那怎么提速呢？ 这就需要我们伟大而又神奇的神器：$FFT$ (快速博立叶变换) 复杂度就只有 $O(nlogn)$ 了。 0X1F—-FFT的前置知识. 1.复数是什么? 我们把形如 $z=a+bi$（ $a,b$ 均为实数）的数称为复数，其中 $a$ 称为实部， $b$ 称为虚部， $i$ 称为虚数单位。当虚部等于零时，这个复数可以视为实数；当z的虚部不等于零时，实部等于零时，常称z为纯虚数。复数域是实数域的代数闭包，即任何复系数多项式在复数域中总有根。 复数是由意大利米兰学者卡当在十六世纪首次引入，经过达朗贝尔、棣莫弗、欧拉、高斯等人 的工作，此概念逐渐为数学家所接受。 —-百度百科 想必大家都知道实数是啥(不知道重读幼儿园吧……)，实数位于数轴上，就像下图这样： 我们稍微观察一下，$1$ 是怎么变到 $-1$ 的呢？ 在数轴上转了 180°。 如果，是 90° 的话，会发生什么呢？ 这个时候，会转到 $0$ 上面的位置，但是那里，好像没有数啊! 不对，其实是有的，只不过这个数不在实数轴上，而是在虚数轴上！ 虚数轴的单位是 $i$ ，我们可以这么表示： 嗯，对。这显然是一个平面坐标系。现在我们的数仅限于数轴上，如果是这个平面坐标系上的一个点怎么表达呢？ 对于下面的红色点： 这个点的坐标很容易的可以得到：$(2,i)$ ，也可以表示成 $2+i$ . 你没猜错！这个就叫复数！ 一个很重要的结论：复数相乘时，模长相乘，幅角相加！ 2.点值表示法是什么?我们用一个二维平面坐标系，在上面画 $N+1$ 个点，最终可以解出一个 $n$ 元的函数。证明略。 同样，我们可以用 $N-1$ 个点来表达一个多项式。 因为点值相乘的复杂度只有 $O(n)$ 显然优秀许多。 3.单位根是什么?*n次单位根(n为正整数)是n次幂为1的复数!*n次单位根(n为正整数)是n次幂为1的复数!*n次单位根(n为正整数)是n次幂为1的复数! 我们先在复平面上画个点，就像这样： Ta叫做单位圆。 圆边上的任意一点的模长都是 $1$. 只有单位圆上的点表示的复数才有可能成为$n$次单位根! 单位根的基本符号：$ω$ 一个单位圆，我们将它切成 $n$ 份，从 $(1,0)$ 开始旋转，每次旋转 $\frac{1}{n} \times 360$ 度，每次旋转后的点都记为 $ω_{n}^{k}$，特别的，$ω_{n}^{0}$ 和 $ω_{n}^{n}$ 都是 $(1,0)$ 点。 还有，当 $k&gt;=n$ 或者 $k&lt;0$ 时，$ω_{n}^{k}$ 也是合法的。 单位根的性质：$1.$ 对于任意的 $n$ , $ω_{n}^{0}$ 都为 $(1,0)$ 点。$2.$ $ω_{n}^{a} \times ω_{n}^{b} = ω_{n}^{a+b} $$3.$ $ω_{an}^{ak} = ω_{n}^{k} $$4.$ $(ω_{n}^{x})^y = (ω_{n}^{y})^x $$5.$ $ω_{n}^{k+n/2} = -ω_{n}^{k} $ if(n%2==0) 0X2F—-FFT的求解过程. 分治思想很重要！ 我们将多项式 $F(x)$ 按位置分成两块。 那么变成了(保证n是2的正整数次幂)： $F(x) = (C_0+C_2x^2+C_4x^4+ \cdots +C_{n-2}x^{n-2}) + (C_1x+C_3x^3+C_5x^5+ \cdots +C_{n-1}x^{n-1})$ 设两个多项式 $F1(x),F2(x)$。 $F1(x) = C_0+C_2x+C_4x^2+ \cdots +C_{n-2}x^{n/2-1}$$F2(x) = C_1x+C_3x+C_5x^2+ \cdots +C_{n-1}x^{n/2-1}$ 则我们可以得出： $F(x) = F1(x^2) + F2(x^2) \times x$ 设 $k&lt;n/2$ ， 将 $ω_{n}^{k}$ 带入多项式 $F(x)$. $F(ω_{n}^{k}) = F1((ω_{n}^{k})2) + F2((ω_{n}^{k})^2) \times ω_{n}^{k}$ 简化得： $F(ω_{n}^{k}) = F1(ω_{n/2}^{k}) + F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ 再假设 $k&lt;n/2$ ，将 $ω_{n}^{k+n/2}$ 带入多项式 $F(x)$. $F(ω_{n}^{k+n/2}) = F1((ω_{n}^{k+n/2})2) + F2((ω_{n}^{k+n/2})^2) \times ω_{n}^{k}$$F(ω_{n}^{k+n/2}) = F1(ω_{n}^{2k+n}) + F2(ω_{n}^{2k+n}) \times ω_{n}^{k+n/2}$$F(ω_{n}^{k+n/2}) = F1(ω_{n}^{2k}) + F2(ω_{n}^{2k}) \times ω_{n}^{k+n/2}$$F(ω_{n}^{k+n/2}) = F1(ω_{n/2}^{k}) + F2(ω_{n/2}^{k}) \times ω_{n}^{k+n/2}$$F(ω_{n}^{k+n/2}) = F1(ω_{n/2}^{k}) - F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ 比较一下两个式子： $F(ω_{n}^{k}) = F1(ω_{n/2}^{k}) + F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ $F(ω_{n}^{k+n/2}) = F1(ω_{n/2}^{k}) - F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ 等式右边只有一个负号的差别! 这两个式子很关键！ 0X3F—-FFT的代码实现.对于复数的使用虽然 $C++ STL$ 里面有复数 $(complex)$ 但是太慢不建议大家使用。 你可以自己手打 $complex$ 手打的 $complex$ : 1234struct complex&#123;complex(double a=0,double b=0)&#123;x=a,y=b;&#125;double x,y;&#125;;complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125;complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125;complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125; FFT: 123456789101112131415complex a[N],b[N];inline void FFT(complex *f,int len,short inv)&#123; if(!len)return;complex f1[len+1],f2[len+2]; for(int k=0;k&lt;len;++k)f1[k]=f[k&lt;&lt;1],f2[k]=f[k&lt;&lt;1|1];//按位置分 FFT(f1,len&gt;&gt;1,inv);FFT(f2,len&gt;&gt;1,inv);//递归处理子问题 complex tmp=complex(cos(PI/len),inv*sin(PI/len)),buf=complex(1,0); /*tmp:做一次平方后坐标的变换*/ /*buf:初始位置*/ for(RI k=0;k&lt;len;++k)&#123; complex t=buf*f2[k]; f[k]=f1[k]+t,f[k+len]=f1[k]-t;buf=buf*tmp;//按照公式还原 &#125;return;&#125;//注意，inv的作用是判断是 "系数转点值" 还是 "点值转系数" $Code$ 中提到的公式是这两项： $F(ω_{n}^{k}) = F1(ω_{n/2}^{k}) + F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ $F(ω_{n}^{k+n/2}) = F1(ω_{n/2}^{k}) - F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ 对于文中的”坐标的变换”：我们依旧来看单位圆： 实际上，这个坐标的变换，直接用园中的三角形，运用三角函数就可以得出解了。 过程略. 最后我们得到的结果是：$ω_{n}^{1} = (cos(\frac{2π}{n}),sin(\frac{2π}{n}))$ 求出 $ω_{n}^{1}$ 后将它乘 $n$ 次，可以得到：$ {ω_{n}^{0},ω_{n}^{1},ω_{n}^{2},ω_{n}^{3},ω_{n}^{4},ω_{n}^{5} \cdots ω_{n}^{n-1}} $ 贴出最终的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define ll long long#define RI register int #define inf 0x3f3f3f3f#define PI 3.1415926535898using namespace std;const int N=6e4+2;template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; struct complex&#123;complex(double a=0,double b=0)&#123;x=a,y=b;&#125;double x,y;&#125;;complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125;complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125;complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;complex a[N],b[N];inline void FFT(complex *f,int len,short inv)&#123; if(!len)return;complex f1[len+1],f2[len+2]; for(int k=0;k&lt;len;++k)f1[k]=f[k&lt;&lt;1],f2[k]=f[k&lt;&lt;1|1]; FFT(f1,len&gt;&gt;1,inv);FFT(f2,len&gt;&gt;1,inv); complex tmp=complex(cos(PI/len),inv*sin(PI/len)),buf=complex(1,0); for(RI k=0;k&lt;len;++k)&#123; complex t=buf*f2[k]; f[k]=f1[k]+t,f[k+len]=f1[k]-t;buf=buf*tmp; &#125;return;&#125;int n,m;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(RI i=0;i&lt;=n;++i)scanf("%lf",&amp;a[i].x); for(RI i=0;i&lt;=m;++i)scanf("%lf",&amp;b[i].x); for(m+=n,n=1;n&lt;=m;n&lt;&lt;=1); FFT(a,n&gt;&gt;1,1);FFT(b,n&gt;&gt;1,1); for(int i=0;i&lt;n;++i)a[i]=a[i]*b[i]; FFT(a,n&gt;&gt;1,-1); for(int i=0;i&lt;=m;++i)printf("%.0f ",fabs(a[i].x)/n); putchar('\n'); return 0;&#125; 听说可以优化，那啥的我还不会，就到这吧. 过了一会儿…… “原来FFT小优化这么简单啊!” 0X4F—-FFT的一些小优化. 不用递归：12345递归版(数组下标，先偶后奇，从0开始)：0 1 2 3 4 5 6 7 --第1层0 2 4 6 |1 3 5 7 --第2层0 4 |2 6 |1 5 |3 7 --第3层0 |4 |2 |6 |1 |5 |3| 7 --第4层 发现了什么吗？ 最后的序列是原序列的二进制反转! 比如： $6 = (110)_2$ 反过来变成了 $(011)_2 = 3$ ！ 如何得到二进制翻转后的数列？递推即可! 12for(RI i=0;i&lt;n;++i)filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); //filp[i] 即为 i 的二进制位翻转 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define ll long long#define RI register int #define inf 0x3f3f3f3f#define PI 3.1415926535898using namespace std;const int N=3e6+2;int n,m,filp[N]; template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; struct complex&#123;complex(double a=0,double b=0)&#123;x=a,y=b;&#125;double x,y;&#125;;complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125;complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125;complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;complex a[N],b[N];inline void FFT(complex *f,short inv)&#123; for(RI i=0;i&lt;n;++i)if(i&lt;filp[i])&#123;complex tmp=f[i];f[i]=f[filp[i]];f[filp[i]]=tmp;&#125; /*换位置*/ for(RI p=2;p&lt;=n;p&lt;&lt;=1)&#123;//每局区间长度 RI len=p/2;//合并子区间的长度(所以是p/2) complex tmp=complex(cos(PI/len),inv*sin(PI/len)); for(RI k=0;k&lt;n;k+=p)&#123;//每局左端点 complex buf=complex(1,0); for(RI l=k;l&lt;k+len;++l)&#123;//遍历区间 complex t=buf*f[len+l]; f[len+l]=f[l]-t,f[l]=f[l]+t,buf=buf*tmp;//赋值有微小的变化，注意顺序！ &#125; &#125; &#125;return;&#125;/*主程序不变*/int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(RI i=0;i&lt;=n;++i)scanf("%lf",&amp;a[i].x); for(RI i=0;i&lt;=m;++i)scanf("%lf",&amp;b[i].x); for(m+=n,n=1;n&lt;=m;n&lt;&lt;=1); for(RI i=0;i&lt;n;++i)filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); FFT(a,1);FFT(b,1); for(RI i=0;i&lt;n;++i)a[i]=a[i]*b[i]; FFT(a,-1); for(RI i=0;i&lt;=m;++i)printf("%.0f ",fabs(a[i].x)/n); putchar('\n'); return 0;&#125; luogu上的题，递归的总是T最后一个点，改成非递归版的就A了？emmmmmmmmmmmmmm 所有优化全开：很作死，建议不要轻易尝试[滑稽] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma GCC optimize(2)#pragma GCC optimize(3)#pragma GCC optimize("Ofast")#pragma GCC optimize("inline")#pragma GCC optimize("-fgcse")#pragma GCC optimize("-fgcse-lm")#pragma GCC optimize("-fipa-sra")#pragma GCC optimize("-ftree-pre")#pragma GCC optimize("-ftree-vrp")#pragma GCC optimize("-fpeephole2")#pragma GCC optimize("-ffast-math")#pragma GCC optimize("-fsched-spec")#pragma GCC optimize("unroll-loops")#pragma GCC optimize("-falign-jumps")#pragma GCC optimize("-falign-loops")#pragma GCC optimize("-falign-labels")#pragma GCC optimize("-fdevirtualize")#pragma GCC optimize("-fcaller-saves")#pragma GCC optimize("-fcrossjumping")#pragma GCC optimize("-fthread-jumps")#pragma GCC optimize("-funroll-loops")#pragma GCC optimize("-fwhole-program")#pragma GCC optimize("-freorder-blocks")#pragma GCC optimize("-fschedule-insns")#pragma GCC optimize("inline-functions")#pragma GCC optimize("-ftree-tail-merge")#pragma GCC optimize("-fschedule-insns2")#pragma GCC optimize("-fstrict-aliasing")#pragma GCC optimize("-fstrict-overflow")#pragma GCC optimize("-falign-functions")#pragma GCC optimize("-fcse-skip-blocks")#pragma GCC optimize("-fcse-follow-jumps")#pragma GCC optimize("-fsched-interblock")#pragma GCC optimize("-fpartial-inlining")#pragma GCC optimize("no-stack-protector")#pragma GCC optimize("-freorder-functions")#pragma GCC optimize("-findirect-inlining")#pragma GCC optimize("-fhoist-adjacent-loads")#pragma GCC optimize("-frerun-cse-after-loop")#pragma GCC optimize("inline-small-functions")#pragma GCC optimize("-finline-small-functions")#pragma GCC optimize("-ftree-switch-conversion")#pragma GCC optimize("-foptimize-sibling-calls")#pragma GCC optimize("-fexpensive-optimizations")#pragma GCC optimize("-funsafe-loop-optimizations")#pragma GCC optimize("inline-functions-called-once")#pragma GCC optimize("-fdelete-null-pointer-checks") [滑稽][滑稽][滑稽][滑稽][滑稽][滑稽][滑稽][滑稽][滑稽][滑稽][滑稽] NNT———学习笔记———关于FFT兄弟的那些事 0X5F—-NTT是啥? NTT(快速数论变换)一种快速数论变换算法，这种算法是以数论为基础，对样本点为的数论变换，按时间抽取的方法，得到一组等价的迭代方程，有效高速简化了方程中的计算公式·与直接计算相比，大大减少了运算次数。（见快速傅里叶变换）。在计算机实现多项式乘法中，我们所熟知的快速傅里叶变换(FFT)是基于n次单位根$ω_{n}$ $(omega)$ 的优秀性质实现的，而由于其计算时会使用正弦函数和余弦函数，在不断运算时无法避免地会产生精度误差。而多项式乘法有些时候会建立在模域中，在对一些特殊的大质数取模时，便可以考虑用原根g来代替$ω_{n}$，而这些特殊的大质数的原根恰好满足$ω_{n}$的某些性质，这使得多项式乘法在模域中也可以快速的分治合并。 ———百度百科 实际上，$NTT$ 跟 $FFT$ 没啥差别，优缺点各有。优点，就是省掉了大精度的操作，常数较小。 贴出我在luogu的P3803测评记录： O2—-FFT: 无优化—NTT: (速度不在一个服务器……) 当然，什么东西都是有缺点的，$NTT$ 的缺点就是多项式的系数只能是整数 ，而且普通的 $NTT$ 并不能做到任意模数，比较有限制(但是像XZY这样的奆佬随手可以水过任意模数NTT)，不过对于一般的像998244353这样的模数可以跑。 实现的基础———原根 原根是一种数学符号，设 $m$ 是正整数，$a$ 是整数，若 $a$ 模 $m$ 的阶等于 $φ(m)$ ，则称 $a$ 为模 $m$ 的一个原根。（其中 $φ(m)$ 表示 $m$ 的欧拉函数）———百度百科 为什么 $FFT$ 可以如此优秀？那是因为单位根有着神奇的性质。原根也是如此！ 合并的时候，$p=2len$ . 单位根：$cos\frac{2π}{P}+i sin\frac{2π}{P} = cos\frac{π}{len} + i sin\frac{π}{len}$ 原根：$g^{\frac{MOD-1}{P}} = g^{\frac{MOD-1}{2len}}$ $NTT$ 的学习是建立在 $FFT$ 上的，建议大家先理解 $FFT$ 再来看 $NTT$ 多说无益，贴板子吧…… 1234567891011121314151617181920212223#define MOD 998244353#define G 3inline int pow(int x,int y)//快速幂&#123;ll z=1ll*x,ans=1ll;for(;y;y/=2,z=z*z%MOD)if(y&amp;1)ans=ans*z%MOD;return (int)ans%MOD;&#125;inline void NTT(int *f,short inv)&#123;//NTT板子 int bit=0;while((1&lt;&lt;bit)&lt;n)bit++; for(RI i=0;i&lt;n;++i)&#123; filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); if(i&lt;filp[i])swap(f[i],f[filp[i]]); &#125; for(RI len=1;len&lt;n;len&lt;&lt;=1)&#123; RI tmp=pow(G,(MOD-1)/(len&lt;&lt;1)); if(inv==-1)tmp=pow(tmp,MOD-2);//是逆运算的话就套逆元 for(RI k=0;k&lt;n;k+=len*2)&#123; int buf=1; for(RI l=0;l&lt;len;++l,buf=1ll*buf*tmp%MOD)&#123; int t=f[l+k],d=1ll*buf*f[l+k+len]%MOD; f[l+k]=t+d,f[l+k+len]=t-d,//注意差别 f[l+k]=(f[l+k]%MOD+MOD)%MOD,f[l+k+len]=(f[l+k+len]%MOD+MOD)%MOD; &#125; &#125; &#125;&#125; 那一题的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define ll long long#define RI register int #define inf 0x3f3f3f3f#define MOD 998244353#define G 3using namespace std;const int N=3e6+2;int n=1,len1,len2,filp[N],a[N],b[N];template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline int pow(int x,int y)&#123;ll z=1ll*x,ans=1ll;for(;y;y/=2,z=z*z%MOD)if(y&amp;1)ans=ans*z%MOD;return (int)ans%MOD;&#125;inline void NTT(int *f,short inv)&#123; int bit=0;while((1&lt;&lt;bit)&lt;n)bit++; for(RI i=0;i&lt;n;++i)&#123; filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); if(i&lt;filp[i])swap(f[i],f[filp[i]]); &#125; for(RI len=1;len&lt;n;len&lt;&lt;=1)&#123; RI tmp=pow(G,(MOD-1)/(len&lt;&lt;1)); if(inv==-1)tmp=pow(tmp,MOD-2); for(RI k=0;k&lt;n;k+=len*2)&#123; int buf=1; for(RI l=0;l&lt;len;++l,buf=1ll*buf*tmp%MOD)&#123; int t=f[l+k],d=1ll*buf*f[l+k+len]%MOD; f[l+k]=t+d,f[l+k+len]=t-d, f[l+k]=(f[l+k]%MOD+MOD)%MOD,f[l+k+len]=(f[l+k+len]%MOD+MOD)%MOD; &#125; &#125; &#125;&#125;int main()&#123; IN(len1),IN(len2);len1++,len2++; while(n&lt;len1+len2)n&lt;&lt;=1; for(RI i=0;i&lt;=len1-1;++i)IN(a[i]); for(RI i=0;i&lt;=len2-1;++i)IN(b[i]); NTT(a,1);NTT(b,1); for(RI i=0;i&lt;n;++i)a[i]=1ll*a[i]*b[i]%MOD; NTT(a,-1); for(RI i=0;i&lt;=len1+len2-2;++i)printf("%d ",1ll*a[i]*pow(n,MOD-2)%MOD); putchar('\n'); return 0;&#125; 0X3f3f3f3f 附记来一张表吧： 模数 G的值 3 2 5 2 17 3 97 5 193 5 257 3 7681 17 12289 11 40961 3 65537 3 786433 10 5767169 3 7340033 3 23068673 3 104857601 3 167772161 3 469762049 3 998244353 3 1004535809 3 2013265921 31 2281701377 3 3221225473 5 75161927681 3 77309411329 7 最后，因为本人实在太弱了，太蒟了，所以实在写不出啥了。 $by Qiuly$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 「网络流24题」骑士共存问题 网络流 luoguP3355]]></title>
    <url>%2F2019%2F02%2F15%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3355%2F</url>
    <content type="text"><![CDATA[最大流于最小割的转换。 假设现在棋盘上非障碍的位置全部摆满了骑士，我们拿走 $x$ 个的骑士可以使棋盘上的所有骑士互不冲突，求最小的 $x$. 可以跑匈牙利，也可以跑最大流算法，我选择跑 $Dinic$。 所有编号为奇数的点向源点 $s$ 连边，所有编号为偶数的点向汇点 $t$ ，连边，边权为 $1$.可以知道，同奇偶编号的点是无法互相攻击的，我们将在奇数和偶数之间可以攻击到彼此的点连一条边权无限大的边。 然后跑一遍 $Dinic$ 。 然后就没了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int #define ID(i,j) ((i-1)*n+j)#define A printf("A")using namespace std;const int M=5e5+2;const short dx[8]=&#123;1,1,-1,-1,2,2,-2,-2&#125;;const short dy[8]=&#123;2,-2,2,-2,1,-1,1,-1&#125;;int n,m,s,t,sum,cnt,dep[M],head[M];short ok[202][202];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct Edge&#123;int nxt,to,val;&#125;G[M];inline void add(int x,int y,int v)&#123; G[cnt].to=y,G[cnt].val=v,G[cnt].nxt=head[x],head[x]=cnt++; G[cnt].to=x,G[cnt].val=0,G[cnt].nxt=head[y],head[y]=cnt++;&#125; inline bool bfs()&#123; memset(dep,-1,sizeof(dep)); queue&lt;int&gt;q;q.push(s);dep[s]=0; while(q.size())&#123; int x=q.front();q.pop(); for(int i=head[x];i!=-1;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]!=-1||!G[i].val)continue; else&#123;dep[y]=dep[x]+1,q.push(y);if(y==t)return true;&#125; &#125; &#125;return false;&#125; inline int dfs(int x,int flow)&#123; if(x==t||!flow)return flow; int used=0,rlow; for(int i=head[x];i!=-1;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used;&#125;inline int dinic()&#123; int maxlow=0; while(bfs())maxlow+=dfs(s,1e9); return maxlow; &#125;int main()&#123; memset(head,-1,sizeof(head)); IN(n),IN(m);s=0,t=n*n+1;sum=n*n-m; for(int x,y,i=1;i&lt;=m;++i)IN(x),IN(y),ok[x][y]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j)&#123; if(ok[i][j])continue; if((i+j)&amp;1)&#123; add(s,ID(i,j),1); for(int k=0;k&lt;8;++k)&#123; int nx=i+dx[k],ny=j+dy[k]; if(nx&lt;1||ny&lt;1||nx&gt;n||ny&gt;n||ok[nx][ny])continue; add(ID(i,j),ID(nx,ny),1e9); &#125; &#125;else add(ID(i,j),t,1); &#125;printf("%d\n",sum-dinic()); return 0; &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 跳楼机 同余最短路 luogu3403]]></title>
    <url>%2F2019%2F02%2F15%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3403%2F</url>
    <content type="text"><![CDATA[对于 $x,y,z$ 三个操作，我们先考虑 $y,z$ 两个操作的情况。 $f[i]$ 表示通过 $y,z$ 两个操作可以到达的 $mod x=i$ 最小的楼层。 可以得知：$f[i+y]=f[i]+y,f[i+z]=f[i]+z.$ 对于最短路，我们可以用一下形式建边： 1add(i,(i+y)%x,y); add(i,(i+z)%x,z); 没问题吧？%x是必须要做的操作，上文讲了。 那如何统计答案呢？ 首先，如果这个 “最小的楼层” 超出了 $H$ ，那么显然是不用统计的。否则，我们将这样统计：ans+=(H-f[i])/x+1; 为什么要这样写呢？想想，现在我们知道了这个最小楼层，我们可以到达这个最小楼层，对吧？如果现在以这个最小楼层为起点，我们可以选择在往上跳 $x$ 层，或者是 $2x$ 层….知道 $nx$ 层，$(n+1)x$就会超出 $H$，这时上面的式子就好理解多了。 Code:(可以不用 堆优$Dijstra$，没必要，用 $Spfa$ 就行了)12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register intusing namespace std;const int N=1e5+3;ll H,x,y,z,ans,f[N];int vis[N],head[N],cnt;struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;1]; inline void add(int x,int y,int v)&#123;G[++cnt].nxt=head[x],G[cnt].to=y,G[cnt].val=v,head[x]=cnt;&#125;inline void spfa()&#123; memset(f,127,sizeof(f)); queue&lt;int&gt; q;f[1]=1,vis[1]=1,q.push(1); while(q.size())&#123; int x=q.front();q.pop();vis[x]=0; for(RI i=head[x];i;i=G[i].nxt)&#123; if(f[G[i].to]&gt;f[x]+G[i].val)&#123; f[G[i].to]=f[x]+G[i].val; if(!vis[G[i].to])q.push(G[i].to),vis[G[i].to]=1; &#125; &#125; &#125;return;&#125;int main()&#123; scanf("%lld%lld%lld%lld",&amp;H,&amp;x,&amp;y,&amp;z); if(x==1||y==1||z==1)&#123;printf("%lld\n",H);return 0;&#125; for(int i=0;i&lt;x;++i)&#123;add(i,(i+y)%x,y);add(i,(i+z)%x,z);&#125; spfa(); for(int i=0;i&lt;x;++i) if(f[i]&lt;=H)ans+=(H-f[i])/x+1; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>同余最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [ICPC-Beijing 2006]狼抓兔子 网络流 bzoj1001/洛谷P4001]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4001%2F</url>
    <content type="text"><![CDATA[网络流水题。 既然要抓到所有的兔子，又要用最少的狼，很容易想到，这是在让我们求最小割。 那么如何求最小割呢？ 有一条定理是这样的：最大流=最小割 所以我们只要用 $Dinic$ 跑出最大流，然后直接输出就行了。 不过，为什么最大流=最小割呢？ 网上的一名 $Dalao$ 给出了答案： $Q:$ 如何凭直觉解释最大流等于最小割? $A:$ $1.$ 最大流不可能大于最小割, 因为最大流所有的水流都一定经过最小割那些割边, 流过的水流怎么可能比水管容量还大呢? $2.$ 最大流不可能小于最小割, 如果小, 那么说明水管容量没有物尽其用, 可以继续加大水流. $Q:$ 如何严谨证明最大流等于最小割? $A:$ $1.$ 证明任意的 $s-t$ 流量小于 $s-t$ 割容量, 证明方法: 根据定义即可; $2.$ 根据 $Ford-Fulkerson$ 算法求出的流来选出一个 $s-t$ 割, $S$ 为残余网络中 $s$ 可达的顶点集合, 这样就可以证出算法求出的流$=$这个割的容量, 再根据已经证明的 $1$ 来得出算法求出的流是最大流, 对应的割是最小割. $Dalao——Jecvay Notes$ 现在要注意的一点就是，直接跑朴素的 $Dinic$ 是会 T 的，这个时候或许会要一些优化，比如说用当前弧优化，或者可以跑$ISAP$，如果还过不了，吸氧算了[滑稽]。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define RI register int#define ll long longconst int N=1e6+2;const int inf=1e9+9;struct Edge&#123; int nxt,to,val;&#125;G[N*6];int n,m,s,t,cnt=1,dep[N],head[N];#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y)) template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline int id(int x,int y)&#123;return (x-1)*m+y;&#125;inline void add(int x,int y,int v)&#123; G[++cnt].nxt=head[x],G[cnt].to=y,G[cnt].val=v,head[x]=cnt; G[++cnt].nxt=head[y],G[cnt].to=x,G[cnt].val=v,head[y]=cnt;&#125;inline bool bfs()&#123; std::memset(dep,0,sizeof(dep)); std::queue&lt;int&gt;q;q.push(s),dep[s]=1; while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]||!G[i].val)continue; dep[y]=dep[x]+1;q.push(y); if(y==t)return true; &#125; &#125;return false;&#125;inline int dfs(int x,int flow)&#123; if(x==t)return flow; int used=0; for(int i=head[x];i&amp;&amp;used&lt;flow;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]!=dep[x]+1||!G[i].val)continue; else&#123; int rlow=dfs(y,min(G[i].val,flow-used)); if(!rlow)&#123;dep[y]=-1;continue;&#125; G[i].val-=rlow,G[i^1].val+=rlow,used+=rlow; &#125; &#125;return used;&#125;inline int Dinic()&#123; int ans=0; while(bfs())ans+=dfs(s,inf); return ans;&#125;int main()&#123; int v; IN(n),IN(m);s=1,t=n*m; for(int i=1;i&lt;=n;++i) for(int j=2;j&lt;=m;++j) IN(v),add(id(i,j-1),id(i,j),v); for(int i=2;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) IN(v),add(id(i-1,j),id(i,j),v); for(int i=2;i&lt;=n;++i) for(int j=2;j&lt;=m;++j) IN(v),add(id(i-1,j-1),id(i,j),v); printf("%d\n",Dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [USACO18DEC]Balance Beam 期望+凸包 洛谷P5155]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP5155%2F</url>
    <content type="text"><![CDATA[被概率冲昏的头脑~~~ 我们先将样例在图上画下来： 会发现，最大收益是： ) 看出什么了吗？ 这不就是凸包吗？ 跑一遍凸包就好了呀，这些点中，如果i号点是凸包上的点，那么它的ans就是自己(第二个点)，不然的话，从上图来看，i的ans肯定和他相邻的两个是凸包边界的点有关(0节点和2节点)，那么怎么求这个ans呢？(第x号点为横坐标为x的点) 实际上我也不知道就是个期望公式啊! l[i]记录i号点往左走第一个为凸包边界的点(如果i为1号，那么l[i]为0，特殊的，如果i为2号，那么l[i]就是本身)，r[i]同理。当l[x]==r[x]时，x时边界。 就是这个方程： (f[l[i]])*(r[i]-i)+f[r[i]]*(i-l[i])))/(r[i]-l[i]);基础的期望方程，在此不再赘述(实际上是不会证) 关于凸包，在这贴一波yyb大神的博客：传送门戳我QwQ(顺便膜一波yyb大神%%%) 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int#define F 100000using namespace std;const int NS=1e5+5;ll f[NS],l[NS],r[NS],hep[NS];//f如题,l[i]/r[i]如上文,hep为凸包 template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int main()&#123; int n,top=0;IN(n);hep[++top]=0;//注意先加入0! for(int i=1;i&lt;=n;++i)IN(f[i]); for(int i=1;i&lt;=n+1;++i)&#123;//凸包 while(top&gt;=2)&#123; int a=hep[top],b=hep[top-1]; if(((f[a]-f[b])*(i-a))&lt;((f[i]-f[a])*(a-b)))--top; else break; &#125;hep[++top]=i; &#125; for(int i=1;i&lt;top;++i)&#123; //中间的节点的l,r值都为hep[i]/hep[i+1] for(int j=hep[i]+1;j&lt;hep[i+1];++j)&#123; l[j]=hep[i],r[j]=hep[i+1]; &#125;l[hep[i]]=hep[i],r[hep[i]]=hep[i]; &#125; for(int i=1;i&lt;=n;++i)&#123; ll ans=0;//记得LL! if(l[i]==r[i])ans=f[i]*F;//为边界，直接跳下最优 else ans=(F*(f[l[i]]*(r[i]-i)+f[r[i]]*(i-l[i])))/(r[i]-l[i]);//否则用方程算 printf("%lld\n",ans); &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>期望</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈树套树(线段树套平衡树)&学习笔记]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E7%AE%97%E6%B3%95%5D%E6%A0%91%E5%A5%97%E6%A0%91(%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E5%B9%B3%E8%A1%A1%E6%A0%91)%2F</url>
    <content type="text"><![CDATA[唉还是太弱了，毕竟只会初级的线段树套平衡树，$QvQ$ 码量巨大，超级不适合我这种天生码量恐惧症的人…… 那么我们开始正文 0XFF 前言 *如果本文有不好的地方，请在下方评论区提出，Monlights感激不尽！ 0X1F 这个东西有啥用? 树套树———线段树套平衡树，可以用于解决待修改区间$K$大的问题，当然也可以用 树套树———树状数组套可持久化线段树，但是 线段树套平衡树 更加容易理解，更加便于新手理解，所以一般也作为树套树的入门类别。对于静态区间$K$大，我们可以用小巧精悍的主席树来做，也可以用强大无比的$Splay$来做。如果带修改，主席树就无能为力了，$Splay$也会变得很棘手难打。如果用普通线段树，每个节点都有着一课包含子节点的$Splay$，对于一个区间，直接调用线段树上的$Splay$就迎刃而解了。这时的$Splay$不是对全局，而是只对这个线段树节点代表的区间。 当然，树套树———线段树套平衡树并不是那么的好打，还是要动纸笔 and 动脑筋。缺点也是有的：因为要打$Splay$和线段树，模板的码量就有 $150$ 行！因为线段树本来就是易手滑的数据结构，稍不留神可能会让你调上好久！另外，因为$Splay$的常数极大，再这么通过线段树一罩，效率就下来了许多，常数巨大无比……总之 树套树 是一个很强的数据结构，但是如果题目不是强制在线的话，$CDQ$分治和整体二分会将树套树吊起来打！ ——————Qiuly 0X2F 这个东西怎么实现?首先，线段树套平衡树可以解决的一般问题如下： 查询 $k$ 在区间 $l,r$ 内的排名 查询区间 $l,r$ 内排名为 $k$ 的值 修改某一位置上的数值 查询 $k$ 在区间 $l,r$ 内的前驱 查询 $k$ 在区间 $l,r$ 内的后继 修改区间 $l,r$ 的值(集体加减)(不会) ………… 我们今天来讲讲前五个基础操作怎么实现(我只会前五个操作) 0X2f-1 查询 $k$ 在区间 $l,r$ 内的排名我们先将一个外面的线段树画下来： (叶子节点中的数字是序列各个元素的权值) 假设我们现在要查询区间 $3,8$ 中 $5$ 的排名。 查询一个数的排名，很显然，就是查询这个区间内有多少个数比 Ta 小，然后在+1(即自己)。 那怎么查询 $3,8$ 区间内有多少个数比他小呢？$3,8$ 不是整个线段树节点啊。 我们可以将它分成若干个线段树节点来处理。 Code:123456789101112131415161718inline int Splay_rank(int i,int k)&#123;//i表示以线段树的i号节点为根的Splay int x=rt[i],cal=0;//板子就不再赘述了 while(x)&#123; if(v[x]==k)return cal+((ch[x][0])?s[ch[x][0]]:0); else if(v[x]&lt;k)&#123; cal+=((ch[x][0])?s[ch[x][0]]:0)+c[x];x=ch[x][1]; &#125;else x=ch[x][0]; &#125;return cal;&#125;;inline void Seg_rank(int x,int l,int r,int L,int R,int Kth)&#123; if(l==L&amp;&amp;r==R)&#123;ans+=Splay_rank(x,Kth);return;&#125;//是整个线段树节点 if(R&lt;=mid)Seg_rank(lc,l,mid,L,R,Kth);//情况1：完全属于左子树 else if(L&gt;mid)Seg_rank(rc,mid+1,r,L,R,Kth);//情况2：完全属于右子树 else Seg_rank(lc,l,mid,L,mid,Kth),Seg_rank(rc,mid+1,r,mid+1,R,Kth);//情况3：横跨两子树区间&#125;;//Main 函数中case 1:&#123;IN(v);ans=0;Seg_rank(1,1,n,x,y,v);printf("%d\n",ans+1);&#125;break; 没看懂？我们来一步一步解读。 首先，进入线段树。 不是整个线段树节点，跳过第一条语句。发现 $3,8$ 横跨了两个子树，拆开询问区间，先询问左子树。这个时候往左子树递归，目标询问区间 $3,4$ ，右子树目标询问区间 $5,8$ 。分别处理。 进入左子树： 然后，发现询问区间完全属于右子树(当前区间：$1,4$ , 询问区间：$3~4$)，所以直接递归右子树： 这个时候，发现当前区间和询问区间合并了(当前区间：$3,4$ , 询问区间：$3~4$)，$Splay$ 询问小于 $5$ 的数的个数。 区间：$3,4$ 的 $Splay$ : 至于 $Splay$ 里面的操作不在模拟，因为 $(4,6)$ 中比 $5$ 小的只有一个数，所以 $ans+=1$ ，现在 $ans=1$ 左子树的任务完成，现在处理在右子树的询问区间 $(5,8)$ ，发现一下去 当前区间：$5,8$ , 询问区间：$5,8$ 合并了！直接跳进 $Splay$。 跑完 $Splay$ 后，发现有两个数小于 $5$ ($=$的不算)，$ans+=2$ ，现在 $ans=3$ 。 所以询问区间全部处理完了，退出函数。main函数输出：$ans(3)+1=4$ 即答案为 $4$ . 0X2f-2 查询区间 $l,r$ 内排名为 $k$ 的值这个我们需要用到二分来实现，我们不能讲询问区间拆成两个区间(像第一个操作那样)，因为合并不了答案啊。 所以我们依靠二分来实现。 Code: 1234567891011inline int Get_Kth(int x,int y,int k)&#123; int L=0,R=MX+1,M;//MX为序列权值的最大值，上图中MX为9. while(L&lt;R)&#123; M=(L+R)&gt;&gt;1; ans=0;Seg_rank(1,1,n,x,y,M);//询问M的排名 if(ans&lt;k)L=M+1;else R=M;//二分 &#125;return L-1;//return&#125;;//Main函数中case 2:&#123;IN(v);printf("%d\n",Get_Kth(x,y,v));&#125;break; 这个我就不贴图了，不好画图解释。理解不难，多读几遍代码就好了。 0X2f-3 修改某一位置上的数值这个很简单，跟普通的线段树单点修改几乎一模一样，只是要同时更新 $Splay$。 123456789inline void Seg_change(int x,int l,int r,int pos,int val)&#123; Splay_Delete(x,a[pos]);Splay_Insert(x,val);//更新 Splay if(l==r)&#123;a[pos]=val;return;&#125;;//修改序列的值 if(pos&lt;=mid)Seg_change(lc,l,mid,pos,val);//普通的线段树 else Seg_change(rc,mid+1,r,pos,val);&#125;;//Main函数中case 3:&#123;Seg_change(1,1,n,x,y);&#125;break; 0X2f-4 查询 $k$ 在区间 $l,r$ 内的前驱对于这个操作，我们依旧可以拆开来操作，合并的时候对于每个拆分后的询问区间的答案取个最大值，因为是求前驱，肯定是越接近 $k$ 越好。 123456789inline void Seg_pre(int x,int l,int r,int L,int R,int val)&#123; if(l==L&amp;&amp;r==R)&#123;ans=max(ans,Splay_Get_pre(x,val));return;&#125; if(R&lt;=mid)Seg_pre(lc,l,mid,L,R,val); else if(L&gt;mid)Seg_pre(rc,mid+1,r,L,R,val); else Seg_pre(lc,l,mid,L,mid,val),Seg_pre(rc,mid+1,r,mid+1,R,val);&#125;;//Main函数中case 4:&#123;IN(v);ans=-inf;Seg_pre(1,1,n,x,y,v);printf("%d\n",ans);&#125;break; 0X2f-4 查询 $k$ 在区间 $l,r$ 内的后继 跟 $4$ 操作同理. 0X3F 一些题目 BZOJ3196: Tyvj 1730 二逼平衡树LUOGU P3380【模板】二逼平衡树(树套树) 这道题就是上面讲的那道啊! Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define RI register int #define A printf("A")#define C printf(" ")#define inf 2147483647#define PI 3.1415926535898using namespace std;const int N=4e6+2;//template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; //template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int n,m,a[N],ans,MX;/*----------------------------------Splay-------------------------------------*/int f[N],c[N],s[N],v[N],ch[N][2],rt[N],tot;inline int chk(int x)&#123;return ch[f[x]][1]==x;&#125;;inline void Splay_del_node(int x)&#123;f[x]=s[x]=c[x]=v[x]=ch[x][0]=ch[x][1]=0;&#125;;inline void Splay_pushup(int x)&#123;s[x]=(ch[x][0]?s[ch[x][0]]:0)+(ch[x][1]?s[ch[x][1]]:0)+c[x];&#125;;inline void Splay_rotate(int x)&#123; int y=f[x],z=f[y],k=chk(x),v=ch[x][k^1]; ch[y][k]=v;if(v)f[v]=y;f[x]=z;if(z)ch[z][chk(y)]=x; f[y]=x,ch[x][k^1]=y;Splay_pushup(y),Splay_pushup(x);&#125;;inline void Splay(int i,int x,int top=0)&#123; while(f[x]!=top)&#123; int y=f[x],z=f[y]; if(z!=top)Splay_rotate((ch[z][0]==y)==(ch[y][0]==x)?y:x); Splay_rotate(x); &#125;if(!top)rt[i]=x;&#125;;inline void Splay_Insert(int i,int x)&#123; int pos=rt[i]; if(!rt[i])&#123; rt[i]=pos=++tot;v[pos]=x;s[pos]=c[pos]=1; f[pos]=ch[pos][0]=ch[pos][1]=0;return; &#125;int last=0; while(1)&#123; if(v[pos]==x)&#123;++c[pos];Splay_pushup(last);break;&#125; last=pos;pos=ch[pos][x&gt;v[pos]]; if(!pos)&#123; pos=++tot;v[pos]=x;s[pos]=c[pos]=1; ch[last][x&gt;v[last]]=pos; f[pos]=last;ch[pos][0]=ch[pos][1]=0; Splay_pushup(last);break; &#125; &#125;Splay(i,pos);return;&#125;;inline int Splay_rank(int i,int k)&#123; int x=rt[i],cal=0; while(x)&#123; if(v[x]==k)return cal+((ch[x][0])?s[ch[x][0]]:0); else if(v[x]&lt;k)&#123; cal+=((ch[x][0])?s[ch[x][0]]:0)+c[x];x=ch[x][1]; &#125;else x=ch[x][0]; &#125;return cal;&#125;;inline int Splay_find(int i,int x)&#123; int pos=rt[i];while(x)&#123; if(v[pos]==x)&#123;Splay(i,pos);return pos;&#125;; pos=ch[pos][x&gt;v[pos]]; &#125;return 0;&#125;;inline int Splay_pre(int i)&#123;int x=ch[rt[i]][0];while(ch[x][1])x=ch[x][1];return x;&#125;inline int Splay_suc(int i)&#123;int x=ch[rt[i]][1];while(ch[x][0])x=ch[x][0];return x;&#125;inline int Splay_Get_pre(int i,int x)&#123; int pos=rt[i];while(pos)&#123; if(v[pos]&lt;x)&#123;if(ans&lt;v[pos])ans=v[pos];pos=ch[pos][1];&#125; else pos=ch[pos][0]; &#125;return ans;&#125;;inline int Splay_Get_suc(int i,int x)&#123; int pos=rt[i];while(pos)&#123; if(v[pos]&gt;x)&#123;if(ans&gt;v[pos])ans=v[pos];pos=ch[pos][0];&#125; else pos=ch[pos][1]; &#125;return ans;&#125;;inline void Splay_Delete(int i,int key)&#123; int x=Splay_find(i,key); if(c[x]&gt;1)&#123;--c[x];Splay_pushup(x);return;&#125; if(!ch[x][0]&amp;&amp;!ch[x][1])&#123;Splay_del_node(rt[i]);rt[i]=0;return;&#125; if(!ch[x][0])&#123;int y=ch[x][1];rt[i]=y;f[y]=0;return;&#125; if(!ch[x][1])&#123;int y=ch[x][0];rt[i]=y;f[y]=0;return;&#125; int p=Splay_pre(i);int lastrt=rt[i]; Splay(i,p,0);ch[rt[i]][1]=ch[lastrt][1];f[ch[lastrt][1]]=rt[i]; Splay_del_node(lastrt);Splay_pushup(rt[i]);&#125;;/*------------------------------Seg_Tree--------------------------------------*/ #define lc ((x)&lt;&lt;1)#define rc ((x)&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)inline void Seg_Insert(int x,int l,int r,int pos,int val)&#123; Splay_Insert(x,val);if(l==r)return; if(pos&lt;=mid)Seg_Insert(lc,l,mid,pos,val); else Seg_Insert(rc,mid+1,r,pos,val);&#125;;inline void Seg_rank(int x,int l,int r,int L,int R,int Kth)&#123; if(l==L&amp;&amp;r==R)&#123;ans+=Splay_rank(x,Kth);return;&#125; if(R&lt;=mid)Seg_rank(lc,l,mid,L,R,Kth); else if(L&gt;mid)Seg_rank(rc,mid+1,r,L,R,Kth); else Seg_rank(lc,l,mid,L,mid,Kth),Seg_rank(rc,mid+1,r,mid+1,R,Kth);&#125;;inline void Seg_change(int x,int l,int r,int pos,int val)&#123; // printf("QvQ:: %d %d %d %d %d\n",x,l,r,pos,val); Splay_Delete(x,a[pos]);Splay_Insert(x,val); if(l==r)&#123;a[pos]=val;return;&#125;; if(pos&lt;=mid)Seg_change(lc,l,mid,pos,val); else Seg_change(rc,mid+1,r,pos,val);&#125;;inline void Seg_pre(int x,int l,int r,int L,int R,int val)&#123; if(l==L&amp;&amp;r==R)&#123;ans=max(ans,Splay_Get_pre(x,val));return;&#125; if(R&lt;=mid)Seg_pre(lc,l,mid,L,R,val); else if(L&gt;mid)Seg_pre(rc,mid+1,r,L,R,val); else Seg_pre(lc,l,mid,L,mid,val),Seg_pre(rc,mid+1,r,mid+1,R,val);&#125;;inline void Seg_suc(int x,int l,int r,int L,int R,int val)&#123; if(l==L&amp;&amp;r==R)&#123;ans=min(ans,Splay_Get_suc(x,val));return;&#125; if(R&lt;=mid)Seg_suc(lc,l,mid,L,R,val); else if(L&gt;mid)Seg_suc(rc,mid+1,r,L,R,val); else Seg_suc(lc,l,mid,L,mid,val),Seg_suc(rc,mid+1,r,mid+1,R,val);&#125;;/*---------------------------------ask----------------------------------------*/inline int Get_Kth(int x,int y,int k)&#123; int L=0,R=MX+1,M; while(L&lt;R)&#123; M=(L+R)&gt;&gt;1; ans=0;Seg_rank(1,1,n,x,y,M); if(ans&lt;k)L=M+1;else R=M; &#125;return L-1;&#125;;/*-------------------------------main-------------------------------------*/int main(int argc,char const* argv[])&#123; IN(n),IN(m); for(RI i=1;i&lt;=n;++i)&#123;IN(a[i]);Seg_Insert(1,1,n,i,a[i]);MX=max(MX,a[i]);&#125; while(m--)&#123; int op,x,y,v;IN(op),IN(x),IN(y); switch(op)&#123; case 1:&#123;IN(v);ans=0;Seg_rank(1,1,n,x,y,v);printf("%d\n",ans+1);&#125;break; case 2:&#123;IN(v);printf("%d\n",Get_Kth(x,y,v));&#125;break; case 3:&#123;Seg_change(1,1,n,x,y);&#125;break; case 4:&#123;IN(v);ans=-inf;Seg_pre(1,1,n,x,y,v);printf("%d\n",ans);&#125;break; case 5:&#123;IN(v);ans=inf;Seg_suc(1,1,n,x,y,v);printf("%d\n",ans);&#125;break; &#125; &#125;return 0;&#125; 然后就是这道题，跟上面的那道题差不多，大家可以拿来练练手： BZOJ3196: 1901 Dynamic RankingsLUOGU P2617 Dynamic Rankings 不贴代码了。 一道不错的细节题： LUOGU P3332 [ZJOI2013]K大数查询 $———by Qiuly$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [JSOI2008]球形空间产生器 高斯消元 洛谷P4035]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4035%2F</url>
    <content type="text"><![CDATA[“你要求出这个n维球体的球心坐标“，这使我想到的解方程…… 先假设n=2，这是一个二维平面。设圆心的坐标为$(x,y)$，有两个坐标$(a_1,b_1)$和$(a_2,b_2)$，显然两个坐标的关系为： (x-a_1)^2+(y-b_1)^2=(x-a_2)^2+(y-b_2)^2考虑如何化简上面的式子。 (x-a_1)^2-(x-a_2)^2+(y-b_1)^2-(y-b_2)^2=0根据完全平方公式： (x-a_1)^2=x^2+a_1^2-2 \times x \times a_1(x-a_1)^2-(x-a_2)^2=x^2+a_1^2-2 \times x \times a_1-x^2-a_2^2+2 \times x \times a_2(x-a_1)^2-(x-a_2)^2=a_1^2-2 \times x \times a_1-a_2^2+2 \times x \times a_2(x-a_1)^2-(x-a_2)^2=a_1^2-a_2^2-2(a_1-a_2)x同理 (y-b_1)^2-(y-b_2)^2=b_1^2-b_2^2-2(b_1-b_2)y整理后： a_1^2-a_2^2-2(a_1-a_2)x+b_1^2-b_2^2-2(b_1-b_2)y=0移项后： a_1^2-a_2^2+b_1^2-b_2^2=2(a_1-a_2)x+2(b_1-b_2)y这个式子最终为： 2(a_1-a_2)x+2(b_1-b_2)y=a_1^2-a_2^2+b_1^2-b_2^2由于 $a_1^2-a_2^2+b_1^2-b_2^2​$ 是已知的，我们将 $a_1^2-a_2^2+b_1^2-b_2^2​$ 设为$Sum​$. $2(a_1-a_2)​$ 和 $2(b_1-b_2)​$都是已知的项，分别设为 $a​$ 和 $b​$ . 所以它又变成了我们亲切的小学奥数之解方程：$ax+by=Sum$ 对于二维的答案是 $(x,y)​$ ，$x​$ 和 $y​$ 都可以通过高斯消元的模板来解出。 对于更高的维数，跟二维同理，只不过”元”多了几个而已。 所以就这样愉快的A掉了这道大水题。Code:1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register intusing namespace std;const int N=25;const double eps=1e-8;double v[N][N],f[N][N],s[N],del;int n;inline bool Gauss()&#123; for(RI k=1,i=1;i&lt;=n;++i,k=i)&#123; for(RI j=i+1;j&lt;=n;++j)if(abs(f[j][i])&gt;abs(f[k][i]))k=j; if(fabs(del=f[k][i])&lt;eps)return false;//不判就出BUG，不知道为啥 swap(f[i],f[k]);swap(s[i],s[k]); for(RI j=i;j&lt;=n;++j)f[i][j]/=del;s[i]/=del; for(k=1;k&lt;=n;++k)if(k!=i)&#123; del=f[k][i]; for(RI j=i;j&lt;=n;++j)f[k][j]-=f[i][j]*del; s[k]-=s[i]*del; &#125; &#125;return true;&#125;int main()&#123; scanf("%d",&amp;n); for(RI i=1;i&lt;=n+1;++i)for(RI j=1;j&lt;=n;++j)scanf("%lf",&amp;v[i][j]); for(RI i=1;i&lt;=n;++i) for(RI j=1;j&lt;=n;++j)&#123; s[i]+=(v[i][j]*v[i][j]-v[i+1][j]*v[i+1][j]);//求上面的 "Sum" f[i][j]=2*(v[i][j]-v[i+1][j]);//求上面的 "a"、"b"等 &#125; Gauss(); for(RI i=1;i&lt;n;++i)printf("%.3lf ",s[i]);//注意输出格式! printf("%.3lf",s[n]); return 0;&#125; 这题啥都好，就是输出格式有点制杖……请各位小心……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2016]生成魔咒 后缀自动机.SAM bzoj4516/luogu4070]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4070%2F</url>
    <content type="text"><![CDATA[一眼题目。 题目简述如下： 任务一：支持询问当前本质不同的子串的个数 任务二：支持插入 很显然后缀自动机可以解决胜任，正好今天刚学了后缀自动机，那么就将它定为练手题了。 插入是很简单的，至于询问本质不同的字串的个数，我们知道新插入一个节点 $now$ 对答案的贡献是: $ |max(now)| - |min(now)| + 1$ 。我们建后缀自动机的时候只保存了 $max(now)$ ，难道还要保存一个 $min(now)$ 吗？其实不需要，根据其性质可以得到：$|max(now)| - |max(fa[now])|$，直接计算即可。 注意数据范围较大，记得开 $longlong​$ ！ *注：文中的 $|S|​$ 指的是字符串 $S​$ 的长度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=2e5+2;const int inf=1e9+9;template&lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct SAM&#123; ll ans; std::map&lt;int,int&gt; ch[N]; int last,cnt,len[N],fa[N]; inline void Insert(int c)&#123; int p=last,now=last=++cnt; len[now]=len[p]+1; while(p&amp;&amp;!ch[p][c])ch[p][c]=now,p=fa[p]; if(!p)fa[now]=1; else&#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[now]=q; else&#123; int copy=++cnt; len[copy]=len[p]+1,ch[copy]=ch[q]; fa[copy]=fa[q],fa[q]=fa[now]=copy; while(p&amp;&amp;ch[p][c]==q)ch[p][c]=copy,p=fa[p]; &#125; &#125; ans+=len[now]-len[fa[now]]; return; &#125;&#125;sam;int main()&#123; int n;IN(n); sam.last=sam.cnt=1; for(int i=1;i&lt;=n;++i)&#123; int c;IN(c); sam.Insert(c); printf("%lld\n",sam.ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>后缀自动机.SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [ZJOI2014]力 FFT bzoj3527/luogu3338]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3338%2F</url>
    <content type="text"><![CDATA[这个式子有点……乱。 嗯，我们来推一推式子……推一推式子。 原式推一推，那么就是： E_i = \frac{F_i}{q_i} = \sum_{j=1}^{i} \frac{q_j}{(i-j)^2} - \sum_{j=i+1}^{n} \frac{q_j}{(i-j)^2}​ 令 $x = \frac{1}{y^2}​$ ， 那么： E_i = \frac{F_i}{q_i} = \sum_{j=1}^{i} q_j x_{i-j} - \sum_{j=i+1}^{n} q_j x_{j-i}​还可以写成： E_i = \sum_{j=1}^{i} q_j x_{i-j} - \sum_{j=i+1}^{n} q_j x_{j-i}​令 $S_i = q_{n-i+1} ​$，那么式子变成了： E_i = \sum_{j=1}^{i} q_j x_{i-j} - \sum_{j=i+1}^{n} p_{n-j+1} x_{j-i}这个时候我们可以发现，$\sum_{j=1}^{i} q_j x_{i-j}​$ 和 $\sum_{j=i+1}^{n} p_{n-j} x_{j-i}​$ 都是卷积，那么我们可以跑两遍 $FFT​$，分别求出上面的两个式子，记录为 $A,B​$ 。最后的答案就是 $A[i].x - B[n+1-i].x​$ 了。 FFT不用做太多修改，套模板跑就行(本来就是模板)。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt; #include&lt;cmath&gt;#include&lt;string&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int #define PI 3.1415926535898using namespace std;const int N=4e5+2;int n,limit=1,filp[N];template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct complex&#123;complex(double a=0,double b=0)&#123;x=a,y=b;&#125;double x,y;&#125;;complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125;;complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125;;complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;;complex A[N],B[N],C[N];inline void FFT(complex *f,short inv)&#123; for(RI i=0;i&lt;limit;++i)if(i&lt;filp[i])&#123;complex t=f[i];f[i]=f[filp[i]],f[filp[i]]=t;&#125; for(RI p=2;p&lt;=limit;p&lt;&lt;=1)&#123; RI len=p/2; complex tmp=complex(cos(PI/len),inv*sin(PI/len)); for(RI k=0;k&lt;limit;k+=p)&#123; complex buf=complex(1,0); for(RI l=k;l&lt;k+len;++l)&#123; complex t=buf*f[l+len]; f[l+len]=f[l]-t,f[l]=f[l]+t,buf=buf*tmp; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n);int cnt=0; for(RI i=1;i&lt;=n;++i)&#123;scanf("%lf",&amp;A[i].x),B[n+1-i].x=A[i].x;&#125; for(RI i=1;i&lt;=n;++i)C[i].x=(1.0/double(i))/double(i); while(limit&lt;=(n&lt;&lt;1))limit&lt;&lt;=1,cnt++; for(RI i=0;i&lt;limit;++i)filp[i]=((filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(cnt-1))); FFT(A,1);FFT(B,1);FFT(C,1); for(RI i=0;i&lt;=limit;++i)A[i]=A[i]*C[i],B[i]=B[i]*C[i]; FFT(A,-1);FFT(B,-1); for(RI i=0;i&lt;=limit;++i)A[i].x/=limit,B[i].x/=limit; for(RI i=1;i&lt;=n;++i)printf("%.3lf\n",-B[n+1-i].x+A[i].x); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 点分治总结&学习笔记]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E7%AE%97%E6%B3%95%5D%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[其实很短的啦，感觉……感觉淀粉质这种东西好像没什么可以总结的……只会有一些简单的板子题而已……(实际上是砍不动难的题目)(淀粉质吗？味道真是不错呢嘿嘿嘿) 0XFF—-点分治是啥？ 点分治，是处理树上路径的一个极好的工具。 一般如果需要大规模处理树上路径，点分治是一个不错的选择。 ———一位网上的Dalao 现在有一个问题，给你一颗树，树上的每一条边都有权值，现在给一个 $k$ ，要求你求出树上所有路径中路径权值小于 $k$ 的路径总数，你怎么办？ 暴力？$O(N^3)$ 的复杂度分分钟让你 T 飞！ 当然，你可以用分治来求，复杂度仅有 $O(nlogn)$。 对于树上做分治，不仅有基于点的分治方式，还有基于边的以及基于链的，但是这不在我们的讨论范围类(作者太蒟了不会QvQ)。 0X1F 点分治的流程0X1F—-1 怎么分治？对于所有的路径，很显然我们可以将它们分成两部分： $1.$ 这条路径经过了它所在的子树的根节点 $2.$ 这条路径没经过它所在的子树的根节点 假设现在有一颗树，Ta的根节点是 $1$： 对于路径 $2 -&gt; 1 -&gt; 3 -&gt; 6$ ，它是经过了根节点的，属于 $1$ 类路径。 对于路径 $4 -&gt; 2 -&gt; 5 -&gt; 8$ ，它没有经过根节点 $1$，属于 $2$ 类路径。 对于第一类路径我们直接处理，对于第二类路径，递归处理当前根的儿子，在儿子里面处理，也就是说现在我们只需要处理第一类路径。 怎么确定这个根呢？显然根的好坏可以决定算法的复杂度。 因为每次是递归儿子，显然递归层数越少越好，什么情况下递归层数越少？当前根是当前树的重心时！ 那么，整个算法的框架如下： 12345678910void solve(int u)&#123;//当前节点u 当前树的当前根节点为u，统计第一类路径; 做标记，当前点已经当过根了(总不可能一直是一个点当吧=。=) for(u的所有儿子)&#123; if(儿子当过根节点了)continue; 去掉满足在一个子树条件的不合法答案; 在儿子的子树中得到一个新的根节点; solve(新的根节点); &#125;return;&#125; 其中，在儿子的子树中得到一个新的根节点如下： 现在在 $Solva(1)$ 函数中，并且现在循环到了 $1$ 的儿子 $3$ ，那么 $3$ 的子树就是灰色三角形中的三个节点，我们的新 $root$ 就是灰色三角形这棵树的重心，现在刚开始的时候可以将 $3$ 看成根节点，然后再往下计算。 0X1F—-2 获取树的重心很简单，只需要一个 $DP$ 就行了。 123456789101112void getroot(int u,int fa)&#123; size[u]=1;mxss[u]=0; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; getroot(v,u); size[u]+=size[v]; mxss[u]=max(mxss[u],size[v]); &#125; mxss[u]=max(mxss[u],sum-size[u]); if(mxss[u]&lt;mxss[root])root=u; //mxss[u]为u的子树中size最大的size，size就是u下面的子树大小。&#125; 那么这一句是什么意思呢：mxss[u]=max(mxss[u],sum-size[u]); 我们再举个栗子，假如现在的 $u$ 是 $1$ ：($Qiuly$懒所以用的前面的那个图) 但是 $size[1]$ 统计的只是Ta下面的 ${2,3,4,5,6,7,8}$ 号节点，万一当前树不止这些呢？也就是说上面还有一坨节点，如果计算的时候显然也是要考虑进去的。 0X1F—-怎么统计1类路径？Code:123456789101112131415161718void getdist(int u,int fa)&#123; use[++cnt]=dist[u]; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; dist[v]=dist[u]+G[i].val;getdist(v,u); &#125;return;&#125;int calc(int u,int dist0)&#123; cnt=0;dist[u]=dist0; getdist(u,0); std::sort(use+1,use+1+cnt); int l=1,r=cnt,res=0; while(l&lt;r) if(use[l]+use[r]&lt;=k)res+=r-l,++l; else --r; return res; &#125; 确定了当前树的 $root$ 后，我们可以定义 $dist[root]$ 为 $0$ ，其余的当前树的节点的 $dist$ 为Ta到 $root$ 的距离(路上所有边的权值和)。 显然，这个问题很容易搞定($getdist$)。 想象一下，现在有一条路径 $l -&gt; \cdots -&gt; root -&gt; \cdots -&gt; r$，显然这条路径的权值就是 $dist[l] + dist[r]$。 可是，如果一一去枚举 $l,r$ 并且统计的话复杂度是报表的啊！这没关系，我们依旧可以用线性的时间复杂度解决问题。 得到了所有的 $dist$ 后，我们排个序。 然后就是统计的流程。 假设现在排好序的数列为 {$1,1,2,3,4,4,5,6,7,7,8$}，$l$ 为 $1$ ，$r$ 为 $cnt$。 现在计算 $1+8$ ，显然如果 $1+8$ 小于 $k$ ，那么 $1 + (1/2/3/4/4/5/6/7/7)$ 都会小于 $k$，这个时候直接统计即可。否则 --r ，因为我们还需要统计的是 $l+1,l+2,\cdots$，既然这个 $r$ 不行了，对后面的答案是肯定不会有影响的。 最后 $return;$ 0X2F 总体代码 Test:Luogu P4178 TreeCode:如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))//为了格式不鬼畜这两个宏定义我只能放着了QvQ#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt; const int N=4e4+2;const int inf=1e9+9;int n,m,k,cnt,sum,ans,root,head[N];int vis[N],use[N],dist[N],size[N],mxss[N];struct Edge&#123; int nxt,to,val; &#125;G[N&lt;&lt;1];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;void getroot(int u,int fa)&#123; size[u]=1;mxss[u]=0; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; getroot(v,u); size[u]+=size[v]; mxss[u]=max(mxss[u],size[v]); &#125; mxss[u]=max(mxss[u],sum-size[u]); if(mxss[u]&lt;mxss[root])root=u; &#125;void getdist(int u,int fa)&#123; use[++cnt]=dist[u]; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; dist[v]=dist[u]+G[i].val;getdist(v,u); &#125;return;&#125;int calc(int u,int dist0)&#123; cnt=0;dist[u]=dist0; getdist(u,0); std::sort(use+1,use+1+cnt); int l=1,r=cnt,res=0; while(l&lt;r) if(use[l]+use[r]&lt;=k)res+=r-l,++l; else --r; return res; &#125;void solve(int u)&#123; ans+=calc(u,0); vis[u]=1; for(int v,i=head[u];i;i=G[i].nxt)&#123; if(vis[(v=G[i].to)])continue; ans-=calc(v,G[i].val); sum=size[v];root=0; getroot(v,0); solve(root); &#125;return;&#125;int main()&#123; IN(n),sum=mxss[0]=n; for(int i=1,u,v,w;i&lt;n;++i)&#123; IN(u),IN(v),IN(w); G[++cnt]=(Edge)&#123;head[u],v,w&#125;;head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,w&#125;;head[v]=cnt; &#125; IN(k); getroot(1,0); solve(root); printf("%d\n",ans); return 0; &#125; Test:Luogu P3806 【模板】点分治1Analysis:很显然我们不能像上面那样傻乎乎的While了，那样不能算出路径的权值，只能统计。干脆统计时来个双重循环暴力吧！然后搞个桶。复杂度很高但是能过得了(至少这一题是这样的)Code:如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))//Q.v.Q........................#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long long#define RI register int const int N=1e4+2;const int inf=1e9+9;int ans[10000005];int n,m,k,cnt,sum,root,head[N];int vis[N],use[N],dist[N],size[N],mxss[N];struct Edge&#123; int nxt,to,val; &#125;G[N&lt;&lt;1];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;void getroot(int u,int fa)&#123; size[u]=1;mxss[u]=0; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; getroot(v,u); size[u]+=size[v]; mxss[u]=max(mxss[u],size[v]); &#125; mxss[u]=max(mxss[u],sum-size[u]); if(mxss[u]&lt;mxss[root])root=u; &#125;void getdist(int u,int fa)&#123; use[++cnt]=dist[u]; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; dist[v]=dist[u]+G[i].val;getdist(v,u); &#125;return;&#125;void calc(int u,int dist0,int add)&#123; cnt=0;dist[u]=dist0; getdist(u,0); for(int i=1;i&lt;=cnt;++i) for(int j=1;j&lt;=cnt;++j) ans[use[i]+use[j]]+=add; &#125;void solve(int u)&#123; calc(u,0,1);vis[u]=1; for(int v,i=head[u];i;i=G[i].nxt)&#123; if(vis[(v=G[i].to)])continue; calc(v,G[i].val,-1); sum=size[v];root=0; getroot(v,0); solve(root); &#125;return;&#125;int main()&#123; IN(n),IN(m),sum=mxss[0]=n; for(int i=1,u,v,w;i&lt;n;++i)&#123; IN(u),IN(v),IN(w); G[++cnt]=(Edge)&#123;head[u],v,w&#125;;head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,w&#125;;head[v]=cnt; &#125; getroot(1,0); solve(root); for(int i=1;i&lt;=m;++i) IN(k),printf(ans[k]?"AYE\n":"NAY\n"); return 0; &#125; ~~(还是背板子最重要嘿嘿嘿)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 小清新人渣的本愿 莫队+bitset luoguP3674]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3674%2F</url>
    <content type="text"><![CDATA[莫队 $+$ $bitset$. 我们可以用 $bitset$ 维护当前 $l,r$ 区间数的出现的状态，莫对依旧按照套路搞，然后来考虑怎么回答每一个询问。 对于操做 $1$ ，要求回答我们从当前区间能否找出 $a,b$ 使得其差为 $x$。 很显然，$a-b=x$ 等价于 $a=b+x$。 我们维护的是数的出现的状态，于是可以将当前的 $bitset$ 左移 $x$ 位，也就是让所有数都加上 $x$，然后与原 $bitset$ 做与运算，看看是否有一个 $a$ 出现，如果与的结果非 $0$ ，那么显然是有的，否则没有。 第二个操作有些不好办，我们再开一个 $bitset$ 集，对于一个出现过的数 $i$，在第二个 $bitset$ 集中记为 $N-i$。然后再来看操作要求，这次是让 $a+b=x$。 那么可以得到：a=x-b 于是设一个数 $z$ ，表示 $N-a$ 。 然后：z=N-x+b 移项得：z-b=N-x 于是我们将第二个 $bitset$ 右移 $N-x$ 为，显然第二个 $bitset$ 集上的第 $i$ 位代表的就是第一个 $bitset$ 上的 $x-i$ 位。 然后，将两个 $bitset$ 与一下，看看是否同时存在 $a$ 和 $x-a$ 即可。 最后对于第三个操作，貌似bitset也不太好搞，那么直接暴力枚举因子就好了，复杂度 $O(\sqrt{n})$，放心不会炸。具体怎么暴力枚举呢？在 $1 - \sqrt{x}$ 的范围类枚举一个 $j$ ，如果 $x$ % $j==0$ 并且同时存在 $j$ 和 $x/j$，显然就有答案了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cmath&gt;#include&lt;bitset&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;std::bitset&lt;N&gt; now1,now2; int n,m,l,r,s,a[N],c[N],Be[N],ans[N];struct MO&#123;int opt,l,r,x,id;&#125;q[N];inline bool cmp(MO a,MO b)&#123;return Be[a.l]==Be[b.l]?a.r&lt;b.r:a.l&lt;b.l;&#125; inline void input()&#123; IN(n),IN(m);s=sqrt(n); for(int i=1;i&lt;=n;++i)IN(a[i]),Be[i]=(i-1)/s+1; for(int i=1;i&lt;=m;++i) IN(q[i].opt),IN(q[i].l),IN(q[i].r),IN(q[i].x),q[i].id=i; std::sort(q+1,q+1+m,cmp); l=1,r=0;now1.reset(),now2.reset();&#125;inline void Add(int x)&#123;if(c[x]++==0)now1[x]=1,now2[N-x]=1;&#125;inline void Del(int x)&#123;if(--c[x]==0)now1[x]=0,now2[N-x]=0;&#125;int main()&#123; input(); for(int i=1;i&lt;=m;++i)&#123; while(l&lt;q[i].l)Del(a[l++]); while(l&gt;q[i].l)Add(a[--l]); while(r&gt;q[i].r)Del(a[r--]); while(r&lt;q[i].r)Add(a[++r]); if(q[i].opt==1)&#123; if((now1&amp;(now1&lt;&lt;q[i].x)).any())ans[q[i].id]=true; &#125;else if(q[i].opt==2)&#123; if((now1&amp;(now2&gt;&gt;(N-q[i].x))).any())ans[q[i].id]=true; &#125;else if(q[i].opt==3)&#123; for(int j=1;j*j&lt;=q[i].x;++j) if(!(q[i].x%j)&amp;&amp;now1[j]&amp;&amp;now1[q[i].x/j]) &#123;ans[q[i].id]=true;break;&#125; &#125; &#125; for(int i=1;i&lt;=m;++i) if(ans[i])printf("hana\n"); else printf("bi\n"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2014]魔法森林 动态加边Spfa bzoj3669/luogu2387]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2387%2F</url>
    <content type="text"><![CDATA[膜法森林2333…… 显然是一道 $LCT$ 动态加边的题目。 然而并不需要这么高深的数据结构来动态加边(实际上是不会)，我们只需要 $Spfa$ 动态加边即可切掉此题。 怎么 $Spfa$?又是个怎么的动态加边法呢？ 在下面我先给出代码，然后再来一步一步剖析(跟 $Spfa$ 板子差不多)。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long long#define RI register intconst int N=5e4+2,M=1e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; bool flag=0;char ch;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;bool vis[N];std::queue&lt;int&gt; q;int head[N],dis[N],tot,cnt,ans,n,m;struct Edge_Spfa&#123;int nxt,to,v1,v2;&#125;G[M];struct Edge_Main&#123; int x,y,v1,v2; bool operator &lt; (Edge_Main a)const&#123; return v1&lt;a.v1; &#125;&#125;L[M];inline void make_line(int x,int y,int v1,int v2)&#123; G[++tot].nxt=head[x],head[x]=tot,G[tot].to=y,G[tot].v1=v1,G[tot].v2=v2; G[++tot].nxt=head[y],head[y]=tot,G[tot].to=x,G[tot].v1=v1,G[tot].v2=v2;&#125; #define A printf("A")#define C printf("\n")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y)) inline void spfa(int star_1,int star_2)&#123; vis[star_1]=true,vis[star_2]=true; q.push(star_1),q.push(star_2); while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i;i=G[i].nxt)&#123; int to=G[i].to; if(max(dis[u],G[i].v2)&lt;dis[to])&#123; dis[to]=max(dis[u],G[i].v2); if(!vis[to])q.push(to),vis[to]=true; &#125; &#125;vis[u]=false; &#125;return;&#125;int main()&#123; IN(n),IN(m); memset(dis,127,sizeof(dis)); dis[1]=0,q.push(1),ans=inf; for(int i=1;i&lt;=m;++i) IN(L[i].x),IN(L[i].y),IN(L[i].v1),IN(L[i].v2); std::sort(L+1,L+1+m); for(int i=1;i&lt;=m;++i)&#123; make_line(L[i].x,L[i].y,L[i].v1,L[i].v2); spfa(L[i].x,L[i].y); ans=min(ans,dis[n]+L[i].v1); &#125;printf("%d\n",ans==inf?-1:ans); return 0;&#125; 动态加边，顾名思义，就是按最优顺序依次将边插入，对于每次插完边的图做一次答案统计($Spfa$)，然后每次在 $main$ 函数里统计答案，最后输出即可。 我们固定 $v1$ ，用 $v2$ 跑 $Spfa$，边的插入顺序是按照 $v1$ 的大小来的，小的先插。 之所以上面要用到 $sort$，是因为我们要达到”按最优顺序依次将边插入”。 $Spfa$ 的板子就不解释了，不懂的同学左转搜素 $Spfa$ ，先刷几道黄牌去吧…… 我们来看看动态加边的过程: 12345for(int i=1;i&lt;=m;++i)&#123; make_line(L[i].x,L[i].y,L[i].v1,L[i].v2); spfa(L[i].x,L[i].y); ans=min(ans,dis[n]+L[i].v1); &#125; make_line(L[i].x,L[i].y,L[i].v1,L[i].v2); : 加边，不解释 spfa(L[i].x,L[i].y); : $Spfa$ 过程。 $Q$ :为什么要定义两个起点 $L[i].x$ 和 $L[i].y$ 呢？ $A$ :显然加进来了这条边后，对当前图中一些点的 $dis$ 值可能会有影响，所以以这个边的两端的点为起点，依次更新旁边的点，直到不能再更新。 ans=min(ans,dis[n]+L[i].v1); : 更新 $ans$ 值 $Q$ :为什么使用 $dis[n]+L[i].v1$ 对 $ans$ 进行更新，有可能这条最短路上并不包含这个边啊，为什么要将 $L[i].v1$ 算进去呢？可能会更新错答案啊。 $A$ :对于当前图的最短路，我们分两种情况来讨论： $1.$ 这条最短路上没包含这条新加上的边 $2.$ 这条最短路上包含了这条新加上的边 对于第一种情况，显然这条最短路在加上这条边之前就已经有了，因为这条边的存在跟这条最短路没任何关系，既然之前有了，那么就肯定已经更新过 $ans$ 了。而那个时候的 $v1$ 是肯定比这个时候的 $v1$ 小的，也就是说 $ans$ 在之前已经被比现在的答案更小的答案更新过了，所以 $ans$ 也不会被当前答案更新。 对于第二种情况，因为这条最短路上包含了这条边，而这条边肯定是这条最短路上 $v1$ 最大的边(当然也是当前图上 $v1$ 最大的边)，所以直接更新没错。 每一次循环后数组不要重置吗？ 显然队列是不要的，因为 $Spfa$ 的退出条件是是队列为空，所以每次做完 $Spfa$ 时队列也就空了。 $vis$ 数组也不需要，跟队列是一个道理，只有 $vis$ 数组里面还有 $true$ 的元素，说明还有元素在队列里，队列空了，$vis$ 数组也自然空了。 $dis$ 数组不需要，因为循环中每次跑 $Spfa$ 是为了更新 $dis$ 数组而非做最短路。 然后……然后就没有然后了……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LCT</tag>
        <tag>Spfa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2010]超级钢琴 RMQ+优先队列 bzoj2006/洛谷P2048]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2048%2F</url>
    <content type="text"><![CDATA[这一道题显然是一道 $RMQ$ 的题目，用一个三元素组$（o，l，r）​$表示：左端点为o，右端点在l到r的区间内的最大子段，元素组用堆维护。 对于每个和弦的值，用前缀和在$O(1)$的时间复杂度求出。 $ans$累加这个三元组的贡献。由于$t$已经被选中，对于这个$o$，$t$已经不能重复选中，但最优解还可能存在于 $t$左右的两端区间中，所以提取出$(o, l, r)$之后，为了避免重复且不丧失其他较优解，我们仍然要把$(o, l, t - 1),(o, t + 1, r)$扔回堆里面去。还要避免重复或错误，即$l = t$或$r = t$的情况要进行特判。 对于$t$的位置，我们直接用ST表预处理出即可。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define Macth#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=500005,Log=20;ll f[N][Log],sum[N];template &lt;typename Tp&gt; inline void read(Tp &amp;x)&#123; x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar();&#125;namespace RMQ&#123;//ST表求区间最优位置(貌似在本题中是这样) inline void make(int n)&#123; for(register int i=1;i&lt;=n;++i)f[i][0]=i; for(register int j=1;(1&lt;&lt;j)&lt;=n;++j) for(register int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)&#123; int x=f[i][j-1],y=f[i+(1&lt;&lt;(j-1))][j-1]; f[i][j]=sum[x]&gt;sum[y]?x:y;//取更优的位置 &#125;return; &#125; inline int query(int l,int r)&#123; int k=log2(r-l+1); int x=f[l][k],y=f[r-(1&lt;&lt;k)+1][k]; return sum[x]&gt;sum[y]?x:y; &#125;&#125;int n,k,L,R;struct Queue&#123; int l,r,o,t;//t就是最优的位置 Queue()&#123;&#125; Queue(int o,int l,int r):o(o),l(l),r(r),t(RMQ::query(l,r))&#123;&#125;//t:取个l至r区间的最优值 bool operator &lt; (Queue a)const&#123;//重载运算符 return sum[a.t]-sum[a.o-1]&lt;sum[t]-sum[o-1]; &#125;&#125;A;std::priority_queue&lt;Queue&gt; q;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;k,&amp;L,&amp;R); for(register int i=1;i&lt;=n;++i)&#123; scanf("%lld",&amp;sum[i]);sum[i]+=sum[i-1]; &#125;RMQ::make(n);ll ans=0; for(register int i=1;i&lt;=n;++i)&#123; if(i+L-1&lt;=n)q.push(Queue(i,i+L-1,min(i+R-1,n))); &#125;while(k--)&#123; A=q.top();q.pop(); ans+=sum[A.t]-sum[A.o-1];//更新ans if(A.l!=A.t)q.push(Queue(A.o,A.l,A.t-1)); if(A.r!=A.t)q.push(Queue(A.o,A.t+1,A.r)); &#125;printf("%lld\n",ans); return 0;&#125; 差不多就是这样了……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>RMQ</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2008]Cave洞穴勘测 LCT bzoj2049/洛谷P2147]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2147%2F</url>
    <content type="text"><![CDATA[Link-Cut-Tree的模板题啊……(听说还可以用其他的方法做，不管了，直接上LCT) 没有要求维护点权，只需要维护点的连通性即可。 就是朴素的LCT，居然还不要pushup。 感觉有些不适应啊…….不得不说LCT是个神器。 简单分析一下。 对于每种命令: 如果是Connect x y (链接 x y):直接 link(x,y)即可。 如果是Destroy x y (切断 x y):直接 cut(x,y)即可。 如果是Query x y (询问 x y 的连通性):判断findroot(x)和findroot(y)是否一致，一致输出Yes，否则输出No。 然后就A了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int#define A printf("A")#define C printf(" ") using namespace std;const int N=2e5+2;template &lt;typename Tp&gt; inline void IN(Tp &amp;x)&#123; int f=1;x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')if(ch=='-')f=-1,ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10+ch-'0',ch=getchar();x*=f;&#125;int n,m,f[N],r[N],hep[N],ch[N][2];inline int chk(int x)&#123;return ch[f[x]][1]==x;&#125;inline int get(int x)&#123;return ch[f[x]][0]==x||ch[f[x]][1]==x;&#125;inline void filp(int x)&#123;swap(ch[x][0],ch[x][1]);r[x]^=1;&#125; inline void pushdown(int x)&#123; if(!r[x])return;r[x]=0; if(ch[x][0])filp(ch[x][0]); if(ch[x][1])filp(ch[x][1]);&#125;inline void rotate(int x)&#123; int y=f[x],z=f[y],k=chk(x),&amp;v=ch[x][!k]; if(get(y))ch[z][chk(y)]=x;v=y,ch[y][k]=v; if(v)f[v]=y;f[y]=x,f[x]=z;return;&#125;inline void Splay(int x)&#123; int y=x,top=0;hep[++top]=y; while(get(y))hep[++top]=y=f[y]; while(top)pushdown(hep[top--]); while(get(x))&#123; y=f[x],top=f[y]; if(get(y))rotate((ch[y][0]==x)^(ch[top][0]==y)?x:y); rotate(x); &#125;return;&#125; inline void Access(int x)&#123; for(register int y=0;x;x=f[y=x]) Splay(x),ch[x][1]=y;&#125;inline void makeroot(int x)&#123; Access(x);Splay(x);filp(x);&#125;inline int findroot(int x)&#123; Access(x);Splay(x); while(ch[x][0])pushdown(x),x=ch[x][0]; return x;&#125;inline void split(int x,int y)&#123; makeroot(x);Access(y);Splay(y);&#125; inline void link(int x,int y)&#123; makeroot(x);if(findroot(y)!=x)f[x]=y;&#125;inline void cut(int x,int y)&#123; makeroot(x); if(findroot(y)==x&amp;&amp;f[x]==y&amp;&amp;!ch[x][1])&#123; f[x]=ch[y][0]=0; &#125;return;&#125;char op[10];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(register int x,y,i=1;i&lt;=m;++i)&#123; scanf("%s%d%d",op,&amp;x,&amp;y); if(op[0]=='C')link(x,y); else if(op[0]=='D')cut(x,y); else if(op[0]=='Q')&#123; if(findroot(x)==findroot(y))printf("Yes\n"); else printf("No\n"); &#125; &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 Tyvj1730二逼平衡树 树套树 luogu3380/bzoj3196]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1730%2F</url>
    <content type="text"><![CDATA[树套树，直接线段树套 $Splay$ . 因为有区间的$k$大，不能直接用$Splay$(大佬忽视这句话)，显然可以用树套树(废话)。对于每一个线段树的节点都建一棵 $Splay$ ，需要查询这个节点所代表的区间第 $k$ 大等操作时直接用 $Splay$ 来完成即可…… 但是，如果不是正好的区间呢？假如询问区间横跨了两个子树区间怎么办呢？ 这就需要技巧了. 下面，对于第一个操作，先贴出代码: 123456789inline void Seg_rank(int x,int l,int r,int L,int R,int Kth)&#123; if(l==L&amp;&amp;r==R)&#123;ans+=Splay_rank(x,Kth);return;&#125;//必须判断啊，一定要相等 if(R&lt;=mid)Seg_rank(lc,l,mid,L,R,Kth);//完全属于左子树 else if(L&gt;mid)Seg_rank(rc,mid+1,r,L,R,Kth);//完全属于左子树 else Seg_rank(lc,l,mid,L,mid,Kth),Seg_rank(rc,mid+1,r,mid+1,R,Kth); //因为 ans 是 += ，所以直接拆开即可，因为有些抽象，可以画图模拟&#125;;case 1:&#123;IN(v);ans=0;Seg_rank(1,1,n,x,y,v);printf("%d\n",ans+1);&#125;break; 基本上，所有有关的操作都可以参考上面的代码段…… 多说无益，直接看代码吧. 哦，对了，其实理解只需纸笔和一份正确的代码，并不要太多的讲解(感觉网上没找到很优秀的文章……) Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define RI register int #define A printf("A")#define C printf(" ")#define inf 2147483647#define PI 3.1415926535898using namespace std;const int N=4e6+2;//template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; //template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int n,m,a[N],ans,MX;/*----------------------------------Splay-------------------------------------*/int f[N],c[N],s[N],v[N],ch[N][2],rt[N],tot;// rt[i] 表示线段树编号为i的节点的Splay的根节点inline int chk(int x)&#123;return ch[f[x]][1]==x;&#125;;inline void Splay_del_node(int x)&#123;f[x]=s[x]=c[x]=v[x]=ch[x][0]=ch[x][1]=0;&#125;;inline void Splay_pushup(int x)&#123;s[x]=(ch[x][0]?s[ch[x][0]]:0)+(ch[x][1]?s[ch[x][1]]:0)+c[x];&#125;;inline void Splay_rotate(int x)&#123; int y=f[x],z=f[y],k=chk(x),v=ch[x][k^1]; ch[y][k]=v;if(v)f[v]=y;f[x]=z;if(z)ch[z][chk(y)]=x; f[y]=x,ch[x][k^1]=y;Splay_pushup(y),Splay_pushup(x);&#125;;inline void Splay(int i,int x,int top=0)&#123; while(f[x]!=top)&#123; int y=f[x],z=f[y]; if(z!=top)Splay_rotate((ch[z][0]==y)==(ch[y][0]==x)?y:x); Splay_rotate(x); &#125;if(!top)rt[i]=x;&#125;;inline void Splay_Insert(int i,int x)&#123; int pos=rt[i]; if(!rt[i])&#123; rt[i]=pos=++tot;v[pos]=x;s[pos]=c[pos]=1; f[pos]=ch[pos][0]=ch[pos][1]=0;return; &#125;int last=0; while(1)&#123; if(v[pos]==x)&#123;++c[pos];Splay_pushup(last);break;&#125; last=pos;pos=ch[pos][x&gt;v[pos]]; if(!pos)&#123; pos=++tot;v[pos]=x;s[pos]=c[pos]=1; ch[last][x&gt;v[last]]=pos; f[pos]=last;ch[pos][0]=ch[pos][1]=0; Splay_pushup(last);break; &#125; &#125;Splay(i,pos);return;&#125;;inline int Splay_rank(int i,int k)&#123; int x=rt[i],cal=0; while(x)&#123; if(v[x]==k)return cal+((ch[x][0])?s[ch[x][0]]:0); else if(v[x]&lt;k)&#123; cal+=((ch[x][0])?s[ch[x][0]]:0)+c[x];x=ch[x][1]; &#125;else x=ch[x][0]; &#125;return cal;&#125;;inline int Splay_find(int i,int x)&#123; int pos=rt[i];while(x)&#123; if(v[pos]==x)&#123;Splay(i,pos);return pos;&#125;; pos=ch[pos][x&gt;v[pos]]; &#125;return 0;&#125;;inline int Splay_pre(int i)&#123;int x=ch[rt[i]][0];while(ch[x][1])x=ch[x][1];return x;&#125;inline int Splay_suc(int i)&#123;int x=ch[rt[i]][1];while(ch[x][0])x=ch[x][0];return x;&#125;inline int Splay_Get_pre(int i,int x)&#123; int pos=rt[i];while(pos)&#123; if(v[pos]&lt;x)&#123;if(ans&lt;v[pos])ans=v[pos];pos=ch[pos][1];&#125; else pos=ch[pos][0]; &#125;return ans;&#125;;inline int Splay_Get_suc(int i,int x)&#123; int pos=rt[i];while(pos)&#123; if(v[pos]&gt;x)&#123;if(ans&gt;v[pos])ans=v[pos];pos=ch[pos][0];&#125; else pos=ch[pos][1]; &#125;return ans;&#125;;inline void Splay_Delete(int i,int key)&#123; int x=Splay_find(i,key); if(c[x]&gt;1)&#123;--c[x];Splay_pushup(x);return;&#125; if(!ch[x][0]&amp;&amp;!ch[x][1])&#123;Splay_del_node(rt[i]);rt[i]=0;return;&#125; if(!ch[x][0])&#123;int y=ch[x][1];rt[i]=y;f[y]=0;return;&#125; if(!ch[x][1])&#123;int y=ch[x][0];rt[i]=y;f[y]=0;return;&#125; int p=Splay_pre(i);int lastrt=rt[i]; Splay(i,p,0);ch[rt[i]][1]=ch[lastrt][1];f[ch[lastrt][1]]=rt[i]; Splay_del_node(lastrt);Splay_pushup(rt[i]);&#125;;/*------------------------------Seg_Tree--------------------------------------*/ #define lc ((x)&lt;&lt;1)#define rc ((x)&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)inline void Seg_Insert(int x,int l,int r,int pos,int val)&#123; Splay_Insert(x,val);if(l==r)return; if(pos&lt;=mid)Seg_Insert(lc,l,mid,pos,val); else Seg_Insert(rc,mid+1,r,pos,val);&#125;;inline void Seg_rank(int x,int l,int r,int L,int R,int Kth)&#123; if(l==L&amp;&amp;r==R)&#123;ans+=Splay_rank(x,Kth);return;&#125; if(R&lt;=mid)Seg_rank(lc,l,mid,L,R,Kth); else if(L&gt;mid)Seg_rank(rc,mid+1,r,L,R,Kth); else Seg_rank(lc,l,mid,L,mid,Kth),Seg_rank(rc,mid+1,r,mid+1,R,Kth);&#125;;inline void Seg_change(int x,int l,int r,int pos,int val)&#123;// printf("QvQ:: %d %d %d %d %d\n",x,l,r,pos,val); Splay_Delete(x,a[pos]);Splay_Insert(x,val); if(l==r)&#123;a[pos]=val;return;&#125;; if(pos&lt;=mid)Seg_change(lc,l,mid,pos,val); else Seg_change(rc,mid+1,r,pos,val);&#125;;inline void Seg_pre(int x,int l,int r,int L,int R,int val)&#123; if(l==L&amp;&amp;r==R)&#123;ans=max(ans,Splay_Get_pre(x,val));return;&#125; if(R&lt;=mid)Seg_pre(lc,l,mid,L,R,val); else if(L&gt;mid)Seg_pre(rc,mid+1,r,L,R,val); else Seg_pre(lc,l,mid,L,mid,val),Seg_pre(rc,mid+1,r,mid+1,R,val);&#125;;inline void Seg_suc(int x,int l,int r,int L,int R,int val)&#123; if(l==L&amp;&amp;r==R)&#123;ans=min(ans,Splay_Get_suc(x,val));return;&#125; if(R&lt;=mid)Seg_suc(lc,l,mid,L,R,val); else if(L&gt;mid)Seg_suc(rc,mid+1,r,L,R,val); else Seg_suc(lc,l,mid,L,mid,val),Seg_suc(rc,mid+1,r,mid+1,R,val);&#125;;/*---------------------------------ask----------------------------------------*/inline int Get_Kth(int x,int y,int k)&#123; int L=0,R=MX+1,M; while(L&lt;R)&#123; M=(L+R)&gt;&gt;1; ans=0;Seg_rank(1,1,n,x,y,M); if(ans&lt;k)L=M+1;else R=M; &#125;return L-1;&#125;;/*-------------------------------main-------------------------------------*/int main(int argc,char const* argv[])&#123; IN(n),IN(m); for(RI i=1;i&lt;=n;++i)&#123;IN(a[i]);Seg_Insert(1,1,n,i,a[i]);MX=max(MX,a[i]);&#125; while(m--)&#123; int op,x,y,v;IN(op),IN(x),IN(y); switch(op)&#123; case 1:&#123;IN(v);ans=0;Seg_rank(1,1,n,x,y,v);printf("%d\n",ans+1);&#125;break; case 2:&#123;IN(v);printf("%d\n",Get_Kth(x,y,v));&#125;break; case 3:&#123;Seg_change(1,1,n,x,y);&#125;break; case 4:&#123;IN(v);ans=-inf;Seg_pre(1,1,n,x,y,v);printf("%d\n",ans);&#125;break; case 5:&#123;IN(v);ans=inf;Seg_suc(1,1,n,x,y,v);printf("%d\n",ans);&#125;break; &#125; &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 楼房重建 线段树 bzoj2957]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj2957%2F</url>
    <content type="text"><![CDATA[每个楼房，还有单点修改操作。简单的想到用线段树来维护信息。 显然线段树只需要维护y/x即可，对于每一个楼房，能看见的条件就是前面楼房的y/x的严格小于当前楼房的y/x。 线段树的区间修改不再赘述。 那么怎么维护可以看到的楼房数呢？ 考虑在线段树的每一个节点上用一个变量sum来表示从这个节点的左端点向右端点看时能看到多少楼房。 假设现在有一区间：1,5,8,0,7,9。维护这个区间信息的节点编号为x。 x的左儿子维护的区间是1,5,8，从1往8看可以看到三个楼房，故x的左儿子的sum的值为3。 x的右儿子维护的区间是0,7,9，从0往9看也可以看到三个楼房，故x的右儿子的sum的值也为3。 难道x的sum值也为3+3=6？错!这显然是不能加在一起的，x的sum的值为4。 为什么会错呢？因为x的右儿子的观察视角不是从1开始的，是从0开始的。 显然0被前面的楼房挡住了。 首先考虑每个线段树节点在维护一个mx，mx代表这个节点所代表的区间中所有的楼房中最高的高度。 上传时，由于两个儿子的sum值是已经处理好的，而左儿子的视角是跟x的视角一样的(对于上面的例子来说都是1)，可以直接上传，即sum(x)+=sum(l(x))。 对于右儿子，考虑递归处理右儿子的区间，递归时带一个Mx变量表示x的左儿子mx(右儿子再左儿子后面，原因下面解释)，递归函数的返回值是当前处理区间可以被看到的楼房数(从x的视角看) 对于现在处理的每一个区间： 如果这个区间的最高的楼房的高度都Mx(可以看到)，那么return 当前区间维护的sum值。 如果这个区间只代表一个楼房，直接判断其能否被看到即可。 对于剩下的情况，递归儿子，分两种情况讨论： 如果左儿子的最高的楼房小于Mx(不能对答案有任何贡献)，直接递归右儿子。 否则，递归左儿子，右儿子能看到的楼房个数为当前区间sum-左儿子sum即可，(应为下面已经更新好了，只需要直接调用就好了。) Code(文中的sum用l代替):12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define lson x&lt;&lt;1#define rson x&lt;&lt;1|1using namespace std;const int N=1e5+2;struct Node &#123; double mx;int l; #define m(x) tree[x].mx #define l(x) tree[x].l&#125; tree[N&lt;&lt;2];int n,m;double val[N];inline void pushup_max(int x) &#123; m(x)=max(m(x&lt;&lt;1),m(x&lt;&lt;1|1));&#125;inline int pushup_sum(double Mx,int x,int l,int r) &#123; if(m(x)&lt;Mx)return 0; if(val[l]&gt;Mx)return l(x); if(l==r)return val[l]&gt;Mx; int mid=(l+r)&gt;&gt;1; if(m(lson)&lt;=Mx)return pushup_sum(Mx,rson,mid+1,r); else return pushup_sum(Mx,lson,l,mid)+l(x)-l(lson);&#125;inline void change(int x,int l,int r,int pos,int value) &#123; if(l==r&amp;&amp;l==pos)&#123;m(x)=(double)value/pos;l(x)=1;return;&#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)change(lson,l,mid,pos,value); else if(pos&gt;mid)change(rson,mid+1,r,pos,value); pushup_max(x); l(x)=l(lson)+pushup_sum(m(lson),rson,mid+1,r);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(register int x,y,i=1; i&lt;=m; ++i) &#123; scanf("%d%d",&amp;x,&amp;y); val[x]=(double)y/x; change(1,1,n,x,y); printf("%d\n",l(1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome,new visitors! Here is Qiuly's blog!]]></title>
    <url>%2F2019%2F02%2F12%2FWelcome%2F</url>
    <content type="text"><![CDATA[数学法则只要与现实有关，都是不确定的；若是确定的，都与现实无关 ——阿尔伯特 · 爱因斯坦 欢迎！这里是 $Qiuly‘s\ blog$ ！在翻阅文章之前，$Qiuly$ 有几个小小的要求： 如果需要复制原文的话可以加 $Qiuly$ $QQ:2641450959$ ，请不要擅自复制却不跟 $Qiuly$ 说一声，谢谢理解。$Qiuly$ 目前还只是一个可爱的小学森，更博勤快的确不容易。 如果有图片挂了的，或者是代码缩进变成了 $8$ 的代码，还有就是格式问题爆炸的话(就是字之间突然有若干个空格之类的)也请加 $QQ$ ，$Qiuly’s \ blog$ 没有邮箱提醒的功能，所以如果只的是评论的话 $Qiuly$ 根本不知道。$QQ$ 的验证就填”六年级”好了，说明的话就填”博客问题”。 作为一个个人博客，当然欢迎加友链啦！想要加友链的朋友可以再下方评论区提出哦。 或许是使用的 $Latex$ 比较多，有些公式/ $Latex$ 的句子或许会加载的比较慢，需要等待片刻后再食用。 好啦，现在开始你的 $Qiuly’s \ blog$ 之旅吧！]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>公告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello new blog!]]></title>
    <url>%2F2019%2F02%2F12%2FHello%20new%20blog!%2F</url>
    <content type="text"><![CDATA[曾经尝试过用 $Wordpress$ 搭过博客，虽说操作简单，却因为我不想花钱而使用不了 $Makedown$ 格式，对于超级依赖 $Makedown$ 的我，找遍了方法都没法解决…… 于是蠢蠢欲动的想要用 $Hexo$ 搭个博客，虽然听学长说，$Hexo$ 只是静态页面，不是那么好。但是却可以免费，还可以用自己喜欢的编辑器学文章。这个计划就这么开始了。 两天时间，一共搭建了四次，前三次在机房搭的，均未成功。一到家用自己的笔记本电脑，却出奇的顺利，看到页面成功的弹出来时，我真的是激动得不能言语！ 然后，对这个也挺满意的。但是由于本人实在太弱，没有实力与精力去优化博客界面，只是草草的搞了一下 $LATEX$(打错了？) ，不知道能不能用。 之前我的 $Wordpress$ 的第一篇文章叫新的开始，现在看来那还不是，希望这才是一个崭新的开始吧！ （实际上原来叫 $Qiuly$，这个 $“monlights”$ 只是小号而已，$QvQ!$） （逃]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>公告</tag>
      </tags>
  </entry>
</search>
