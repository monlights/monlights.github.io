<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【题解】 [九省联考2018]林克卡特树 树形DP+wqs二分优化 loj2478]]></title>
    <url>%2F2019%2F05%2F12%2F%5B%E9%A2%98%E8%A7%A3%5Dloj2478%2F</url>
    <content type="text"><![CDATA[毒瘤传送门：戳我戳我 仔细观察会发现该题需要从树上拿出 $k+1$ 条互不相交的链，求这些链的节点的权值总和的最大值。那么我们选出这些链后就可以用 $k$ 条边将其连起来了，这样就满足了题意。 用 $f_{i,j}$ 表示 $i$ 的子树中选出了 $j$ 个链的最大值，但是会发现转移很难办，枚举一个 $i$ 的儿子 $v$ 的时候，我们不好算出 $v$ 对 $i$ 上的链做出的贡献。 那么我们新增加一个状态，设 $f_{0/1/2,i,j}$ 为我们的状态，$i,j$ 的意思和上面一样，其中 $0/1/2$ 分别表示——$0$ : $i$ 不属于子树中 $j$ 条链中的任意一条，$1$ : $i$ 属于 $j$ 条链中其中一条，$2$ : $i$ 属于 $j$ 条链中的其中两条 。 那么我们枚举一个儿子 $v$ ，现在我们需要转移的对象就是 $u$ (上面的 $i$ ) ，那么我们注意来考虑： 我们转移的时候枚举一个 $i$ 表示当前的链数，然后枚举 $j$ 表示 $v$ 子树中的链数，那么之前 $u$ 子树中的链数显然就是 $i-j$ 了。 令 $num_{v,j}=\max(f_{0,v,j},f_{1,v,j},f_{2,v,j})$ . 计算 $v$ 对 $f_{0,u,i}$ 的贡献 因为该状态必须满足 $u$ 不能属于任意一条链，所有我们理所当然也不能连上 $u\rightarrow v$ 这条边。那么也就是说 $v$ 中发生什么事情都跟 $u$ 没有任何关系了，因为要统计最大，我们直接将 $num$ 统计进去即可。 转移： f_{0,u,i}=\max_v\max_j \{f_{0,u,i-j}+num_{v,j}\} 计算 $v$ 对 $f_{1,u,i}$ 的贡献 考虑两种情况，第一种，这一条和 $u$ 有关的链是连着别的子树的，那么也就肯定不会连上 $u\rightarrow v$ 这条边，按照上面的转移即可。 第一种转移： f_{1,u,i}=\max_v\max_j \{f_{1,u,i-j}+num_{v,j}\}​ 第二种情况就是这一条链是和 $v$ 相连接的，那么这个时候 $v$ 的状态只能是 $0,1$ ，原因很显然，链不能香蕉(最好吃了🍌) ，那么对于 $v$ 状态是 $0$ 的情况，这样一连接后就会新出现一条链了，记得算上边权： 转移 $0$ 情况： f_{1,u,i}=\max_v\max_j\{f_{0,u,i-j}+f_{0,v,j-1}+w\}​$f_{0,u,i-j}$ 不解释，$f_{0,v,j-1}$ 这里为什么要 $j-1$ 呢？因为很显然当前局面只有 $i-1$ 条链，上面讲了连接后会多出来一条，那么 $i-1+1$ 就正好用来转移 $i$ 了。最后的 $w$ 即为当前转移带来的贡献。 $v$ 的状态是 $1$ 的时候和上面差不多，但是因为连接 $u,v$ 后 $u$ 属于了原来就存在的一条链，也就是说没有新增链，那么就没必要 $j-1$ 了。 转移 $1$ 的情况： f_{1,u,i}=\max_v\max_j\{f_{0,u,i-1}+f_{1,v,j}+w\} 计算 $v$ 对 $f_{2,u,i}$ 的贡献 首先如果这两条链连接别的子树了，那么 $v$ 就没有限制了，转移同上： 转移： f_{2,u,i}=\max_v\max_j \{f_{2,u,i-j}+num_{v,j}\} 接下来的就很好办了，因为连接 $u,v$ 最多是一条链，也就是说我们不可能将两条链都放到 $v$ 下来。先考虑 $v$ 状态为 $0$ 的情况，因为连接后 $v$ 属于了 $u$ 原来所在的链(没有新增链)，那么直接算贡献： 转移： f_{2,u,i}=\max_v\max_j\{f_{1,u,i-j}+f_{0,v,j}+w\} 然后考虑 $v$ 状态为 $1$ 的情况，这个时候连接 $u,v$ 会使得 $v$ 原来所在的链和 $u$ 原来所在的链合并为一条链，那么这里的和上面的 $j-1$ 不同，这里因为是少了一条链所有要变成 $j+1$ 。 转移： f_{2,u,i}=\max_v\max_j\{f_{1,u,i-j}+f_{1,v,j+1}+w\} 所有的转移式都得到了，我们来考虑初始化，首先因为是取最大值，我们需要全部初始化为一个很小的负数。然后对于 $f_{0,u,0}$ 这样的状态的值很显然是 $0$ 。 其他的没了，注意这样的 $\rm{DP}$ 复杂度只能让我们最多拿到 $60$ 分。 Code (60 $pts$ ) ：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=3e5+2;const int inf=1e9+9;int n,k,sz[N],head[N],cnt;ll dp[3][N][110];struct Edge&#123;int nxt,to,val;&#125; G[N&lt;&lt;1];void add(int u,int v,int w) &#123; G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,w&#125;,head[v]=cnt;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;void dfs(int u,int fa) &#123; dp[0][u][0]=0;/*初始化*/ for(int e=head[u];e;e=G[e].nxt) &#123; int v=G[e].to,w=G[e].val; if(v==fa) continue; dfs(v,u),sz[u]+=sz[v]; /*利用sz数组优化，同样是O(nk^2)的代码，其他的只能拿到30 ~40，但是这个优化过后是妥妥的60分*/ for(int i=min(sz[u],k);i;--i) &#123; /*计算v下面没有链的情况，计算初始状态带来的贡献*/ dp[2][u][i]=max(dp[2][u][i],dp[1][u][i]+w); dp[2][u][i]=max(dp[2][u][i],dp[1][u][i]+dp[1][v][1]+w); for(int j=min(sz[v],i);j;--j) &#123; /*计算出num*/ ll num=max(dp[0][v][j],max(dp[1][v][j],dp[2][v][j])); /*下面的7个式子就是上文讲的转移了*/ dp[0][u][i]=max(dp[0][u][i],dp[0][u][i-j]+num); dp[1][u][i]=max(dp[1][u][i],dp[1][u][i-j]+num); dp[1][u][i]=max(dp[1][u][i],dp[0][u][i-j]+dp[1][v][j]+w); dp[1][u][i]=max(dp[1][u][i],dp[0][u][i-j]+dp[0][v][j-1]+w); dp[2][u][i]=max(dp[2][u][i],dp[2][u][i-j]+num); dp[2][u][i]=max(dp[2][u][i],dp[1][u][i-j]+dp[0][v][j]+w); dp[2][u][i]=max(dp[2][u][i],dp[1][u][i-j]+dp[1][v][j+1]+w); &#125; /*也是一种特殊情况，可以直接放到上面去的(v下没有链)*/ dp[1][u][i]=max(dp[1][u][i],dp[0][u][i-1]+w); &#125; &#125; if(!sz[u]) dp[0][u][1]=0; ++sz[u];&#125;int main() &#123; IN(n),IN(k); for(int i=1;i&lt;n;++i) &#123; int x,y,v;IN(x),IN(y),IN(v),add(x,y,v); &#125; memset(dp,-0x3f,sizeof(dp));/*极小值*/ ++k;dfs(1,0); printf("%lld\n",max(dp[0][1][k],max(dp[1][1][k],dp[2][1][k]))); /*输出最优👆*/ return 0;&#125; 如果打出了表，你会发现对于单调递增的 $k$ ，关于其的最优解所形成的一定是一个上凸的函数，感性理解的话就是说 $k$ 小的时候我们可以选更多的更大的边，但是随着 $k$ 增大，这些边不够了，我们只能选更小的或者是拆掉一些边(将一条链断成两条增加链数) ，这样子答案就好慢慢变小。 因为是上凸函数，我们可以使用 $\rm{DP}$ 凸优化，带权二分/$wqs$二分套路优化一下就可以过了。 注意二分边界！还有就是需要注意一个点也可以成为一条链的情况！ Code (100 $pts$ )12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=6e5+2;const ll inf=1e18+9;int n,k,head[N],cnt;struct date &#123; ll x;int y; bool operator &lt; (const date&amp;var) const &#123;return x==var.x?y&gt;var.y:x&lt;var.x;&#125; date operator + (const date&amp;var) &#123;return (date)&#123;x+var.x,y+var.y&#125;;&#125; date operator + (const ll&amp;var) &#123;return (date)&#123;x+var,y&#125;;&#125;&#125;dp[3][N];ll number(date var) &#123;return var.x;&#125;struct Edge&#123;int nxt,to,val;&#125; G[N&lt;&lt;1];void add(int u,int v,int w) &#123; G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,w&#125;,head[v]=cnt;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;void check(ll add,int u,int fa) &#123; dp[0][u]=(date)&#123;0,0&#125;, dp[1][u]=(date)&#123;-inf,0&#125;, dp[2][u]=(date)&#123;add,1&#125;; for(int e=head[u];e;e=G[e].nxt) &#123; int v=G[e].to; ll w=G[e].val; if(v==fa) continue; check(add,v,u); date num=max(dp[0][v],max(dp[1][v],dp[2][v])); dp[2][u]=max(dp[2][u],dp[2][u]+num); dp[2][u]=max(dp[2][u],dp[1][u]+(date)&#123;w,0&#125;+max(dp[0][v],dp[1][v]+(date)&#123;-add,-1&#125;)); dp[1][u]=max(dp[1][u],dp[1][u]+num); dp[1][u]=max(dp[1][u],dp[0][u]+(date)&#123;w,0&#125;+max(dp[1][v],dp[0][v]+(date)&#123;add,1&#125;)); dp[0][u]=dp[0][u]+num; &#125;return;&#125;ll wqs(ll sum) &#123; ll l=-sum,r=sum,mid; date now; while(l&lt;r) &#123; mid=(l+r+1)&gt;&gt;1,check(mid,1,0); now=max(dp[0][1],max(dp[1][1],dp[2][1])); if(!(now.y^k)) &#123;l=r=mid;break;&#125; now.y&lt;k?l=mid:r=mid-1; &#125; mid=l;check(mid,1,0); now=max(dp[0][1],max(dp[1][1],dp[2][1])); return now.x-mid*k;&#125;int main() &#123; // freopen("lct2.in","r",stdin); // freopen("P4383.out","w",stdout); IN(n),IN(k);++k; ll sum=0; for(int i=1;i&lt;n;++i) &#123; int x,y,v;IN(x),IN(y),IN(v); add(x,y,v),sum+=abs(v); &#125; printf("%lld\n",wqs(sum)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>树形DP</tag>
        <tag>wqs二分/带权二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [ZJOI2010]基站选址 线段树优化DP luoguP2065]]></title>
    <url>%2F2019%2F05%2F09%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2605%2F</url>
    <content type="text"><![CDATA[这题居然只有 $luogu$ 有……无法水多倍经验了（逃。 朴素的 $\rm{DP}$ 很简单，设 $f_{i,j}$ 表示前 $i$ 个村庄建了 $j$ 个基站的花费最小值，注意因为是前 $i$ 个，所有完全无视掉后面的所有村庄了。转移的话直接枚举一个 $k$ ，从 $f_{k,j-1}$ 转移过来即可，加上的代价就是中间村庄产生的补偿费用。 那么这样的复杂度就是 $O(n^2k)$ [爆炸] ，我们需要做到的就是如何快速计算中间村庄的补偿，那么外围的 $\rm{DP}$ 复杂度其实是 $O(nk)$ 的，如果中间的补偿可以快速算出那么就可以过掉了。 我们对于每一个村庄 $i$ ，用二分计算出最左边可以覆盖到其的村庄 $st_i$ 和最右边可以覆盖到其的村庄 $ed_i$ ，那么我们从 $i$ 到 $i+1$ 的时候，所有 $ed$ 值为 $i$ 的点都将失去右边的依靠，这个时候对于 $i+1$ 的最优转移点 $k$ ，有对于一个失去”右边依靠”的村庄 $j$ ，如果 $k$ 的范围在 $[1,st_j-1]$ 之间的话那么就要给 $j$ 补偿了。 于是我们考虑用线段树优化，对于这样一个村庄 $j$ ，我们在 $[1,st_j-1]$ 区间集体加上 $w_j$ ，表示决策点如果落在那个区间就要多付出 $w_j$ 的费用。 线段树的每个位置维护的就是 $f_k+$ $i$ 和 $k$ 中间村庄的补偿费用，因为我们每一次的答案就是整个区间的 $\min$ 值了，只是随着 $i$ 的变化线段树维护的值也应当做出变化，所以就会向上面那样更新。 不过有个问题，有个情况没有考虑道：第 $n$ 个村庄不建基站的情况，对于一个小于 $n$ 的 $i$ ，$f_i$ 管不了 $n$ ，那么 $f_n$ 也仅仅表示 $n$ 建站的情况。 所以我们需要在 $n+1$ 的位置上建一个辅助基站，当然 $c_{n+1}=0$ ，这样子就很好计算 第 $n$ 个村庄不建站时全局的花费了 。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2e4+2;const int K=1e2+2;const int inf=1e9+9;int head[N],cnt;struct link&#123;int nxt,to;&#125; G[N&lt;&lt;2];void add(int u,int v) &#123;G[++cnt]=(link)&#123;head[u],v&#125;;head[u]=cnt;&#125;int n,k,d[N],c[N],s[N],w[N],f[N],st[N],ed[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;namespace Segment_Tree &#123; #define mid ((l+r)&gt;&gt;1) #define ls(x) ((x)&lt;&lt;1) #define rs(x) ((x)&lt;&lt;1|1) int val[N&lt;&lt;2],tag[N&lt;&lt;2]; void pushdown(int x,int l,int r) &#123; val[ls(x)]+=tag[x],tag[ls(x)]+=tag[x]; val[rs(x)]+=tag[x],tag[rs(x)]+=tag[x]; tag[x]=0; &#125; void build(int x,int l,int r) &#123; tag[x]=0; if(l==r) &#123;val[x]=f[l];return;&#125; build(ls(x),l,mid),build(rs(x),mid+1,r); val[x]=min(val[ls(x)],val[rs(x)]); &#125; void change(int x,int l,int r,int L,int R,int v) &#123; if(L==l&amp;&amp;r==R) &#123;val[x]+=v,tag[x]+=v;return;&#125; if(tag[x]) pushdown(x,l,r); if(R&lt;=mid) change(ls(x),l,mid,L,R,v); else if(L&gt;mid) change(rs(x),mid+1,r,L,R,v); else change(ls(x),l,mid,L,mid,v),change(rs(x),mid+1,r,mid+1,R,v); val[x]=min(val[ls(x)],val[rs(x)]); &#125; int query(int x,int l,int r,int L,int R) &#123; if(L==l&amp;&amp;r==R) return val[x]; if(tag[x]) pushdown(x,l,r); if(R&lt;=mid) return query(ls(x),l,mid,L,R); else if(L&gt;mid) return query(rs(x),mid+1,r,L,R); else return min(query(ls(x),l,mid,L,mid),query(rs(x),mid+1,r,mid+1,R)); &#125;&#125;using namespace Segment_Tree;int main() &#123; IN(n),IN(k); for(int i=2;i&lt;=n;++i) IN(d[i]); for(int i=1;i&lt;=n;++i) IN(c[i]); for(int i=1;i&lt;=n;++i) IN(s[i]); for(int i=1;i&lt;=n;++i) IN(w[i]); ++n;w[n]=d[n]=inf; for(int i=1;i&lt;=n;++i) &#123; st[i]=lower_bound(d+1,d+1+n,d[i]-s[i])-d; ed[i]=lower_bound(d+1,d+1+n,d[i]+s[i])-d; if(d[ed[i]]&gt;d[i]+s[i]) ed[i]--;add(ed[i],i); &#125; int ans=inf; for(int i=1;i&lt;=k;++i) if(i==1) &#123; int res=0; for(int j=1;j&lt;=n;++j) &#123; f[j]=res+c[j]; for(int e=head[j];e;e=G[e].nxt) res+=w[G[e].to]; &#125;ans=f[n]; &#125; else &#123; build(1,1,n); for(int j=1;j&lt;=n;++j) &#123; f[j]=(j&gt;i-1?query(1,1,n,i-1,j-1):0)+c[j]; for(int e=head[j],v;e;e=G[e].nxt) if(st[v=G[e].to]&gt;1) change(1,1,n,1,st[v]-1,w[v]); &#125;ans=min(ans,f[n]); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 最长上升子序列 状压DP bzoj3591]]></title>
    <url>%2F2019%2F05%2F08%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj3591%2F</url>
    <content type="text"><![CDATA[这题脑洞很大——你需要状压 $\rm{LTS}$ 数组，而且是三进制状压。复杂度很高……大约是 $O(n3^n)$ 左右，当然实际复杂度会小于这个，$1000^+ms$ 是可以通过的。 对于每一个数字，分别记录其三种状态：该数字没有进过 $\rm{LTS}$ 数组记为 $0$ ，该数字在 $\rm{LTS}$ 数组中记为 $1$ ，该数字进过 $\rm{LTS}$ 数组，结果又出来了记为 $2$ 。 设 $f_i$ 表示 $1$ 到 $n$ 所有数字的状态为 $i$ 时的方案数，接下来考虑转移，首先对于这个 $i$ 状态我们还原其 $\rm{LTS}$ 数组，也就是当前位置上为 $1$ 的那些数字。接着我们枚举所有位置上为 $0$ 的数字，并考虑将其插入当前的 $\rm{LTS}$ 当中。替换掉一个状态为 $1$ 的数。 我们就选定这个要被替换的状态为 $1$ 的数为当前 $\rm{LTS}$ 中第一个大于当前要加入的数的数，那么这样替换后 $\rm{LTS}$ 依然满足其性质。 维护一个指针扫一遍就好，碰到需要换的数就将其标记为 $2$ ，然后将当前需要加入的数变成 $1$ 即可。 需要注意的是，我们这里的”加入”并不是只的在原数组中加入，也就是说跟排列什么的几乎扯不上关系，比如说当前序列为 $1,2,3,4,5$ ，$\rm{LTS}$ 数组为 $1,3,4$ ，我们在这里将 $3$ 丢掉，然后加入 $2$ ，其实是不变的。 当所有数字都被考虑过的时候就可以直接统计答案了，普通的 $\rm{LTS}$ 也是所有数字都要考虑一回的。 在做 $\rm{DP}$ 转移的时候我们顺带满足一下题面给出的那些数的递增即可，那么可以保证所有被统计的状态都带有题面要求的 $\rm{LTS}$ 。 Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e2+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int n,m,ans,arr[N],pos[N],mul[N];int hep[N],var[N],dp[14348907+3];int main() &#123; freopen("3591.in","r",stdin); freopen("3591.out","w",stdout); IN(n),IN(m); for(int i=0;i&lt;m;++i) IN(arr[i]),--arr[i],pos[arr[i]]=i; mul[0]=dp[0]=1; for(int i=1;i&lt;=n;++i) mul[i]=mul[i-1]*3; for(int i=0;i&lt;mul[n];++i) if(dp[i]) &#123; int state=i,top=0,num=0,per=0; for(int j=0;j&lt;n;++j) &#123; var[j]=state%3,state/=3; if(var[j]) ++num; if(var[j]==1) hep[top++]=j; &#125; if(num==n) &#123;ans+=dp[i];continue;&#125; for(int j=0;j&lt;n;++j) &#123; if(var[j]) continue; if(pos[j]&amp;&amp;!var[arr[pos[j]-1]]) continue; while(hep[per]&lt;j&amp;&amp;per&lt;top) ++per; if(per&gt;=m) continue; state=i+mul[j]; if(per&lt;top) state+=mul[hep[per]]; dp[state]+=dp[i]; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP进阶必刷题单]]></title>
    <url>%2F2019%2F05%2F07%2FDP%E8%BF%9B%E9%98%B6%E5%BF%85%E5%88%B7%E9%A2%98%E5%8D%95%2F</url>
    <content type="text"><![CDATA[在此输入你的密码以便阅读全文 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2009]双递增序列 线性DP luoguP4728]]></title>
    <url>%2F2019%2F05%2F07%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4728%2F</url>
    <content type="text"><![CDATA[其实这题很容易设出四维的 $\rm{DP}$ ，也就是用 $dp_{i,j,x,y}$ 表示第一个序列的终止位置为 $i$ 且长度为 $x$，第二个序列的终止位置为 $j$ 且长度为 $y$ 是否成立 ，然后也很容易想到降维，枚举当前序列长度 $len$ 的时候知道了 $x$ 就已经知道 $y$ 了—— $y$ 就是 $len-x$ 。也就是说现在的 $DP$ 是 $O(n^3)$ 的，还需要优化。 考虑设 $dp_{i,j}$ 表示第一个序列的最终位置为 $i-1$ 且长度为 $j$ 时第二个序列的最终位置的最小值。枚举当前数字 $i$ ，然后分两种情况进行转移——将 $a_i$ 放到第一个序列末尾 $\texttt{and}$ 将 $a_i$ 放到第二个序列末尾。 放到第一个序列末尾很好想：因为当前第一个序列的结尾处就是 $a_{i-1}$ ，比较一下大小直接转移就好了： dp_{i,j}=min(dp_{i,j},dp_{i-1,j-1}) \ \ \ (a_i>a_{i-1})因为第二个序列的末尾没变，所有直接转移就好。 接下来考虑将第 $i$ 个数放到第二个序列末尾的情况，其实第一个序列和第二个序列没区别，当然除了名字上有一个字的差异，假设第 $i-1$ 个数是第二个序列末尾，当前第一个序列的长度为 $j-1$ ，那么第二个序列的长度因该就是 $(i-1)-(j-1)$ 了，因为我们假设了第 $i-1$ 个数是第二个序列末尾，那么 $dp_{i-1,i-j}$ 又可以被解释为第二个序列的末尾为 $i-1$ 个数且第二个序列的长度为 $i-j$ 的时候第一个序列的末尾的最小值 ，如果这个最小值小于 $a_i$ ，说明 $a_i$ 可以接到第一个序列前面，那么这个时候第二个序列的末尾为 $a_{i-1}$ ，显然又有转移： dp_{i,j}=min(dp_{i,j},a_{i-1}) \ \ \ (a_i>dp_{i-1,i-j})开始的时候我们将 $dp$ 数组赋成极大值，然后最后判断一下 $dp_{n,n/2}$ 这个状态变小没有就好。 Code:1234567891011121314151617181920212223242526272829303132333435363738#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=2e3+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int a[N],f[N][N];int solve() &#123; int n;IN(n); memset(f,0x3f,sizeof(f)); for(int i=1;i&lt;=n;++i) IN(a[i]); a[0]=f[0][0]=-1; for(int i=1;i&lt;=n;++i) &#123; f[i][0]=a[i]; for(int j=1;j&lt;=i&amp;&amp;j&lt;=n/2;++j) &#123; if(a[i]&gt;a[i-1]) f[i][j]=min(f[i][j],f[i-1][j-1]); if(a[i]&gt;f[i-1][i-j]) f[i][j]=min(f[i][j],a[i-1]); &#125; &#125;return f[n][n/2]&lt;0x3f3f3f3f;&#125;int main() &#123; int T;IN(T); while(T--) puts(solve()?"Yes!":"No!"); return 0;&#125; 感觉这道题的确很绕……=。=]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HEOI2013]SAO 组合数学+树形DP luoguP4099]]></title>
    <url>%2F2019%2F05%2F06%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4099%2F</url>
    <content type="text"><![CDATA[$loj$ 上没有此题，$bzoj$ 上是权限题，对于不上 $yzoj$ 的我来说只能去洛谷做题了：转送门😄 。 我们先不考虑边的权值(&lt;与&gt;)，这样子 $n-1$ 条边组成的就是树了，很显然是需要我们求出这棵树的合法拓扑序的个数，考虑使用 $\rm{DP}$ ，对于边的方向(即&lt;,&gt;) ，我们分类讨论即可。 首先的一个想法就是设 $f_u$ 表示点 $u$ 的子树的合法拓扑序的总数，但是这个时候如何计算呢，对于一个 $u$ 的儿子 $v$ ，我们虽然知道 $u$ 和 $v$ 的攻克的前后关系，但是合并答案貌似并不好合并。这个时候我们增加一维 $j$ ，$f_{u,j}$ 表示 $u$ 的子树的所有合法拓扑序中 $u$ 在第 $j$ 位上的总状态数。 也就是说，对于一个必须在 $u$ 前面攻克的关卡 $v$ ，我们考虑枚举一个 $j$ ，$v$ 子树中 $j$ 个结点在合并 $u,v$ 后放到 $u$ 前面，另外 $sz_v-j$ 个放到 $u$ 后面，然后枚举一个 $k$ ，表示当前的 $v$ 排在 $v$ 子树的拓扑序中的第 $k$ 位，只有 $k\leq j$ 的时候 $v$ 才可以转移 $u$ ，因为这个时候 $v$ 在 $u$ 前面。 现在再来考虑$“$ $j$ 个结点放在 $u$ 前面 $”$ 的方案数和$“$ $sz_v-j$ 个结点放在 $u$ 后面的方案数$”$，这个显然可以用组合数算，合并 $v$ 的子树后，$u$ 的排名从 $i$ 变成了 $i+j$ ，也就是说我们需要将 $j$ 个乱序插入到 $u$ 前面 $i+j-1$ 个数中，方案数显然为 $C_{i+j-1}^{j}$ ，那么现在总节点数显然为 $sz_u+sz_v$ (现在 $sz_u$ 和 $sz_v$ 还没有并在一起) ，$u$ 后面理所当然有 $sz_u+sz_v-i-j$ 个位置，将 $sz_v-j$ 个数插进去的方案数显然为 $C_{sz_u+sz_v-i-j}^{sz_v-j}$ 个，这两个数再乘上 $f_{u,i}$ 和 $f_{v,k}$ 就好了，这一次合并后 $u$ 的位置显然到了 $i+j$ ，所以 $f_{u,i+j}$ 显然要加上这一组贡献。 经整理后的转移方程如下： pls(f_{u,i+j},f_{u,i}\cdot f_{v,k}\cdot C_{i+j-1}^{j}\cdot C_{sz_u+sz_v-i-j}^{sz_v-j})代码就是这样写： 1234for i=1 to sz[u] for j=1 to sz[v] for k=1 to j pls(f[u][i+j],f[u][i]*f[v][k]*C[i+j-1][j]*C[sz[u]+sz[v]-i-j][sz[v]-j]) 这是 $n^3$ 的，过不去。考虑前缀和优化，几下 $f_v$ 的前缀和，最后的一层循环就可以直接丢掉了。 这个就是 $v$ 要在 $u$ 前面的情况，$u$ 在 $v$ 前面的情况和这个差不多，不过转移的时候 $j$ 就要从 $0$ 开始了，因为那个时候 $u$ 前面是可以不多放任何东西的，还有就是 $u$ 在 $v$ 前面的时候注意 $k\geq j$ 时才可以转移 ! 最后的答案就是 $\sum\limits_{i=1}^{n} f_{1,i}$ 啦。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e3+9;const int mod=1e9+7;int head[N],cnt;struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;1];int C[N][N],f[N][N],pre[N][N],suf[N][N],sz[N],g[N];void add(int u,int v,int w) &#123; G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,w^1&#125;,head[v]=cnt;&#125;namespace OI &#123; void pls(int&amp;x,int y) &#123;x+=y;if(x&gt;=mod)x-=mod;&#125; template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x; &#125;&#125;using namespace OI;void dfs(int u,int fa) &#123; sz[u]=f[u][1]=1; for(int l=head[u];l;l=G[l].nxt) &#123; int v=G[l].to,w=G[l].val; if(v==fa) continue; dfs(v,u); memset(g,0,sizeof(g)); if(w) &#123; for(int i=1;i&lt;=sz[u];++i) for(int j=1;j&lt;=sz[v];++j) pls(g[i+j],1ll*f[u][i]*pre[v][j]%mod*C[i+j-1][j]%mod *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod); &#125; else &#123; for(int i=1;i&lt;=sz[u];++i) for(int j=0;j&lt;=sz[v];++j) pls(g[i+j],1ll*f[u][i]*suf[v][j+1]%mod*C[i+j-1][j]%mod *C[sz[u]+sz[v]-i-j][sz[v]-j]%mod); &#125; sz[u]+=sz[v]; memcpy(f[u],g,sizeof(g)); &#125; pre[u][0]=suf[u][sz[u]+1]=0; for(int i=1;i&lt;=sz[u];++i) pre[u][i]=(pre[u][i-1]+f[u][i])%mod; for(int i=sz[u];i&gt;=1;--i) suf[u][i]=(suf[u][i+1]+f[u][i])%mod;&#125;int solve() &#123; memset(head,0,sizeof(head)),cnt=0; memset(f,0,sizeof(f)); int n;IN(n); for(int i=1;i&lt;n;++i) &#123; int u,v;char sign; IN(u),sign=getchar(),IN(v); add(u+1,v+1,sign=='&lt;'?0:1); &#125; dfs(1,0); int ans=0; for(int i=1;i&lt;=n;++i) pls(ans,f[1][i]); return ans;&#125;int main() &#123; /*预处理组合数*/ for(int i=0;i&lt;=N-2;++i) C[i][0]=1; for(int i=1;i&lt;=N-2;++i) for(int j=1;j&lt;=N-2;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; int T;IN(T); while(T--) printf("%d\n",solve()); return 0;&#125; 可能有人会问，如果 $u$ 的儿子 $v$ 下面的边全都是 $&gt;$ ，并且 $u$ 连向 $v$ 的边也是 $&gt;$ ，那么这个时候 $v$ 以及其子树的所有点都必须在 $u$ 前面完成，在转移的时候为什么可以 $“$ 提出 $j$ 个结点放到 $u$ 前面 $”$ 呢？ 其实想想就可以明白，在向上统计答案的时候对于一个 $v$ 的儿子 $a$ ，我们只统计了合并后 $a$ 在 $v$ 前面的情况，同样在 $u$ 统计 $v$ 时也只是统计了合并后 $v$ 在 $u$ 前面的情况，所有我们也只是统计了 $“$ $a$ 在 $v$ 前面且 $v$ 在 $u$ 前面 $”$ 的情况，所有被统计的情况一定是合法的。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>组合数学</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HAOI2018]苹果树 组合数学 loj2526]]></title>
    <url>%2F2019%2F05%2F05%2F%5B%E9%A2%98%E8%A7%A3%5Dloj2526%2F</url>
    <content type="text"><![CDATA[有趣的题目，可爱的传送门：戳这呢=￣ω￣= 刚开始往概率 $\rm{DP}$ 想了，发现对于一个点的概率是好算，但是如果求贡献的话就会很难办。最后万般无赖的点开了题解，发现居然是……组合数学？其实和 $\rm{DP}$ 没有半毛钱关系。 我们考虑一个节点 $i$ ，我们枚举其子树大小 $j$ 。现在考虑最终有多少种合法的情况可以使得 $i$ 的子树大小恰好为 $j$ 。 易知节点数为 $n$ 的二叉树的总形态数为 $n!$ ，而且 $i$ 子树下的所有节点的编号一定要大于 $i$ ，我们考虑”先将 $i$ 子树构造出来再填入节点”的过程，子树的形态数显然为 $j!$ ，然后我们只能选剩下的 $n-i$ 个节点(编号要比 $i$ 大) ，填入剩下的 $j-1$ 个位置( $i$ 占了一个位置) ，显然这样的方案数为 $C_{n-i}^{j-1}$ 。 这样的一个 $i$ ，其子树大小为 $j$ ，那么它可以做出多少贡献呢？考虑 $fa_i \Rightarrow i$ 这条边会经过多少次，显然是 $j\cdot(n-j)$ 次( $j$ 为子树节点个数，$n-j$ 为上面的节点个数) ，也就是说这样的方案可以造成 $j\cdot (n-j)$ 的贡献。 那么现在 $i$ 的子树得到确定了，我们将 $i$ 以及其子树看做一个点，我们考虑 $1$ 到 $i$ 这些节点，它们可以以任意形态组成一棵树，方案数是 $i!$ 。 接着我们需要将剩下的 $n-j-(i-1)$ 个节点挂到树上去。对于第 $i$ 个挂到树上的点，它有 $i$ 个位置可以挂。但是因为 $i$ 一定要占一个位置，所以这个节点只有 $i-1$ 个位置可以挂了，第二个多出来的节点就有 $i$ 个位置可以挂……第 $k$ 个显然有 $i-2+k$ 个位置可以挂。也就是说这些点挂上去的总方案数为 $\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 。 将上面的乘起来就是这一组 $i,j$ 对答案造成的贡献了： j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$\prod\limits_{k=1}^{n-j-(i-1)} (i-2+k)$ 比较不好计算，但是简单的变化后发现这个是和 $(n-j-1)!/(i-2)!$ 等价的，我们带进原式子。 j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i!\cdot(n-j-1)!/(i-2)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot (n-j)\cdot i\cdot (i-1)\cdot(n-j-1)!\\\\=j!\cdot C_{n-i}^{j-1}\cdot j\cdot i\cdot (i-1)\cdot (n-j)!这样就很好算了，我们预处理组合数和阶乘，上面的式子 $O(1)$ 算~ 代码很短。 Code：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2e3+2;const int inf=1e9+9;int n,p,ans,fac[N],C[N][N];namespace OI &#123; void pls(int&amp;x,int y) &#123;x+=y;x%=p;&#125; template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x; &#125;&#125;using namespace OI;int main() &#123; IN(n),IN(p); fac[1]=1; for(int i=2;i&lt;=n;++i) fac[i]=1ll*fac[i-1]*i%p; for(int i=0;i&lt;=n;++i) C[i][0]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=i;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n-i+1;++j) pls(ans,(ll)fac[j]*fac[n-j]%p*C[n-i][j-1]%p*(i*(i-1))%p*j%p); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [六省联考2017]分手是祝愿 概率DP loj2145]]></title>
    <url>%2F2019%2F05%2F05%2F%5B%E9%A2%98%E8%A7%A3%5Dloj2145%2F</url>
    <content type="text"><![CDATA[概率神仙题的传送门：别戳偏了 设 $f_i$ 表示还剩下 $i$ 盏灯亮到还剩下 $i-1$ 盏灯亮的期望操作次数，这个时候有 $\frac{i}{n}$ 的概率按中亮的，但是没有按中亮的的话就只能退到 $f_{i+1}$ 。不难列出转移方程： f_i=\frac{i}{n}+(1-\frac{i}{n})\cdot (1+f_i+f_{i+1})因为转移式中有个 $f_i$ ，有些不好办……推一推式子康康。 f_i=\frac{i}{n}+1\cdot (1+f_i+f_{i+1})-\frac{i}{n}\cdot (1+f_i+f_{i+1})\\\\f_i=\frac{i}{n}+1+f_i+f_{i+1}-\frac{i}{n}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\f_i=1+f_i+f_{i+1}-\frac{i}{n}f_i-\frac{i}{n}f_{i+1}\\\\\frac{i}{n}f_i=1+f_{i+1}-\frac{i}{n}f_{i+1}\\\\f_i=\frac{1+f_{i+1}-\frac{i}{n}f_{i+1}}{\frac{i}{n}}\\\\f_i=\frac{n\cdot(1+f_{i+1})-i\cdot f_{i+1}}{i}\\\\f_i=\frac{n+(n-i)\cdot f_{i+1}}{i}\\\\f_i=1+\frac{(n-i)\cdot (f_{i+1}+1)}{i}预处理逆元就可以直接计算了，记得最后乘上 $n!$ 。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e5+7;const int inf=1e9+9;const int p=100003;int n,k,step,a[N];long long ans,f[N],inv[N];vector&lt;int&gt; g[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int main() &#123; IN(n),IN(k); inv[0]=0,inv[1]=1; for(int i=2;i&lt;=n;++i) inv[i]=(long long)(p-p/i)*inv[p%i]%p; for(int i=1;i&lt;=n;++i) IN(a[i]); for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;j+=i) g[j].push_back(i); for(int i=n;i&gt;=1;--i) if(a[i]) &#123; for(int j=0;j&lt;g[i].size();++j) a[g[i][j]]^=1; ++step; &#125; if(step&lt;=k) ans=step; else &#123; f[n]=1; for(int i=n-1;i&gt;1;--i) f[i]=(1ll+(1ll*n-i)*(f[i+1]+1)*inv[i])%p; for(int i=step;i&gt;k;--i) ans=(ans+f[i])%p; ans=(ans+k)%p; &#125; for(int i=1;i&lt;=n;++i) ans=(1ll*i*ans)%p; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SCOI2014]方伯伯的玉米田 树状数组优化DP luoguP3287]]></title>
    <url>%2F2019%2F05%2F04%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3287%2F</url>
    <content type="text"><![CDATA[以后不要被这种傻逼题给蒙骗了。传送门：方伯伯的传送门=。= 首先要明确一个道理，每一次拔高的右端点一定是 $n$ ，如果是只拔高中间部分，右边的又要尽可能大于中间部分，索性一起拔了，这一定是最优的。 设 $f_{i,j}$ 表示第 $i$ 个玉米被拔高了 $j$ 次时以 $i$ 结尾的最长不下降子序列长度，容易得出转移方程： f_{i,j}=\max\{f_{k,l}+1\} \ \ (k]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>树状数组</tag>
        <tag>二维树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SHOI2014]概率充电器 概率DP loj2192]]></title>
    <url>%2F2019%2F05%2F02%2F%5B%E9%A2%98%E8%A7%A3%5Dloj2192%2F</url>
    <content type="text"><![CDATA[传送门在这：我是传送门$QwQ$ 其实不难发现，我们需要算的就是 $\sum a_i$ (其中 $a_i$ 为点 $i$ 的通电概率) 。我们需要算出每个点的通电概率即可。因为有些点可以自己发电，所以我们要分别考虑父亲和儿子的通电情况。 因为直接设通电概率有些棘手，我们设 $f_i$ 表示点 $i$ 的儿子没有向点 $i$ 通电的概率，这个比较好算，我们顺带算上点 $i$ 自己发电的概率。 枚举每一个儿子，对于这个儿子只有两种情况：该儿子没有通上电，该儿子通上电了且传送失败。两种情况的概率都很好算。我们可以列出转移方程： f_u=(1-q_u)\cdot \prod (f_v+(1-f_v)\cdot(1-G_i.p))其中 $(1-q_u)$ 显然为该点本身不通电的概率，然后枚举儿子 $v$ ，$f_v$ 就是该儿子本来就没有通上电的概率，$(1-f_v)\cdot(1-G_i.p)$ 就是通上电的传送失败(注：$G_i.p$ 是当前连接 $u,v$ 的边的通电概率) 。 那么如何计算父亲传来的电呢？设 $g_i$ 表示点 $i$ 的父亲没有向点 $i$ 通电的概率。计算一下父节点不通电的概率，注意不要计算上该儿子的贡献，不然会乱。计算完不通电的概率后分上面两种情况讨论即可。 res=g_u\cdot f_v / (f_v+(1-f_v)\cdot(1-G_i.p))\\\\g_v=res+(1-res)\cdot(1-G_i.p)两边 $dfs$ 就可以搞定。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=5e5+7;const int inf=1e9+9;double ans,f[N],g[N],q[N];int head[N],cnt,n,tot;struct Edge&#123;int nxt,to;double p;&#125;G[N&lt;&lt;1];void add(int x,int y,double p) &#123;G[++cnt]=(Edge)&#123;head[x],y,p&#125;,head[x]=cnt;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;void dfs1(int u,int fa) &#123; f[u]=1-q[u]; for(int i=head[u],v;i;i=G[i].nxt) if((v=G[i].to)!=fa) dfs1(v,u),f[u]*=(f[v]+(1-f[v])*(1-G[i].p));&#125;void dfs2(int u,int fa) &#123; for(int i=head[u],v;i;i=G[i].nxt) if((v=G[i].to)!=fa) &#123; double res=g[u]*f[u]/(f[v]+(1-f[v])*(1-G[i].p)); g[v]=res+(1-res)*(1-G[i].p);dfs2(v,u); &#125;&#125;int main() &#123; IN(n); for(int i=1;i&lt;n;++i) &#123; int x,y,p;IN(x),IN(y),IN(p); add(x,y,p/100.0),add(y,x,p/100.0); &#125; for(int i=1,x;i&lt;=n;++i) IN(x),q[i]=x/100.0; dfs1(1,1); g[1]=1.0,dfs2(1,1); for(int i=1;i&lt;=n;++i) ans+=1-f[i]*g[i]; printf("%.6f\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2015]寿司晚宴 状压DP loj2131]]></title>
    <url>%2F2019%2F05%2F01%2F%5B%E9%A2%98%E8%A7%A3%5Dloj2131%2F</url>
    <content type="text"><![CDATA[首先，两个数不互质同理于两个数的质因子集合没有交集。考虑一下 $n\leq 30$ 的情况，可以发现这里面的质数也只有 $10$ 个，那么我们将每一个寿司分解质因数，然后将质因子压成一个状态。 设 $f[s1][s2]$ 表示小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ，小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。转移的时候枚举寿司，分别判断两个人是否能吃然后转移即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e2+2;const int mul=1024;const int pri[]=&#123;0,2,3,5,7,11,13,17,19,23,29&#125;;int n,s[N];ll p,f[2][mul][mul];namespace OI &#123; void pls(ll&amp;x,ll&amp;y) &#123;x+=y;if(x&gt;p)x-=p;&#125; template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x; &#125;&#125;using namespace OI;int main() &#123; // freopen("1.in","r",stdin); // freopen("1.out","w",stdout); IN(n),IN(p); for(int i=2;i&lt;=n;++i) for(int j=1;j&lt;=10;++j) if(!(i%pri[j])) s[i]|=1&lt;&lt;(j-1); f[1][0][0]=1; for(int i=2;i&lt;=n;++i) &#123; int now=i&amp;1,lst=!now; memcpy(f[now],f[lst],sizeof(f[lst])); for(int s1=0;s1&lt;mul;++s1)for(int s2=0;s2&lt;mul;++s2) &#123; if(!f[lst][s1][s2]) continue; if(!(s2&amp;s[i])) pls(f[now][s1|s[i]][s2],f[lst][s1][s2]); if(!(s1&amp;s[i])) pls(f[now][s1][s2|s[i]],f[lst][s1][s2]); &#125; &#125; long long ans=0; for(int s1=0;s1&lt;mul;++s1) for(int s2=0;s2&lt;mul;++s2) pls(ans,f[n&amp;1][s1][s2]); printf("%lld\n",ans); return 0;&#125; 可以知道 $n\leq 500$ 的时候，每一个数最多带上一个大于等于 $23$ 的质因子。我们首先将所有的寿司分为两类：带了大于等于 $23$ 的质因子的和没带的。 没带的显然可以向上面那样转移。那么带了的呢？这个显然不能压缩吧。 我们考虑将带了同样的大于等于 $23$ 的质因子的分成一组，这一组要不小 $\rm{G}$ 吃小 $\rm{W}$ 不吃，要不小 $\rm{W}$ 吃小 $G$ 不吃。分别讨论即可。 设 $f1[s1][s2]$ 表示这一组是小 $\rm{G}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。同理，设 $f2[s1][s2]$ 表示这一组是小 $\rm{W}$ 吃时，小 $\rm{G}$ 吃了的寿司的状态为 $s1$ ， 小 $\rm{W}$ 吃了的寿司的状态为 $s2$ 时的方案数。分别转移就好了。 12345678910111213141516for(int i=pos+1;i&lt;=n;++i) &#123; /*枚举这些寿司*/ if(a[i].t!=a[i-1].t) /*大质因子不同了*/ memcpy(f1,f,sizeof(f)),memcpy(f2,f,sizeof(f)); for(int s1=M-1;~s1;--s1)for(int s2=M-1;~s2;--s2) &#123; /*倒着枚举所以没用滚动数组*/ /*所谓的分别转移*/ if(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]); if(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]); &#125; /*这一组结束了，需要合并答案*/ if(a[i].t!=a[i+1].t||i==n) for(int s1=0;s1&lt;M;++s1)for(int s2=0;s2&lt;M;++s2) /*因为f1[s1][s2]和f2[s1][s2]都重复算了一遍原来的 f[s1][s2]，所以减掉后再取膜*/ f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p;&#125; Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=5e2+2;const int M=256;const int pri[]=&#123;0,2,3,5,7,11,13,17,19&#125;;ll p,f[M][M],f1[M][M],f2[M][M];struct Node &#123;int t,s;&#125;a[N];bool cmp(Node a,Node b) &#123;return a.t&lt;b.t;&#125;namespace OI &#123; void pls(ll&amp;x,ll&amp;y) &#123;x+=y;if(x&gt;=p)x%=p;&#125; template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x; &#125;&#125;using namespace OI;int main() &#123; int n;IN(n),IN(p); for(int i=2;i&lt;=n;++i) &#123; a[i].t=i; for(int j=1;j&lt;=8;++j)if(!(i%pri[j])) &#123; a[i].s|=1&lt;&lt;(j-1),a[i].t/=pri[j]; while(!(a[i].t%pri[j])) a[i].t/=pri[j]; &#125; &#125; f[0][0]=1; sort(a+2,a+n+1,cmp); int pos=2; while(a[pos].t==1) ++pos;--pos; for(int i=2;i&lt;=pos;++i) &#123; for(int s1=M-1;~s1;--s1)for(int s2=M-1;~s2;--s2) &#123; if(!(s2&amp;a[i].s)) pls(f[s1|a[i].s][s2],f[s1][s2]); if(!(s1&amp;a[i].s)) pls(f[s1][s2|a[i].s],f[s1][s2]); &#125; &#125; for(int i=pos+1;i&lt;=n;++i) &#123; if(a[i].t!=a[i-1].t) memcpy(f1,f,sizeof(f)),memcpy(f2,f,sizeof(f)); for(int s1=M-1;~s1;--s1)for(int s2=M-1;~s2;--s2) &#123; if(!(s2&amp;a[i].s)) pls(f1[s1|a[i].s][s2],f1[s1][s2]); if(!(s1&amp;a[i].s)) pls(f2[s1][s2|a[i].s],f2[s1][s2]); &#125; if(a[i].t!=a[i+1].t||i==n) for(int s1=0;s1&lt;M;++s1)for(int s2=0;s2&lt;M;++s2) f[s1][s2]=(f1[s1][s2]+f2[s1][s2]-f[s1][s2]+p)%p; &#125; long long ans=0; for(int s1=0;s1&lt;M;++s1) for(int s2=0;s2&lt;M;++s2) pls(ans,f[s1][s2]); printf("%lld\n",(ans+p)%p); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [JSOI2016]灯塔 决策单调性&DP loj2074]]></title>
    <url>%2F2019%2F04%2F30%2F%5B%E9%A2%98%E8%A7%A3%5Dloj2047%2F</url>
    <content type="text"><![CDATA[其实这道题是 $\rm{POI}$ 的原题，$loj$ 传送门链接：在这呢o(￣︶￣)o 刚开始肯定还是看不出这题是什么 $\rm{DP}$ ，感觉很诡异，但是推一推自然就出来了： h_j \leq h_i+p-\sqrt{|i−j|}\\\\p\geq h_j-h_i +\sqrt{|i−j|}\\\\p=\max\{ h_j-h_i +\sqrt{|i−j|}\}设 $f_i$ 表示 $i$ 的 $p$ 值，那么继续： f_i=\max\{ h_j +\sqrt{|i−j|}\}-h_i发现绝对值很烦人，将绝对值拆开。 f_i=\max(\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\},\max\limits_{j=i}^{n}\{h_j +\sqrt{j-i}\})-h_i原序列翻转一下就可以直接计算后面的式子，也就是说我们只需要考虑第一个： f_i=\max\limits_{j=1}^{i}\{h_j +\sqrt{i−j}\}-h_i假设对于 $i$ 来说 $j$ 是最优的决策，那么如果存在一个小于 $j$ 的 $k$ ，是否在转移一个大于 $i$ 的 $l$ 会更优呢？显然不会，可以知道 $i-k$ 显然是大于 $i-j$ 的，而且根号是增长的越来越慢的。所以如果在 $i$ 时 $k$ 就没有 $j$ 优了，那么在以后所以大于 $i$ 的 $l$ 转移时 $k$ 也不可能比 $j$ 优。 也就是说上面的式子满足决策单调性，那么我们可以 $O(n\log n)$ 愉快求出了。 这里说明两个方法： 1. 单调队列维护三元组，三元组包含 $v$ (决策点 $v$) ，$l$ (决策点 $v$ 作为最优决策点的最左端点) ，$r$ (决策点 $v$ 作为最优决策点的最右端点) ，每一次排除掉最右端点小于 $i$ 的元素(因为该元素已经没用了) ，插入队列的时候去掉完全劣于 $i$ 的，然后对于折中的二分即可。(具体参见诗人小 $\rm{G}$ 的题解) 。 2. 分治计算答案。设 $slove(al,ar,vl,vr)$ 表示在原数组 $al$ 到 $ar$ 这段区间的最优决策点位于 $vl$ 到 $vr$ 区间。我们每一次找到 $al$ 到 $ar$ 的中间点，也就是 $mid$ ，然后在 $vl$ 到 $vr$ 寻找最优的决策点更新 $f_{mid}$ ( $\rm{DP}$ 数组)，设这个最优点为 $g$ 。因为满足决策单调性，$al$ 到 $mid-1$ 的所有点的最优决策点一定在 $vl$ 到 $g$ 之间，右边 $mid+1$ 到 $ar$ 的也同理，就这么分治下去即可。 实际运用中分治的效率不如三元组，但是代码却好写得多，很短，并且调试难度也大大降低，所以最终我选择了分治……分治的具体细节看代码。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=6e5+2;const int inf=1e9+9;int n;ll a[N];long double f1[N],f2[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;void solve_f1(int al,int ar,int vl,int vr) &#123; if(al&gt;ar) return; int mid=(al+ar)&gt;&gt;1,g=0; f1[mid]=a[mid]; for(int i=vl;i&lt;=min(vr,mid);++i) &#123; long double calc=a[i]+sqrt(double(mid-i)); if(calc&gt;f1[mid]) f1[mid]=calc,g=i; &#125; if(!g) g=mid;f1[mid]-=a[mid]; solve_f1(al,mid-1,vl,g),solve_f1(mid+1,ar,g,vr);&#125;void solve_f2(int al,int ar,int vl,int vr) &#123; if(al&gt;ar) return; int mid=(al+ar)&gt;&gt;1,g=0; f2[mid]=a[mid]; for(int i=vr;i&gt;=max(vl,mid);--i) &#123; long double calc=a[i]+sqrt(double(i-mid)); if(calc&gt;f2[mid]) f2[mid]=calc,g=i; &#125; if(!g) g=mid;f2[mid]-=a[mid]; solve_f2(al,mid-1,vl,g),solve_f2(mid+1,ar,g,vr);&#125;int main() &#123; IN(n); for(int i=1;i&lt;=n;++i) IN(a[i]); solve_f1(1,n,1,n),solve_f2(1,n,1,n); /*最终没有翻转序列，而是选择做两遍分治*/ for(int i=1;i&lt;=n;++i) printf("%lld\n",(ll)ceil(max(f1[i],f2[i]))); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>决策单调性</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2016]国王饮水记 斜率优化DP loj2087]]></title>
    <url>%2F2019%2F04%2F29%2F%5B%E9%A2%98%E8%A7%A3%5Dloj2087%2F</url>
    <content type="text"><![CDATA[可爱的题目传送门：戳我戳我·(╹▽╹)· 说实话这道题如果单看斜率优化 $\texttt{DP}$ ，但是如果没猜到那么多结论，你是怎么也想不到”斜率优化”是从哪里来的。那么我们开始猜结论吧…… 1. 初始水位小于 $h_1$ 的没有用。 这很显然。 2. 如果 $n\leq k$ ，那么只需要将所以大于 $h_1$ 的跟 $1$ 城市连就好了。 每次连接的城市数越少贡献越大，那么每个逐一连一次一定是最优方案。 3. 每次操作必然跟 $1$ 城市有关系。 不然没贡献。 4. 除了 $1$ 号城市，其他每个城市最多连一次。 因为连过一次的城市的水位已经和 $1$ 城市一样了，简单点说肯定就是废了。 5. 每次连的所有城市中最小的 $h_i$ 必然大于上一次链接的最大的 $h_i$ 。 这很显然，不然不满足最优方案。 6. 将所以城市按水位排序后，每次选择的必然是连续一段区间。 和上一个差不多。 7. 每次选择的区间必然和上一次的选择区间接触。 这很显然。 8. 每次选择的区间的长度必定单调不增。 满足最优，都说了每次连接的城市越少贡献越大。 那么显然就变成了一个区间问题了，我们需要将这个区间分成若干块。 设 $f_{i,j}$ 表示排序后前 $i$ 个城市联通了 $j$ 次后 $1$ 号城市的最大水位高度。那么转移直接枚举一个 $k$ ，在新的一次连接中连接了 $k+1$ 到 $i$ 这些城市。转移方程显然： f_{i,j}=\frac{f_{k,j-1}+(s_i-s_k)}{i-k+1}*注：$s_i$ 为前缀和。 上式的复杂度为 $O(n^2k)$ ，肯定爆炸。但是这个是可以斜率优化的： \frac{f_{k,j-1}+(s_i-s_k)}{i-k+1} =\frac{s_i-(s_k-f_{k,j-1})}{i-(k-1)}\Rightarrow \frac{Y(i)-Y(k)}{X(i)-X(k)}然后通过第 $8$ 条性质可以得知 $\texttt{DP}$ 是有决策单调性的，故复杂度为 $O(nk)$ 。因为恶心的高精度小数的运算还需要 $O(p)$ 的复杂度，所以最终总时间复杂度为 $O(nkp)$ 。 我们发现 $k$ 有 $10^9$ ，所以复杂度带 $k$ 的一定假掉了。 那么观察第 $2$ 条性质会发现，如果 $k$ 大于 $n$ 了直接将 $k$ 设为 $n$ 就好了。也就是说复杂度应该为 $O(n^2p)$ ，这样就是 $86$ 分，通过数据来看会发现这个倾向于大众分，一车厢的人都是这个分数。 那么如果想要 $\texttt{AC}$ 的话需要最后一条很迷的性质： 9. 因为 $h$ 各不同，选择的区间最多只有 $14$ 个区间长度大于 $1$ ，其他的区间均等于 $1$ 。 很迷，准确的说这样的区间是 $O(\log\frac{nh}{\min_i\{h_i-h_{i-1}\}})$ 个。 证明不会……但是这里写了证明(唯一的且很迷的证明)：哈哈我是传送门O(∩_∩)O 那么就丢代码了，实际上是需要高精小数的，这里先给出一个除去高精小数板子的版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=8e3+2;Decimal ans;int n,k,p,lim,h[N],s[N],pre[N][16],tot;int q[N],head,tail;double f[N][16];struct point&#123;double x,y;&#125;t[N];double slope(point a,point b) &#123;return (a.y-b.y)/(a.x-b.x);&#125;Decimal solve(int i,int j) &#123; if(!j) return h[1]; return (solve(pre[i][j],j-1)+s[i]-s[pre[i][j]])/(i-pre[i][j]+1);&#125;int main() &#123; scanf("%d%d%d%d",&amp;n,&amp;k,&amp;p,&amp;h[tot=1]); for(int i=2;i&lt;=n;++i) &#123; scanf("%d\n",&amp;h[i]); if(h[i]&gt;h[1]) h[++tot]=h[i]; &#125; n=tot;sort(&amp;h[1],&amp;h[n+1]); for(int i=1;i&lt;=n;++i) f[i][0]=h[1]; for(int i=1;i&lt;=n;++i) s[i]=s[i-1]+h[i]; k=min(k,n),lim=min(k,14); for(int j=1;j&lt;=lim;++j) &#123; q[head=tail=1]=1; for(int i=1;i&lt;=n;++i) t[i]=(point)&#123;i-1,s[i]-f[i][j-1]&#125;; for(int i=2;i&lt;=n;++i) &#123; point now=(point)&#123;i,s[i]&#125;; while(head&lt;tail&amp;&amp;slope(now,t[q[head]])&lt;slope(now,t[q[head+1]])) ++head; f[i][j]=(f[q[head]][j-1]+s[i]-s[q[head]])/(i-q[head]+1); pre[i][j]=q[head]; while(head&lt;tail&amp;&amp;slope(t[q[tail]],t[q[tail-1]])&gt;slope(t[q[tail]],t[i])) --tail; q[++tail]=i; &#125; &#125; int m=n-k+lim,pos; double mx=0; for(int i=0;i&lt;=lim;++i) if(f[m][i]&gt;mx) mx=f[m][i],pos=i; ans=solve(m,pos); for(int i=m+1;i&lt;=n;++i) ans=(ans+h[i])/2; cout&lt;&lt;ans.to_string(p&lt;&lt;1)&lt;&lt;endl; return 0;&#125; 那么高精度小数板子的下载链接就贴这了：$loj$ 的下载地址传送们(～￣▽￣)～]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>斜率优化</tag>
        <tag>题解</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 小谈斜率优化]]></title>
    <url>%2F2019%2F04%2F28%2F%5B%E7%AE%97%E6%B3%95%5D%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在此输入你的密码以便阅读全文 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>算法</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2015]亚瑟王 概率DP loj2112]]></title>
    <url>%2F2019%2F04%2F28%2F%5B%E9%A2%98%E8%A7%A3%5Dloj2112%2F</url>
    <content type="text"><![CDATA[发现 $loj$ 真的好用……比 $luogu$ 不知道清爽到哪里去了，更何况 $loj$ 的题目也更多，而且提供数据和代码，更加开放。估计以后都会在 $loj$ 上多逛逛。( $bzoj$ 是真的丑，除非是做 $bzoj$ 的原创题不然我不会上 $bzoj$ 的) 。 顺便贴一下题目传送门：$loj$的传送门就戳我啦(～￣▽￣)～ 概率 $\texttt{DP}$ ，设 $f_{i,j}$ 表示打了前 $i$ 张牌，还有 $j$ 轮没有打出牌的概率。我们枚举第 $i+1$ 张牌，分别讨论一下该牌打出与不打出的情况即可。 第一种情况：$j$ 轮中都没有打出第 $i+1$ 张牌，由于一轮中不打出第 $i+1$ 张牌的概率为 $1-p_i$ ，那么 $j$ 轮都不打出该牌的概率显然为 $(1-p_i)^j$ 。转移方程显然： f_{i+1,j}+=f_{i,j}\cdot (1-p_i)^j​因为 $f_{i+1,j}$ 可能从多方向转移过来，所以是 $+=$ 。 第二种情况：$j$ 轮中至少有一轮打出了第 $i+1$ 张牌，概率显然为 $1-(1-p_i)^j$ ，转移也就很显然了： f_{i+1,j-1}+=f_{i,j}\cdot （1-(1-p_i)^j）如果我们打出了第 $i+1$ 张牌，那么肯定是要计算贡献的，这个时候直接用这个概率算贡献就好了。 Code:12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=3e2+2;int T,n,r,d[N];double f[N][N],p[N],pw[N][N];int main() &#123; scanf("%d",&amp;T); while(T--) &#123; memset(f,0,sizeof(f)); scanf("%d%d",&amp;n,&amp;r); for(int i=1;i&lt;=n;++i) scanf("%lf%d",&amp;p[i],&amp;d[i]); for(int i=1;i&lt;=n;++i) &#123; pw[i][0]=1; for(int j=1;j&lt;=r;++j) pw[i][j]=pw[i][j-1]*(1-p[i]); &#125; f[0][r]=1; double ans=0; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;=r;++j) &#123; f[i+1][j]+=f[i][j]*pw[i+1][j]; if(j) &#123; double calc=f[i][j]*(1-pw[i+1][j]); f[i+1][j-1]+=calc,ans+=calc*d[i+1]; &#125; &#125; printf("%.10f\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [CEOI2017]Building Bridges 斜率优化DP loj2483]]></title>
    <url>%2F2019%2F04%2F27%2F%5B%E9%A2%98%E8%A7%A3%5Dloj2483%2F</url>
    <content type="text"><![CDATA[愉快的推式子吧(ﾉ≧∀≦)ﾉ！ 设 $f_i$ 表示前 $i$ 根柱子完工后的最小代价。枚举一个小于 $i$ 的 $j$ ，表示为从 $j$ 向 $i$ 连了一座桥，中间的柱子当然全部推掉，计算一下就好： f_i=\min\{f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\}*其中 $s$ 为 $w$ 的前缀和。 f_i=f_j+(s_{i-1}-s_j)+(h_i-h_j)^2\\\\f_i=f_j+s_{i-1}-s_j+h_i^2+h_j^2-2h_ih_j\\\\f_j+s_{i-1}-s_j+h_i^2+h_j^2=2h_ih_j+f_i于是最终式子变成了 $y=kx+b$ 的形式，斜率优化！ 但是……注意这个式子的 $k$ 不是单调递增的，并且 $x$ 也不是单调递增的！那么我们不能用朴素做法了，也不能用二分……难道用 $Splay$ ？(码量巨大) 。 不，用 $CDQ$ 分治。 对于一个 $i$ ，可能可以对 $i$ 做出贡献的只有所有小于 $i$ 的 $j$ 。为了保证 $x$ 单调我们先大力将原来的数组按照 $x$ 从小到大排个序，然后 $CDQ$ 的时候分左右两边，左边的所有元素在初始数组的位置都小于右边的左右元素，也就是说我们直接用左边元素对右边元素做出贡献。 同时这里也保证了左右两边的 $x$ 一定是单调上增的。 我们使用单调队列，扫一遍左边的元素，留下能做贡献的点(下凸壳上的点)，这时候左边的所有元素可以保证 $x$ 和斜率都是单调上增的。 右边呢？因为直线的斜率是 $2x$ ，而右边的 $x$ 也是单调上增的，所以我们可以愉快的做朴素的单调队列了。 $CDQ$ 分治部分的代码： 12345678910111213141516171819202122232425262728293031323334void CDQ(int l,int r) &#123; if(l==r) &#123;/*一个点的时候直接计算y值*/ a[l].y=f[a[l].id]-s[a[l].id]+S(a[l].x); return; &#125; int mid=(l+r)&gt;&gt;1; for(int i=l,c1=l,c2=mid+1;i&lt;=r;++i) if(a[i].id&lt;=mid) b[c1++]=a[i]; /*编号小的左边去*/ else b[c2++]=a[i]; /*编号大些的右边去*/ for(int i=l;i&lt;=r;++i) a[i]=b[i]; CDQ(l,mid); /*计算出左边所有元素的 f*/ int head=1,tail=0; static int q[N]; for(int i=l;i&lt;=mid;++i) &#123; /*处理出左边所有元素组成的下凸壳*/ while(head&lt;tail&amp;&amp;slope(q[tail-1],q[tail])&gt;slope(q[tail],i)) --tail; q[++tail]=i; &#125; for(int i=mid+1;i&lt;=r;++i) &#123; /*计算左边元素对右边元素产生的贡献*/ while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&lt;2*a[i].x) ++head; /*维护队列*/ int x=a[i].id,y=a[q[head]].id; f[x]=min(f[x],f[y]+s[x-1]-s[y]+S(a[i].x-a[q[head]].x)); /*可能计算多次所以要取min*/ &#125; CDQ(mid+1,r); for(int i=l,c1=l,c2=mid+1;i&lt;=r;++i) /*还原a数组至初始状态*/ if(c2&gt;r||(c1&lt;=mid&amp;&amp;a[c1].x&lt;a[c2].x)) b[i]=a[c1++]; else b[i]=a[c2++]; for(int i=l;i&lt;=r;++i) a[i]=b[i]; return;&#125;//main函数中sort(a+1,a+1+n,cmp),CDQ(1,n); /*排序后CDQ开始*/printf("%lld\n",f[n]); /*输出*/ 最后因为存在 $0$ ，在计算斜率的时候需要特判一下。还需要注意一下 $long\ long$ 的问题，记得将 $f$ 数组初始化。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e5+2;const ll inf=1e18+9;struct point &#123;int x,id;ll y;&#125;a[N],b[N];ll s[N],w[N],f[N];int n;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;ll S(ll x) &#123;return x*x;&#125;bool cmp(point x,point y) &#123;return x.x&lt;y.x;&#125;double slope(int i,int j) &#123; if(a[i].x==a[j].x) &#123; return a[i].y&lt;a[j].y?inf:-inf; &#125;return double(a[i].y-a[j].y)/double(a[i].x-a[j].x);&#125;void CDQ(int l,int r) &#123; if(l==r) &#123;a[l].y=f[a[l].id]-s[a[l].id]+S(a[l].x);return;&#125; int mid=(l+r)&gt;&gt;1; for(int i=l,c1=l,c2=mid+1;i&lt;=r;++i) if(a[i].id&lt;=mid) b[c1++]=a[i]; else b[c2++]=a[i]; for(int i=l;i&lt;=r;++i) a[i]=b[i]; CDQ(l,mid); int head=1,tail=0; static int q[N]; for(int i=l;i&lt;=mid;++i) &#123; while(head&lt;tail&amp;&amp;slope(q[tail-1],q[tail])&gt;slope(q[tail],i)) --tail; q[++tail]=i; &#125; for(int i=mid+1;i&lt;=r;++i) &#123; while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&lt;2*a[i].x) ++head; int x=a[i].id,y=a[q[head]].id; f[x]=min(f[x],f[y]+s[x-1]-s[y]+S(a[i].x-a[q[head]].x)); &#125; CDQ(mid+1,r); for(int i=l,c1=l,c2=mid+1;i&lt;=r;++i) if(c2&gt;r||(c1&lt;=mid&amp;&amp;a[c1].x&lt;a[c2].x)) b[i]=a[c1++]; else b[i]=a[c2++]; for(int i=l;i&lt;=r;++i) a[i]=b[i]; return;&#125;int main() &#123; IN(n); for(int i=1;i&lt;=n;++i) IN(a[i].x),a[i].id=i,f[i]=inf; f[1]=0; for(int i=1;i&lt;=n;++i) IN(w[i]),s[i]=s[i-1]+w[i]; sort(a+1,a+1+n,cmp),CDQ(1,n); printf("%lld\n",f[n]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>斜率优化</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2008]玩具装箱TOY 斜率优化DP luoguP3195]]></title>
    <url>%2F2019%2F04%2F24%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3195%2F</url>
    <content type="text"><![CDATA[差不多搞懂了斜率优化吧……说实话网上的文章都写得很迷，还好找到了一个不错的文章：转送门戳我(￣▽￣)~* 。(为什么突然发现这道题和诗人小G很像呢) 这个 $\texttt{DP}$ 方程谁都会设：设 $f_i$ 表示前 $i$ 个玩具的最小费用，转移显然如下： f_i=\min\limits_{j=1}^{i-1}\{f_j+(sum_i-sum_j+i-j-l)^2\}(其中 $sum$ 是前缀和)。这个复杂度是 $O(n^2)$ 的，过不去…… 继续推式子： f_i=\min\limits_{j=1}^{i-1}\{f_j+[(sum_i+i)-(sum_j+j)-l]^2\}设 $s_i=sum_i+i$ ，我们假设 $j$ 为最优决策，将 $\min$ 去掉。 f_i=f_j+(s_i-s_j-l)^2\\f_i=f_j+s_i^2+(s_j+l)^2-2\cdot s_i\cdot(s_j+l)\\f_j+s_i^2+(s_j+l)^2=2\cdot s_i\cdot(s_j+l)+f_i​于是上面的式子变成了 $y=kx+b$ 的形式，其中 $y=f_j+s_i^2+(s_j+l)^2$ ，$k=2\cdot s_i$ ，$x=s_j+l$ ，$b=f_i$ 。 然后将 $x,y$ 两个值作为点 $(x,y)$ 放到平面上即可，因为最终答案是取 $min$ ，所以我们需要维护的是下凸壳。有一点需要注意的是，我们算斜率的时候可以将每个点的常数项或者只和 $i$ 有关的项去掉，因为算斜率是相减的，减的时候这些项同样也没了。 上面的 $x$ 中的 $l$ 是常数项于是可以省略，$y$ 中的 $s_i^2$ 只和 $i$ 有关，于是也省略掉。 Code:1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#define S(x) ((x)*(x))using namespace std;const int N=1e5+2;int n,l,head,tail;long long f[N],s[N],q[N];double X(int i) &#123;return s[i];&#125;/*每个点的x坐标*/double Y(int i) &#123;return f[i]+S(s[i]+l);&#125;/*每个点的y坐标*/double slope(int i,int j) &#123;return (Y(j)-Y(i))/(X(j)-X(i));&#125;/*算斜率*/int main() &#123; scanf("%d%d",&amp;n,&amp;l); for(int i=1;i&lt;=n;++i) scanf("%lld",&amp;s[i]),s[i]+=s[i-1]; for(int i=1;i&lt;=n;++i) s[i]+=i; for(int i=1;i&lt;=n;++i) &#123; while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&lt;2*s[i]) ++head; f[i]=f[q[head]]+S(s[i]-s[q[head]]-l-1);/*转移*/ while(head&lt;tail&amp;&amp;slope(q[tail],i)&lt;slope(q[tail],q[tail-1])) --tail; q[++tail]=i; &#125; printf("%lld\n",f[n]); return 0;&#125; 下面来解释一些问题。 1.为什么要维护下凸壳因为我们的 $\texttt{DP}$ 方程是在取 $\min$ ，如果是 $\max$ 的话则维护上凸壳。而且维护下凸壳显然是让 $f_i$ 更小。 以上面为例，我们用 $y=kx+b​$ 的直线从下面网上扫，注意这条直线的斜率就是 $k​$ 。很显然如果我们从下往上这样扫越往上扫 $b​$ 越大(不明白的画画图)，但是我们的目的是使得 $b​$ 最小( $b​$ 就是 $f_i​$ ) 。下凸壳包含了最下面的所有点，显然不是下凸壳上的点一定不能成为最优的。 2.维护队列的过程是什么鬼操作首先第一个过程，也就是下面的代码： 1while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&lt;2*s[i]) ++head; 上面讲了我们需要使得 $b​$ 最小，那么最优的决策点在直线从下往上扫的过程中肯定是最先扫到的，因为那样可以保证 $f_i​$ 最小。假设最优的点为 $i​$ ，上一个点为 $j​$ ，下一个点为 $k​$ ，那么 $i​$ 一定保证 $j​$ 到 $i​$ 的斜率小于直线斜率并且 $i​$ 到 $k​$ 的斜率大于直线斜率。 然后我们会发现对于单调上增的需要更新的 $i​$ ，其直线的斜率 $k​$ 一定是单调上增的，因为前缀和是单调上增的。 所以对于斜率已经不满足要求的点直接踢出队就好了。 然后康康出队的过程。如果在纸上画画会发现，如果满足 slope(q[tail],i)&lt;slope(q[tail],q[tail-1]) ，那么说明 $q[tail]$ 已经不再下凸壳中了！没错吧？那么这个时候 $q[tail]$ 永远也不可能成为最优的转移点了，直接丢掉即可。 最后有一些斜率优化的套路总结(自己总结出来的)： $\texttt{DP}$ 方程取 $\min$ 就维护下凸壳，取 $\max$ 就维护上凸壳 $y=kx+b​$ 中的 $k​$ 一定要是常量或者是完全是 $i​$ 的量(例如 $s_i,2\cdot g_i^2​$ 等)，$b​$ 一定是你需要转移的对象(就是 $f_i​$ )，$x​$ 和 $y​$ 两个值一定要包含和 $j​$ 有关的值，要随 $j​$ 的变化而变化。 提炼出来的 $x,y$ 放到坐标系上之前记得去掉没用的值。 差不多就这些吧，也不知道是不是完全正确，至少这个套路还是过了几道题目的。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>斜率优化</tag>
        <tag>题解</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [APIO2010]特别行动队 斜率优化DP luoguP3628]]></title>
    <url>%2F2019%2F04%2F24%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3628%2F</url>
    <content type="text"><![CDATA[依旧是斜率优化的套路。 设 $f_i$ 表示前 $i$ 个士兵的最大贡献，转移显然是枚举一个 $j$ ，将 $j+1$ 到 $i$ 这些士兵组成特别行动队算贡献： f_i=\max\{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c\}​其中 $s_i$ 为战斗力的前缀和。这个方程是 $O(n^2)$ 的，需要优化。发现这个转移式貌似不满足单调队列优化的条件，于是将中间的式子拆开看看可不可以斜率优化。 f_i=\max\{f_j+a(s_i^2+s_j^2-2s_is_j)+b\cdot s_i-b\cdot s_j+c\}\\f_i=\max\{f_j+a\cdot s_i^2+a\cdot s_j^2-2a\cdot s_is_j)+b\cdot s_i-b\cdot s_j+c\}\\f_i=f_j+a\cdot s_i^2+a\cdot s_j^2-2a\cdot s_is_j+b\cdot s_i-b\cdot s_j+c\\f_j+a\cdot s_i^2+a\cdot s_j^2+b\cdot s_i-b\cdot s_j+c=2a\cdot s_i\cdot s_j +f_i​诶，是 $y=kx+b$ 的形式，而且满足斜率优化的条件诶。继续将 $x,y$ 找出来放到坐标系上( $x=s_j$,$y=f_j+a\cdot s_j^2-b\cdot s_j$) 。 因为是 $\max​$ ，所以用单调队列维护一下上凸壳然后转移即可，复杂度 $O(n)​$ 。 Code:1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#define S(x) ((x)*(x))using namespace std;const int N=1e6+2;int n,a,b,c,head,tail;long long s[N],f[N],q[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;double X(int i) &#123;return s[i];&#125;double Y(int i) &#123;return f[i]+1ll*S(s[i])*a-1ll*s[i]*b;&#125;double slope(int i,int j) &#123;return (Y(j)-Y(i))/(X(j)-X(i));&#125;inline void calc(int i,int j) &#123; f[i]=f[j]+1ll*S(s[i]-s[j])*a+1ll*(s[i]-s[j])*b+c;&#125;int main() &#123; IN(n),IN(a),IN(b),IN(c); for(int i=1;i&lt;=n;++i) IN(s[i]),s[i]+=s[i-1]; for(int i=1;i&lt;=n;++i) &#123; while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&gt;2*a*s[i]) ++head; calc(i,q[head]); while(head&lt;tail&amp;&amp;slope(q[tail],i)&gt;slope(q[tail],q[tail-1])) --tail; q[++tail]=i; &#125; printf("%lld\n",f[n]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>斜率优化</tag>
        <tag>题解</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SCOI2008]奖励关 状压DP luoguP2473]]></title>
    <url>%2F2019%2F04%2F23%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2473%2F</url>
    <content type="text"><![CDATA[发现数据范围很小，并且涉及到”集合”，很容易可以想到用状压 $\texttt{DP}$ 。 设 $f[i][j]$ 表示已经抛出了 $i$ 次宝物，获得的宝物集合为 $j$ 时的最优分值。那么转移的时候枚举每一个宝物，分两种情况即可——选当前宝物或者不选。注意选当前宝物的前提是必须满足前提，按照最优情况选取即可。注意最后将所有的宝物的贡献加上后还需要$/n$ ，因为题目要求的是”平均”。 Code:12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;double f[101][65540];int p[18],d[18],v[18],N,K;int main() &#123; for(int i=1;i&lt;=16;++i) p[i]=1&lt;&lt;(i-1); scanf("%d%d",&amp;K,&amp;N); for(int i=1;i&lt;=N;++i) &#123; int x;scanf("%d%d",&amp;v[i],&amp;x); while(x) &#123;d[i]|=p[x];scanf("%d",&amp;x);&#125; &#125; for(int i=K;i;--i) /*倒着枚举会好些*/ for(int j=0;j&lt;=p[N+1]-1;++j) &#123; /*上面两重循环枚举状态*/ for(int k=1;k&lt;=N;++k)/*枚举所有宝物并计算贡献*/ if((d[k]&amp;j)==d[k]) /*可以选取当前宝物*/ f[i][j]+=max(f[i+1][j],f[i+1][j|p[k]]+v[k]); /*按照最优选取*/ else f[i][j]+=f[i+1][j]; /*不能选取直接转移*/ f[i][j]/=N;/*所谓"平均"*/ &#125; printf("%.6f\n",f[1][0]);/*最终答案*/ return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2011]Noi嘉年华 决策单调性优化DP luoguP1973]]></title>
    <url>%2F2019%2F04%2F22%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1973%2F</url>
    <content type="text"><![CDATA[这道题一共有两问，第一问瞎搞 $\texttt{DP}$ ，第二问如果直接 $\texttt{DP}$ 的话复杂度是 $O(n^4)$ 的过不去，这个时候需要用到决策单调性优化复杂度就可以降低至 $O(n^3)$ ，这样就过了。我们先来讨论一下第一问的做法。 时间的范围太大了，我们需要离散化一下。离散化后时间就控制在 $0$ 到 $2n$ 的范围内了。 首先可以发现最终的答案一定就是一段一段时间，每一段时间内的活动都是在同一个会场举行。我们可以预处理一个 $tot_{l,r}$ 表示完全在时间 $l,r$ 之内的活动有多少个。计算直接暴力，预处理的复杂度为 $O(n^3)$ 。 然后设一个 $pre_{i,j}​$ 表示 $1​$ 到 $i​$ 的时间一个会场的活动数为 $j​$ 时另一个会场的最大活动数。那么转移的话我们枚举一个时间 $k​$ ，然后考虑 $k​$ 到 $i​$ 这段时间中的所有活动分配给哪个会场即可。可以得到转移方程： pre_{i,j}=\max\limits_{k=1}^{i}\{pre_{k,j}+tot_{k,i},pre_{k,j-tot_{k,i}}\}​这里我们 $pre$ 方程的定义中”一个会场”就是一号会场，”另一个会场”就是二号会场$。pre_{k,j}+tot_{k,i}$ 就是将 $k$ 到 $i$ 这段时间中所有活动都分配给了二号会场，$pre_{k,j-tot_{k,i}}$ 很显然就是分配给了一号会场。计算时枚举 $i,j,k$ ，复杂度是 $O(n^3)$ 。(其实准确的复杂度带个常数，因为 $i$ 枚举的是时间，而时间最大是 $2n$ 的) 。 我们设离散化后时间总长为 $m$ ，那么答案显然为 $\max\limits_{i=1}^m\{\min(pre_{m,i},i)\}$ 。接下来我们解决第二问。 我们的 $tot_{l,r}$ 统计的就是完全在时间 $l,r$ 的区间有多少个。那么对于第 $i$ 个活动，设该活动的起始时间与终止时间分别为 $s_i,t_i$ ，那么我们再考虑一对 $x,y \ \ (x\leq s_i,t_i\leq y)$ ，那么如果我们将答案计算上 $tot_{x,y}$ ，那么也就选择了第 $i$ 个活动了。 我们设 $f_{i,j}$ 表示一号会场强制选择 $i$ 到 $j$ 时间中的所有活动时的最优答案。(注意这里的最优答案就是两个会场中活动少的一方的最大值，我们只是考虑在一号会场强制选择 $i$ 到 $j​$ 中的所有活动的情况下考虑最优的全局答案) 。 继续看向一号会场，假设在 $i$ 前面的时间中一号会场已经合法举办了 $x$ 场活动，在 $j$ 后面的时间中也合法举办了 $y$ 场活动。那么我们枚举 $i,j,x,y$ 也可以得到二号会场的活动数：$i$ 前面的时间种有 $pre_{i,x}$ 场活动，$j$ 后面的时间中有……诶这里用 $pre$ 貌似不是很好表示诶，于是我们新定义一个 $suf$ ，$suf_{i,j}$ 表示 $i$ 到 $m$ 的时间一个会场的活动数为 $j$ 时另一个会场的最大活动数，$suf$ 的状态转移方程和 $pre$ 的同理。 枚举 $i,j,x,y$ 后就可以得到两个会场的活动个数，那么就可以直接算答案了： f_{i,j}=\max\limits_{x=1}^{m}\max\limits_{y=1}^{m}\{\min(x+tot_{i,j}+y,pre_{i,x}+suf_{j,y})\}​但是这样子的复杂度是 $O(n^4)​$ 的，过不了。 不过，我们会发现，对于单调递增的 $x$ ，对应的最优的 $y$ 一定是单调递减的 。为什么呢？首先对于一个单调递增的 $i$ ，$pre_{?_i},suf_{?_i}$ 一定是单调递减的( $?$ 为任意数) 。那么如果对于单调递增的 $x$ ，$pre_{i,x}$ 一定是单调递减的，这个时候如果 $y$ 单调递增也就意味着 $suf_{j,y}$ 会单调递减，那么 $x+tot_{i,j}+y$ 和 $pre_{i,x}+suf_{j,y}$ 将会越拉越大，对于答案显然是不利的。反过来，如果 $y$ 是单调递减的，那么就会相对比较均衡。(感性理解理解……) 那么我们就不需要枚举 $y$ 了，只需要扫一扫就好了，最终计算 $f$ 的时间复杂度为 $O(n^3)$ 。 最终统计答案的时候，对于一个活动 $i$ ，我们的答案显然为 $\max\limits_{x=1}^{s_i}\max\limits_{y=t_i}^{m}f_{x,y}$ 。必须满足 $x\leq s_i,t_i\leq y$ ，因为这样就会满足一定会选择第 $i$ 个活动。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;#define F(i,j,k) for((i)=(j);(i)&lt;=(k);++i)#define R(i,j,k) for((i)=(j);(i)&gt;=(k);--i)const int N=4e2+9;const int inf=1e9+9;int n,m,i,j,k,l,r,s[N],t[N],b[N];int tot[N][N],pre[N][N],suf[N][N],f[N][N];inline int IN() &#123; char ch;bool flag=0;int x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;return x;&#125;inline int calc(int x,int y) &#123;return min(x+tot[l][r]+y,pre[l][x]+suf[r][y]);&#125; int main() &#123; n=IN(); F(i,1,n) b[++m]=s[i]=IN(),b[++m]=t[i]=IN()+s[i]; sort(b+1,b+1+m), m=unique(b+1,b+1+m)-b-1;/*离散化去重*/ F(i,1,n) &#123; s[i]=lower_bound(b+1,b+1+m,s[i])-b; t[i]=lower_bound(b+1,b+1+m,t[i])-b; F(l,1,s[i]) R(r,m,t[i]) ++tot[l][r];/*计算出tot*/ &#125; F(i,1,m) F(j,1,n) pre[i][j]=suf[i][j]=-inf;/*初始化*/ /*----------计算出pre和suf----------*/ F(i,1,m) F(j,0,tot[1][i]) F(k,1,i) &#123; pre[i][j]=max(pre[i][j],pre[k][j]+tot[k][i]); if(j&gt;=tot[k][i]) pre[i][j]=max(pre[i][j],pre[k][j-tot[k][i]]); &#125; R(i,m,1) F(j,0,tot[i][m]) F(k,i,m) &#123; suf[i][j]=max(suf[i][j],suf[k][j]+tot[i][k]); if(j&gt;=tot[i][k]) suf[i][j]=max(suf[i][j],suf[k][j-tot[i][k]]); &#125; /*计算f*/ F(l,1,m) F(r,l+1,m) for(int y=n,x=0;x&lt;=n;++x) &#123;/*y当做指针扫一遍*/ int old_calc=calc(x,y),new_calc; while(y&amp;&amp;old_calc&lt;=(new_calc=calc(x,y-1))) --y,old_calc=new_calc; f[l][r]=max(f[l][r],calc(x,y));/*转移*/ &#125; /*输出答案*/ int ans=0; F(i,1,n) ans=max(ans,min(pre[m][i],i)); printf("%d\n",ans);/*第一问*/ F(i,1,n) &#123; ans=0; F(l,1,s[i]) R(r,m,t[i]) ans=max(ans,f[l][r]); printf("%d\n",ans);/*第二问*/ &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【模板】动态DP LCT+DP+矩阵 luoguP4751]]></title>
    <url>%2F2019%2F04%2F19%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4751%2F</url>
    <content type="text"><![CDATA[看懂了后发现 $\texttt{DDP}$ 其实不难呢…… 其实主要思想就是将 $\texttt{DP}$ 转移式搞到矩阵上，然后如果是树形 $\texttt{DP}$ 的话就可以直接上树剖或者是 $LCT$ 进行维护，当然还可以用全局平衡二叉树(不费) 。如果只是线性的话可以直接用线段树等数据结构进行维护了。 注意这道模板树剖的复杂度是 $O(nlog^2n)$ ，而 $LCT$ 的复杂度为 $O(nlogn)$ ，于是窝选择了 $LCT$ ，跑的还挺快。 开始分析题目，如果没有”动态”限制的话就是一个裸的”没有上司的舞会”，解法显然是设 $f[u][0/1]​$ 表示 $u​$ 不选/选 的时候其子树的最大价值，转移显然为： f[u][0]=\sum \max(f[v][0],f[v][1])\\f[u][1]=val[u]+\sum f[v][0]对于树中的一个节点 $u$ 的所有儿子中有个重儿子，其他的儿子就是轻儿子，我们将重儿子和轻儿子的贡献分开算。设一个 $g[u][0/1]$ ，其值为： g[u][0]=\sum\max(f[v][0],f[v][1])\\g[u][1]=val[u]+\sum f[v][0]注意上式中的 $v$ 只的是轻儿子，然后 $f$ 的转移就变成了以下形式( $x$ 为重儿子)： f[u][0]=\max(f[x][0],f[x][1])+g[u][0]\\f[u][1]=g[u][1]+f[x][0]其实这里的 $g$ 很好维护，我们在 $Access$ 的时候只要计算儿子变化时的贡献就好了。 接着我们构造出转移矩阵： \begin{bmatrix}g[u][0] & g[u][0]\\g[u][1] & -inf\end{bmatrix}\cdot\begin{bmatrix}f[x][0] \\f[x][1]\end{bmatrix}=\begin{bmatrix}f[u][0]\\f[u][1]\end{bmatrix}这样子就可以直接更新了，对于每个节点我们只需要维护两个矩阵即可，一个就是上面乘法中的 $g$ 矩阵，一个就是上面乘法中的 $f$ 矩阵。 需要注意的是这是广义矩阵乘法，也就是说这个矩阵乘法的运算规则为： c[i][j]=max(c[i][j],a[i][k]+b[k][j])很像 $floyd$ ，可以直接算了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;struct matrix &#123;int c[2][2];matrix()&#123;c[0][0]=c[0][1]=c[1][0]=c[1][1]=-inf;&#125;&#125;;matrix operator * (matrix&amp;a,matrix&amp;b) &#123; matrix ret; for(int i=0;i&lt;2;++i)for(int j=0;j&lt;2;++j)for(int k=0;k&lt;2;++k) ret.c[i][j]=max(ret.c[i][j],a.c[i][k]+b.c[k][j]); return ret;&#125;int v[N],dp[N][2],head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;void add(int u,int v) &#123;nxt[++cnt]=head[u],to[cnt]=v,head[u]=cnt;&#125;struct link_cut_tree &#123; matrix f[N],g[N]; int ch[N][2],fa[N]; inline bool isroot(int x) &#123;return !((ch[fa[x]][0]==x)||(ch[fa[x]][1]==x));&#125; inline void pushup(int x) &#123; f[x]=g[x]; if(ch[x][0]) f[x]=f[ch[x][0]]*f[x];if(ch[x][1]) f[x]=f[x]*f[ch[x][1]]; &#125; inline void rotate(int x) &#123; int y=fa[x],z=fa[y],k=ch[y][1]==x,v=ch[x][!k]; if(!isroot(y)) ch[z][ch[z][1]==y]=x;ch[x][!k]=y,ch[y][k]=v; if(v) fa[v]=y;fa[y]=x,fa[x]=z;pushup(y); &#125; inline void Splay(int x) &#123; while(!isroot(x)) &#123; if(!isroot(fa[x])) rotate((ch[fa[x]][0]==x)^(ch[fa[fa[x]]][0]==fa[x])?x:fa[x]); rotate(x); &#125;pushup(x);return; &#125; inline void Access(int x) &#123; for(int y=0;x;x=fa[y=x]) &#123; Splay(x); if(ch[x][1]) &#123; g[x].c[0][0]+=max(f[ch[x][1]].c[0][0],f[ch[x][1]].c[1][0]); g[x].c[1][0]+=f[ch[x][1]].c[0][0]; &#125; if(y) &#123; g[x].c[0][0]-=max(f[y].c[0][0],f[y].c[1][0]); g[x].c[1][0]-=f[y].c[0][0]; &#125; g[x].c[0][1]=g[x].c[0][0]; ch[x][1]=y,pushup(x); &#125;return; &#125; inline void change(int x,int y) &#123; Access(x),Splay(x),g[x].c[1][0]-=v[x]-y; pushup(x),v[x]=y;return; &#125; inline void build(int u) &#123; dp[u][1]=v[u]; for(int i=head[u];i;i=nxt[i]) &#123; int v=to[i];if(v!=fa[u]) &#123; fa[v]=u,build(v); dp[u][0]+=max(dp[v][0],dp[v][1]); dp[u][1]+=dp[v][0]; &#125; &#125; g[u].c[0][0]=g[u].c[0][1]=dp[u][0]; g[u].c[1][0]=dp[u][1];f[u]=g[u]; &#125;&#125;T;int main() &#123; int n,m;IN(n),IN(m); for(int i=1;i&lt;=n;++i) IN(v[i]); for(int i=1,u,v;i&lt;n;++i)IN(u),IN(v),add(u,v),add(v,u); T.build(1); while(m--) &#123; int x,y;IN(x),IN(y); T.change(x,y),T.Splay(1); printf("%d\n",max(T.f[1].c[0][0],T.f[1].c[1][0])); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>LCT</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [十二省联考2019]异或粽子 可持久化Trie树 luoguP5283]]></title>
    <url>%2F2019%2F04%2F19%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP5283%2F</url>
    <content type="text"><![CDATA[要是我不是 $\texttt{HN}​$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响…… [十二省联考2019]异或粽子，可持久化 $trie​$ 树的板子题，比最大异或和还要板子些。相信 $60​$ 分入门者都会做，那么 $100​$ 分的话我们上可持久化 $trie​$ 树维护前缀异或和，嗯没错就像主席树那样。然后对于每个节点的可持久化 $trie​$ 树我们将其当成区间右端点，然后在此位置上的 $trie​$ 树中贪心寻找左端点即可。 寻找前 $K$ 大区间的具体操作如下： 12345678910for(ll i=1;i&lt;=n;++i) q.push(MKP(T.query(T.root[i],sum[i],qrank[i]=1),i));/*对于每一个右端点，找一个第一大(最优)的左端点放入优先队列*/ll ans=0;while(k--) &#123; ll i=q.top().second;/*取出当前最优元素*/ ans+=q.top().first;q.pop(); if(qrank[i]!=i) q.push(MKP(T.query(T.root[i],sum[i],++qrank[i]),i)); /*更新队列元素*/&#125; 复杂度大约是 $O(nlogn)​$ 级别。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;#define MKP make_pairconst ll N=5e5+2;const ll logN=33;const ll inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;ll n,k,sum[N],qrank[N];priority_queue&lt;pair&lt;ll,ll&gt; &gt; q;struct Trie &#123; ll ch[N*logN][2],sum[N*logN],root[N],tot; ll newnode(ll x) &#123; ++tot,ch[tot][0]=ch[x][0],ch[tot][1]=ch[x][1]; sum[tot]=sum[x];return tot; &#125; void Insert(ll&amp;rt,ll val) &#123; rt=newnode(rt),++sum[rt]; ll now=rt; for(ll i=31;~i;--i) &#123; bool son=(val&gt;&gt;i)&amp;1; ch[now][son]=newnode(ch[now][son]); now=ch[now][son],++sum[now]; &#125;return; &#125; ll query(ll now,ll val,ll k) &#123; ll ans=0; for(ll i=31;~i;--i) &#123; bool son=!((val&gt;&gt;i)&amp;1); if(k&lt;=sum[ch[now][son]]) now=ch[now][son],ans|=(1u&lt;&lt;i); else k-=sum[ch[now][son]],now=ch[now][!son]; &#125;return ans; &#125;&#125;T;int main()&#123; IN(n),IN(k); for(ll i=1,x;i&lt;=n;++i) IN(x),sum[i]=sum[i-1]^x; for(ll i=0;i&lt;=n;++i) &#123; if(i) T.root[i]=T.root[i-1]; T.Insert(T.root[i],sum[i]); &#125; for(ll i=1;i&lt;=n;++i) q.push(MKP(T.query(T.root[i],sum[i],qrank[i]=1),i)); ll ans=0; while(k--) &#123; ll i=q.top().second; ans+=q.top().first;q.pop(); if(qrank[i]!=i) q.push(MKP(T.query(T.root[i],sum[i],++qrank[i]),i)); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>可持久化Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [十二省联考2019]春节十二响 堆+启发式合并 luoguP5290]]></title>
    <url>%2F2019%2F04%2F19%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP5290%2F</url>
    <content type="text"><![CDATA[要是我不是 $\texttt{HN}$ 的该多好，今年十二省联考两道傻逼题，一道异或粽子，一道十二响…… [十二省联考2019]春节十二响，启发式合并裸题。对于树中的一个节点 $u$ ，从其子树中选择一段的方式显然只能是从 $u$ 的所有子树中各选出一个节点。于是我们每一个节点开一个堆，存的就是其子树中(包括自己)的所有段的内存。 然后从下往上启发式合并即可，复杂度大约是 $O(nlogn)$ 。 启发式合并的具体代码实现如下： 12345678910111213141516void merge(int x, int y) &#123; if(q[x].size()&lt;q[y].size()) swap(q[x],q[y]); while(!q[y].empty()) &#123; hep.push_back(max(q[x].top(),q[y].top())); q[x].pop(),q[y].pop(); /*贪心选取*/ &#125; while(hep.size()) q[x].push(hep.back()),hep.pop_back(); /*更新节点*/&#125;void solve(int x) &#123; for(int i=0,sz=G[x].size();i&lt;sz;++i) solve(G[x][i]),merge(x,G[x][i]);/*将当前子树与之前枚举过的子树合并*/ q[x].push(s[x]);&#125; 最后的总代码长度不超过 $40$ 行。 Code:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=2e5+7;int n,f,s[N];vector&lt;int&gt; hep,G[N];priority_queue&lt;int&gt; q[N];void merge(int x, int y) &#123; if(q[x].size()&lt;q[y].size()) swap(q[x],q[y]); while(!q[y].empty()) &#123; hep.push_back(max(q[x].top(),q[y].top())); q[x].pop(),q[y].pop(); &#125; while(hep.size()) q[x].push(hep.back()),hep.pop_back();&#125;void solve(int x) &#123; for(int i=0,sz=G[x].size();i&lt;sz;++i) solve(G[x][i]),merge(x,G[x][i]); q[x].push(s[x]);&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;s[i]); for(int i=2;i&lt;=n;++i) scanf("%d",&amp;f),G[f].push_back(i); solve(1); long long ans=0; while(!q[1].empty()) ans+=q[1].top(),q[1].pop(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>堆</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[HNOI2019]白兔之舞 单位根反演+MTT luoguP5293]]></title>
    <url>%2F2019%2F04%2F17%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP5293%2F</url>
    <content type="text"><![CDATA[单位根反演不会啊怎么搞 $FFT$ 吧，还是了解了单位根反演后才可以搞的好吧……居然有人吐槽我说我学了 $FFT​$ 但是不会运用？！，嘤嘤嘤打击有些大…… 实际上所谓的单位根反演就是这个东西： \frac{1}{n}\sum_{i=0}^{n-1}(\omega_n^d)^i=[n|d] 回到题目，我们先考虑正解的简化版—— $n=1$ 的版本，我们先定义 $W=w[1][1]$ 。 现在对于每一个 $t$ 的答案显然为 $\sum_{i=0}^{L}[i\% k=t] W^i (^L_i)$ 这个式子显然等于 $\sum_{i=0}^{L}[k|(i-t)] w^i (^L_i)$ 。会发现 $[k|(i-t)]$ 和上面单位根反演的 $[n|d]$ 一样，于是我们尝试将单位根反演的式子带进去。 =\sum_{i=0}^{L}\frac{1}{k}\sum_{j=0}^{k-1}(\omega_k^{i-t})^j W^i \binom{L}{i}\\\\ =\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \omega_k^{ij} W^i \binom{L}{i}\\\\ =\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \binom{L}{i}(\omega_k^{j} W)^i\\\\ =\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^{L} \binom{L}{i}(\omega_k^{j} W)^i 1^{n-i}\\\\ =\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}(\omega_k^{j} W+1)^L后面的 $(\omega_k^{j} W+1)^L$ 显然可以预处理，记为 $num_j$ 。 然后发现 $-tj=\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}$ =\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{\binom{t}{2}+\binom{j}{2}-\binom{t+j}{2}}num_j\\\\ =\frac{1}{k}\omega_k^{\binom{t}{2}}\sum_{j=0}^{k-1}num_j\omega_k^{\binom{j}{2}}\cdot\omega_k^{-\binom{t+j}{2}}后面的式子可以用 $FFT$ 加速，但是值域太大这里需要用到 $MTT$ 。现在就有 $40$ 分了，接下来考虑 $n&gt;1$ 的情况。 我们建矩阵，然后会发现 $n&gt;1$ 仅会对 $num_j$ 的计算方式有变化。 我们定义一个 $begin$ 矩阵，该矩阵只有 $(0,x)$ 位置上有值且值为 $1$ ，也就是说这是白兔的起点。那么最后我们需要留下来的也就是矩阵的 $(0,y)$ ，因为只有在第二维为 $y$ 是才会计入答案。 嗯，差不多可以这样写： 12345begin.c[0][x]=1;for(int i=0;i&lt;k;++i) num[i]=(begin*pow(w*num[i]+I,n)).c[0][y]%MOD;/*w就是上文中的W，不过这里是矩阵*//*I是矩阵中的单位'1'*/ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=65536;const double PI=acos(-1); int m,k,n,x,y,MOD,G,num[N],A[N&lt;&lt;2],B[N&lt;&lt;2];namespace OI &#123; #define F(x,i,j) for((x)=(i);(x)&lt;=(j);++(x)) inline ll IN() &#123; char ch;bool flag=0;ll x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;return x; &#125; struct matrix &#123;int c[3][3];matrix()&#123;memset(c,0,sizeof(c));&#125;&#125;; matrix operator + (const matrix&amp;a,const matrix&amp;b) &#123; matrix ans;int i,j;F(i,0,2)F(j,0,2) &#123; ans.c[i][j]=a.c[i][j]+b.c[i][j]; if(ans.c[i][j]&gt;=MOD) ans.c[i][j]-=MOD; &#125;return ans; &#125; matrix operator * (const matrix&amp;a,const matrix&amp;b) &#123; matrix ans;int i,j,k;F(i,0,2)F(j,0,2)F(k,0,2) ans.c[i][k]=(ans.c[i][k]+1ll*a.c[i][j]*b.c[j][k])%MOD; return ans; &#125; matrix operator * (const matrix&amp;a,const int&amp;b) &#123; matrix ans;int i,j;F(i,0,2)F(j,0,2)ans.c[i][j]=1ll*a.c[i][j]*b%MOD; return ans; &#125; struct complex&#123;complex(long double a=0,long double b=0)&#123;x=a,y=b;&#125;long double x,y;&#125;; complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125; complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125; complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125; matrix I; inline int pow(int x,int y) &#123; int res=1;for(;y;y&gt;&gt;=1,x=1ll*x*x%MOD) if(y&amp;1) res=1ll*res*x%MOD; return res%MOD; &#125; inline matrix pow(matrix x,int y) &#123; matrix res=I;for(;y;y&gt;&gt;=1,x=x*x) if(y&amp;1) res=res*x; return res; &#125;&#125;using namespace OI;namespace MTT &#123; #define BLOCK 32768 int limit=1,cnt=0,filp[N&lt;&lt;2],Ans[N&lt;&lt;2]; complex A1[N&lt;&lt;2],B1[N&lt;&lt;2],A2[N&lt;&lt;2],B2[N&lt;&lt;2],X[N&lt;&lt;2],omg[N&lt;&lt;2]; inline void fft(complex *f,short inv)&#123; for(int i=0;i&lt;limit;++i)if(i&lt;filp[i])std::swap(f[i],f[filp[i]]); for(int p=1;p&lt;limit;p&lt;&lt;=1) for(complex *a=f;a!=f+limit;a+=(p&lt;&lt;1)) for(int l=0;l&lt;p;++l)&#123; complex t=a[l+p]*omg[limit/(p&lt;&lt;1)*l]; a[l+p]=a[l]-t,a[l]=a[l]+t; &#125; &#125; inline void mtt(int *A,int *B)&#123; while(limit&lt;(k*3+5)) limit&lt;&lt;=1,++cnt; for(int i=0;i&lt;limit;++i) filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(cnt-1)); for(int i=0;i&lt;limit;++i) A1[i].x=A[i]&amp;(BLOCK-1),A2[i].x=A[i]&gt;&gt;15; for(int i=0;i&lt;limit;++i) B1[i].x=B[i]&amp;(BLOCK-1),B2[i].x=B[i]&gt;&gt;15; for(int i=0;i&lt;limit;++i) omg[i]=(complex)&#123;cos(i*PI*2/limit),sin(i*PI*2/limit)&#125;; fft(A1,1),fft(B1,1);fft(A2,1),fft(B2,1); for(int i=0;i&lt;limit;++i)&#123; complex a1=A1[i],a2=A2[i],b1=B1[i],b2=B2[i]; A1[i]=a1*b1,A2[i]=a2*b2,B1[i]=a1*b2,B2[i]=a2*b1; &#125; for(int i=0;i&lt;limit;++i) omg[i]=(complex)&#123;cos(i*PI*2/limit),-sin(i*PI*2/limit)&#125;; fft(A1,-1),fft(B1,-1);fft(A2,-1),fft(B2,-1); for(int i=0;i&lt;limit;++i) A1[i].x/=limit,A2[i].x/=limit,B1[i].x/=limit,B2[i].x/=limit; for(int i=0;i&lt;limit;++i) Ans[i]=((ll)(A1[i].x+0.5)%MOD+1073741824ll*((ll)(A2[i].x+0.5)%MOD)%MOD+ 32768ll*((ll)(B1[i].x+0.5)%MOD)%MOD+32768ll*((ll)(B2[i].x+0.5)%MOD)%MOD)%MOD; &#125;&#125;using namespace MTT;int divisor[105],tot;inline int get_G() &#123;/*获取原根*/ for(int i=2,S=MOD-1;i&lt;=S;++i) if(S%i==0) &#123;divisor[++tot]=i;while(!(S%i)) S/=i;&#125; for(int g=2;;++g) &#123; bool ok=true; for(int j=1;j&lt;=tot;++j) if(pow(g,(MOD-1)/divisor[j])==1) &#123;ok=false;break;&#125; if(ok) return g; &#125;&#125;matrix w,s;int main() &#123; I.c[0][0]=I.c[1][1]=I.c[2][2]=1; m=IN(),k=IN(),n=IN(),x=IN(),y=IN(),MOD=IN();--x,--y; /*num其实就是上文中的单位根，这里预处理一下计算方便些*/ num[0]=1,num[1]=pow(G=get_G(),(MOD-1)/k); for(int i=2;i&lt;k;++i) num[i]=1ll*num[1]*num[i-1]%MOD; for(int i=0;i&lt;m;++i) for(int j=0;j&lt;m;++j) w.c[i][j]=IN(); for(int i=0;i&lt;(k&lt;&lt;1|1);++i) A[i]=num[(k-1ll*i*(i-1)/2%k)%k]; s.c[0][x]=1; for(int i=0;i&lt;k;++i) B[i]=1ll*num[1ll*i*(i-1)/2%k]*(s*pow(w*num[i]+I,n)).c[0][y]%MOD; /*计算后面两个多项式的值*/ reverse(B,B+k+1),mtt(A,B); int invk=pow(k,MOD-2); for(int i=0;i&lt;k;++i) printf("%lld\n",1ll*Ans[i+k]*invk%MOD*num[1ll*i*(i-1)/2%k]%MOD); /*计算答案*/ return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>FFT</tag>
        <tag>单位根反演</tag>
        <tag>MTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2019]校园旅行 生成树+DP luoguP5292]]></title>
    <url>%2F2019%2F04%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP5292%2F</url>
    <content type="text"><![CDATA[$myy$ 出的神题……貌似正解并不难但是没有人切…… $30$ 分可以用 $DP$ ，设 $f[i][j]$ 表示 $i$ 到 $j$ 是否有一条满足条件的路径。对于有一条满足条件的路径的 $i,j$ ，我们枚举连接 $i$ 的点和连接 $j$ 的点，如果这两个点的标记相同，那么既然 $i,j​$ 合法，这两个点也一定合法。 不过这样的复杂度是 $O(m^2)$ 的，所以只能过 $30$ 分。 然后考虑优化，我们发现所有的边也就只有三种： 该边连接的两个点的标记相同 两个点的标记都为 $1$ 两个点的标记都为 $0​$ 改边连接的两个点的标记不同 然后我们开 $3$ 个图，对于每一条读入进来的边，如果属于第一种就插入到第一个图中，其他同理。 然后会发现这三个图都是有若干个连通块组成的，可以知道，如果我们留下来的仅是该连通块的生成树也不会对答案产生影响，但是边数却大大减少！ 但是直接对每个连通块求生成树是不对的，因为生成树上任意两个点之间的路径经过的边的条数的奇偶是确定的，并且只有二分图满足该条件，不过我们无法保证连通块是二分图，也就是说，连通块中的任意两个点之间的路径经过的边的条数的奇偶是不确定的。 那么我们现在需要做的就是，如何使得不是二分图的连通块所求出的生成树可以满足——任意两个点之间的路径经过的边的条数的奇偶是不确定的。 仔细想想后发现并不难，我们只需要在生成树上加上一个奇环就好了，当然也等价于在生成树上的某一个点上加个自环。 这就很好办了，现在我们的边数已经大大减少了，这个时候再跑原先的 $30$ 分算法就可以过了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define MKP make_pairconst int N=5e3+7;const int M=5e5+7;int n,m,q,s[N],vis[N],f[N][N];int flag,sta[N],top;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;struct Graph &#123; int head[N],nxt[M&lt;&lt;1],to[M&lt;&lt;1],from[N],cnt; void ins(int u,int v) &#123; ++cnt,nxt[cnt]=head[u],to[cnt]=v,head[u]=cnt; ++cnt,nxt[cnt]=head[v],to[cnt]=u,head[v]=cnt; &#125; void check(int u,int col) &#123; vis[u]=col,sta[++top]=u; for(int i=head[u];i;i=nxt[i]) if(!vis[to[i]]) from[to[i]]=u,check(to[i],3-col); else flag|=(vis[to[i]]!=3-col); &#125; void solve() &#123; queue&lt;pair&lt;int,int&gt; &gt; q; while(!q.empty()) q.pop(); for(int i=1;i&lt;=n;++i) f[i][i]=1,q.push(MKP(i,i)); for(int i=1;i&lt;=n;++i) for(int j=head[i];j;j=nxt[j]) if(s[i]==s[to[j]]) f[i][to[j]]=1,q.push(MKP(i,to[j])); while(!q.empty()) &#123; int x=q.front().first,y=q.front().second,u,v; q.pop(); for(int i=head[x];i;i=nxt[i]) for(int j=head[y];j;j=nxt[j]) if(!f[u=to[i]][v=to[j]]&amp;&amp;s[u]==s[v]) f[u][v]=f[v][u]=1,q.push(MKP(u,v)); &#125;return; &#125;&#125;G[3],t;char str[N];int main() &#123; IN(n),IN(m),IN(q); scanf("%s",str); for(int i=0;i&lt;n;++i) s[i+1]=str[i]-'0'; for(int i=1;i&lt;=m;++i) &#123; int x,y;IN(x),IN(y); if(s[x]==s[y]) &#123; if(s[x]) G[0].ins(x,y); else G[1].ins(x,y); &#125; else G[2].ins(x,y); &#125; for(int k=0;k&lt;=2;++k) &#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;++i) if(!vis[i]) &#123; flag=top=0,G[k].check(i,1); while(top) &#123; int x=sta[top]; if(G[k].from[x]) t.ins(G[k].from[x],x); --top; &#125;if(flag) t.ins(i,i); &#125; &#125; t.solve(); for(int i=1,x,y;i&lt;=q;++i) IN(x),IN(y),printf(f[x][y]?"YES\n":"NO\n"); return 0;&#125; 额……其实这份代码在 $luogu$ 上会被卡成 $70$ ，不过那是在没开 $O2$ 的情况下的，开了 $O2$ 顿时飞起！(幸好这题在考场上就是开 $O2$ 的)。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2012]魔幻棋盘 二维线段树+差分 luoguP2086/bzoj2788]]></title>
    <url>%2F2019%2F04%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2086%2F</url>
    <content type="text"><![CDATA[细节诸多………… $gcd$ 显然可以用线段树维护，但是如果是区间修改的话就不好办了。这个时候我们需要将原矩阵以棋盘守护者的位置为中心进行差分，那么区间修改就变为单点修改了，$gcd$ 自然好维护多了。 但是当我们整体加的时候，因为我们对原矩阵进行了拆分，所以对于每个点是加是减还是不动的话需要分类讨论一番。 经过观察我们会发现，有三种情况(棋盘守护者的位置为 $(X,Y)$ 询问矩阵不包括 $(X,Y)$ 询问矩阵包含棋盘守护者所在的 $X$ 轴或是 $Y$ 轴。 询问矩阵不包含棋盘守护者所在的 $X$ 轴或是 $Y$ 轴。 询问矩阵包括 $(X,Y)$ 这个时候我们可以自己更改原矩阵，然后输出其差分矩阵寻找规律了。需要注意的是判断的时候的边界情况以及自己修改的点的位置是否正确。细节很多，需要注意。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;#define F(i,x,y) for((i)=(x);(i)&lt;=(y);++(i))#define R(i,x,y) for((i)=(x);(i)&gt;=(y);--(i)) const int N=5e5+7;const int inf=1e9+9; int n,m;LL a[N],b[N];int id(int x,int y) &#123;return (x-1)*m+y;&#125; namespace OI &#123; LL abs(LL x) &#123;return x&gt;=0?x:-x;&#125; LL gcd(LL x,LL y) &#123;return y?gcd(y,x%y):abs(x);&#125; template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x; &#125;&#125;using namespace OI; namespace _2D_Segment_tree &#123;/*四分线段树*/ #define midl ((x1+x2)&gt;&gt;1) #define midr ((y1+y2)&gt;&gt;1) int tot,root; struct Node &#123;LL v;int ll,lr,rl,rr;&#125;t[N&lt;&lt;4]; void pushup(int x) &#123; LL vl=gcd(t[t[x].ll].v,t[t[x].lr].v); LL vr=gcd(t[t[x].rl].v,t[t[x].rr].v); t[x].v=gcd(vl,vr);return; &#125; void build(int&amp;x,int x1,int y1,int x2,int y2) &#123; if(x1&gt;x2||y1&gt;y2) return;x=++tot; if(x1==x2&amp;&amp;y1==y2) &#123;t[x].v=a[id(x1,y1)];return;&#125; build(t[x].ll,x1,y1,midl,midr); build(t[x].lr,midl+1,y1,x2,midr); build(t[x].rl,x1,midr+1,midl,y2); build(t[x].rr,midl+1,midr+1,x2,y2); pushup(x);return; &#125; void change(int x,int x1,int y1,int x2,int y2,int X,int Y,LL val) &#123; if(x1&gt;X||X&gt;x2||y1&gt;Y||Y&gt;y2) return; if(x1==x2&amp;&amp;y1==y2) &#123;t[x].v+=val;return;&#125; change(t[x].ll,x1,y1,midl,midr,X,Y,val); change(t[x].lr,midl+1,y1,x2,midr,X,Y,val); change(t[x].rl,x1,midr+1,midl,y2,X,Y,val); change(t[x].rr,midl+1,midr+1,x2,y2,X,Y,val); pushup(x);return; &#125; LL query(int x,int x1,int y1,int x2,int y2,int X1,int Y1,int X2,int Y2) &#123; if(x1&gt;X2||x2&lt;X1||y1&gt;Y2||y2&lt;Y1) return 0; if(X1&lt;=x1&amp;&amp;Y1&lt;=y1&amp;&amp;x2&lt;=X2&amp;&amp;y2&lt;=Y2) return t[x].v; LL vll=query(t[x].ll,x1,y1,midl,midr,X1,Y1,X2,Y2); LL vlr=query(t[x].lr,midl+1,y1,x2,midr,X1,Y1,X2,Y2); LL vrl=query(t[x].rl,x1,midr+1,midl,y2,X1,Y1,X2,Y2); LL vrr=query(t[x].rr,midl+1,midr+1,x2,y2,X1,Y1,X2,Y2); return gcd(vll,gcd(vlr,gcd(vrl,vrr))); &#125;&#125;using namespace _2D_Segment_tree; int main() &#123; IN(n),IN(m); int X,Y,T,i,j;IN(X),IN(Y),IN(T); for(int i=1;i&lt;=n*m;++i) IN(a[i]); /*-------对原矩阵进行差分-------*/ for(int i=1;i&lt;=n*m;++i)&#123; if((i-1)%m+1&lt;Y) b[i]=a[i]-a[i+1]; else if((i-1)%m+1&gt;Y) b[i]=a[i]-a[i-1]; else b[i]=a[i]; &#125; for(int i=1;i&lt;=n*m;++i) &#123; if((i-1)/m+1&lt;X) a[i]=b[i]-b[i+m]; else if((i-1)/m+1&gt;X) a[i]=b[i]-b[i-m]; else a[i]=b[i]; &#125; /*----------------------------*/ build(root,1,1,n,m); while(T--) &#123; int op,x1,y1,x2,y2;IN(op),IN(x1),IN(y1),IN(x2),IN(y2); if(!op) printf("%lld\n",query(1,1,1,n,m,X-x1,Y-y1,X+x2,Y+y2)); else &#123; LL val;IN(val); if(x1&lt;=X&amp;&amp;x2&gt;=X&amp;&amp;y1&lt;=Y&amp;&amp;y2&gt;=Y) &#123;/*包含了(X,Y)*/ change(1,1,1,n,m,X,Y,val); if(y1-1&gt;=1) change(1,1,1,n,m,X,y1-1,-val); if(y2+1&lt;=m) change(1,1,1,n,m,X,y2+1,-val); if(x1-1&gt;=1) change(1,1,1,n,m,x1-1,Y,-val); if(x2+1&lt;=n) change(1,1,1,n,m,x2+1,Y,-val); if(x1-1&gt;=1&amp;&amp;y1-1&gt;=1) change(1,1,1,n,m,x1-1,y1-1,val); if(x1-1&gt;=1&amp;&amp;y2+1&lt;=m) change(1,1,1,n,m,x1-1,y2+1,val); if(x2+1&lt;=n&amp;&amp;y1-1&gt;=1) change(1,1,1,n,m,x2+1,y1-1,val); if(x2+1&lt;=n&amp;&amp;y2+1&lt;=m) change(1,1,1,n,m,x2+1,y2+1,val); &#125; else if(y1&lt;=Y&amp;&amp;Y&lt;=y2) &#123;/*包含Y轴*/ if(x1&lt;X&amp;&amp;x2&lt;X) &#123;/*在上面*/ change(1,1,1,n,m,x2,Y,val); if(y1-1&gt;=1) change(1,1,1,n,m,x2,y1-1,-val); if(y2+1&lt;=m) change(1,1,1,n,m,x2,y2+1,-val); if(x1-1&gt;=1) change(1,1,1,n,m,x1-1,Y,-val); if(x1-1&gt;=1&amp;&amp;y1-1&gt;=1) change(1,1,1,n,m,x1-1,y1-1,val); if(x1-1&gt;=1&amp;&amp;y2+1&lt;=m) change(1,1,1,n,m,x1-1,y2+1,val); &#125; else if(x1&gt;X&amp;&amp;x2&gt;X) &#123;/*在下面*/ change(1,1,1,n,m,x1,Y,val); if(y1-1&gt;=1) change(1,1,1,n,m,x1,y1-1,-val); if(y2+1&lt;=m) change(1,1,1,n,m,x1,y2+1,-val); if(x2+1&lt;=n) change(1,1,1,n,m,x2+1,Y,-val); if(x2+1&lt;=n&amp;&amp;y1-1&gt;=1) change(1,1,1,n,m,x2+1,y1-1,val); if(x2+1&lt;=n&amp;&amp;y2+1&lt;=m) change(1,1,1,n,m,x2+1,y2+1,val); &#125; &#125; else if(x1&lt;=X&amp;&amp;X&lt;=x2) &#123;/*包含X轴*/ if(y1&lt;Y&amp;&amp;y2&lt;Y) &#123;/*在左边*/ change(1,1,1,n,m,X,y2,val); if(x1-1&gt;=1) change(1,1,1,n,m,x1-1,y2,-val); if(x2+1&lt;=n) change(1,1,1,n,m,x2+1,y2,-val); if(y1-1&gt;=1) change(1,1,1,n,m,X,y1-1,-val); if(y1-1&gt;=1&amp;&amp;x1-1&gt;=1) change(1,1,1,n,m,x1-1,y1-1,val); if(y1-1&gt;=1&amp;&amp;x2+1&lt;=n) change(1,1,1,n,m,x2+1,y1-1,val); &#125; else if(y1&gt;Y&amp;&amp;y2&gt;Y) &#123;/*在右边*/ change(1,1,1,n,m,X,y1,val); if(x1-1&gt;=1) change(1,1,1,n,m,x1-1,y1,-val); if(x2+1&lt;=n) change(1,1,1,n,m,x2+1,y1,-val); if(y2+1&lt;=m) change(1,1,1,n,m,X,y2+1,-val); if(y2+1&lt;=m&amp;&amp;x1-1&gt;=1) change(1,1,1,n,m,x1-1,y2+1,val); if(y2+1&lt;=m&amp;&amp;x2+1&lt;=n) change(1,1,1,n,m,x2+1,y2+1,val); &#125; &#125; else &#123;//剩下的判断四个角 if(x2&lt;X&amp;&amp;y2&lt;Y) &#123;//左上角 change(1,1,1,n,m,x2,y2,val); if(y1-1&gt;=1) change(1,1,1,n,m,x2,y1-1,-val); if(x1-1&gt;=1) change(1,1,1,n,m,x1-1,y2,-val); if(x1-1&gt;=1&amp;&amp;y1-1&gt;=1) change(1,1,1,n,m,x1-1,y1-1,val); &#125; else if(x2&lt;X&amp;&amp;y1&gt;Y) &#123;/*右上角*/ change(1,1,1,n,m,x2,y1,val); if(y2+1&lt;=m) change(1,1,1,n,m,x2,y2+1,-val); if(x1-1&gt;=1) change(1,1,1,n,m,x1-1,y1,-val); if(x1-1&gt;=1&amp;&amp;y2+1&lt;=m) change(1,1,1,n,m,x1-1,y2+1,val); &#125; else if(x1&gt;X&amp;&amp;y2&lt;Y) &#123;/*左下角*/ change(1,1,1,n,m,x1,y2,val); if(y1-1&gt;=1) change(1,1,1,n,m,x1,y1-1,-val); if(x2+1&lt;=n) change(1,1,1,n,m,x2+1,y2,-val); if(x2+1&lt;=n&amp;&amp;y1-1&gt;=1) change(1,1,1,n,m,x2+1,y1-1,val); &#125; else if(x1&gt;X&amp;&amp;y1&gt;Y) &#123;/*右下角*/ change(1,1,1,n,m,x1,y1,val); if(y2+1&lt;=m) change(1,1,1,n,m,x1,y2+1,-val); if(x2+1&lt;=n) change(1,1,1,n,m,x2+1,y1,-val); if(x2+1&lt;=n&amp;&amp;y2+1&lt;=m) change(1,1,1,n,m,x2+1,y2+1,val); &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>二维线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2019]多边形 组合数学 luoguP5288]]></title>
    <url>%2F2019%2F04%2F12%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP5288%2F</url>
    <content type="text"><![CDATA[$\texttt{HNOI2019}$ 终于改出来一道题目了……感谢 $JerryC$ 跟我一起讨论，不然我也看不懂题解。这题真的是 $\texttt{HNOI2019}$ 最可做的题啊，可想而知 $\texttt{HNOI2019}$ 有多么毒瘤了。 $orz yyb$ ，感谢 $yyb$ 大佬的题解。 这一题一共有两问，并且部分分也比较多，接下来我们一起来逐一攻破这些特殊条件。 1.只有第一问且 $m=0$ 的情况其实这个时候我们可以发现，最终的答案是要满足所有的点都连向 $n$ 。 对于每一次旋转操作，可以让 一个没有连向 $n$ 的点连向 $n$ ，并且一次旋转操作也最多可以使得一个没有连向 $n$ 的点连向 $n$ 。既然要求最少步数，我们考虑最优情况：每一次旋转都有一个新的点连向 $n$ 。这个时候最终需要的最少步数显然就是 $n-1-$已经与 $n$ 连接了的点数，为什么 $-1$ ？因为最终需要连向 $n$ 的点不包括 $n$ 。(ps：这里指的已经与 $n$ 连接了的点数其实包括 $1$ 与 $n-1$) 。 至于代码实现的话，我们用个 $vector$ 来存连接的点，最后统计一下 $size$ 即可。 2.有两问且 $m=0$ 的情况初始局面的第一问我们已经解决了，现在我们来看看怎么解决初始局面的第二问。 假设当前与 $n$ 连接了的点的集合为 $S=\{a_1,a_2,\cdots ,a_s\}$ ，这个时候我们将 $1$ 到 $n$ 分成若干个区间：$[1,a_1],[a_1,a_2],\cdots,[a_{s-1},a_s],[a_s,n-1]$ ，我们会发现，每一次旋转操作的四个点一定属于同一个区间 。在最终状态，每一个区间中的所有的点都是连向 $n$ 的。 那么我们考虑计算每一个区间的操作序列，我们设 $[a_i,a_{i+1}]$ 区间的操作序列长度为 $sz(a_i)$ 。注意这个操作序列指的就是一个区间从初始状态到最终状态的所有旋转操作组成的序列。 我们现在考虑方案数，假设我们知道了 $sz(a_i),sz(a_{i+1})$ ，也就是区间 $[a_i,a_{i+1}]$ 和区间 $[a_{i+1},a_{i+2}]$ 的操作序列的长度。那么使得这两个区间都到达最终状态的方案数显然为 $C_{sz(a_i)+sz(a_{i+1})}^{sz(a_i)}$，当然也是 $C_{sz(a_i)+sz(a_{i+1})}^{sz(a_{i+1})}$ 。 这下子计算就变得简单多了，但是我们怎么求出使得单个区间变为最终状态的方案数以及当个区间的操作序列长度呢？这个时候我们可以将每一个区间 $[a_i,a_{i+1}]$ 建成一棵二叉树，每一次将 $[a_i,a_{i+1}]$ 拆成 $[a_i,p],[p,a_{i+1}]$ ，在树中这两个子区间就是 $[a_i,a_{i+1}]$ 的两个儿子。 这下子使得 $[a_i,a_{i+1}]$ 变为最终状态的方案数显然可以从其树中的两个儿子得出了，计算的方法和上面同理。 至于这个 $p$ ，假设当前区间为 $l,r$ ，我们可以选择 第一个比 $l+1$ 大且与 $r$ 连了边的点 ，那么这个时候可以理解为 拆掉 $p,r$ 这条边，然后连起来 $p,n$ 这条边 ，于是 $l,p$ 可以作为一个区间了，$p,r$ 也可以作为一个区间了。 为什么一定要选择第一个比 $l+1$ 大且与 $r$ 连了边的点呢？我们考虑两个点 $a$ 和 $b$ ，其中 $a$ 就是第一个比 $l+1$ 大且与 $r$ 连了边的点，$b$ 则是一个小于 $r$ 大于 $a$ 并且和 $r$ 连了边的点 。如果这个时候选择将 $b,r$ 断开连接 $b,n$ 的话，线段 $a,r$ 和线段 $b,n$ 显然会交叉 ，那么就不合法了。所以我们选择第一个比 $l+1$ 大且与 $r$ 连了边的点，这样至少是合法的。当然如果这个点大于 $r$ 了就没办法了。 代码的话一个 $dfs$ 可以搞定。 3.$m&gt;0$ 且只有第一问的情况首先我们会发现，第一问的答案其实就是我们的树的结点个数。 然后考虑这个旋转操作，现在有 $a&lt;b&lt;c&lt;d​$ ，我们需要求出的就是 $(a,c)​$ 旋转对第一问带来的变化。 既然 $a,c$ 是连了边的，那么在树中也一定有一个节点代表 $[a,c]$ 区间，我们先在树中找到这个节点，然后再分两种情况来讨论。 一.该节点在树中有父节点我们将图画出来： （左边的是原来的，右边的是经过了 $(a,c)$ 旋转的） 可以发现，旋转之后我们损失了 $(a,c)$ 节点，但是多了个 $(b,d)$ 节点，我们的节点数实际上是没有变的。也就是说我们第一问的答案没有变。 二.该节点在树中没有父节点这个时候 $a,c$ 肯定都是已经连向了 $n$ 的，不然不可能没有父节点。那么这个时候 $d$ 要不是 $n$ 要不是其他区间的点了。上文已经讲了，旋转操作只可能在一个区间内进行，也就是说 $d$ 只能等于 $n$ 。 那么 $d=n$ 的话树会怎么变换呢？很显然，$(a,c)$ 会消失，剩下的就是 $(a,b)$ 和 $(b,c)$ 。这个时候是少了一个点的，那么第一问的答案就要减一了。 如果从多边形的角度理解的话，会发现多了一个连接了 $n$ 的点，那么第一问的答案自然就少了一。 这个代码实现就不讲了。 4.$m&gt;0$ 且两问都有的情况解决了这个情况我们就胜利了。 也就是说现在我们需要解决 $m&gt;0$ 时第二问怎么变化。 按照上面的来就行了。 一.该节点在树中有父节点按照上面的图，我们可以先将这些节点的贡献去掉。然后再加上新的贡献即可。 二.该节点在树中没有父节点我们直接去掉 $(a,c)$ 的贡献，然后加上 $(a,b),(b,c)$ 的贡献即可。 这一部分可以参照代码了。 综上，我们解决了所有的问题，接下来贴出代码 $QwQ$ 。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e5+2;const int MOD=1e9+7;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int W,n,Ans1,Ans2=1;vector&lt;int&gt; G[N];/*G[i]表示与i相连接的点的集合*/map&lt;pair&lt;int,int&gt;,int&gt; vis;/*这个是为了方便快速找到代表(a,c)节点所用的map*/inline void solve() &#123;//初始化 for(int i=2;i&lt;n;++i) G[i].push_back(i+1),G[i].push_back(i-1); G[1].push_back(n),G[1].push_back(2); G[n].push_back(n-1),G[n].push_back(1); for(int i=1;i&lt;=n;++i) sort(G[i].begin(),G[i].end());&#125;int inv[N&lt;&lt;1],fct[N&lt;&lt;1],fci[N&lt;&lt;1];/*分别对应逆元，阶乘，逆元的阶乘。主要用于计算组合数*/inline int C(int n,int m) &#123; if(n&lt;0||m&lt;0||n&lt;m) return 0; return 1ll*fct[n]*fci[m]%MOD*fci[n-m]%MOD;&#125;inline int Inv_C(int n,int m) &#123; if(n&lt;0||m&lt;0||n&lt;m) return 0; return 1ll*fci[n]*fct[m]%MOD*fct[n-m]%MOD;&#125;inline int calc(int n,int m) &#123;return C(n+m,n);&#125;inline int Inv_calc(int n,int m) &#123;return Inv_C(n+m,n);&#125;/*上面的组合数不再赘述......*/int root[N],fa[N&lt;&lt;1],sz[N&lt;&lt;1],ch[N&lt;&lt;1][2],tot;/*root[i]就是S集合中的区间ai,ai+1在树中的节点的编号*//*fa表示父节点，sz表示节点子树大小，ch表示节点的左右儿子*/void dfs(int&amp;x,int f,int l,int r) &#123; if(r-l&lt;=1) return; x=++tot,sz[x]=1,fa[x]=f; int p=lower_bound(G[r].begin(),G[r].end(),l+1)-G[r].begin(); /*找到这个p*/ p=G[r][p],vis[make_pair(l,r)]=x; /*找到p在原多边形中对应的点，并记录l,r在树中的点的编号*/ dfs(ch[x][0],x,l,p),dfs(ch[x][1],x,p,r);/*向下计算子树*/ sz[x]+=sz[ch[x][0]]+sz[ch[x][1]];/*统计子树大小*/ Ans2=1ll*Ans2*calc(sz[ch[x][0]],sz[ch[x][1]])%MOD;/*计算贡献*/&#125;int main() &#123; IN(W),IN(n); inv[0]=inv[1]=fct[0]=fci[0]=1; for(int i=2;i&lt;=n+n;++i) inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD; for(int i=1;i&lt;=n+n;++i) fct[i]=1ll*fct[i-1]*i%MOD; for(int i=1;i&lt;=n+n;++i) fci[i]=1ll*fci[i-1]*inv[i]%MOD; /*以上为初始化逆元，阶乘，逆元的阶乘*/ for(int i=1;i&lt;=n-3;++i) &#123; int x,y;IN(x),IN(y); G[x].push_back(y),G[y].push_back(x); &#125; solve(),Ans1=n-1-G[n].size(); for(int i=0,len=G[n].size();i&lt;len-1;++i) dfs(root[i],0,G[n][i],G[n][i+1]);/*计算每个区间ai,ai+1的树*/ int Size=0; for(int i=0,len=G[n].size();i&lt;len-1;++i) Ans2=1ll*Ans2*calc(Size,sz[root[i]])%MOD,Size+=sz[root[i]]; /*统计答案*/ if(!W) printf("%d\n",Ans1); else printf("%d %d\n",Ans1,Ans2); int q;IN(q); while(q--) &#123; int a,b;IN(a),IN(b); if(a&gt;b) a^=b^=a^=b; int x=vis[make_pair(a,b)];/*找到在原树中a,b所代表的节点*/ if(!W) &#123;printf("%d\n",Ans1-(fa[x]?0:1));continue;&#125; else &#123; int nowans1=Ans2; if(fa[x]) &#123; int y=fa[x],k=ch[y][1]==x; nowans1=1ll*nowans1*Inv_calc(sz[ch[x][0]],sz[ch[x][1]])%MOD; nowans1=1ll*nowans1*Inv_calc(sz[ch[y][0]],sz[ch[y][1]])%MOD; nowans1=1ll*nowans1*calc(sz[ch[x][!k]],sz[ch[y][!k]])%MOD; nowans1=1ll*nowans1*calc(1+sz[ch[y][!k]]+sz[ch[x][!k]],sz[ch[x][k]])%MOD; /*除掉贡献与增加贡献*/ &#125; else &#123; nowans1=1ll*nowans1*Inv_calc(sz[ch[x][0]],sz[ch[x][1]])%MOD; nowans1=1ll*nowans1*Inv_calc(Size-sz[x],sz[x])%MOD; nowans1=1ll*nowans1*calc(Size-sz[x],sz[ch[x][0]])%MOD; nowans1=1ll*nowans1*calc(Size-sz[x]+sz[ch[x][0]],sz[ch[x][1]])%MOD; /*除掉贡献与增加贡献*/ &#125; printf("%d %d\n",Ans1-(fa[x]?0:1),nowans1);/*输出答案*/ &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 不同子串个数 后缀数组.SA luoguP2408]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2408%2F</url>
    <content type="text"><![CDATA[后缀数组。 假设我们现在已经求出了 $height$ 数组，我们发现，对两个后缀，其重复了的字串的个数就是 $height$ 数组所记录的数。我们举个例子： 后缀$sa[i-1]$: $aaabbdbs$后缀$sa[i]$ : $aabbdbs$ 会发现，最前面的”$aa$”是两个串都有的，”$aa$”中包含的”$a$”也是两个串都有的，这样子就有两个重复的了，可以发现这个重复个数正好是 $height[i]$ 的值。 但是后面还是有重复的啊？没关系，因为我们有所有的后缀，所以整个串中所有的重复的串都会被统计进来。所以这下子我们可以很容易的求出整个串中重复的串的个数了，就是 $\sum_{i=1}^{n}height[i]$ 。 子串的个数显然是 $\frac{n(n+1)}{2}$ ，这两项相减就是我们需要的答案了，记得开 $longlong$ 。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e5+2;const int inf=1e9+9;namespace Suffix_array &#123; char s[N]; int sa[N],x[N],y[N],hep[N],height[N],n,m; void Sort() &#123; for(int i=0;i&lt;=m;++i) hep[i]=0; for(int i=1;i&lt;=n;++i) ++hep[x[i]]; for(int i=1;i&lt;=m;++i) hep[i]+=hep[i-1]; for(int i=n;i&gt;=1;--i) sa[hep[x[y[i]]]--]=y[i]; &#125; void Pre_sa() &#123; for(int i=1;i&lt;=n;++i) x[i]=s[i],y[i]=i; m=129;Sort(); for(int w=1,p=0;m=p,p&lt;n;w&lt;&lt;=1) &#123; p=0; for(int i=1;i&lt;=w;++i) y[++p]=n-w+i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;w) y[++p]=sa[i]-w; Sort(),swap(x,y),x[sa[1]]=p=1; for(int i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+w]==y[sa[i-1]+w])?p:++p; &#125;return; &#125; ll Pre_height() &#123; for(int i=1;i&lt;=n;++i) x[sa[i]]=i; int k=0,res=0; for(int i=1;i&lt;=n;++i) &#123; k-=k&gt;0; int j=sa[x[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) ++k; height[x[i]]=k,res+=k; &#125;return res;//直接返回height数组的和 &#125;&#125;using namespace Suffix_array;int main() &#123; scanf("%d\n",&amp;n); scanf("%s",s+1); Pre_sa(); ll ans=1ll*n*(n+1)/2; ans-=Pre_height(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>后缀数组.SA</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[SDOI2017]数字表格 莫比乌斯反演 luoguP3704]]></title>
    <url>%2F2019%2F04%2F10%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3704%2F</url>
    <content type="text"><![CDATA[我们设 $n \leq m​$ ，然后开始推式子，我们将 $gcd(i,j)​$ 的值作为 “$d​$” 提出来： \prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}if(gcd(i,j)=d) f[d]=\prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}if(gcd(i,j)=d) f[d]=\prod_{d=1}^{n}\prod_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\prod_{j=1}^{ \lfloor\frac{m}{d}\rfloor }if(gcd(i,j)=1) f[d]=\prod_{d=1}^{n} f[d]^{\sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]} $\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]​$ 是个熟悉的式子，我们从这个式子继续开刀： \sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{ \lfloor\frac{m}{d}\rfloor }[gcd(i,j)=1]​=\sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor }\sum_{j=1}^{ \lfloor\frac{m}{d}\rfloor }\sum_{x|gcd(i,j)} \mu(x)​=\sum_{x=1}^{n}\mu(x)\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor​于是原来的式子变成了： \prod_{d=1}^{n} f[d]^{\sum_{x=1}^{n}\mu(x)\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor}​设 $T=dx$ ，并将 $T$ 提出来枚举： \prod_{d=1}^{n} f[d]^{\sum_{x=1}^{n}\mu(x)\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor}​=\prod_{T=1}^{n}\prod_{d|T} f[d]^{\mu( \lfloor\frac{T}{d}\rfloor )\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor}=\prod_{T=1}^{n}(\prod_{d|T} f[d]^{\mu( \lfloor\frac{T}{d}\rfloor )})^{\lfloor\frac{n}{T}{\rfloor\lfloor\frac{m}{T}\rfloor}}这个样子多好啊，我们可以将可爱的 $(\prod_{d|T} f[d]^{\mu( \lfloor\frac{T}{d}\rfloor )})$ 预处理，也就是枚举每一个 $d$ ，然后将可以整除 $d$ 的每一个 $T$ 都算上 $d$ 带来的贡献即可。最后的时候可以整除分块。最终的时间复杂度为 $O(\sqrt{n})$ ，当然不算上预处理时候的复杂度，如果加上预处理的复杂度，最终的复杂度应该为 $O(N(log\ N+log\ mod)+T(\sqrt{n} \ log\ mod))$ ，$log\ mod$ 就是算逆元的复杂度。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e6+2;#define MOD 1000000007template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;bool vis[N+15];int mui[N+15],inv[N+15],fib[N+15],sum[N+15],prime[N],cnt;inline int pow(int x,int y) &#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%MOD) if(y&amp;1) res=1ll*res*x%MOD; return res%MOD;&#125;inline void pre() &#123; fib[1]=inv[1]=sum[0]=sum[1]=1; vis[1]=true,mui[1]=1; for(int i=2;i&lt;=N;++i) &#123; fib[i]=(fib[i-1]+fib[i-2])%MOD; inv[i]=pow(fib[i],MOD-2),sum[i]=1; if(!vis[i]) prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;++j) &#123; vis[i*prime[j]]=1; if(!(i%prime[j])) break; else mui[i*prime[j]]=-mui[i]; &#125; &#125; for(int d=1;d&lt;=N;++d) &#123; if(!mui[d]) continue; for(int T=d;T&lt;=N;T+=d) sum[T]=1ll*sum[T]*(mui[d]==1?fib[T/d]:inv[T/d])%MOD; &#125; for(int i=2;i&lt;=N;++i) sum[i]=1ll*sum[i]*sum[i-1]%MOD; return;&#125;int T,n,m;int main() &#123; pre(),IN(T); while(T--) &#123; IN(n),IN(m); if(n&gt;m) swap(n,m); int ans=1,res,num; for(int l=1,r=0;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); num=1ll*(n/l)*(m/l)%(MOD-1); res=1ll*sum[r]*pow(sum[l-1],MOD-2)%MOD; ans=1ll*ans*pow(res,num)%MOD; &#125; printf("%d\n",(ans+MOD)%MOD); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【游记】 HNOI2019酱油记]]></title>
    <url>%2F2019%2F04%2F08%2F%5B%E6%B8%B8%E8%AE%B0%5DHNOI2019%2F</url>
    <content type="text"><![CDATA[在此输入你的密码以便阅读全文 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2012]永无乡 线段树+启发式合并 luoguP3224]]></title>
    <url>%2F2019%2F04%2F04%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3224%2F</url>
    <content type="text"><![CDATA[实际上可以用平衡树做的但是不喜欢平衡树。 还是喜欢可爱的线段树，于是打了一发线段树合并。很久没有这样子的做题感觉了，真是美妙，思路清晰，交上去一遍过(窝不会告诉泥萌窝第一次交的时候忘关文件=。=)。 我们对于每一个点维护一个权值线段树，然后用并查集维护点与点之间的联通关系。对于一个连通块，该连通块的所有结点信息都保留在该连通块的 $root$ 上。 这样子我们合并两个岛的时候 $x,y$ ，可以直接将 $x$ 所在连通块的 $root$ (简称 $fx$ ) 和 $y$ 所在连通块的 $root$ (简称 $fy$ ) 合并起来，也就是将 $fy$ 的线段树并到 $fx$ 上去。这样子 $fx$ 就维护了这两个连通块的信息了，最后我们按照并查集的套路将 $fy$ 的父亲设为 $fx$ 即可。 询问就是基础操作，权值线段树就像主席树那样询问即可。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N=1e5+7;const int Max=N*650;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;struct Seg_Tree &#123; #define mid ((l+r)&gt;&gt;1) int cnt,rt[N],val[Max],lc[Max],rc[Max]; inline void pushup(int x) &#123; val[x]=val[lc[x]]+val[rc[x]]; &#125; void update(int&amp;x,int l,int r,int pos) &#123; if(!x) x=++cnt; if(l==r) &#123;++val[x];return;&#125; if(pos&lt;=mid) update(lc[x],l,mid,pos); else update(rc[x],mid+1,r,pos); pushup(x); &#125; int query(int x,int l,int r,int k) &#123; if(l==r) return l; int th=val[lc[x]]; if(k&lt;=th) query(lc[x],l,mid,k); else return query(rc[x],mid+1,r,k-th); &#125; int merge(int x,int y,int l,int r) &#123; if(!x||!y) return x+y; if(l==r) &#123;val[x]+=val[y];return x;&#125; lc[x]=merge(lc[x],lc[y],l,mid), rc[x]=merge(rc[x],rc[y],mid+1,r); pushup(x);return x; &#125;&#125;T;int fa[N],pos[N],n,m,q;int find(int x) &#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125;int main() &#123; IN(n),IN(m); for(int i=1,x;i&lt;=n;++i) fa[i]=i,IN(x),pos[x]=i,T.update(T.rt[i],1,n,x); for(int i=1;i&lt;=m;++i) &#123; int u,v;IN(u),IN(v); int fu=find(u),fv=find(v); if(fu!=fv) T.merge(T.rt[fu],T.rt[fv],1,n),fa[fv]=fu; &#125; IN(q); for(int i=1;i&lt;=q;++i) &#123; char op[2];int x,y,k; scanf("%s",op); if(op[0]=='B') &#123; IN(x),IN(y); int fx=find(x),fy=find(y); if(fx!=fy) T.merge(T.rt[fx],T.rt[fy],1,n),fa[fy]=fx; &#125; else if(op[0]=='Q') &#123; IN(x),IN(k); int fx=find(x); if(T.val[T.rt[fx]]&lt;k) printf("-1\n"); else printf("%d\n",pos[T.query(T.rt[fx],1,n,k)]); /*我们query到的是第K大的权值而非岛屿的编号*/ /*于是加个pos数组就好了*/ &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【考试总结】 Test-2019.4.3 HNOI2019模拟]]></title>
    <url>%2F2019%2F04%2F03%2F%5B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%5Dtest20190403%2F</url>
    <content type="text"><![CDATA[三道题目，一眼出算法。 第一道题目显然是后缀自动机，第二道题目显然是莫比乌斯反演加上杜教筛。第三道题目显然是网络流。 然而考场上都没做出来……自闭了。 真的，现在已经是傍晚了，大后天就是毒瘤的省选了……小学中现在正在举办运动会，班级群中一群人在那里一个劲的喊加油，但是，班上有人给我加油吗？除了几个好朋友之外…… 题目压缩包戳我!!!~\(≧▽≦)/~(有时链接可能会崩，如果崩了的话请稍后尝试QwQ) T1 期望得分：40分实际得分：40分正解：后缀自动机(SAM)+FFT窝的解法：哈希 题解嗯后缀自动机是会的但是感觉不好做。 于是弄了个哈希上去骗分，暴力枚举字串然后玄学哈希即可。 不会正解。。。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=666;const int inf=1e9+9;const int MOD=100000007;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int k,m,cnt,res[N*N],ans;char s[N],c[N];map&lt;int,int&gt; hash;void dfs(int step,int sum) &#123; if(step==k+1&amp;&amp;sum==m) &#123;++ans;return;&#125; if(step==k+1) return; if(sum&gt;m) return; for(int i=1;i&lt;=cnt;++i) dfs(step+1,sum+res[i]); return;&#125;int main() &#123; freopen("tele.in","r",stdin); freopen("tele.out","w",stdout); IN(k),IN(m); scanf("%s",s+1); int n=strlen(s+1); for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;++j) &#123; int tot=0; for(int k=i;k&lt;=j;++k) tot=(1ll*tot*27%MOD+s[k]-'a'+1)%MOD; /*大力玄学哈希+map判重*/ hash[tot]++; &#125; for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;++j) &#123; int tot=0; for(int k=i;k&lt;=j;++k) tot=(1ll*tot*27%MOD+s[k]-'a'+1)%MOD; res[++cnt]=hash[tot]; &#125; dfs(1,0); /*灵机一动这样写，那么k打于2的时候如果数据小可以多拿一些分*/ /*实验证明这样布星*/ printf("%d\n",ans); return 0;&#125; T2 期望得分：60分实际得分：40分正解：莫比乌斯反演+杜教筛窝的解法：莫比乌斯反演 题解考场上忘记了杜教筛，于是GG。 本来有六十分的……脑抽的窝，预处理 $\sum_{i=1}^{T}\lfloor\frac{T}{i}\rfloor$ 居然用 $O(n\sqrt{n})$ 来解决……实际上改两个字符就变成 $O(n)$ 的复杂度了，就有 $60$ 分了…… 嗯然后筛 $\mu$ 的时候可以搞个杜教筛加速，这样子的话 $\mu$ 函数的前缀和就可以 $O(n^{\frac{2}{3}})$ 筛出。不过估计是标程质量不行，题目范围只有 $10^9$ ……杜教筛可以解决 $O(10^{11})$ 左右的问题……吧? Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=4e6;const int inf=1e9+9;const int MOD=1000000007;bitset&lt;N+7&gt; vis;int n,mui[N+7],prime[N],cnt;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;inline void pre() &#123; mui[1]=1; for(int i=2;i&lt;N;++i) &#123; if(!vis[i]) prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;N;++j) &#123; vis[i*prime[j]]=1; if(!(i%prime[j])) &#123;mui[i*prime[j]]=0;break;&#125; else mui[i*prime[j]]=-mui[i]; &#125; &#125;for(int i=1;i&lt;N;++i) mui[i]+=mui[i-1]; return;&#125;ll S(int MX) &#123; ll sum=0; for(int l=1,r;l&lt;=MX;l=r+1) &#123; r=MX/(MX/l); sum=(sum+1ll*(r-l+1)*(MX/l)%MOD)%MOD; &#125;return sum;&#125;map&lt;int,int&gt; MU;int Sum(int x) &#123;/*杜教筛*/ if(x&lt;N) return mui[x]; else if(MU.count(x)) return MU[x]; else if(!x) return 0; else &#123; int s=1; for(int l=2,r;l&lt;=x;l=r+1) &#123; r=x/(x/l); s-=(r-l+1)*Sum(x/l); &#125;return MU[x]=s; &#125;&#125;int main() &#123; freopen("math.in","r",stdin); freopen("math.out","w",stdout); scanf("%d",&amp;n); pre(); ll res=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); ll num=S(n/l); res=(res+1ll*(Sum(r)-Sum(l-1))*num*num%MOD+MOD)%MOD; &#125; printf("%lld\n",(res+MOD)%MOD); return 0;&#125; 嗯实际这题窝觉得是一道莫反板子题，但是没做出来，看来杜教筛还是不会…… T3 期望得分：50分实际得分：0分正解：最小割窝的解法：最小割+爆搜 题解看完题目后，窝决定第一个看这道题。 哇，一眼网络流题目欸！ 咦这题好像小$M$的作物欸，但是第二个操作又不对劲了……(实际上第二个操作就是文理分科那题，但是窝没做那题)。 嗯，需要花费的什么费用……费用流？！然后手画了一下图……自己模拟一下发现根本不好模拟，想着费用流板子也就 $10$ 分钟的事，于是打了个费用流照着窝之前的想法建一下边，跑一下后发现错了…… 然后苦苦思索……转眼间 $30$ 分钟过去了。发现时间过得比较快，于是决定先将暴力 $30$ 打好再想……嗯爆搜一下救过了样例(不过窝的爆搜又打错了以至于窝没拿到分？！) 嗯这个时候感觉前 $30$ 分稳了，于是观察部分分，发现有 $\%20$ 的数据不包含第二个操作，直接上小$M$的作物发现自己忘了，没办法只好自己瞎 $YY$ 一通。最后的结果发现是最小割，然后拆点，拆成牛羊两个点，源点连牛点，边权自然是其收益，羊点同理。然后中间连一条边权为 $inf$ 的边，表示这个要不圈牛要不圈羊只能圈一个。 嗯，发现还挺有道理的。对于，对于限制的话我们只需要再限制的两个牛羊点之间连上一条边权为 $inf$ 的边即可。 一遍过样例，美滋滋地开始造数据拍，嗯第一次和爆搜拍得挺顺利 $500$ 组数据全过了。 没过瘾，再来一组，结果第二组 $500$ 数据，拍到三百多个就 $WA$ 了…… 后面没有想出来，于是弃疗了。 接下来讲一讲正解怎么做 小$M$的作物自然不用讲，我们来讲讲文理分科怎么做。 对于本题的第二个操作，我们需要新建一个结点 $p​$ ，然后如果这个操作的 $a​$ 是 $0​$ 我们就从源点向其连一条边权为 $b​$ 的边，$a​$ 是 $1​$ 的情况同理。 然后呢，对于 $S$ 中的每个点，如果 $a$ 为 $0$ 则从 $p$ 向该点连边，$a$ 是 $1$ 的情况同理。 嗯，然后就是不需要拆点。然后就差不多了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e5+2;const int inf=1e9+9;int n,m,k,a[N],b[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;namespace Dinic&#123; queue&lt;int&gt; q; int s,t,head[N],dep[N],cnt=1; struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;1]; inline void add(int u,int v,int w) &#123; G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,0&#125;,head[v]=cnt; &#125; int bfs() &#123; memset(dep,0,sizeof(dep)); dep[s]=1,q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=head[u];i;i=G[i].nxt) &#123; int v=G[i].to; if(!dep[v]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,q.push(v); &#125; &#125;return dep[t]; &#125; int dfs(int u,int flow) &#123; if(u==t||!flow) return flow; int used=0,rlow; for(int i=head[u];i;i=G[i].nxt) &#123; int v=G[i].to; if(dep[v]==dep[u]+1&amp;&amp;G[i].val&gt;0) &#123; used+=(rlow=dfs(v,min(flow-used,G[i].val))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used) dep[u]=-1; return used; &#125;&#125;using namespace Dinic;int main() &#123; freopen("work.in","r",stdin); freopen("work.out","w",stdout); IN(n),IN(m),IN(k); int sum=0,nodetot=n+1;s=0,t=n+1; for(int i=1;i&lt;=n;++i) IN(a[i]),sum+=a[i]; for(int i=1;i&lt;=n;++i) IN(b[i]); for(int i=1;i&lt;=m;++i) &#123; int x,y,z;IN(x),IN(y),IN(z); add(x,y,z),add(y,x,z); &#125; for(int i=1;i&lt;=k;++i) &#123; int size,x,y; IN(size),IN(x),IN(y); sum+=y,++nodetot; x?add(nodetot,t,y):add(s,nodetot,y); for(int j=1;j&lt;=size;++j) &#123; int c;IN(c); x?add(c,nodetot,inf):add(nodetot,c,inf); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; if(a[i]&gt;=b[i]) add(s,i,a[i]-b[i]); else add(i,t,b[i]-a[i]),sum+=b[i]-a[i]; &#125; int maxflow=0; while(bfs()) maxflow+=dfs(s,inf); printf("%d\n",sum-maxflow); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>考试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2005]维护数列 Splay luoguP2042]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2042%2F</url>
    <content type="text"><![CDATA[神奇的题目。 网上说什么做了这道题 $Splay$ 就差不多了，嗯对窝也这么觉得。于是终于码掉了。 主要涉及的操作还是提取区间，我们组需要将 $l-1$ 提取至 $root$ ， 然后将 $r+1$ 提取至 $l-1$ 的下方，最终询问的 $l,r$ 区间的 $Splay$ 就是 $r+1$ 的左孩子。 这个时候该输出的就输出，该打标记的就打标记就好了。 至于插入的话我们可以先将所有需要插入的结点 $build$ 成一棵树，然后直接挂到 $r+1$ 的左孩子即可。 但是毒瘤出题人卡空间，于是我们需要将删除的结点全部重新应用，就像垃圾回收那样，搞个栈就行了。 最后因为怕 $l-1$ 和 $r+1$ 出界我们还需要新增两个”哨兵结点”，这样子的话需要提取的结点都加上了 $1$ ，提取区间变动的两个节点就变成 $l$ 和 $r+2$ 了。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=5.5e5+7;const int inf=1e8;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;struct Splay &#123; int root,cnt; int ch[N][2],sz[N],fa[N],val[N],tag[N],rev[N]; int sum[N],lmax[N],rmax[N],smax[N]; int date[N],trash[N],top; Splay()&#123;root=cnt=top=0;&#125; bool chk(int x) &#123;return ch[fa[x]][1]==x;&#125; void clear(int node) &#123; ch[node][0]=ch[node][0]=sz[node]=fa[node]=val[node]=0, rev[node]=sum[node]=lmax[node]=rmax[node]=smax[node]=0; tag[node]=inf; &#125; int MKN() &#123; int node; node=top?trash[top--]:++cnt; clear(node);return node; &#125; void pushup(int x) &#123; int l=ch[x][0],r=ch[x][1]; sz[x]=sz[l]+sz[r]+1; sum[x]=sum[l]+sum[r]+val[x]; lmax[x]=max(lmax[l],sum[l]+val[x]+lmax[r]); rmax[x]=max(rmax[r],sum[r]+val[x]+rmax[l]); smax[x]=max(rmax[l]+lmax[r]+val[x],max(smax[l],smax[r])); &#125; void pushdown(int x) &#123; int l=ch[x][0],r=ch[x][1]; if(tag[x]!=inf) &#123; if(l) val[l]=tag[l]=tag[x],sum[l]=tag[x]*sz[l]; if(r) val[r]=tag[r]=tag[x],sum[r]=tag[x]*sz[r]; if(tag[x]&gt;=0) &#123; if(l) lmax[l]=rmax[l]=smax[l]=sum[l]; if(r) lmax[r]=rmax[r]=smax[r]=sum[r]; &#125; else if(tag[x]&lt;0) &#123; if(l) lmax[l]=rmax[l]=0,smax[l]=tag[x]; if(r) lmax[r]=rmax[r]=0,smax[r]=tag[x]; &#125; tag[x]=inf; &#125; if(rev[x]) &#123; if(l) swap(ch[l][0],ch[l][1]),swap(lmax[l],rmax[l]),rev[l]^=1; if(r) swap(ch[r][0],ch[r][1]),swap(lmax[r],rmax[r]),rev[r]^=1; rev[x]=0; &#125; &#125; void rotate(int x) &#123; int y=fa[x],z=fa[y]; pushdown(y),pushdown(x); int k=chk(x),v=ch[x][k^1]; ch[z][chk(y)]=x,fa[x]=z,ch[y][k]=v,fa[v]=y, ch[x][k^1]=y,fa[y]=x;pushup(y),pushup(x); &#125; void splay(int x,int gola=0) &#123; while(fa[x]!=gola) &#123; if(fa[fa[x]]!=gola) rotate(chk(x)^chk(fa[x])?x:fa[x]); rotate(x); &#125;if(!gola) root=x; &#125; int kth(int x) &#123; int pos=root; while(pos) &#123; pushdown(pos); if(x&lt;=sz[ch[pos][0]]) pos=ch[pos][0]; else &#123; x-=sz[ch[pos][0]]+1; if(!x) return pos; pos=ch[pos][1]; &#125; &#125;return 0; &#125; int build(int l,int r,int f) &#123; if(l&gt;r) return 0; int x=MKN(),mid=(l+r)&gt;&gt;1; ch[x][0]=build(l,mid-1,x),ch[x][1]=build(mid+1,r,x); val[x]=date[mid],fa[x]=f,pushup(x); return x; &#125; void trashcan_node(int x) &#123; if(!x) return; trash[++top]=x,trashcan_node(ch[x][0]),trashcan_node(ch[x][1]); &#125; int split(int&amp;l,int&amp;r,int pos,int tot) &#123; l=kth(pos),r=kth(pos+tot+1);splay(l),splay(r,l); &#125; void work_insert() &#123; int pos,tot,l,r; IN(pos),IN(tot); for(int i=1;i&lt;=tot;++i) IN(date[i]); split(l,r,pos+1,0); ch[r][0]=build(1,tot,r),pushup(r),pushup(root); &#125; void work_delete() &#123; int pos,tot,l,r; IN(pos),IN(tot),split(l,r,pos,tot); trashcan_node(ch[r][0]),ch[r][0]=0,pushup(r),pushup(root); &#125; void work_same() &#123; int pos,tot,c,l,r; IN(pos),IN(tot),IN(c),split(l,r,pos,tot); int p=ch[r][0]; if(p) &#123; val[p]=tag[p]=c,sum[p]=c*sz[p]; if(c&gt;=0) lmax[p]=rmax[p]=smax[p]=sum[p]; else if(c&lt;0) lmax[p]=rmax[p]=0,smax[p]=c; &#125;pushup(r),pushup(root); &#125; void work_rev() &#123; int pos,tot,l,r; IN(pos),IN(tot),split(l,r,pos,tot); if(ch[r][0]) &#123; swap(ch[ch[r][0]][0],ch[ch[r][0]][1]); swap(lmax[ch[r][0]],rmax[ch[r][0]]); rev[ch[r][0]]^=1; &#125;pushup(r),pushup(root); &#125; void work_sum() &#123; int pos,tot,l,r; IN(pos),IN(tot),split(l,r,pos,tot); printf("%d\n",sum[ch[r][0]]); &#125; void work_max() &#123; int l=kth(1),r=kth(sz[root]);splay(l),splay(r,l); printf("%d\n",smax[ch[r][0]]); &#125;&#125;T;int n,m;char op[25];int main() &#123; // freopen("testdata.in","r",stdin); // freopen("myout.out","w",stdout); IN(n),IN(m); for(int i=1;i&lt;=n;++i) IN(T.date[i+1]); T.smax[0]=T.date[1]=-inf,T.date[n+2]=inf; T.root=T.build(1,n+2,0); while(m--) &#123; scanf("%s",op); if(op[0]=='M') &#123; if(op[3]=='E') T.work_same(); else T.work_max(); &#125; else if(op[0]=='I') T.work_insert(); else if(op[0]=='D') T.work_delete(); else if(op[0]=='R') T.work_rev(); else if(op[0]=='G') T.work_sum(); &#125; return 0;&#125; 哎离 $HNOI2019$ 不远了，感觉多多更博增加 $RP$ …… $QwQ$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [Vani有约会]雨天的尾巴 线段树+启发式合并 luoguP4556]]></title>
    <url>%2F2019%2F04%2F02%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4556%2F</url>
    <content type="text"><![CDATA[毒瘤出题人，卡时间卡空间！ 嗯，如果这一题不是在树上的话貌似可以直接权值线段树维护？不过到了树上的话难道可以权值线段树+树链剖分，表示不明白。于是尝试了一发线段树合并，但是我们的线段树是权值线段树。 我们的权值线段树是用来存原树中 $x$ 结点以及其子树中的每种救济粮的个数。 怎么个合并法呢，其实特别简单，两个线段树同时进行，发现到了一个节点的时候一个线段树有这个结点另一个没有这个节点，那么这个节点以及其下面的结点的信息都可以直接作为新线段树的这个节点的信息。 当然如果到了一个叶子节点，直接将两个线段树的这个位置的救济粮的个数加起来即可。 嗯，每个线段树再维护一个值存出现最多次数的救济粮是什么，这样就可以得到答案了。但是为了避免一些结点与其子树压根就没有救济粮的情况，我们需要判断一下这个节点与其子树是否有救济粮即可。 然后直接一遍 $dfs$ ，遍历 $u$ 的所有孩子然后拿 $u$ 的线段树依次去和 $u$ 的儿子的线段树合并。最终合并完的线段树存储的就是 $u$ 以及其子树的信息了。然后就可以获得答案了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e5+7;const int LogN=27;const int M=6e6+7;int n,m,q,X[N],Y[N],Z[N],Ans[N],head[N],cnt;struct Edge &#123;int nxt,to;&#125;G[N&lt;&lt;1];inline void add(int u,int v) &#123; G[++cnt]=(Edge)&#123;head[u],v&#125;,head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u&#125;,head[v]=cnt;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=--x;&#125;namespace Lca &#123; int dep[N],fa[N][LogN+4]; void dfs(int u,int f) &#123; fa[u][0]=f,dep[u]=dep[f]+1; for(int i=1;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=f) dfs(G[i].to,u); &#125; int lca(int x,int y) &#123; if(x==y)return x; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=LogN;i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i]; if(x==y)return x; for(int i=LogN;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; &#125;&#125;using namespace Lca;struct Segment_Tree &#123; #define mid ((l+r)&gt;&gt;1) int rt[N],lc[M],rc[M],d[M],t[M],tot; void pushup(int x) &#123; if(d[lc[x]]&gt;=d[rc[x]]) d[x]=d[lc[x]],t[x]=t[lc[x]]; else d[x]=d[rc[x]],t[x]=t[rc[x]]; &#125; int update(int x,int l,int r,int pos,int val) &#123; if(!x) x=++tot; if(l==r) &#123;d[x]+=val;t[x]=l;return x;&#125; if(pos&lt;=mid) lc[x]=update(lc[x],l,mid,pos,val); else rc[x]=update(rc[x],mid+1,r,pos,val); pushup(x);return x; &#125; int merge(int x,int y,int l,int r) &#123; if(!x) return y; if(!y) return x; if(l==r) &#123;d[x]+=d[y];t[x]=l;return x;&#125; lc[x]=merge(lc[x],lc[y],l,mid); rc[x]=merge(rc[x],rc[y],mid+1,r); pushup(x);return x; &#125;&#125;T;void calc(int u,int f) &#123; for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=f) calc(G[i].to,u), T.rt[u]=T.merge(T.rt[u],T.rt[G[i].to],1,m); if(T.d[T.rt[u]]) Ans[u]=T.t[T.rt[u]];&#125;int main() &#123; IN(n),IN(q); for(int i=1,x,y;i&lt;n;++i) IN(x),IN(y),add(x,y); for(int i=1;i&lt;=q;++i) IN(X[i]),IN(Y[i]),IN(Z[i]),m=max(m,Z[i]); //权值线段树离线处理 dfs(1,0); for(int i=1;i&lt;=q;++i) &#123; int lca_xy=lca(X[i],Y[i]); T.rt[X[i]]=T.update(T.rt[X[i]],1,m,Z[i],1); T.rt[Y[i]]=T.update(T.rt[Y[i]],1,m,Z[i],1); T.rt[lca_xy]=T.update(T.rt[lca_xy],1,m,Z[i],-1); if(fa[lca_xy][0]) T.rt[fa[lca_xy][0]]=T.update(T.rt[fa[lca_xy][0]],1,m,Z[i],-1); &#125; calc(1,0); for(int i=1;i&lt;=n;++i) printf("%d\n",Ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 虚树入门]]></title>
    <url>%2F2019%2F04%2F01%2F%5B%E7%AE%97%E6%B3%95%5D%E8%99%9A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[在此输入你的密码以便阅读全文 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HAOI2012]高速公路 线段树 luoguP2221]]></title>
    <url>%2F2019%2F03%2F31%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2221%2F</url>
    <content type="text"><![CDATA[$3$ 月份的最后一篇题解了呢……明天就属于 $4$ 月了，离省选不远了…$QwQ$… 发现窝真的很制杖，我们先来聊聊刚开始窝的想法。 我画了画图，然后发现，对于最后答案的分母(不是最简)，是这个序列中这些数的值(废话)，然后发现了每个点的出现次数，然后线段树维护求和。发现效率很低于是试图将出现次数般到二维平面上，然后曼哈顿距离转切比雪夫距离然后二维树状数组维护然后 $WA$ 了然后弃疗。 你可能认为窝很傻对吧？ 嗯对窝是挺傻的。 正解是线段树，没猜错，但是和什么二维树状数组有什么关系 我们考虑区间中的一个点 $i$ ，权值为 $v_i$ 。然后我们观察当前询问区间中有多少子区间包含了 $v_i$ ，这个个数就是点 $i$ 做出的贡献。现在我们来考虑怎么计算这个包含了 $i$ 的子区间个数。 可以发现，我们从 $i$ 向左扩展若干个点，然后又向右扩展若干个点，这样子一来就成了一个包含了 $i$ 子区间。这个就很好计算了，答案显然为 $(i-l)\times(r-i)$ 。然后还要算进没有向左/右扩展的情况，并且算上权值，最终 $i$ 造成的贡献显然为： v_i\times(i-l+1)\times (r-i+1)那么我们将式子拆开可以得到： v_i\times [i\times (r-i+1)-l\times(r-i+1)+(r-i+1)]v_i\times [i\times r-i\times i+i-l\times r+l\times i-l+r-i+1]v_i\times [i(r+l)-i^2-lr-l+r+1]v_i i(r+l)-v_ii^2-v_ilr+v_i(r-l)+v_i其中 $l,r$ 为当前询问区间，这个是可以直接算出的。我们发现我们需要维护的就是 $v_i\ ,\ v_ii\ ,\ v_ii^2$ 三个值，用线段树维护即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e5+2;const int inf=1e9+9;int n,m;char op[2];namespace OI &#123; template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x; &#125; template &lt;typename _Tp&gt; _Tp gcd(_Tp x,_Tp y) &#123; return y?gcd(y,x%y):x; &#125;&#125;using namespace OI;struct Segment_Tree &#123; #define mid ((l+r)&gt;&gt;1) #define LS(x) ((x)&lt;&lt;1) #define RS(x) ((x)&lt;&lt;1|1) ll ans1,ans2,ans3; ll sum1[N&lt;&lt;2],sum2[N&lt;&lt;2],sum3[N&lt;&lt;2]; ll tag[N&lt;&lt;2],suq[N&lt;&lt;2],rle[N&lt;&lt;2],len[N&lt;&lt;2]; void build(ll x,ll l,ll r) &#123; if(l==r) &#123; len[x]=1,suq[x]=l,rle[x]=l*l; return; &#125; build(LS(x),l,mid),build(RS(x),mid+1,r); len[x]=len[LS(x)]+len[RS(x)]; suq[x]=suq[LS(x)]+suq[RS(x)], rle[x]=rle[LS(x)]+rle[RS(x)]; &#125; void pushdown(ll x,ll l,ll r) &#123; ll k=tag[x];tag[x]=0; sum1[LS(x)]+=len[LS(x)]*k,sum1[RS(x)]+=len[RS(x)]*k; sum2[LS(x)]+=suq[LS(x)]*k,sum2[RS(x)]+=suq[RS(x)]*k; sum3[LS(x)]+=rle[LS(x)]*k,sum3[RS(x)]+=rle[RS(x)]*k; tag[LS(x)]+=k,tag[RS(x)]+=k; &#125; void update(ll x,ll l,ll r,ll L,ll R,ll v) &#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; tag[x]+=v; sum1[x]+=len[x]*v; sum2[x]+=suq[x]*v; sum3[x]+=rle[x]*v; return; &#125; if(tag[x])pushdown(x,l,r); if(L&lt;=mid)update(LS(x),l,mid,L,R,v); if(R&gt;mid)update(RS(x),mid+1,r,L,R,v); sum1[x]=sum1[LS(x)]+sum1[RS(x)]; sum2[x]=sum2[LS(x)]+sum2[RS(x)]; sum3[x]=sum3[LS(x)]+sum3[RS(x)]; &#125; void query(ll x,ll l,ll r,ll L,ll R) &#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; ans1+=sum1[x],ans2+=sum2[x],ans3+=sum3[x]; return; &#125; if(tag[x])pushdown(x,l,r); if(L&lt;=mid)query(LS(x),l,mid,L,R); if(R&gt;mid)query(RS(x),mid+1,r,L,R); &#125; &#125;T;int main() &#123; IN(n),IN(m); T.build(1,1,n); for(int i=1;i&lt;=m;++i) &#123; scanf("%s",op); ll l,r;IN(l),IN(r);--r; ll v; if(op[0]=='C') IN(v),T.update(1,1,n,l,r,v); else if(op[0]=='Q') &#123; T.ans1=T.ans2=T.ans3=0; T.query(1,1,n,l,r); ll res1=T.ans1,res2=T.ans2,res3=T.ans3; ll ans=(r-l+1-l*r)*res1+(r+l)*res2-res3; ll len=(r-l+1)*(r-l+2)/2; ll esw=gcd(ans,len); printf("%lld/%lld\n",ans/esw,len/esw); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2011]消耗战 虚树+树形DP luoguP2495]]></title>
    <url>%2F2019%2F03%2F31%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2495%2F</url>
    <content type="text"><![CDATA[去 $Mina!$ 上了解了一波虚树，$\%\%\% XZY$ 学长太强辣！ 这次总算明白了些虚树，然后 $XZY$ 大佬的例题就是消耗战。 于是看了过来。 首先，考虑普通的树形 $DP$ ，设 $dp[u]$ 表示在 $u$ 为根的子树中满足目标所花费的最小代价 ，那么转移方程也不是很难，我们枚举 $u$ 的孩子 $v$ 。如果 $v$ 本身就是”能源丰富的岛屿”那么 $dp[u]+=G[i].val$ ，其中 $G[i].val$ 表示 $u$ 到 $v$ 的边的边权。为什么这样转移呢？因为 $v$ 必须切断。 那么没有必要切断的岛屿呢？就分切/不切两种情况了： dp[u]+=min(G.val[i],dp[G.to[i]]);这个也很好懂。 这个时候我们打完代码交一发发现只有 $40$ 分……往下看，可以看到 $n$ 到最后的顶尖数据有 $250000$ …… 但是我们可以观察到，$\sum k_i \leq 5*10^5$ ，发现总共的 $k$ 也不过这么大，这个时候我们可以用虚树来解决。 $Qiuly$ ：有关虚树的文章先咕一下蛤，最近有点忙。 建好虚树后直接用上面的转移方程做就得了。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2.5e5+7;const int LogN=27;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct graph &#123; int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],val[N&lt;&lt;1],cnt; void init() &#123;memset(head,-1,sizeof(head));cnt=0;&#125; graph() &#123;init();&#125; void add(int u,int v,int w) &#123; nxt[cnt]=head[u],to[cnt]=v,val[cnt]=w,head[u]=cnt++; &#125;&#125;G;int n,m,point[N],stack[N],top;ll dp[N];bool vis[N];namespace LCA &#123; int dep[N],fa[N][LogN+3],num[N][LogN+3]; int id[N],dfn,Edge_Mx; void _Pre_Lca(int u,int f) &#123; fa[u][0]=f,dep[u]=dep[f]+1,id[u]=++dfn; for(int i=1;i&lt;=LogN;++i) &#123; fa[u][i]=fa[fa[u][i-1]][i-1]; num[u][i]=min(num[u][i-1],num[fa[u][i-1]][i-1]); &#125; for(int i=G.head[u];~i;i=G.nxt[i]) if(G.to[i]!=f)num[G.to[i]][0]=G.val[i],_Pre_Lca(G.to[i],u); &#125; int lca(int x,int y) &#123; Edge_Mx=inf; if(x==y)return x; if(dep[x]&lt;dep[y])swap(x,y); for(int i=LogN;i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) Edge_Mx=min(Edge_Mx,num[x][i]),x=fa[x][i]; if(x==y)return x; for(int i=LogN;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) Edge_Mx=min(Edge_Mx,min(num[x][i],num[y][i])), x=fa[x][i],y=fa[y][i]; return fa[x][0]; &#125;&#125;using namespace LCA;bool cmp(int x,int y) &#123;return id[x]&lt;id[y];&#125;void solve(int u) &#123;//DP过程 dp[u]=0; for(int i=G.head[u];~i;i=G.nxt[i]) &#123; solve(G.to[i]); if(vis[G.to[i]])dp[u]+=G.val[i]; else dp[u]+=min((ll)G.val[i],dp[G.to[i]]); &#125;return;&#125;void build(int k) &#123;//建立虚树 sort(point+1,point+1+k,cmp); stack[top=1]=1,G.cnt=0,G.head[1]=-1; for(int i=1;i&lt;=k;++i) if(point[i]!=1) &#123; int l=lca(stack[top],point[i]); if(l!=stack[top]) &#123; while(id[l]&lt;id[stack[top-1]]) &#123; lca(stack[top-1],stack[top]); G.add(stack[top-1],stack[top],Edge_Mx); --top; &#125; if(id[l]&gt;id[stack[top-1]]) &#123; G.head[l]=-1,lca(l,stack[top]); G.add(l,stack[top],Edge_Mx),stack[top]=l; &#125; else lca(l,stack[top]),G.add(l,stack[top],Edge_Mx),--top; &#125; G.head[point[i]]=-1,stack[++top]=point[i]; &#125; for(int i=1;i&lt;top;++i) lca(stack[i],stack[i+1]),G.add(stack[i],stack[i+1],Edge_Mx);&#125;int main() &#123; IN(n); for(int i=1;i&lt;n;++i) &#123; int u,v,w;IN(u),IN(v),IN(w); G.add(u,v,w),G.add(v,u,w); &#125; _Pre_Lca(1,0),IN(m); while(m--) &#123; int k;IN(k); for(int i=1;i&lt;=k;++i)IN(point[i]),vis[point[i]]=true; build(k); solve(1),printf("%lld\n",dp[1]); for(int i=1;i&lt;=k;++i)vis[point[i]]=false; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>虚树</tag>
        <tag>题解</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [AHOI2013]差异 后缀自动机.SAM luoguP4248]]></title>
    <url>%2F2019%2F03%2F30%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4248%2F</url>
    <content type="text"><![CDATA[刚开始发现 $SA$ 很可做，不过当时没有看范围，心想美滋滋了这个就是 $SA$ 的板子，然后一看范围心就凉了。 不过可以用 $SAM$ ，我们知道，对于两个串，它们的最长公共子串就是它们在前缀树上的 $Lca$ 。这是显然的，不明白的同学可以康康 $Qiuly$ 酱之前写的 $SAM$ ，可以观察观察图片。 我们观察式子，发现 $\sum_{1\leq i&lt;j\leq n} len(T_i)+len(T_j)$ 是等于 $\frac{(n-1)\times n\times(n+1)}{2}$ 的，这个可以 $O(1)$ 算出。 那么 $2\times lcp(T_i,T_j)$ 怎么求呢？ 那么对于一个结点 $x$ ，我们依次统计 $x$ 的儿子，并依次更新 $x$ 的 $size$ ，对于一个 $x$ 的儿子 $y$ ，枚举的时候它对答案的贡献显然是 $size[x]\times len[x]\times size[y]$ ，因为 $y$ 的子树中的任意一结点(包括 $y$ ) ，与 $x$ 之前枚举过的所有儿子的子树中的所有结点的 $Lca$ 都是 $x$ 。并且对于一个 $x$ ，它所造成的贡献就是 $Len[x]$ 。 最后统计出来的答案再乘上 $2$ 就是后面那个式子啦~\(≧▽≦)/~ 。 不过要注意一点，后缀自动机是会复制结点的，这些复制的结点不属于原串因此不能计算贡献。 然后就是代码的问题了。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e6+7;struct SAM &#123; int last,cnt; int ch[N][26],fa[N],len[N],sz[N],hep[N],tot[N]; SAM() &#123;last=cnt=1;&#125; inline void ins(int c) &#123; int p=last,np=++cnt; last=np,len[np]=len[p]+1,sz[np]=1; while(p&amp;&amp;!ch[p][c]) ch[p][c]=np,p=fa[p]; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt;len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[nq]=fa[q],fa[q]=fa[np]=nq; while(p&amp;&amp;ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125;return; &#125; inline ll calc() &#123; ll res=0; for(int i=1;i&lt;=cnt;++i) hep[len[i]]++; for(int i=1;i&lt;=cnt;++i) hep[i]+=hep[i-1]; for(int i=1;i&lt;=cnt;++i) tot[hep[len[i]]--]=i; for(int i=cnt;i&gt;=1;--i) &#123; int node=tot[i]; res+=(ll)sz[fa[node]]*sz[node]*len[fa[node]]; sz[fa[node]]+=sz[node]; &#125;return res; &#125;&#125;T;char s[N];int main() &#123; scanf("%s",s); int n=strlen(s); for(int i=0;i&lt;n;++i)T.ins(s[i]-'a'); printf("%lld\n",(ll)(n-1)*n*(n+1)/2-2*T.calc()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>后缀自动机.SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [CQOI2011]动态逆序对 CDQ分治 luoguP3157]]></title>
    <url>%2F2019%2F03%2F30%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3157%2F</url>
    <content type="text"><![CDATA[一个可爱的 $CDQ$ ，我们将原始序列看成一个一个加入，然后后面的操作就是一个一个删除，这么一个一个操作我们都记下来，然后每个操作记一个 $id$ 表示它将为第几个时间点做出贡献。 当然对于原始序列的一个一个插入的操作这里的贡献是 $1$ ，删除操作的贡献自然是 $-1$ 。 每个时间点统计答案，最后输出前做一个前缀和然后依次输出就好了。 这是具体的框架，但是统计 $ans$ 数组具体怎么做呢？ 可以知道对于一个位置 $i$ ，位置上的元素是 $a_i$ 。对于一个 $j$ 满足 $j\leq i$ ，并且 $a_i\leq a_j$ ，而且还要保证 $id_j\leq id_i$ ，那么 $j$ 就可以对 $i$ 做出贡献。这个就是在 $i$ 前面的元素可以做出的贡献。$i$ 后面的元素做出的贡献同理。 这就是一个很普通的三位偏序了，注意要开 $long\ long$ 。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=2e5+2;template &lt;typename _Tp&gt; inline void IN(_Tp &amp;x)&#123; x=0;int flag=0;char ch; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int n,m,cnt,pos[N],a[N];long long ans[N];struct Query&#123;int r,v,d,id;&#125;Q[N];bool cmp(Query a,Query b) &#123;return a.d&lt;b.d;&#125;int C[N];#define lowbit(x) ((x)&amp;(-(x)))void add(int x,int v) &#123;for(;x&lt;=n;x+=lowbit(x))C[x]+=v;&#125;int sum(int x) &#123;int res=0;for(;x;x-=lowbit(x))res+=C[x];return res;&#125;inline void CDQ(int l,int r) &#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; CDQ(l,mid),CDQ(mid+1,r); sort(Q+l,Q+mid+1,cmp),sort(Q+mid+1,Q+r+1,cmp); int j=l; for(int i=mid+1;i&lt;=r;++i) &#123; while(j&lt;=mid&amp;&amp;Q[j].d&lt;=Q[i].d) add(Q[j].v,Q[j].r),++j; ans[Q[i].id]+=Q[i].r*(sum(n)-sum(Q[i].v)); &#125; for(int i=l;i&lt;j;++i) add(Q[i].v,-Q[i].r); j=mid; for(int i=r;i&gt;mid;--i) &#123; while(j&gt;=l&amp;&amp;Q[j].d&gt;=Q[i].d) add(Q[j].v,Q[j].r),--j; ans[Q[i].id]+=Q[i].r*sum(Q[i].v-1); &#125; for(int i=mid;i&gt;j;--i) add(Q[i].v,-Q[i].r);&#125;int main()&#123; IN(n),IN(m); for(int i=1;i&lt;=n;++i) IN(a[i]),pos[a[i]]=i,Q[++cnt]=(Query)&#123;1,a[i],i,0&#125;; for(int i=1;i&lt;=m;++i) &#123; int x;IN(x); Q[++cnt]=(Query)&#123;-1,x,pos[x],i&#125;; &#125; CDQ(1,cnt); for(int i=1;i&lt;=m;++i) ans[i]+=ans[i-1]; for(int i=0;i&lt;m;++i) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2013]森林 主席树+启发式合并 luoguP3302]]></title>
    <url>%2F2019%2F03%2F29%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3302%2F</url>
    <content type="text"><![CDATA[初看题面，看到 $K$ 大我们可以想到主席树，但是连边却又符合 $LCT$ ，但是毕竟 $LCT$ 是不能支持 $K$ 大的，因为 $Splay$ 辅助树不是二叉查找树。 不过主席树我们可以大力启发式合并，合并的时候重建节点的倍增数组并且重新建立节点的权值线段树。这样子每个节点要被修改的期望次数为 $logn​$ 次，那么时间复杂度就是 $O(nlog^2n)​$ (貌似是的)，这足以让我们过这道题了。 1.主席树如何上树上树[手动滑稽]…… 首先，对于节点 $u$ 的权值线段树，$ta$ 是由 $fa[u]$ 的权值线段树继承过来的，因为只是多了一个 $u$ ，所以主席树只是多增加了 $logn$ 个节点。 既然是从父亲节点继承过来的话，那么很显然我们可以在预处理倍增数组的时候顺便将主席树建好。 Code-builld:1234567void dfs(int u,int f) &#123; update(root[u],root[f],1,tmp,S(a[u])); fa[u][0]=f,dep[u]=dep[f]+1; for(int i=1;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=f) dfs(G[i].to,u);&#125; 这个很容易理解，那么我们怎么暴力合并两颗树呢？ 对于要合并的两颗树，我们选择将 $size$ 小的往 $size$ 大的并，对于给出的 $x,y$ ，我们先给 $x,y$ 连好边，然后将 $y$ 的权值线段树从 $x$ 更新，丢掉以前的。最后遍历 $y$ 的子树，更新其倍增数组和权值线段树即可。 至于 $size$ 的维护的话，我们可以找到 $x,y$ 所在的树的根。这个样子 $size$ 谁大谁小只需要判断 $x,y$ 所在的树的根的 $size$ 谁大谁小即可。我们在网下遍历 $y$ 的子树时每次都将$x$ 所在树的根的 $size$ 加一即可。 Code-merge:12345678910111213void merge(int rt,int u,int f) &#123; /*rt:x所在树的根，u:当前需要重构的节点,刚进入函数的时候为y*/ /*f:当前需要重构的节点的父节点，刚进入函数的时候为x*/ fa[u][0]=f,dep[u]=dep[f]+1;//更新深度 for(int i=1;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; /*更新倍增数组*/ size[rt]++,//更新size sta[u]=f,//记录父亲(不是倍增数组,这是用来查询所在树的根的) vis[u]=true;//记录一下 update(root[u],root[f],1,tmp,S(a[u]));//重建 for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=f) merge(rt,G[i].to,u);//遍历子树&#125; 然后差不多了，至于 $sta$ 的话，因为要查询所在树的根，为了提高效率我们可以将其作为并查集的形式。 还有一点，对于 $vis$ 数组，实际上我们建树的时候就直接用 $merge$ 好了，$vis$ 只是用来判重而已，因为是森林，有很多树。所以说我们可以不用 $dfs$ 就将初始形态的树建好。 Code-pre:12for(int i=1;i&lt;=n;++i) if(!vis[i]) &#123;merge(i,i,0);sta[i]=i;&#125; 最后需要注意的就是主席树的空间要开很大，差不多是 $nlog^2n$ ，因为有很多结点。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=8e4+7;const int LogN=22;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int testcase,lastans,n,m,T,a[N],b[N],tmp,head[N],cnt;int size[N],sta[N],vis[N];struct Edge &#123;int nxt,to;&#125;G[N&lt;&lt;2];inline int S(int x) &#123;return lower_bound(b+1,b+1+tmp,x)-b;&#125;inline void add(int u,int v) &#123; G[++cnt]=&#123;head[u],v&#125;,head[u]=cnt; G[++cnt]=&#123;head[v],u&#125;,head[v]=cnt;&#125;namespace Segment_Tree &#123; #define mid ((l+r)&gt;&gt;1) int root[N],tot; struct tree &#123;int l,r,v;&#125;t[N*601]; void update(int&amp;now,int last,int l,int r,int pos) &#123; now=++tot,t[now]=t[last],t[now].v++; if(l==r) return; if(pos&lt;=mid) update(t[now].l,t[last].l,l,mid,pos); else update(t[now].r,t[last].r,mid+1,r,pos); &#125; int query(int r1,int r2,int r3,int r4,int l,int r,int k) &#123; if(l==r) return l; int th=t[t[r1].l].v+t[t[r2].l].v-t[t[r3].l].v-t[t[r4].l].v; if(k&lt;=th) return query(t[r1].l,t[r2].l,t[r3].l,t[r4].l,l,mid,k); else return query(t[r1].r,t[r2].r,t[r3].r,t[r4].r,mid+1,r,k-th); &#125; #undef mid&#125;using namespace Segment_Tree;int dep[N],fa[N][LogN+4];int lca(int x,int y) &#123; if(x==y)return x; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=LogN;i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i]; if(x==y)return x; for(int i=LogN;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void merge(int rt,int u,int f) &#123; fa[u][0]=f,dep[u]=dep[f]+1; for(int i=1;i&lt;=LogN;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; size[rt]++, sta[u]=f, vis[u]=true; update(root[u],root[f],1,tmp,S(a[u])); for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=f) merge(rt,G[i].to,u);&#125;int find(int u) &#123;return u==sta[u]?u:sta[u]=find(sta[u]);&#125;int main() &#123; IN(testcase); IN(n),IN(m),IN(T); for(int i=1;i&lt;=n;++i) IN(a[i]),b[i]=a[i],sta[i]=i; sort(b+1,b+1+n); for(int i=1;i&lt;=n;++i) if(b[i]!=b[i-1])b[++tmp]=b[i]; for(int i=1;i&lt;=m;++i) &#123; int x,y;IN(x),IN(y);add(x,y); &#125; for(int i=1;i&lt;=n;++i) if(!vis[i]) &#123;merge(i,i,0);sta[i]=i;&#125; for(int i=1;i&lt;=T;++i) &#123; char op[2];int x,y,k; scanf("%s",op);IN(x),IN(y); if(op[0]=='L') &#123; x^=lastans,y^=lastans; add(x,y); int a=find(x),b=find(y); if(size[a]&lt;size[b])swap(x,y),swap(a,b); merge(a,y,x); &#125; else &#123; IN(k); x^=lastans,y^=lastans,k^=lastans; int lca_xy=lca(x,y); lastans=b[query(root[x],root[y], root[lca_xy],root[fa[lca_xy][0]],1,tmp,k)]; printf("%d\n",lastans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>启发式合并</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2008]Sandy的卡片 后缀数组.SA luoguP2463]]></title>
    <url>%2F2019%2F03%2F28%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2463%2F</url>
    <content type="text"><![CDATA[后缀数组，我们可以先将所有的卡片连成一个串，每一个卡片数列之间用一个极大数分开保证不出锅。然后的话，对于相同的定义有些鬼，使得我们不能直接做 $SA$ ，这个时候我们将所有的卡片数列的值都转换为当前位置减去上个位置的值即可。 然后就是统计答案，我们二分这个最长公共子序列的长度，每一次去判断是否合法。怎么判断呢？首先对于 $height$ 数组，如果要满足要求的话选取的这一段的 $height$ 数组的值都不能小于当前的 $mid$ ，这是显然的。 怎么确保我们将所有的卡片数列都选了呢？直接开一个 $vis​$ 数组即可，然后在碰到不合法的地方(也就是 $height[i]​$ 小于了 $mid​$ )全部清空即可。 最后如何判断当前的 $mid$ 是否合法呢？很显然，只有在所有的卡片数列都成功选择的情况下就合法了。我们用一个栈维护 $vis$ ，清空方便，然后当栈顶为卡片序列数的时候，也就是所有的卡片序列都选择的时候，$mid$ 就合法了。 然后有个悲催的事情，窝打二分的时候……打成了这样： 12345while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,l=mid+1; r=mid-1;&#125; 很显然，$r$ 前面应该要有 $else$ ，但是窝看了一晚上都没看出来……. Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2e6+7;const int M=5e2+7;const int G=5e3+7;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace SA &#123; int n,m,S[N],sa[N],height[N],x[N],y[N],hep[N]; inline void pre_sa() &#123; ++m; for(int i=1;i&lt;=n;++i) x[i]=S[i]; for(int i=1;i&lt;=n;++i) hep[x[i]]++; for(int i=1;i&lt;=m;++i) hep[i]+=hep[i-1]; for(int i=n;i&gt;=1;--i) sa[hep[x[i]]--]=i; for(int w=1,p=0;m=p,p&lt;n;w&lt;&lt;=1) &#123; p=0; for(int i=1;i&lt;=w;++i) y[++p]=n-w+i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;w) y[++p]=sa[i]-w; for(int i=0;i&lt;=m;++i) hep[i]=0; for(int i=1;i&lt;=n;++i) hep[x[i]]++; for(int i=1;i&lt;=m;++i) hep[i]+=hep[i-1]; for(int i=n;i&gt;=1;--i) sa[hep[x[y[i]]]--]=y[i]; swap(x,y); x[sa[1]]=p=1; for(int i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+w]==y[sa[i-1]+w])?p:++p; &#125;return; &#125; inline void pre_height()&#123; for(int i=1;i&lt;=n;++i)x[sa[i]]=i; int k=0; for(int i=1;i&lt;=n;++i)&#123; k-=k&gt;0; int j=sa[x[i]-1]; while(j+k&lt;=n&amp;&amp;i+k&lt;=n&amp;&amp;S[j+k]==S[i+k])++k; height[x[i]]=k; &#125;return; &#125;&#125;using namespace SA;int vis[G],stack[G],top;int num,len[G],id[N],a[G][M];inline bool check(int x) &#123; while(top) vis[stack[top--]]=0; for(int i=1;i&lt;=n;++i) &#123; if(height[i]&lt;x) &#123; while(top) vis[stack[top--]]=0; &#125; if(!vis[id[sa[i]]]) &#123; stack[++top]=id[sa[i]],vis[id[sa[i]]]=true; if(top==num) return true; &#125; &#125;return false;&#125;int main() &#123; IN(num); int mx=-inf,mi=inf,l=0,r=inf; for(int i=1;i&lt;=num;++i) &#123; IN(len[i]),r=min(r,len[i]-1); for(int j=1;j&lt;=len[i];++j) &#123; IN(a[i][j]); if(j!=1)mx=max(mx,a[i][j]-a[i][j-1]); &#125; &#125; for(int i=1;i&lt;=num;++i) &#123; for(int j=2;j&lt;=len[i];++j) S[++n]=a[i][j]-a[i][j-1],id[n]=i,mi=min(mi,S[n]); S[++n]=++mx; &#125; m=0; for(int i=1;i&lt;=n;++i) S[i]=S[i]-mi+1,m=max(m,S[i]); pre_sa(),pre_height(); int ans=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid))ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d\n",ans+1); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>后缀数组.SA</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【考试总结】 Test-2019.3.28 HNOI2019模拟]]></title>
    <url>%2F2019%2F03%2F28%2F%5B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%5Dtest20190328%2F</url>
    <content type="text"><![CDATA[今天的题目貌似暴力分好拿写欸，然而……窝只有 $70$ ？不过排名比昨天上升了什么鬼。 $QwQ$ 题目的确很难懂，所以窝听了讲解后也没听懂多少，不过还是改出了第一题(第一题是人就改的出好吧o(≧口≦)o)。 题目压缩包戳我!!!~\(≧▽≦)/~(有时链接可能会崩，如果崩了的话请稍后尝试QwQ) T1 期望得分：30分实际得分：30分正解：找规律??窝的解法：暴力模拟题意 题解：第一眼看到题目，欸，如果按照题面模拟就有 $30$ 分！出题人良心啊。然后看数据范围，$100\%$ 的数据的 $n\leq 3\times10^7$ ，这应该是 $O(n)$ 算法才行啊，于是想，或许是线性 $DP$ ，然后推式子，推出这么一个鬼玩意： f[i]=f[i-1]+sum(a[i])$sum(a[i])$ 就是在 $1$ 到 $i-1$ 中大于 $a[i]$ 的数的个数，然后 $f[i]$ 表示将前 $i$ 个元素进行冒泡需要的交换次数。 很显然这是错的。 然后我就想到了 $NOI$ 往年的冒泡排序(貌似是 $NOI$ 的?)，其实两道题没什么联系。 哎好吧发现过不去直接上暴力吧，题目说什么就做什么，于是把我用来对拍的暴力程序提交了上去，$30$ 分。 接下来讲讲正解。 很显然，对于一个元素 $a_i$ ，它所在的位置为 $i$ ，然而最后排好序后 $ta$ 应该回到的位置为 $a_i$ 。观察冒泡过程，发现对于一个元素，每次冒泡排序都最多会将 $ta$ 向自己的目标位置移动一格。 然后就是，比如说当前序列的最小元素，假设最小元素的起点位置为 $s$ ,我们发现每次冒泡总会将 $ta$ 向前移一格，然后在第 $s-1$ 次冒泡排序的时候 $1$ 归位了。然后发现 $1$ 的移动对 $2$ 的移动次数并没有产生影响，这个时候将 $1$ 删去，发现 $2$ 归位的移动次数变成了 $2$ 的初始位置 $-$ $1$ ，放在原序列中就是 $2$ 的初始位置 $-$ $2$ 。 这至少说明，对于任意一个元素 $i$ ，其所需要的移动次数为 $i-a_i$ 。 那么，如果要使序列有序，所需要的排序次数就是 $max\{ i-a_i \}$ 。直接计算答案即可。 (实际上窝也不是很明白…..貌似是这样的吧 $QwQ$ ) Code：12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n,S,B,C,D,A[10006];int main() &#123; freopen("magician.in","r",stdin); freopen("magician.out","w",stdout); scanf("%d%d%d%d%d",&amp;n,&amp;S,&amp;B,&amp;C,&amp;D); for(int i=1;i&lt;=n;++i) &#123; A[i]=i; S=(S*B+C)%D; swap(A[i],A[(S%i)+1]); &#125; int counter=0; for(int i=1;i&lt;=n;++i)counter=max(counter,i-A[i]); printf("%d\n",counter); return 0;&#125; T2 期望得分：30分实际得分：0分正解：容斥+搜索+剪枝窝的解法：暴搜 题解：不会………….然后暴搜打挂了没得分。 所以这不能说是题解，留个坑吧。 T3 期望得分：40分实际得分：40分正解：将所有颜色维护成链，然后分块加速窝的解法：直接维护成链 对于一个 $i$ ，如果 $a_i=k$ ，并且 $a_j=k$ ，而且 $i$ 和 $j$ 是离得最近的，则将它们向前向星那样连起来，最后对询问的区间直接暴力跳即可。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=5e5+7;const int LogN=27;vector&lt;int&gt; seq;map&lt;int,int&gt; hashs;int n,q,a[N],head[N],nxt[N],f[LogN+7][N],logs[N],ans;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline void pre_st()&#123; logs[0]=-1; for(int i=1;i&lt;=n;++i)logs[i]=logs[i&gt;&gt;1]+1; for(int i=1;i&lt;=n;++i)f[0][i]=a[i]; for(int t=1;t&lt;LogN;++t) for(int i=1;i&lt;=n;++i) if(i+(1&lt;&lt;t)-1&lt;=n) f[t][i]=max(f[t-1][i],f[t-1][i+(1&lt;&lt;(t-1))]);&#125; inline int query(int x,int y)&#123; int t=logs[y-x+1]; return max(f[t][x],f[t][y-(1&lt;&lt;t)+1]);&#125; inline void solve(int x,int lim) &#123; for(int now=x,last=nxt[x];last&gt;=lim;last=nxt[last]) &#123; while(now&gt;last&amp;&amp;query(last,now)&gt;a[last]) now=nxt[now]; ans=max(ans,now-last+1); &#125;&#125; inline void make_hashs() &#123; sort(seq.begin(),seq.end()); seq.erase(unique(seq.begin(),seq.end()),seq.end()); for(int i=0;i&lt;seq.size();++i) hashs[seq[i]]=i+1; for(int i=1;i&lt;=n;++i) a[i]=hashs[a[i]]; memset(head,-1,sizeof head);&#125;int main() &#123; freopen("spiral.in","r",stdin); freopen("spiral.out","w",stdout); IN(n),IN(q); for(int i=1;i&lt;=n;++i) IN(a[i]),seq.push_back(a[i]); make_hashs(); for(int i=1;i&lt;=n;++i) nxt[i]=head[a[i]],head[a[i]]=i; pre_st(); while(q--) &#123; ans=1; int x,y;IN(x),IN(y); for(int i=y;i&gt;=x;--i) solve(i,x); printf("%d\n",ans); &#125; return 0;&#125; 正解不费………………………………….]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>考试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【考试总结】 Test-2019.3.27 HNOI2019模拟]]></title>
    <url>%2F2019%2F03%2F27%2F%5B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%5Dtest20190327%2F</url>
    <content type="text"><![CDATA[今天全是原题，然而窝几乎都没做过，于是挂了…… 丢人的是考场上组合数的式子 $C[i][j]$=$C[i$-$1][j]$+$C[i$-$1][j$-$1]$ 写成了 $C[i][j]$=$C[i][j$-$1]$+$C[i$-$1][j$-$1]$ ，然后第一题光荣爆 $0​$ ……TAT。 吸取教训！ 题目压缩包戳我!!!~\(≧▽≦)/~(有时链接可能会崩，如果崩了的话请稍后尝试QwQ) T1 期望得分：100分实际得分：0分正解：Purfer+DP+组合数学窝的解法：Purfer+DP+组合数学 题解：十年OI一场空，组合数打错见祖宗。 上面的正解有误，听说 $DP$ 不是正解，不过，$DP$ 复杂度高达 $O(n^4)$ ，本应该 $T$ 的，却仗着小常数不仅 $AC$ ，还爆踩标程？这究竟是道德的沦丧还是人性的扭曲？ 不了不了，正经一点。众所周知，有个东西叫 $Purfer$ 序列，对于每一个不同的树，都有不同的 $Purfer$ 序列。所以每个树都可以用其 $Purfer$ 序列来表示，这个树中的每个结点在 $Purfer$ 序列中的出现次数为其度数减一。至于$Purfer​$ 序列具体是什么就不赘述了。 那么 $DP​$ 方程怎么设？ 我们设 $f[i][j][k]$ 表示 从前 $i$ 个结点中选出 $j$ 个结点，并且这 $j$ 个结点共在原树的 $Purfer$ 序列出现了 $k$ 次的合法 $Purfer$ 序列的数量 。 那么转移呢？很显然分为两种情况： 没选第 $i​$ 个点。 选了第 $i​$ 个点。 然后分别进行转移，这就很简单了： 没选：$f[i][j][k]+=f[i-1][j][k]​$ 选了：$f[i][j][k]+=f[i-1][j-1][k-d]\times C[k][d]​$ 其中 $d​$ 为我们正在枚举的第 $i​$ 个点的出现次数 $(0​$ ~ $du[i]-1)​$ ，然后就是下面的组合数，就是代表着在 $k-d​$ 长度的序列中插入 $d​$ 个 $i​$ 的方案数 。当然也可以这么写： f[i][j+1][d+k]+=C[d+k][d]\times f[i-1][j][k]​ 我们知道一棵 $n​$ 个结点的树的 $Purfer​$ 序列的长度是 $n-2​$ 的，所以我们的答案应该就是 $f[n][i][i-2]​$ 。 最后，记得随时膜模！ Code:1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=57;const int MOD=1000000007;int du[N],n,T;ll C[N][N],f[N][N][N];int main() &#123; C[0][0]=1; for(int i=1;i&lt;=50;++i)&#123; C[i][0]=C[i][i]=1; for(int j=1;j&lt;i;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;//就是这儿! &#125; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;du[i]); memset(f,0,sizeof(f)); f[0][0][0]=1; for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;i;++j) for(int k=0;k&lt;=n-2;++k) &#123; f[i][j][k]=(f[i][j][k]+f[i-1][j][k])%MOD; for(int d=0;d&lt;du[i]&amp;&amp;d+k&lt;=n-2;++d) f[i][j+1][d+k]=(f[i][j+1][d+k]+C[d+k][d]*f[i-1][j][k]%MOD)%MOD; &#125; printf("%d ",n); for(int i=2;i&lt;=n;++i)printf("%lld ",f[n][i][i-2]); printf("\n"); &#125; return 0;&#125; T2 期望得分：5分实际得分：30分正解：???没发sol……窝的解法：手玩小数据+瞎搞 题解：一看就是懵逼题……但是看到 $30$ 分的数据很小，并且还有菊花图，所以我们来瞎搞吧！刚开始的时候以为前六个点都是菊花图，然后都手玩，到后面才看清，只能说数据太弱了啊。 正解表示不明白……贴一发考场上的代码： Code:123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen("b.in","r",stdin); freopen("b.out","w",stdout); int n,k; scanf("%d%d",&amp;n,&amp;k); int x,flag=0; for(int i=1;i&lt;n;++i)&#123; scanf("%d",&amp;x); if(x!=0)flag=1; &#125; if(k==0)&#123;printf("1\n");exit(0);&#125; if(!flag) &#123;//菊花图输出瞎搞手玩？ if(n==1&amp;&amp;k&gt;=0)&#123;printf("1\n"),exit(0);&#125; if(n==2&amp;&amp;k&gt;=0)&#123;printf("1\n"),exit(0);&#125; if(n==3&amp;&amp;k==0)&#123;printf("1\n"),exit(0);&#125; if(n==3&amp;&amp;k&gt;=1)&#123;printf("3\n"),exit(0);&#125; if(n==4&amp;&amp;k==0)&#123;printf("1\n"),exit(0);&#125; if(n==4&amp;&amp;k==1)&#123;printf("7\n"),exit(0);&#125; if(n==4&amp;&amp;k&gt;=2)&#123;printf("10\n"),exit(0);&#125; if(n==5&amp;&amp;k==0)&#123;printf("1\n"),exit(0);&#125; if(n==5&amp;&amp;k==1)&#123;printf("13\n"),exit(0);&#125; &#125; else &#123;//其他情况输出样例？？ if(n==4)&#123;printf("8\n");exit(0);&#125; if(n==6)&#123;printf("28\n");exit(0);&#125; &#125; return 0;&#125; 实际上玩到 $n​$=$5\&amp;\&amp;k​$=$2​$ 的时候我就崩了，玩不下去了。 T3 期望得分：0分实际得分：0分正解：最小割窝的解法：没做…. 题解：真的看不出来是最小割啊 $QwQ$ ，以为是数论题，还看到质因子了感觉就更不像最小割了……但是在想题目的时候最小割的确出现在了我的脑海中，但是一闪就过了…… 一个有趣的事情：考试期间高二机房神仙一度怀疑此题为数论题，这个时候 $chl$神仙 和另一位 $Dalao$ 走了出去，站在门外讨论此题中的”物理”，说什么重心和”物理”有关因此此题不可做，然后树王神仙表示不懂”物理”中的”重心”准备弃疗，然而最终树王神仙还是选择了网络流…… 好吧不扯淡了，我们来讨论一下这题的粗略解法。 可以发现题目给出了一个限制：$N$ 最多有两个质因子。这个限制有什么用呢？ 对于一个有 $N$ 个扇叶的风扇，我们考虑平衡的并且独立扇叶只有一个的风扇： 左边的就是有 $(N=8)$ 个扇叶的风扇，右边的呢就是在 $8$ 个扇叶中有 $2$ 个扇叶的风扇 ($(A_1,D_1,F_1),$$(A_1,H_1,B_1)$)，可以知道这个 $2$ 个扇叶的风扇是一定平衡的，因为 $2$ 是 $8$ 的因子。 可以知道，对于 $8$ 的其他因子(例如 $4$ )是可以被质因子 $2$ 组成的，因此也是平衡的风扇。 那么对于两个不同的质因子，可以组成两个不同样式的且平衡的 $N$ 个扇叶的风扇的子风扇。 当然还有位置不同，对于上图中 $2$ 个扇叶的子风扇根据不同的位置有很多个： 这个时候我们的问题就可以转化如下了： 有两种类型的风扇 $p,q$ ，风扇类型等于 $2$ 的样子如上图，现在我们需要用这两种风扇无重叠的覆盖尽可能多的剩下的残缺扇叶。 这个时候考虑建图，我们从 $S$ 向所有不同位置的 $p$ 类风扇连一条边，边权为 $p$ ，表示选择了这个风扇可以多覆盖一共 $p$ 个扇叶。所有不同位置的 $q$ 类风扇向 $T$ 连边，边权为 $q$ ，和上面同理。 然后这个时候的最小割是什么呢？对于一个起点为 $x$ 的 $p$ 类风扇，我们将 $S$ 连向Ta的边切断，表示不使用起点为 $x$ 的 $p$ 类风扇，$q$ 类风扇同理。当然是不使用的风扇越少越好，剩下的可用的风扇当然是越多越好，所以成了最小割。 那么怎么表示无重叠呢？ 可以知道同类风扇是不可能重叠的，我们考虑异类风扇。我们对于一个 $p$ 类风扇和一个 $q$ 类风扇，如果其重叠了，那么只能选择其中一个，于是我们在这两个风扇间连一条边，边权为 $inf$ ，这个时候跑最大流的时候必定有流经过此地，也就是说这两个风扇必然要割掉一个才行。 所以什么事情都解决了，就差代码了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2e6+2;const int inf=2e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace Dinic &#123;//Dinic板子封装 queue&lt;int&gt; Que; int s,t,sum,head[N&lt;&lt;1],cnt=1,dep[N&lt;&lt;1]; struct Edge &#123;int nxt,to,val;&#125;G[N&lt;&lt;2]; inline void add(int u,int v,int w) &#123; G[++cnt]=&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=&#123;head[v],u,0&#125;,head[v]=cnt; &#125; inline int bfs() &#123; memset(dep,0,sizeof(dep)); dep[s]=1,Que.push(s); while(!Que.empty()) &#123; int u=Que.front(),v;Que.pop(); for(int i=head[u];i;i=G[i].nxt) if(!dep[v=G[i].to]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,Que.push(v); &#125;return dep[t]; &#125; int dfs(int u,int flow) &#123; if(!flow||u==t) return flow; int used=0,rlow,v; for(int i=head[u];i;i=G[i].nxt) if(dep[v=G[i].to]==dep[u]+1&amp;&amp;G[i].val&gt;0) &#123; used+=(rlow=dfs(v,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; if(!used) dep[u]=-1; return used; &#125; inline void dinic() &#123; while(bfs()) sum-=dfs(s,inf); &#125;&#125;using namespace Dinic;int n,m,p,q,point,bock[N],vis[N],fan[N];inline void pre() &#123; for(int i=1;i&lt;=n/p;++i) if(!bock[i]) &#123;//起点扇叶没有损坏 for(int j=i;j&lt;=n;j+=n/p) if(bock[j]) goto end1; //枚举每个扇叶，如果损坏的那么该风扇就不合法 ++point,add(s,point,p),sum+=p;//连边 for(int j=i;j&lt;=n;j+=n/p) fan[j]=point;//标记 end1:; &#125; for(int i=1;i&lt;=n/q;++i) if(!bock[i]) &#123; for(int j=i;j&lt;=n;j+=n/q) if(bock[j]) goto end2; ++point,add(point,t,q),sum+=q;//连边 for(int j=i;j&lt;=n;j+=n/q) vis[fan[j]]=false; //清理标记，防止有风扇被连两次边 for(int j=i;j&lt;=n;j+=n/q) if(fan[j]&amp;&amp;!vis[fan[j]]) vis[fan[j]]=true,add(fan[j],point,inf);//连边 end2:; &#125;return;&#125;int main() &#123; IN(n),IN(m);s=0,t=N-2; for(int i=1;i&lt;=m;++i) &#123;int x;IN(x),bock[x]=true;&#125; int copy=n,sqr=sqrt(n),first=0; for(int i=2;i&lt;=sqr;++i) &#123;/*寻找两个质因子p和q*/ if(!(n%i)&amp;&amp;!first) &#123; first=true,p=i; while(!(n%p))n/=p; &#125; else if(!(n%i)) &#123; q=i; while(!(n%q))n/=q; break; &#125; &#125; if(n!=1)q=n;n=copy; pre(),dinic(); if(!sum)printf("-1"); else printf("%d\n",n-m-sum); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>考试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈K-D Tree&学习笔记]]></title>
    <url>%2F2019%2F03%2F26%2F%5B%E7%AE%97%E6%B3%95%5DKD-Tree%2F</url>
    <content type="text"><![CDATA[又是一个神奇的数据结构…… $K$-$D \ Tree$ 中 $D$ 是维度($Dimension$)的缩写，所以 $K$-$D \ Tree$ 的实际意思就是 $K$ 维树。当然 $K$-$D \ Tree $ 一般用于维护二维平面上的信息，所以我们平常用的 $K$-$D\ Tree$ 又叫 $2$-$D \ Tree$ 。 假设我们现在有一个二维平面，二维平面上有若干个点 ，现在怎么用 $2​$-$D \ Tree​$ 维护这些点呢？很简单，我们将这些点建成一颗树，最好是一颗二叉搜索树，但是怎么建树呢？我们就来分割这个平面，横着一刀，竖着一刀，每次选取最优的结点当根即可。 可能很抽象，我们以下图为例，假设我们需要将下图的 $7$ 个点建成二叉搜索树： 首先我们准备竖着切，这个竖着切切哪里呢？我们会发现 $D$ 是最中间的结点，于是我们对着 $D$ 就是一刀，现在的矩阵分割成了两半，那么自然的 $A,B,C$ 就是 $D$ 的左子树中的结点，$E,F,G$ 就是 $D$ 的右子树中的结点。 然后我们先建 $D$ 的左子树，由于上一次是竖着切的，这一次我们需要横着切。我们递归下去，发现 $A,B,C$ 这一块 $B$ 是最中间的(以横着的视角，因为需要横着切嘛)，那么很显然 $D$ 的左儿子就是 $B$ 了，$A,C$ 分别是 $B$ 的两孩子，由于 $A,C$ 已经在 $B$ 的左右了并且只有一个点了，那么理所当然 $C$ 就是 $B$ 的左孩子，$A$ 就是 $B$ 的右儿子(横着看就好了)。 同样的，我们发现 $G$ 是 $D$ 左边横着切时最合适的结点(因为在横着的视角中 $G$ 是最中间的 )，于是我们将 $D$ 的右儿子定为 $G$ ，同样的，$F,E$ 为 $G$ 的两孩子。 那么这样子我们的树就建好了。 Code-build-kdt:123456789int build(int l,int r,int wd) &#123;//lr:当前对应的结点区间,wd:当前需要切的方向 if(l&gt;r) return 0; int x=new_node(),mid=(l+r)&gt;&gt;1;//新建结点 WD=wd,nth_element(p+l,p+mid,p+r+1),//重载了运算符，按照当前切的方向排序 tr[x].tp=p[mid];//找到最合适切割的最中间的结点 tr[x].l=build(l,mid-1,wd^1);//建立左子树 tr[x].r=build(mid+1,r,wd^1);//建立右子树 return pushup(x),x;//上传信息&#125; 但是怎么查询呢？实际上查询跟普通的二叉搜索树差不多，按照方位坐标查找即可。 对于一个结点的信息是这样的： Code-node-kdt1234struct node &#123; int mi[2],mx[2],l,r,sz; point tp;&#125;tr[N]; l,r,sz 就是左右儿子以及子树大小，point 显然是该结点代表的二维平面上的点，但是 $mi,mx$ 是干什么的呢？我们用 $mi,mx$ 记录的就是当前结点已经它的子树中的所有节点中，最大/最小的 $x$ 坐标以及最大/最小的 $y$ 坐标。 这样记录有什么用呢？假设我们将这个看成一个矩形，那么对于一个我们需要搜索的坐标，如果这个需要搜索坐标 已经不属于 $mi,mx$ 围城的矩阵中，那么这个需要搜索的坐标就跟当前子树没关系了，这也就相当于一个剪枝。 我们的 $pushup$ 上传时就是对 $mi,mx$ 进行更新，所以 $pushup$ 应该这样写： Code-pushup-kdt1234567891011121314151617inline void pushup(int x) &#123; int l=tr[x].l,r=tr[x].r;//简写左右儿子 tr[x].sz=tr[l].sz+tr[r].sz+1;//更新size for(int i=0;i&lt;=1;++i) &#123;//枚举方向，节省码量 /*---------更新mi[x],mx[x]---------*/ tr[x].mi[i]=tr[x].mx[i]=tr[x].tp.x[i]; if(l) &#123; tr[x].mi[i]=min(tr[x].mi[i],tr[l].mi[i]); tr[x].mx[i]=max(tr[x].mx[i],tr[l].mx[i]); &#125; if(r) &#123; tr[x].mi[i]=min(tr[x].mi[i],tr[r].mi[i]); tr[x].mx[i]=max(tr[x].mx[i],tr[r].mx[i]); &#125; /*---------更新mi[x],mx[x]---------*/ &#125;&#125; 然后呢，这里不待修改的，那么如果说要兹磁插入节点怎么办？ 需要兹磁插入节点的题目：[Violet]天使玩偶/SJY摆棋子 这道题因为允许离线，我们可以使用 $CDQ​$ ，但是如果强制在线的话就只能用 $K​$-$D \ Tree​$ 了。我们来讨论 $K​$-$D \ Tree​$ 的做法。 实际上 $K​$-$D \ Tree​$ 插入节点非常简单，就像普通的二叉搜索树那样找个位置插就好了。 Code-Insert-kdt12345678910void Insert(point tmp,int&amp;x,int wd) &#123;//tmp:当前需要插入的点,x:当前树中结点,wd:当前切割方向 if(!x) &#123;//找到要插入的位置了 x=new_node();//新建结点 tr[x].tp=tmp,tr[x].l=tr[x].r=0; pushup(x);return; &#125; if(tr[x].tp.x[wd]&lt;tmp.x[wd]) Insert(tmp,tr[x].r,wd^1);//应该往右插 else Insert(tmp,tr[x].l,wd^1); //否则往左插 pushup(x);//更新结点信息&#125; 但是呢，你会发现就像一般的二叉搜索树一样，这个插入很容易被卡，卡成一条链，这就很不舒服了。于是我们需要一些平衡树的思想，使得 $K$-$D \ Tree$ 保持平衡。 “我会 $Splay$ ！我会 无旋$Treap$ ！” 呸呸呸，今天我们讲的是替罪羊树，跟你俩没关系。 没错，就是用替罪羊树的思想，将 $K​$-$D \ Tree​$ 拍扁重建。差不多就是 $insert​$ 的时候，在 $insert​$ 的最后 $check​$ 一下子树是否平衡，如果当前结点的子树已经”不平衡”了，那么拍扁该结点以及该结点子树，重建。 这里的 $\alpha$ 的值一般定为 $0.75$ 左右，但是也不能确定，如果实在要掐得准的话就得看看询问多还是插入多了。不过一般用 $0.75$ 是没问题的。 Code-check&amp;pia-kdt:123456789void pia(int x,int num) &#123;//就是拍扁的意思,sto litble orz if(tr[x].l) pia(tr[x].l,num);//先拍左子树 p[num+tr[tr[x].l].sz+1]=tr[x].tp,trh[++top]=x;//再拍自己 if(tr[x].r) pia(tr[x].r,num+tr[tr[x].l].sz+1);//然后拍右子树&#125;void check(int&amp;x,int wd) &#123;//判断x的子树是否满足"平衡",wd记录当前切割方向,建树的时候有用 if(alph*tr[x].sz&lt;tr[tr[x].l].sz||alph*tr[x].sz&lt;tr[tr[x].r].sz)//判断 pia(x,0),x=build(1,tr[x].sz,wd);//拍扁 and 重新build建树&#125; 然后就是应用了，值得注意的是，如果维护的不是点而是矩形，那么有些地方(例如边界，$mi,mx​$ 都要注意)。 就像这道题：[APIO2018] Circle selection 选圆圈，注意一下细节就好。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>K-D Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 「网络流24题」最长不下降子序列问题 网络流 luoguP2766]]></title>
    <url>%2F2019%2F03%2F26%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2766%2F</url>
    <content type="text"><![CDATA[第一问显然是一个很简单的 $DP$ ，但是第二问和第三问就要用最大流来求了，怎么求呢？ 首先我们 $DP$ 出来的 $f$ 数组，$f[i]$ 表示以i结尾的最长不下降子序列的长度 ，然后就是网络流的连边了。首先因为一个点只能经过两次，我们需要将其拆为入点和出点，中间连的边的边权自然是 $1$ ，然后对于一个 $i$ ，如果 $f[i]$ 等于最长长度($s$)，那么很显然这个 $i$ 就可以给答案做出一个贡献，这个时候 $i$ 的出点向 $t$ 连一条边权为 $1$ 边。 如果 $i$ 等于 $1$ ，那么自然 $1$ 是可以作为一个起点的，那么 $s$ 向 $i$ 的入点连一条边权为 $1$ 的边即可。 然后就是剩下的情况了，可以想到让 $i$ 向 $i$ 能够最优转移的位置连边，也就是说，如果有一个 $j$ ，使得 $f[j]=f[i]+1$ 并且 $a[i]&lt;=a[j]$ ，这个时候如果是在最优方案中 $i$ 是可以转移到 $j$ 的，这个时候从 $i$ 的出点向 $j$ 的入点连一条边，边权依旧是 $1$ 。 然后我们这个时候跑最大流，就是第二问的答案。 那么第三问呢？ 很显然，对于 $1$ ，如果它是连向 $s$ 的，则将其连向 $s$ 的边的边权改为 $inf$ ，并将入点连出点的边权改为 $inf$ ，表示可以取无限次。然后 $n$ 如果连向了 $t$ ，也将边权改为 $inf$ ，并将入点连出点的边权改为 $inf$ ，和上面同理。这个时候再跑一次最大流即可，这就是第三问的答案了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e5+7;const int M=5e2+7;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace Dinic &#123; queue&lt;int&gt; q; int s,t,head[N],cnt=1,dep[N]; struct Edge &#123;int nxt,to,val;&#125;G[N]; inline void add(int u,int v,int w) &#123; G[++cnt]=&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=&#123;head[v],u,0&#125;,head[v]=cnt; &#125; inline int bfs() &#123; memset(dep,0,sizeof(dep)); dep[s]=1,q.push(s); while(!q.empty()) &#123; int u=q.front(),v;q.pop(); for(int i=head[u];i;i=G[i].nxt) if(!dep[v=G[i].to]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,q.push(v); &#125;return dep[t]; &#125; int dfs(int u,int flow) &#123; if(!flow||u==t) return flow; int used=0,rlow,v; for(int i=head[u];i;i=G[i].nxt) if(dep[v=G[i].to]==dep[u]+1&amp;&amp;G[i].val&gt;0) &#123; used+=(rlow=dfs(v,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; if(!used) dep[u]=-1; return used; &#125; inline int dinic() &#123; int maxflow=0; while(bfs()) maxflow+=dfs(s,inf); return maxflow; &#125;&#125;using namespace Dinic;int n,l,ans,a[N],f[N];inline int id(int type,int x) &#123; return type*n+x;&#125;int main() &#123; IN(n);s=0,t=2*n+1; for(int i=1;i&lt;=n;++i) &#123; IN(a[i]); for(int j=0;j&lt;i;++j) if(a[j]&lt;=a[i]) f[i]=max(f[i],f[j]+1); l=max(l,f[i]); &#125; printf("%d\n",l);/*Q1*/ for(int i=1;i&lt;=n;++i) &#123; add(id(0,i),id(1,i),1); if(f[i]==1) add(s,id(0,i),1); if(f[i]==l) add(id(1,i),t,1); for(int j=1;j&lt;i;++j) if(a[j]&lt;=a[i]&amp;&amp;f[i]==f[j]+1)add(id(1,j),id(0,i),1); &#125; ans=dinic(); printf("%d\n",ans);/*Q2*/ if(f[1]==1)add(s,id(0,1),inf),add(id(0,1),id(1,1),inf); if(f[n]==l)add(id(1,n),t,inf),add(id(0,n),id(1,n),inf); ans+=dinic(); printf("%d\n",ans);/*Q3*/ return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SCOI2010]股票交易 单调队列优化DP luoguP2569]]></title>
    <url>%2F2019%2F03%2F24%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2569%2F</url>
    <content type="text"><![CDATA[我们一起来推一推。 设 $f[i][j]$ 表示：现在是第 $i$ 天，手上拥有的股票数为 $j$ 时赚到的最多的钱 我们考虑转移几个方向：空手买，不买不卖，之前买过了现在继续买，买过后需要卖 空手买空手买就是第一次买，显然不要考虑 “间隔 $w$ 天” 的限制，直接买就好。 那么很容易得到转移式： f[i][j]= - AP_i\times j因为是买入，所以是负数。 不买不卖很显然可以直接从 $f[i-1][j]$ 转移过来。 转移式： f[i][j]=f[i-1][j]之前买过了现在继续买很显然这次我们需要考虑 $w$ 的限制了，不过我们可以直接从 $i-w-1$ 天转移。 假设我们是从 $f[i-w-1][k]$ 转移过来的，那么这次转移我们多买了 $j-k$ 张股票，容易得到转移式： f[i][j]=max\{f[i-w-1][k]-(j-k)\times AP_i\}当然因为规定了一天最多买入 $AS_i$ 股，上面的式子必须满足 $j-AS_i\leq k \leq j$ 买过之后需要卖同样的有 $w$ 的限制，但是跟上面的第三种情况没什么两样，转移式： f[i][j]=max\{ f[i-w-1][k] + (k-j)\times BP_i\}因为 $BS_i$ 的限制条件，上面的式子必须满足 $j\leq k \leq j+BS_i$ 时间复杂度？枚举 $i,j$ 状态就需要 $n^2$ 的复杂度，在这个基础上转移的复杂度为： 空手买 ： $O(1)$ 不买不卖 ： $O(1)$ 之前买过了现在继续买 ：$O(n)$ 买过之后需要卖 ：$O(n)$ 会发现如果加上枚举状态的复杂度，后面两个转移的总复杂度为 $O(n^3)$ ！ 于是考虑优化。 我们观察第三个转移式： f[i][j]=max\{f[i-w-1][k]-(j-k)\times AP_i\}对于当前的 $i,j$ ，假设有 $a,b$ 作为 $k$ 的两个选项对 $f[i][j]$ 进行转移，我们算一算 $a$ 比 $b$ 优的条件是什么： f[i][j]=max\{f[i-w-1][k]-(j-k)\times AP_i\}=max\{f[i-w-1][k]+k\times AP_i-j\times AP_i\}这里我们会发现 $j\times AP_i$ 跟里面的式子没有任何关系，提出来不会产生仍和影响 =max\{f[i-w-1][k]+k\times AP_i\}-j\times AP_i​于是我们发现我们只需要得到最大的 $f[i-w-1][k]+k\times AP_i$ 就好了，这里我们可以用到单调队列优化DP 。 具体代码实现如下： 1234567l=1,r=0;for(int j=0;j&lt;=MaxP;++j) &#123;/*枚举所有的合法的j*/ while(l&lt;=r&amp;&amp;q[l]&lt;j-AS) ++l;/*淘汰掉过期的队头*/ while(l&lt;=r&amp;&amp;f[i-W-1][q[r]]+q[r]*AP&lt;=f[i-W-1][j]+j*AP) --r;/*淘汰掉不如当前决策优的队尾*/ q[++r]=j;/*当前决策进队*/ if(l&lt;=r) f[i][j]=max(f[i][j],f[i-W-1][q[l]]+q[l]*AP-j*AP);/*转移*/&#125; 因为每一个状态都只进队/出队了一次，所以可以证明时间复杂度现在变为 $O(n^2)$ 了。 第四个操作一样可以这样优化，可以尝试一下，不贴解释了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=2e3+2;const int inf=1e9+9;int T,MaxP,W,AP,BP,AS,BS,l,r;int q[N],f[N][N];int main() &#123; memset(f,128,sizeof(f));/*赋极小值*/ scanf("%d%d%d",&amp;T,&amp;MaxP,&amp;W); for(int i=1;i&lt;=T;++i) &#123; scanf("%d%d%d%d",&amp;AP,&amp;BP,&amp;AS,&amp;BS); for(int j=0;j&lt;=AS;++j) f[i][j]=-AP*j; for(int j=0;j&lt;=MaxP;++j) f[i][j]=max(f[i][j],f[i-1][j]); if(i&lt;=W)continue; l=1,r=0; for(int j=0;j&lt;=MaxP;++j) &#123; while(l&lt;=r&amp;&amp;q[l]&lt;j-AS) ++l; while(l&lt;=r&amp;&amp;f[i-W-1][q[r]]+q[r]*AP&lt;=f[i-W-1][j]+j*AP) --r; q[++r]=j; if(l&lt;=r) f[i][j]=max(f[i][j],f[i-W-1][q[l]]+q[l]*AP-j*AP); &#125; l=1,r=0; for(int j=MaxP;j&gt;=0;--j) &#123; while(l&lt;=r&amp;&amp;q[l]&gt;j+BS) ++l; while(l&lt;=r&amp;&amp;f[i-W-1][q[r]]+q[r]*BP&lt;=f[i-W-1][j]+j*BP) --r; q[++r]=j; if(l&lt;=r) f[i][j]=max(f[i][j],f[i-W-1][q[l]]+q[l]*BP-j*BP); &#125; &#125; int ans=0; for(int i=0;i&lt;=MaxP;++i)ans=max(ans,f[T][i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2009]植物大战僵尸 网络流 luoguP2805]]></title>
    <url>%2F2019%2F03%2F24%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2805%2F</url>
    <content type="text"><![CDATA[前置芝士：网络流-最大权闭合子图定义：对于一个图的子图，当且仅当这个子图中的任意一点都不会与该子图外的点联通时，称这个子图为该图的闭合子图。在该图所有的闭合子图中，点权和最大的那个我们称作最大权闭合子图。 那么最大权闭合子图怎么求呢？ 对于给出的图，如果要求将 $u,v$ 连一条边，那么从 $u$ 向 $v$ 连一条边权为 $inf$ 的边。 然后对于每个点如果该点的点权为正，那么从 $s$ 向该点连一条边权为该点点权的边，否则从该点向 $t$ 连一条边权为$-1\times$该点权的边。 跑最小割，这个时候最大权闭合子图的”最大权”为正点点权和-最小割。 最大权闭合子图跟这一题有什么关系呢？ 可以发现，对于一个植物，僵尸必须先吃掉它右边的植物和保护它的植物才能吃它，那么这个植物就像它右边的植物与保护它的植物连边，这个连好边的图的最大权闭合子图就是答案！ 但是值得注意的一点是，可能存在互相保护的关系，比如说样例中的 $(2,0)$ 保护 $(2,1)$ ，但是 $(2,1)$ 又作为 $(2,0)$ 右边的植物保护 $(2,0)$ ，然后这对关系怎么都是攻不破的，这是一个环！ 于是我们可以先建好图后拓扑一边，然后再在访问过的点之间连边(该点访问过意味着该点不在环内)，最后再跑最小割即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e5+7;const int inf=1e9+9;int Score[N],n,m,s,t;#define id(x,y) (((x)-1)*m+(y))template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;namespace Dinic &#123; queue&lt;int&gt; q; int head[N],dep[N],cnt=1; struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;4]; inline void add(int u,int v,int w) &#123; G[++cnt]=(Edge)&#123;head[u],v,w&#125;,head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,0&#125;,head[v]=cnt; &#125; inline int bfs() &#123; memset(dep,0,sizeof(dep)); dep[s]=1;q.push(s); while(!q.empty()) &#123; int u=q.front(),v;q.pop(); for(int i=head[u];i;i=G[i].nxt) if(!dep[v=G[i].to]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,q.push(v); &#125;return dep[t]; &#125; int dfs(int u,int flow) &#123; if(!flow||u==t) return flow; int used=0,rlow; for(int i=head[u];i;i=G[i].nxt) &#123; int v=G[i].to; if(dep[v]==dep[u]+1&amp;&amp;G[i].val&gt;0) &#123; used+=(rlow=dfs(v,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[u]=-1; return used; &#125; inline int dinic() &#123; int maxflow=0; while(bfs()) maxflow+=dfs(s,inf); return maxflow; &#125;&#125;namespace Topology &#123; int vis[N],in[N]; vector&lt;int&gt; out[N]; queue&lt;int&gt; q; inline void topology()&#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(!in[id(i,j)]) q.push(id(i,j)),vis[id(i,j)]=true; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;out[u].size();++i) &#123; int v=out[u][i];--in[v]; if(!vis[v]&amp;&amp;!in[v]) &#123;vis[v]=true;q.push(v);&#125; &#125; &#125;return; &#125;&#125;using namespace Topology;using namespace Dinic;int main() &#123; // freopen("test.in","r",stdin); IN(n),IN(m);s=0,t=n*m+7; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; int tot,x,y; IN(Score[id(i,j)]),IN(tot); for(int k=1;k&lt;=tot;++k) &#123; IN(x),IN(y);++x,++y; out[id(i,j)].push_back(id(x,y)); ++in[id(x,y)]; &#125; if(j&lt;m) &#123; out[id(i,j+1)].push_back(id(i,j)); ++in[id(i,j)]; &#125; &#125; topology(); int sum=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(vis[id(i,j)])&#123; int u=id(i,j); if(Score[u]&lt;0) &#123;add(u,t,-Score[u]);&#125; else &#123;add(s,u,Score[u]);sum+=Score[u];&#125; for(int k=0;k&lt;out[u].size();++k) &#123; int v=out[u][k]; if(vis[v])add(v,u,inf); &#125; &#125; printf("%d\n",max(sum-dinic(),0)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [AH2017/HNOI2017]大佬 搜索+DP luoguP3724/bzoj4828]]></title>
    <url>%2F2019%2F03%2F21%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj4828%2F</url>
    <content type="text"><![CDATA[首先可以发现，刷水题跟打伤害是可以分开处理的。 我们先用 $DP$ 预处理出能打伤害的最大天数，其余的天数都只能用刷水题的方式恢复。 于是设 $dp[i][j]$ 表示前 $i$ 天，信心值还剩 $j$ 的能够打伤害的最大天数。 可以知道一天只有两种情况，我们枚举 $i,j​$ 然后进行转移： 如果可以坚持到下一天：dp[i+1][j-a[i+1]]=max(dp[i+1][j-a[i+1]],dp[i][j]+1) 如果是要刷水题：dp[i+1][j-a[i+1]+w[i+1]]=max(dp[i+1][j-a[i+1]+w[i+1]],dp[i][j]) 当然，如果要做第一个转移的话得先判断一下 j-a[i+1] 是否超了界，超界了的话当然就不能转移了。第二个转移也要注意，j-a[i+1]+w[i+1] 先要跟信心上界($mc$) 取 $min$ 。 最后在所有的状态中取一个最大值即可。 Code-DP12345678910111213141516inline void DP_maxday()&#123; memset(dp,-1,sizeof(dp));//初始化 dp[0][mc]=0; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;=mc;++j)&#123; if(dp[i][j]&lt;0)continue; int t1=j-a[i+1];if(t1&lt;0)continue; dp[i+1][t1]=max(dp[i+1][t1],dp[i][j]+1); int t2=min(t1+w[i+1],mc); dp[i+1][t2]=max(dp[i+1][t2],dp[i][j]); &#125; for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;=mc;++j) d=max(d,dp[i][j]); return;&#125; 这个 $d$ 就是我们能够打伤害的最大天数。 然后我们需要预处理出打出伤害的所有状态，这里我用广搜。 队列的结构体 $Node$ 由三个元素组成：$F,L,D$ ，表示在第 $D$ 天，你的 $F$ 的值为 $F$ ，$L$ 的值为 $L$ 。 然后就是转移，这里也是两种情况： 使讽刺能力乘上等级：F,L,D -&gt; F*L,L,D+1 (L&gt;0) 使等级加一：F,L,D -&gt; F,L+1,D+1 直接这样转移就好了，注意我们需要开个数组将这些打出伤害的方案记下来，当然，记录的时候不用记 $L$ ，因为后面打伤害的时候 $L$ 是没太多用的。 还有就是每次需要判断一下当前的天数，如果当前状态的天数已经大于了 $d$ 那么当前状态显然是不合法的。 最后就是需要用 $map$ 判个重，不然的话会爆炸，当然判重的时候也不要判 $L$ 。 Code-Bfs1234567891011121314151617181920map&lt;pair&lt;int,int&gt;,int&gt; vis;inline void BFS_maxhurt()&#123; q.push((Node)&#123;1,0,1&#125;);//初始化 while(!q.empty())&#123; Node x=q.front();q.pop(); if(x.D&gt;d)continue; else if(x.D==d)&#123;T[++cnt]=(Data)&#123;x.F,x.D&#125;;continue;&#125; else T[++cnt]=(Data)&#123;x.F,x.D&#125;; /*第一种转移*/ if(x.L&amp;&amp;(ll)x.F*x.L&lt;=1e8&amp;&amp;!vis[pair&lt;int,int&gt;(x.F*x.L,x.L)])&#123; q.push((Node)&#123;x.F*x.L,x.L,x.D+1&#125;); vis[pair&lt;int,int&gt;(x.F*x.L,x.L)]=x.D;//标记 &#125; /*第二种转移*/ if(!vis[pair&lt;int,int&gt;(x.F,x.L+1)])&#123; q.push((Node)&#123;x.F,x.L+1,x.D+1&#125;); vis[pair&lt;int,int&gt;(x.F,x.L+1)]=x.D;//标记 &#125; &#125;return;&#125; 抱歉我的英语真的不好 然后我们已经将所有可行的打伤害的方案记录到 $T​$ 数组里面了，接下来就是看看怎么用这些方案打大佬了。 首先还嘴是可以直接算的，这个是不用考虑的。我们唯一要处理的就是怼大佬，我们可以选择怼一次还是两次。可以发现怼一次的话直接枚举 $T​$ 数组中的方案即可，算上天数，剩下的天数当然是每天还嘴，看看这样可不可以干掉大佬： 1if(T[i].F&lt;=C&amp;&amp;T[i].D&lt;=d&amp;&amp;C-T[i].F&lt;=d-T[i].D)return true; ( $C$ 为当前大佬的信心值) 首先，T[i].F&lt;=C 是为了保证你不被虐飞，然后 T[i].D&lt;=d 当然就是你有足够的天数来实现这个方案，最后的 C-T[i].F&lt;=d-T[i].D 就是看看打完这个方案后剩下的天数能否通过仅剩的还嘴来干掉大佬。 那么如果是怼两次大佬呢？ 可以发现其实跟上面差不多，设两次中一次是第 $i$ 套方案，一次是第 $j$ 套方案。那么首先这两套方案的 $F$ 的和不能超过 $C$ ，然后就是要保证剩下的天数中可以通过还嘴干掉大佬，于是我们可以列出式子： T[i].F+T[j].F \leq C \ , \ T[i].F+T[j].F+(d-T[i].D-T[j].D) \geq C​然后前式很容易满足，我们来看看后式： T[i].F+T[j].F+d-T[i].D-T[j].D \geq CT[i].F-T[i].D+T[j].F-T[j].D+d \geq C我们枚举一个 $i$ ，寻找 $j$ 。既然 $i$ 已经确定，最优的 $j$ 一定满足 $T[j].F-T[j].D$ 最大，取 $max$ 就好。 至于代码的问题，我们先将 $T[i]$ 按照 $F$ 排序，然后按顺序寻找 $j$ ，代码实现就不是很难了。 Code-Solve:12345678910111213inline bool solve(int C)&#123; if(C&lt;=d)return true;//可以全程顶嘴干掉大佬，直接retrun int l=0,mx=-inf;//初始化 for(int i=cnt;i&gt;=1;--i)&#123; /*用第i方案怼一次可以干掉大佬，return*/ if(T[i].F&lt;=C&amp;&amp;T[i].D&lt;=d&amp;&amp;C-T[i].F&lt;=d-T[i].D)return true; /*按顺序扫描满足要求的 j*/ while(l&lt;cnt&amp;&amp;T[i].F+T[l+1].F&lt;=C) l++,mx=max(mx,T[l].F-T[l].D);//取max /*可以怼两次干掉大佬，return*/ if(T[i].F-T[i].D+mx+d&gt;=C)return true; &#125;return false;//干不掉大佬了&#125; 当然这个时间复杂度很玄学，大概是 $O($状态数$)$ 。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1.5e2+2;const int S=1e7+5;const int inf=1e9+9;int n,m,mc,a[N],w[N];int d,dp[N][N],cnt;struct Node&#123;int F,L,D;&#125;;struct Data&#123; int F,D; bool operator &lt; (const Data&amp;x)const&#123;return F&lt;x.F;&#125;&#125;T[S];map&lt;pair&lt;int,int&gt;,int&gt; vis;queue&lt;Node&gt; q;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline void DP_maxday()&#123; memset(dp,-1,sizeof(dp)); dp[0][mc]=0; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;=mc;++j)&#123; if(dp[i][j]&lt;0)continue; int t1=j-a[i+1];if(t1&lt;0)continue; dp[i+1][t1]=max(dp[i+1][t1],dp[i][j]+1); int t2=min(t1+w[i+1],mc); dp[i+1][t2]=max(dp[i+1][t2],dp[i][j]); &#125; for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;=mc;++j) d=max(d,dp[i][j]); return;&#125;inline void BFS_maxhurt()&#123; q.push((Node)&#123;1,0,1&#125;); while(!q.empty())&#123; Node x=q.front();q.pop(); if(x.D&gt;d)continue; else if(x.D==d)&#123;T[++cnt]=(Data)&#123;x.F,x.D&#125;;continue;&#125; else T[++cnt]=(Data)&#123;x.F,x.D&#125;; if(x.L&amp;&amp;(ll)x.F*x.L&lt;=1e8&amp;&amp;!vis[pair&lt;int,int&gt;(x.F*x.L,x.L)])&#123; q.push((Node)&#123;x.F*x.L,x.L,x.D+1&#125;); vis[pair&lt;int,int&gt;(x.F*x.L,x.L)]=x.D; &#125; if(!vis[pair&lt;int,int&gt;(x.F,x.L+1)])&#123; q.push((Node)&#123;x.F,x.L+1,x.D+1&#125;); vis[pair&lt;int,int&gt;(x.F,x.L+1)]=x.D; &#125; &#125;return;&#125;inline bool solve(int C)&#123; if(C&lt;=d)return true; int l=0,mx=-inf; for(int i=cnt;i&gt;=1;--i)&#123; if(T[i].F&lt;=C&amp;&amp;T[i].D&lt;=d&amp;&amp;C-T[i].F&lt;=d-T[i].D)return true; while(l&lt;cnt&amp;&amp;T[i].F+T[l+1].F&lt;=C) l++,mx=max(mx,T[l].F-T[l].D); if(T[i].F-T[i].D+mx+d&gt;=C)return true; &#125;return false;&#125;int main()&#123; IN(n),IN(m),IN(mc); for(int i=1;i&lt;=n;++i)IN(a[i]); for(int i=1;i&lt;=n;++i)IN(w[i]); DP_maxday(); BFS_maxhurt(); sort(T+1,T+cnt+1); for(int i=1;i&lt;=m;++i)&#123; int C;IN(C); if(solve(C))printf("1\n"); else printf("0\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [Violet]天使玩偶/SJY摆棋子 K-D Tree luoguP4169/bzoj2648]]></title>
    <url>%2F2019%2F03%2F21%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4169%2F</url>
    <content type="text"><![CDATA[$KDT$ 大法好！ 直接建 $KDT$ 维护一下所有的可能存在玩偶的结点，该插入的时候插入，查询的时候只需要沿着 $KDT$ 往下走，然后随时对 $ans$ 取 $min$ 即可。 注意这题有插入，这意味着 $KDT$ 到后面或许会不平衡，这个时候我们就需要用替罪羊树的思想——拍扁重建即可。注意这里判断是否平衡的 $check$ 函数需要放在 $insert$ 的最后，也就是还要在 $pushup$ 以后再 $check$ 即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1e6+7;const int inf=1e9+9;#define alph (0.75)template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x) &#123; char ch=0;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1; while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); if(flag) x=-x;&#125;int root,ans,WD,trh[N],top,cnt;struct point&#123;int x[2];&#125;p[N];struct node &#123; int mi[2],mx[2],l,r,sz; point tp;&#125;tr[N];int operator &lt; (point a,point b) &#123;return a.x[WD]&lt;b.x[WD];&#125;inline int new_node() &#123; if(top) return trh[top--]; else return ++cnt;&#125;inline void pushup(int x) &#123; int l=tr[x].l,r=tr[x].r; tr[x].sz=tr[l].sz+tr[r].sz+1; for(int i=0;i&lt;=1;++i) &#123; tr[x].mi[i]=tr[x].mx[i]=tr[x].tp.x[i]; if(l) &#123; tr[x].mi[i]=min(tr[x].mi[i],tr[l].mi[i]); tr[x].mx[i]=max(tr[x].mx[i],tr[l].mx[i]); &#125; if(r) &#123; tr[x].mi[i]=min(tr[x].mi[i],tr[r].mi[i]); tr[x].mx[i]=max(tr[x].mx[i],tr[r].mx[i]); &#125; &#125;&#125;int build(int l,int r,int wd) &#123; if(l&gt;r) return 0; int x=new_node(),mid=(l+r)&gt;&gt;1; WD=wd,nth_element(p+l,p+mid,p+r+1),tr[x].tp=p[mid]; tr[x].l=build(l,mid-1,wd^1); tr[x].r=build(mid+1,r,wd^1); return pushup(x),x;&#125;void pia(int x,int num) &#123; if(tr[x].l) pia(tr[x].l,num); p[num+tr[tr[x].l].sz+1]=tr[x].tp,trh[++top]=x; if(tr[x].r) pia(tr[x].r,num+tr[tr[x].l].sz+1);&#125;void check(int&amp;x,int wd) &#123; if(alph*tr[x].sz&lt;tr[tr[x].l].sz||alph*tr[x].sz&lt;tr[tr[x].r].sz) pia(x,0),x=build(1,tr[x].sz,wd);&#125;void Insert(point tmp,int&amp;x,int wd) &#123; if(!x) &#123; x=new_node(); tr[x].tp=tmp,tr[x].l=tr[x].r=0; pushup(x);return; &#125; if(tr[x].tp.x[wd]&lt;tmp.x[wd]) Insert(tmp,tr[x].r,wd^1); else Insert(tmp,tr[x].l,wd^1); pushup(x);check(x,wd);&#125;int getdist(point tmp,int x) &#123; int res=0; for(int i=0;i&lt;=1;++i) res+=max(0,tmp.x[i]-tr[x].mx[i])+max(0,tr[x].mi[i]-tmp.x[i]); return res;&#125;int dist(point a,point b) &#123; return abs(a.x[0]-b.x[0])+abs(a.x[1]-b.x[1]);&#125;void query(point tmp,int x) &#123; ans=min(ans,dist(tmp,tr[x].tp)); int disl=inf,disr=inf; if(tr[x].l) disl=getdist(tmp,tr[x].l); if(tr[x].r) disr=getdist(tmp,tr[x].r); if(disl&lt;disr) &#123; if(disl&lt;ans) query(tmp,tr[x].l); if(disr&lt;ans) query(tmp,tr[x].r); &#125; else &#123; if(disr&lt;ans) query(tmp,tr[x].r); if(disl&lt;ans) query(tmp,tr[x].l); &#125;&#125;int main() &#123; int n,m,op; IN(n),IN(m); for(int i=1;i&lt;=n;++i) IN(p[i].x[0]),IN(p[i].x[1]); root=build(1,n,0); for(int i=1;i&lt;=m;++i) &#123; point tmp; IN(op),IN(tmp.x[0]),IN(tmp.x[1]); if(op==1) Insert(tmp,root,0); else &#123; ans=inf;query(tmp,root); printf("%d\n",ans); &#125; &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>K-D Tree</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI/AHOI2018]转盘 线段树 luoguP4425]]></title>
    <url>%2F2019%2F03%2F20%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4425%2F</url>
    <content type="text"><![CDATA[首先再来讲明一下题意： 给定一个长度为 $n$ 的环，环上的每个点有一个权值 $T_i$ ，要求你从环上选中任意一个点为起点开始，每个时间可以顺时钟到下一个点，或者停留不动。对于一个点，如果到这个点的时间大于等于了 $T_i$ ，那么这个点将被标记，问最少什么时候可以让所有物品都被标记。 可以发现，这个问题的答案跟以下问题的答案是等价的： 给定一个长度为 $n​$ 的环，环上的每个点有一个权值 $T_i​$ ，要求你从环上选中任意一个点为起点开始，，开始的时间为 $t​$ ，每个时间可以逆时针到下一个点，或者停留不动。对于一个点，它将在 $T_i​$ 时间损坏 ，求一个最小的 $t​$ 使得我们能够在没有点损坏的情况下遍历所有点。 我们算一下每一个点离起点的距离，那么这个时候我们就可以在起点等，等一段时间后再出发，这样子我们转一圈就够了，这个方案显然是最优的。 我们断环为链，枚举起点 $s$ ，对于一个点 $i$ ，$s$ 到达 $i$ 的耗时显然是 $(i-s)$ ，那么我们如果想要等一段时间出发后正好标记该点，这一段等待的时间当然就是 $T_i-(i-s)$ 。我们对所有的点 $i$ 的 $T_i-(i-s)$ 取 $max$ ，最后的结果就是我们应该在 $s$ 等的时间。 那么很显然我们的答案为： Ans=min_{s \in [1,n]}\{ max_{i \in [s,s+n-1]}[T_i-(i-s)] \}+n-1$min_{s \in [1,n]}\{ max_{i \in [s,s+n-1]}[T_i-(i-s)] \}​$ 这显然是在选择一个最优的起点使得等待时间最小，$n-1​$ 就是等待完后转一圈的时间。 这个时候暴力枚举就可以得到 $30$ 分。 不过我们继续： Ans=min_{s \in [1,n]}\{ max_{i \in [s,s+n-1]}[T_i-i+s] \}+n-1我们设 $A_i$ 为 $T_i-i$ 。 Ans=min_{s \in [1,n]}\{ max_{i \in [s,s+n-1]}[A_i+s] \}+n-1假设现在有一对 $A_i,A_{i+n}$ ，我们可以发现 $A_{i+1}$ 是必然比 $A_i$ 小的，也就是说 $A_{s+n}$ 到 $A_{2n}$ 这一段数就算算进来也造不成影响。 也就是说原式跟这个式子是等价的： Ans=min_{s \in [1,n]}\{ max_{i \in [s,2n]}[A_i+s] \}+n-1发现 $max$ 里面 $s$ 并没有什么卵用，直接提出来。 Ans=min_{s \in [1,n]}\{ max_{i \in [s,2n]}A_i +s\}+n-1​这个的话……因为 $A_i$ 的值跟 $s$ 没有关系……所以……所以我们可以预处理一个 $ST$ 表……嗯……然后枚举 $s$ ……结果我们是 $O(n)$ 搞定？？？ 哦哦哦作者脑抽了，这题是待修改的。 不过没关系，我们还有出路。 现在考虑用线段树来维护，假设结点 $x$ 代表的区间为 $l,r$ ，维护一个 $val[x]$ 表示区间 $[l,r]$ 中 $A_i$ 的最大值，这个是线段树基本操作不再赘述，然后再维护一个 $ans[x]$ 表示区间 $min_{s \in [l,mid]}\{ max_{i \in [s,r]} \}$ 。$1$ 号结点的区间为 $1,2n$ ，我们的答案就是 $ans[1]$ 。 那么怎么上传 $ans$ 呢。 我们对于 $[mid,r]$ 区间的最大值 $A_x$ ，这个 $A_x$ 显然可以 $O(1)$ 求出，然后再找到一个 $A_y$ ，表示当 $s$ 为 $y$ 的时候，整个 $[s,r]$ 的 $A_i$ 的最大值为 $A_x$ 。在寻找 $y$ 的时候顺便更新一下 $s\in [l,y-1]$ 的区间的答案就好。 当 $s\in [y,r]​$ 的时候答案明显为 $A_x+s​$ ，要满足最小嘛。 有关这一部分的代码实现： 123456inline void calc(int k,int l,int r,int Ax)&#123; if(l==r)return l+max(val[k],Ax); int mid=(l+r)&gt;&gt;1; else if(val[k&lt;&lt;1|1]&gt;=Ax)return min(calc(k&lt;&lt;1|1,mid+1,r,Ax),ans[k&lt;&lt;1]); else return min(calc(k&lt;&lt;1,l,mid,Ax),(mid+1)+Ax);&#125; 我们来剖析一下代码。 1inline void calc(int k,int l,int r,int Ax)&#123; 这一句表示当前的结点为 $k$ ，$k$ 代表的区间为 $l,r$ ，$Ax$ 为上文中的 $A_x$ 。 1if(l==r)return l+max(val[k],Ax); 这个显然就是找到了 $y$ ，这个时候答案为 $A_x+s$ ，上文也讲了，这里的 $s$ 就是 $y$ 的位置，$A_x$ 已经在函数中了直接调用就好。但是为什么要取 $max$ 呢？因为怕 $A_y$ 是大于 $A_x$ 的! ，所以加个 $max$ 就好。 1else if(val[k&lt;&lt;1|1]&gt;=Ax)return min(calc(k&lt;&lt;1|1,mid+1,r,Ax),ans[k&lt;&lt;1]); 这个就是当前结点的右区间有比 $A_x$ 大的数，那么这个时候 $y$ 就不可能到左区间去了，不然的话 $[y,r]$ 中 $max\{A_i\}$ 就不是 $A_x$ 了，所以我们往右子树走。这个时候可以发现 $s$ 属于左区间的时候的答案为 $ans[k&lt;&lt;1]$ ，顺带更新一下。 1else return min(calc(k&lt;&lt;1,l,mid,Ax),(mid+1)+Ax); 这个时候 $y$ 就是在左区间了，那么我们往左区间走，右区间的答案呢？右区间为 $[mid,r]$ ，显然这一段的最大值肯定都为 $A_x$ ——包括 $mid+1$ ，所以不要跟 $mid+1$ 取一下 $max$ 了——尽管第一句是与 $A_y$ 取了 $max$ 的。 这个时候因为要 $s$ 尽量的小，所以就是右区间的左端点——$mid+1$ 了。 这个时候 $pushup$ 就应该这么写： 12345inline void pushup(int x,int l,int r)&#123; val[x]=max(val[x&lt;&lt;1],val[x&lt;&lt;1|1]); int mid=(l+r)&gt;&gt;1; ans[x]=calc(x&lt;&lt;1,l,mid,val[x&lt;&lt;1|1]);&#125; Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define min(x,y) ((x)&lt;(y)?(x):(y))#define max(x,y) ((x)&gt;(y)?(x):(y))typedef long long ll;const int N=4e5+2;const int inf=1e9+9;int n,m,p,lastans,a[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct Seg_Tree&#123; #define mid ((l+r)&gt;&gt;1) int ans[N&lt;&lt;2],val[N&lt;&lt;2]; int calc(int x,int l,int r,int Mx)&#123; if(l==r)return l+max(val[x],Mx); if(val[x&lt;&lt;1|1]&gt;=Mx)return min(calc(x&lt;&lt;1|1,mid+1,r,Mx),ans[x]); else return min(calc(x&lt;&lt;1,l,mid,Mx),mid+1+Mx); &#125; inline void pushup(int x,int l,int r)&#123; val[x]=max(val[x&lt;&lt;1],val[x&lt;&lt;1|1]); ans[x]=calc(x&lt;&lt;1,l,mid,val[x&lt;&lt;1|1]); &#125; inline void build(int x,int l,int r)&#123; if(l==r)&#123;val[x]=a[l],ans[x]=a[l]+l;return;&#125; build(x&lt;&lt;1,l,mid),build(x&lt;&lt;1|1,mid+1,r); pushup(x,l,r);return; &#125; inline void updata(int x,int l,int r,int pos)&#123; if(l==r)&#123;val[x]=a[l],ans[x]=a[l]+l;return;&#125; if(pos&lt;=mid)updata(x&lt;&lt;1,l,mid,pos); else if(pos&gt;mid)updata(x&lt;&lt;1|1,mid+1,r,pos); pushup(x,l,r); &#125;&#125;T;int main()&#123; IN(n),IN(m),IN(p); for(int i=1;i&lt;=n;++i)IN(a[i]),a[i+n]=a[i]; for(int i=1;i&lt;=(n&lt;&lt;1);++i)a[i]-=i; T.build(1,1,(n&lt;&lt;1)); lastans=T.ans[1]+n-1,printf("%d\n",lastans); for(int i=1;i&lt;=m;++i)&#123; int x,y;IN(x),IN(y); if(p)x^=lastans,y^=lastans; a[x]=y-x,a[x+n]=y-x-n; T.updata(1,1,(n&lt;&lt;1),x),T.updata(1,1,(n&lt;&lt;1),x+n); printf("%d\n",lastans=T.ans[1]+n-1); &#125; return 0;&#125; 但是这份代码是 TLE 的。 这玩意坑了我好久，你知道为什么 TLE 吗？ 就是这个鬼东西！： 12#define min(x,y) ((x)&lt;(y)?(x):(y))#define max(x,y) ((x)&gt;(y)?(x):(y)) 这里的 $x$ 和 $y$ 是调用了两次的，然后我们发现 $calc$ 函数…… 12345int calc(int x,int l,int r,int Mx)&#123; if(l==r)return l+max(val[x],Mx); if(val[x&lt;&lt;1|1]&gt;=Mx)return min(calc(x&lt;&lt;1|1,mid+1,r,Mx),ans[x]); else return min(calc(x&lt;&lt;1,l,mid,Mx),mid+1+Mx);&#125; $min$ 里面有 $calc$ 函数………..然后 $calc$ 函数调用了两次……….然后………..爆炸！ 所以 $Qiuly$ 提醒您：代码千万条，时间第一条，$define$ 不规范，$OIer$ 两行泪 。 还是跟着 $std$ 走好嘿嘿嘿，$using\ namespace\ std$ 万岁！ 最终 $AC$ 的代码。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N=4e5+2;const int inf=1e9+9;int n,m,p,lastans,a[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct Seg_Tree&#123; #define mid ((l+r)&gt;&gt;1) int ans[N&lt;&lt;2],val[N&lt;&lt;2]; int calc(int x,int l,int r,int Mx)&#123; if(l==r)return l+max(val[x],Mx); if(val[x&lt;&lt;1|1]&gt;=Mx)return min(calc(x&lt;&lt;1|1,mid+1,r,Mx),ans[x]); else return min(calc(x&lt;&lt;1,l,mid,Mx),mid+1+Mx); &#125; inline void pushup(int x,int l,int r)&#123; val[x]=max(val[x&lt;&lt;1],val[x&lt;&lt;1|1]); ans[x]=calc(x&lt;&lt;1,l,mid,val[x&lt;&lt;1|1]); &#125; inline void build(int x,int l,int r)&#123; if(l==r)&#123;val[x]=a[l],ans[x]=a[l]+l;return;&#125; build(x&lt;&lt;1,l,mid),build(x&lt;&lt;1|1,mid+1,r); pushup(x,l,r);return; &#125; inline void updata(int x,int l,int r,int pos)&#123; if(l==r)&#123;val[x]=a[l],ans[x]=a[l]+l;return;&#125; if(pos&lt;=mid)updata(x&lt;&lt;1,l,mid,pos); else if(pos&gt;mid)updata(x&lt;&lt;1|1,mid+1,r,pos); pushup(x,l,r); &#125;&#125;T;int main()&#123; IN(n),IN(m),IN(p); for(int i=1;i&lt;=n;++i)IN(a[i]),a[i+n]=a[i]; for(int i=1;i&lt;=(n&lt;&lt;1);++i)a[i]-=i; T.build(1,1,(n&lt;&lt;1)); lastans=T.ans[1]+n-1,printf("%d\n",lastans); for(int i=1;i&lt;=m;++i)&#123; int x,y;IN(x),IN(y); if(p)x^=lastans,y^=lastans; a[x]=y-x,a[x+n]=y-x-n; T.updata(1,1,(n&lt;&lt;1),x),T.updata(1,1,(n&lt;&lt;1),x+n); printf("%d\n",lastans=T.ans[1]+n-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 历史研究 回滚莫队 luoguAT1219]]></title>
    <url>%2F2019%2F03%2F20%2F%5B%E9%A2%98%E8%A7%A3%5DluoguAT1219%2F</url>
    <content type="text"><![CDATA[回滚莫队板子题，在此不再赘述。 关于回滚莫队的文章戳这 $QwQ$ :[算法]浅谈4种莫队及例题 可以算作一个回滚莫队的板子来参考。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;const int N=1e5+2;const int inf=1e9+9;int n,m,block,a[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(flag)x=-x; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace MO&#123; ll ans,Ans[N]; int v[N],b[N],blo[N],cnt[N],hep[N]; struct Query&#123;int l,r,id;&#125;q[N]; bool cmp(Query x,Query y)&#123; return blo[x.l]==blo[y.l]?x.r&lt;y.r:blo[x.l]&lt;blo[y.l]; &#125; inline void roll(int pos)&#123;--cnt[b[pos]];&#125; inline void add(int pos)&#123; ++cnt[b[pos]]; ans=max(ans,1ll*a[pos]*cnt[b[pos]]); &#125; inline ll query(int l,int r)&#123; ll res=0; for(int i=l;i&lt;=r;++i)hep[b[i]]=0; for(int i=l;i&lt;=r;++i)&#123; ++hep[b[i]]; res=max(res,1ll*a[i]*hep[b[i]]); &#125;return res; &#125; inline int solve(int num,int bloid)&#123; int L=min(block*bloid,n); int i=num,l=L+1,r=l-1; for(int k=1;k&lt;=n;++k)cnt[k]=0; ans=0; for(;blo[q[i].l]==bloid;++i)&#123; if(blo[q[i].l]==blo[q[i].r])&#123; Ans[q[i].id]=query(q[i].l,q[i].r); continue; &#125; while(r&lt;q[i].r)add(++r); ll tmp=ans; while(l&gt;q[i].l)add(--l); Ans[q[i].id]=ans; while(l&lt;L+1)roll(l++); ans=tmp; &#125;return i; &#125; inline void Main()&#123; sort(v+1,v+1+n); int tot=unique(v+1,v+1+n)-(v+1); for(int i=1;i&lt;=n;++i) b[i]=lower_bound(v+1,v+1+tot,a[i])-v; sort(q+1,q+1+m,cmp); int num=1; for(int i=1;i&lt;=blo[n];++i)num=solve(num,i); for(int i=1;i&lt;=m;++i)printf("%lld\n",Ans[i]); return; &#125;&#125;using namespace MO;int main()&#123; IN(n),IN(m);block=sqrt(n); for(int i=1;i&lt;=n;++i)IN(a[i]),v[i]=a[i]; for(int i=1;i&lt;=n;++i)blo[i]=(i-1)/block+1; for(int i=1;i&lt;=m;++i)&#123; IN(q[i].l),IN(q[i].r); q[i].id=i; &#125;return Main(),0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [AH2017/HNOI2017]单旋 线段树 luoguP3721/bzoj4825]]></title>
    <url>%2F2019%2F03%2F15%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj4825%2F</url>
    <content type="text"><![CDATA[$Spaly​$ 是不会用的，这辈子也不会用的。 这道题当然可以用 $Splay​$ 做，然而不会。 于是考虑怎么来做这道题，我们先来观察一下所有的操作： 1.插入操作：很普通的插入操作……2.单旋最小值： 结点的深度的变化如下： 需要旋转的结点 $(4)$ ：变为 $root$ ，深度变为 $1$ 。 需要旋转的结点的子树 $(7)$ ：深度不变。 其他结点 $(1,2,3,5,6)$ ：深度加 $1$ 。 3.单旋最大值：变化和上面的 “单旋最小值” 一样。 4.5 删除最大/最小值先将需要删除的 最大/最小值 转到树根，这个时候我们将树根删掉，可以发现整棵树的深度全部都减了 $1$ ，一起计算上旋转造成的深度的影响会得到： 删掉的结点的子树 $(7)$ ：深度减 $1$ 其他节点 $(1,2,3,5,6)$ ：深度不变 发现深度的变化也不是很大，于是我们考虑用线段树维护每一个节点的深度。线段树不易寻找最大/最小值，这个地方我们用 $set$ 来辅助即可，操作的时候更新一下 $set$ 中树的形态就好。 线段树的要求很低，一个很普通的兹磁区间修改的线段树即可： 123456789101112131415161718192021222324252627struct Segment_Tree&#123; #define mid ((l+r)&gt;&gt;1) int dep[N&lt;&lt;2]; inline void pushdown(int x,int l,int r)&#123; if(dep[x])&#123; dep[x&lt;&lt;1]+=dep[x],dep[x&lt;&lt;1|1]+=dep[x],dep[x]=0; &#125;return; &#125; void add(int x,int l,int r,int L,int R,int res)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;dep[x]+=res;return;&#125; pushdown(x,l,r); if(L&lt;=mid)add(x&lt;&lt;1,l,mid,L,R,res); if(R&gt;mid)add(x&lt;&lt;1|1,mid+1,r,L,R,res); &#125; void change(int x,int l,int r,int pos,int res)&#123; if(l==r)&#123;dep[x]=res;return;&#125; pushdown(x,l,r); if(pos&lt;=mid)change(x&lt;&lt;1,l,mid,pos,res); else change(x&lt;&lt;1|1,mid+1,r,pos,res); &#125; int query(int x,int l,int r,int pos)&#123; if(l==r)return dep[x]; pushdown(x,l,r); if(pos&lt;=mid)return query(x&lt;&lt;1,l,mid,pos); else return query(x&lt;&lt;1|1,mid+1,r,pos); &#125;&#125;T; 1.插入操作的实现：12345678910111213141516std::set&lt;int&gt; Spaly;inline int Insert(int x)&#123; std::set&lt;int&gt;::iterator it=Spaly.insert(x).first; if(!root)&#123;//还没有树根 T.change(1,1,tmp,x,1);//修改x的深度 root=x;return 1;//深度为1 &#125; if(it!=Spaly.begin())&#123;//不是最小值，所以可能成为其他结点的右儿子 if(!ch[*--it][1])ch[fa[x]=*it][1]=x;//成为右儿子 *it++;//维持it不变 &#125; if(!fa[x])ch[fa[x]=*++it][0]=x;//成为右儿子失败，于是成为左儿子 int dep_x=T.query(1,1,tmp,fa[x])+1;//x的深度就是它父节点的深度加1 T.change(1,1,tmp,x,dep_x);//在线段树中修改x的深度 return dep_x;//题目要求&#125; 2.单旋最小/最大值的实现：1234567891011121314151617181920inline int Rotate_min()&#123; int x=*Spaly.begin(),ans=T.query(1,1,tmp,x);//获取当前的最小值和需要返回的答案 if(x==root)return 1;//是根就直接返回 if(x+1&lt;fa[x])T.add(1,1,tmp,x+1,fa[x]-1,-1);//x有子树，先给x的子树的深度整体减1 T.add(1,1,tmp,1,tmp,1);//整棵树深度加1，这个时候x的子树深度不变了 ch[fa[x]][0]=ch[x][1],fa[ch[x][1]]=fa[x];//将x的子树接到x的父亲上 ch[x][1]=root,fa[root]=x,root=x;//更新root T.change(1,1,tmp,x,1);//修改x的深度，变为1 return ans;//题目要求&#125;inline int Rotate_max()&#123;//与上面的Rotate_min操作同理 int x=*Spaly.rbegin(),ans=T.query(1,1,tmp,x); if(x==root)return 1; if(x-1&gt;fa[x])T.add(1,1,tmp,fa[x]+1,x-1,-1); T.add(1,1,tmp,1,tmp,1); ch[fa[x]][1]=ch[x][0],fa[ch[x][0]]=fa[x]; ch[x][0]=root,fa[root]=x,root=x; T.change(1,1,tmp,x,1); return ans;&#125; 3.删除最小/最大值的实现：12345678910inline void Delete_min()&#123; printf("%d\n",Rotate_min());//先旋上来，按照题目要求输出 T.add(1,1,tmp,1,tmp,-1);//整棵树的深度发生变化 Spaly.erase(root),root=ch[root][1],fa[root]=0;//更新root&#125;inline void Delete_max()&#123;//与上面的Delete_min操作同理 printf("%d\n",Rotate_max()); T.add(1,1,tmp,1,tmp,-1); Spaly.erase(root),root=ch[root][0],fa[root]=0;&#125; Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;set&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int N=1e5+2;const int inf=1e9+9;int m,tmp,v[N],a[N],op[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct Segment_Tree&#123; #define mid ((l+r)&gt;&gt;1) int dep[N&lt;&lt;2]; inline void pushdown(int x,int l,int r)&#123; if(dep[x])&#123; dep[x&lt;&lt;1]+=dep[x],dep[x&lt;&lt;1|1]+=dep[x],dep[x]=0; &#125;return; &#125; void add(int x,int l,int r,int L,int R,int res)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;dep[x]+=res;return;&#125; pushdown(x,l,r); if(L&lt;=mid)add(x&lt;&lt;1,l,mid,L,R,res); if(R&gt;mid)add(x&lt;&lt;1|1,mid+1,r,L,R,res); &#125; void change(int x,int l,int r,int pos,int res)&#123; if(l==r)&#123;dep[x]=res;return;&#125; pushdown(x,l,r); if(pos&lt;=mid)change(x&lt;&lt;1,l,mid,pos,res); else change(x&lt;&lt;1|1,mid+1,r,pos,res); &#125; int query(int x,int l,int r,int pos)&#123; if(l==r)return dep[x]; pushdown(x,l,r); if(pos&lt;=mid)return query(x&lt;&lt;1,l,mid,pos); else return query(x&lt;&lt;1|1,mid+1,r,pos); &#125;&#125;T;struct Spaly_Tree&#123; std::set&lt;int&gt; Spaly; int root,fa[N],ch[N][2]; inline int Insert(int x)&#123; std::set&lt;int&gt;::iterator it=Spaly.insert(x).first; if(!root)&#123; T.change(1,1,tmp,x,1); root=x;return 1; &#125; if(it!=Spaly.begin())&#123; if(!ch[*--it][1])ch[fa[x]=*it][1]=x; *it++; &#125; if(!fa[x])ch[fa[x]=*++it][0]=x; int dep_x=T.query(1,1,tmp,fa[x])+1; T.change(1,1,tmp,x,dep_x); return dep_x; &#125; inline int Rotate_min()&#123; int x=*Spaly.begin(),ans=T.query(1,1,tmp,x); if(x==root)return 1; if(x+1&lt;fa[x])T.add(1,1,tmp,x+1,fa[x]-1,-1); T.add(1,1,tmp,1,tmp,1); ch[fa[x]][0]=ch[x][1],fa[ch[x][1]]=fa[x]; ch[x][1]=root,fa[root]=x,root=x; T.change(1,1,tmp,x,1); return ans; &#125; inline int Rotate_max()&#123; int x=*Spaly.rbegin(),ans=T.query(1,1,tmp,x); if(x==root)return 1; if(x-1&gt;fa[x])T.add(1,1,tmp,fa[x]+1,x-1,-1); T.add(1,1,tmp,1,tmp,1); ch[fa[x]][1]=ch[x][0],fa[ch[x][0]]=fa[x]; ch[x][0]=root,fa[root]=x,root=x; T.change(1,1,tmp,x,1); return ans; &#125; inline void Delete_min()&#123; printf("%d\n",Rotate_min()); T.add(1,1,tmp,1,tmp,-1); Spaly.erase(root),root=ch[root][1],fa[root]=0; &#125; inline void Delete_max()&#123; printf("%d\n",Rotate_max()); T.add(1,1,tmp,1,tmp,-1); Spaly.erase(root),root=ch[root][0],fa[root]=0; &#125;&#125;S;int main()&#123; IN(m); for(int i=1,x;i&lt;=m;++i)&#123; IN(op[i]); if(op[i]==1)IN(x),v[++tmp]=a[i]=x; &#125; std::sort(v+1,v+1+tmp); for(int i=1;i&lt;=m;++i) if(op[i]==1)a[i]=std::lower_bound(v+1,v+1+tmp,a[i])-v; for(int i=1;i&lt;=m;++i)&#123; if(op[i]==1)printf("%d\n",S.Insert(a[i])); if(op[i]==2)printf("%d\n",S.Rotate_min()); if(op[i]==3)printf("%d\n",S.Rotate_max()); if(op[i]==4)S.Delete_min(); if(op[i]==5)S.Delete_max(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [AH2017/HNOI2017]影魔 线段树 luoguP3722/bzoj4826]]></title>
    <url>%2F2019%2F03%2F15%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj4826%2F</url>
    <content type="text"><![CDATA[真心巧妙，不看题解准做不出(之前题解都看不懂QwQ) 这道题貌似有许多的做法，都不费，主席树的话不知道怎么搞，于是建了 $3$ 棵线段树，实测是不会炸的。 30分做法： 小学生都能轻易想出来的解法，对于一个询问的区间，暴力枚举其子区间，然后按照题面的要求算贡献，区间最大值可以用 $ST$ 表预处理，复杂度爆炸，但是仍然可以拿到 $30$ 暴力分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e5+2;const int LogN=23;const int inf=1e9+9; int v[N],n,m,p1,p2;struct ST&#123; int logs[N],f[N][LogN+2]; inline void make()&#123; logs[0]=-1; for(int i=1;i&lt;=n;++i) f[i][0]=v[i],logs[i]=logs[i&gt;&gt;1]+1; for(int j=1;j&lt;=LogN;++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; inline int query(int x,int y)&#123; int ans=logs[y-x+1]; return max(f[x][ans],f[y-(1&lt;&lt;ans)+1][ans]); &#125;&#125;T;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; int main()&#123; IN(n),IN(m),IN(p1),IN(p2); for(int i=1;i&lt;=n;++i)IN(v[i]); T.make(); for(int i=1;i&lt;=m;++i)&#123; int l,r,ans=0; IN(l),IN(r); for(int a=l;a&lt;=r;++a) for(int b=a+2;b&lt;=r;++b)&#123; int sum=T.query(a+1,b-1); if(v[a]&gt;=sum&amp;&amp;v[b]&gt;=sum)ans+=p1; if((v[a]&lt;sum&amp;&amp;sum&lt;v[b])||(v[b]&lt;sum&amp;&amp;sum&lt;v[a]))ans+=p2; &#125; printf("%d\n",ans+(r-l)*p1); &#125; return 0;&#125; 100分做法 对于一个点 $i$ ，我们设 $lmax[i]$ 为 $i$ 向左走遇到的第一个大于自己的数(没有的话为 $0$) ，同样的，设 $rmax[i]$ 为 $i$ 向右走遇到的第一个大于自己的数(没有的话为 $n+1$) 。这两个数组比较容易求出，搞个单调栈求就好。 12345678910top=0,stack[0]=0;for(int i=1;i&lt;=n;++i)&#123; while(top&amp;&amp;k[stack[top]]&lt;k[i])--top; lmax[i]=stack[top],stack[++top]=i;&#125;top=0,stack[0]=n+1;for(int i=n;i&gt;=1;--i)&#123; while(top&amp;&amp;k[stack[top]]&lt;k[i])--top; rmax[i]=stack[top],stack[++top]=i;&#125; 然后可以发现，如果枚举点 $i$ 的话，有了上面的两个数组后有关 $i$ 的贡献就好求些了，首先我们可以知道 $i$ 是区间 $[lmax[i]+1,rmax[i]-1]$ 的最大值，那么对于每种贡献： 如果 $lmax[i]$ 和 $rmax[i]$ 都在当前询问区间内，那么就可以做出 $p_1$ 的贡献。 如果 $lmax[i]$ 在当前询问区间中，那么显然 $lmax[i]$ 为区间 $[lmax[i],rmax[i]-1]$ 的最大值，这个时候右端点如果在 $[i+1,rmax[i]-1]$ 区间中，那么可以保证右端点不是 $[lmax[i],rmax[i]-1]$ 的次大值，这个时候可以产生多个 $p_2$ 的贡献。 如果 $rmax[i]$ 在当前询问区间中，那么显然当左端点为 $[lmax[i]+1,i-1]$ 的时候该子区间均能产生 $p_2$ 的贡献，原因跟上面一样的。 但是这样的话复杂度依旧是 $O(n^2)$ 的，所以还要优化。 考虑用线段树维护，我们离线处理询问，把每个询问按左端点排个序，然后反着扫一遍，如果遇到了一个点 $x$ ，它是 某个点/某些点 的 $lmax$ ，假设 $x$ 是 $i$ 的 $lmax$ ，那么我们依次在第一颗线段树中实现区间加：将 $[i+1,rmax[i]-1]$ 区间正题加上 $p_2$ ，因为当前的左端点为 $x$ ，这个时候我们将要计算的是所有的左端点为 $x$ 的区间对答案的贡献，因为对于 $i$ 来说右端点的范围就是 $[i+1,rmax[i]-1]$，这些区间均可以做出贡献，于是都在线段树中加上。当然在做贡献的之前不要忘记判断 $i+1&lt;rmax[i]$ ，如果不满足的话就没有右端点了…… 那么接下来讨论怎么计算 $p_1$ 的贡献，对于询问区间来说，现在我们确定了左端点为 $x$ ，这个时候当右端点落在 $[rmax[i],n+1]$ 的时候询问区间都可以算上 $[lmax[i],rmax[i]]$ 区间的贡献，也就是 $p_1$ 的贡献，于是我们可以在另一个线段树中将 $[rmax[i],n+1]$ 全都加上 $p_1$ 即可。 按照上面的方法，再正着扫一遍计算 $rmax$ 的情况就好，当然反着扫的时候就不要算 $p_1$ 的贡献了，不然就会重复了，想想就可以明白。最后就是一定要开 $longlong$ 。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define swap(x,y) ((x)^=(y)^=(x)^=(y))typedef long long ll;const int N=2e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; struct Seg_Tree&#123;//线段树板子 #define mid ((l+r)&gt;&gt;1) ll v[N&lt;&lt;2];int tag[N&lt;&lt;2]; inline void pushdown(int x,int l,int r)&#123; if(tag[x])&#123; tag[x&lt;&lt;1]+=tag[x],tag[x&lt;&lt;1|1]+=tag[x]; v[x&lt;&lt;1]+=tag[x]*(mid-l+1),v[x&lt;&lt;1|1]+=tag[x]*(r-mid); &#125;tag[x]=0;return; &#125; inline void updata(int x,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;v[x]+=r-l+1,++tag[x];return;&#125; pushdown(x,l,r); if(L&lt;=mid)updata(x&lt;&lt;1,l,mid,L,R); if(R&gt;mid)updata(x&lt;&lt;1|1,mid+1,r,L,R); v[x]=v[x&lt;&lt;1]+v[x&lt;&lt;1|1]; &#125; inline ll query(int x,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return v[x]; pushdown(x,l,r); ll ans=0; if(L&lt;=mid)ans+=query(x&lt;&lt;1,l,mid,L,R); if(R&gt;mid)ans+=query(x&lt;&lt;1|1,mid+1,r,L,R); return ans; &#125;&#125;st1,st2,st3;//三棵线段树[滑稽]int n,m,k[N];ll p1,p2;struct Query&#123;int l,r;ll ans;&#125;q[N];int lmax[N],rmax[N],stack[N],top;std::vector&lt;int&gt; li[N],ri[N],lq[N],rq[N];inline void _Pre_lmax_rmax()&#123; top=0,stack[0]=0; for(int i=1;i&lt;=n;++i)&#123; while(top&amp;&amp;k[stack[top]]&lt;k[i])--top; lmax[i]=stack[top],li[stack[top]].push_back(i);//统计上文中的x stack[++top]=i; &#125; top=0,stack[0]=n+1; for(int i=n;i&gt;=1;--i)&#123; while(top&amp;&amp;k[stack[top]]&lt;k[i])--top; rmax[i]=stack[top],ri[stack[top]].push_back(i); stack[++top]=i; &#125;&#125;int main()&#123; //freopen("code.in","r",stdin); IN(n),IN(m),IN(p1),IN(p2); for(int i=1;i&lt;=n;++i)IN(k[i]); _Pre_lmax_rmax(); for(int i=1;i&lt;=m;++i)&#123; IN(q[i].l),lq[q[i].l].push_back(i); IN(q[i].r),rq[q[i].r].push_back(i); &#125; for(int i=n;i&gt;=1;--i)&#123; for(int j=0;j&lt;li[i].size();++j)&#123;//计算左端点在i的区间的贡献 if(li[i][j]+1&lt;rmax[li[i][j]]) st1.updata(1,0,n+1,li[i][j]+1,rmax[li[i][j]]-1); st3.updata(1,0,n+1,rmax[li[i][j]],n+1); &#125; for(int j=0;j&lt;lq[i].size();++j)&#123;//统计左端点在i的询问区间的答案 q[lq[i][j]].ans+=st1.query(1,0,n+1,i,q[lq[i][j]].r)*p2; q[lq[i][j]].ans+=st3.query(1,0,n+1,q[lq[i][j]].r,q[lq[i][j]].r)*p1; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=0;j&lt;ri[i].size();++j) if(ri[i][j]-1&gt;lmax[ri[i][j]]) st2.updata(1,0,n+1,lmax[ri[i][j]]+1,ri[i][j]-1); for(int j=0;j&lt;rq[i].size();++j) q[rq[i][j]].ans+=st2.query(1,0,n+1,q[rq[i][j]].l,i)*p2; &#125; for(int i=1;i&lt;=m;++i)//输出答案，不要忘了漏统计的长度为2的区间 printf("%lld\n",q[i].ans+1ll*(q[i].r-q[i].l)*p1); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [AH2017/HNOI2017]礼物 FFT luoguP3723/bzoj4827]]></title>
    <url>%2F2019%2F03%2F15%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj4827%2F</url>
    <content type="text"><![CDATA[题目背景有些……………通过题目我们可以知道最终我们要求的式子就是： \sum_{i=1}^{n}(a_i+c-b_i)^2于是我们将式子拆开： (a_i+c-b_i)^2=a_i^2+b_i^2+c^2+2a_ic-2b_ic-2a_ib_i \sum_{i=1}^{n}(a_i+c-b_i)^2=\sum_{i=1}^{n}a_i^2+\sum_{i=1}^{n}b_i^2+nc^2+2c(\sum_{i=1}^{n}a_i-\sum_{i=1}^{n}b_i)-2\sum_{i=1}^{n}a_ib_i​前面的这些都很容易求出，但是最后的 $\sum_{i=1}^{n}a_ib_i​$ 无法很快算出，我们算答案的时候枚举 $c​$ 以及手环旋转了多少，这个时候如果在里面直接大力计算 $\sum_{i=1}^{n}a_ib_i​$ 可以拿到 $30​$ 分。如果将这个式子在之前拿出来预处理一下，将会拿到 $70​$ 分。 这个时候将 $a_i$ 反向，式子变为：$\sum_{i=1}^{n}a_{n-i+1}b_i$ ，可以发现这是一个卷积，是可以用 $FFT$ 跑的，众所周知 $FFT$ 的复杂度是 $O(nlogn)$ ，是能跑过的。 具体实现的时候我们需要将 $a​$ 拉成两倍长，或者说是断环为链？至于为什么的话，是因为题目要求了这个数列是可以旋转的。然后按照上式将 $b​$ 反向就好了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define PI 3.1415926535898#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))typedef long long ll;const int N=5e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; struct complex&#123;complex(double a=0,double b=0)&#123;x=a,y=b;&#125;double x,y;&#125;;complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125;complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125;complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;int n,m,limit=1,a[N],b[N],filp[N];ll a1=0,a2=0,b1=0,b2=0;complex A[N],B[N];inline void FFT(complex *f,short inv)&#123; for(int i=0;i&lt;limit;++i) if(i&lt;filp[i])&#123;complex tmp=f[i];f[i]=f[filp[i]];f[filp[i]]=tmp;&#125; for(int p=2;p&lt;=limit;p&lt;&lt;=1)&#123; int len=p/2; complex tmp=complex(cos(PI/len),inv*sin(PI/len)); for(int k=0;k&lt;limit;k+=p)&#123; complex buf=complex(1,0); for(int l=k;l&lt;k+len;++l)&#123; complex t=buf*f[len+l]; f[len+l]=f[l]-t,f[l]=f[l]+t,buf=buf*tmp; &#125; &#125; &#125;return;&#125;int main()&#123; IN(n),IN(m); for(int i=1;i&lt;=n;++i) IN(a[i]),a1+=a[i]*a[i],a2+=a[i]; for(int i=1;i&lt;=n;++i) IN(b[i]),b1+=b[i]*b[i],b2+=b[i]; for(int i=1;i&lt;=n;++i) A[i].x=A[i+n].x=a[i],B[i]=b[n-i+1]; while(limit&lt;=(3*n))limit&lt;&lt;=1; for(int i=0;i&lt;limit;++i)filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?limit&gt;&gt;1:0); FFT(A,1),FFT(B,1); for(int i=0;i&lt;=limit;++i)A[i]=A[i]*B[i]; FFT(A,-1); for(int i=0;i&lt;=limit;++i)A[i].x=(ll)(A[i].x/limit+0.5); ll ans=inf; for(int i=1;i&lt;=n;++i) for(int j=-m;j&lt;=m;++j) ans=min(ans,a1+b1+1ll*j*j*n+2ll*j*(a2-b2)-2ll*(ll)A[i+n].x); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2016]序列 莫队+ST表 luoguP3246]]></title>
    <url>%2F2019%2F03%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3246%2F</url>
    <content type="text"><![CDATA[一道莫队………. 最主要的就是怎么从当前区间推到相邻区间。 假设当前区间为 $[l,r]$ ，目标区间为 $[l,r+1]$ 。那么很显然这样子就会增加： [l,r+1],[l+1,r+1],[l+2,r+1]\cdots \cdots这些区间，现在我们要做的就是尽快的算出这些区间的答案。 假设 $p$ 为区间 $[l,r+1]$ 的最小值的位置，那么在上面的区间中，$[l,r+1] \cdots [p,r+1]$ 这些区间显然都包含了 $p$ ，也就是说这些区间的最小值都为 $p$ ，那么这一段区间的贡献显然为 $a[p]\cdot (p-l+1)$ ，其中 $a[p]$ 为 $p$ 位置上的权值。 很显然我们可以预处理一个 $ST$ 表，通过 $ST$ 表上面的 $p$ 就可以 $O(1)$ 求出。 然后接下来考虑剩下的 $[p+1,r+1]\cdots [r+1,r+1]$ 这些区间。 我们设 $f[i][j]$ 表示右端点为 $j$ ，左端点的位置在 $[i,j]$ 范围内的所有区间所造成的贡献。 我们可以用单调栈预处理出位置 $i$ 的 $lmin$ 和 $rmin$ ，$lmin[i]$ 表示 $i$ 往左走遇到的第一个比 $i$ 小的数的位置，$rmin$ 同理。 那么我们很轻易的可以得到： f[i][j]=f[i][lmin_j-1]+a[lmin_j]\cdot (j-lmin_j)发现 $i$ 是没有影响的，于是我们将 $i$ 丢掉。 f[j]=f[lmin_j-1]+a[lmin_j]\cdot (j-lmin_j)这个式子 $DP$ 与处理一下就好了。 那么最后我们从 $[l,r]$ 移向 $[l,r+1]$ 产生的贡献为： a[p]\cdot (p-l+1) + f[r+1]-f[p]至于为什么要减去 $f[p]$ ，差不多是容斥的道理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))typedef long long ll;const int N=1e5+2;const int inf=1e9+9;int n,m,block,a[N];struct MO&#123;int l,r,id;&#125;q[N];int top,stack[N],lmin[N],rmin[N];ll res,Ans[N],fl[N],fr[N];bool cmp(MO a,MO b)&#123; return a.l/block==b.l/block?a.l/block&amp;1?a.r&lt;b.r:a.r&gt;b.r:a.l/block&lt;b.l/block;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; namespace ST&#123; const int LogN=23; int logs[N],f[N][LogN+2]; inline void Make()&#123; logs[0]=-1; for(int i=1;i&lt;=n;++i) f[i][0]=i,logs[i]=logs[i&gt;&gt;1]+1; for(int j=1;j&lt;=logs[n];++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) f[i][j]=a[f[i][j-1]]&lt;a[f[i+(1&lt;&lt;(j-1))][j-1]]?f[i][j-1]:f[i+(1&lt;&lt;(j-1))][j-1]; &#125; inline ll query(int x,int y)&#123; int ans=logs[y-x+1]; return a[f[x][ans]]&lt;a[f[y-(1&lt;&lt;ans)+1][ans]]?f[x][ans]:f[y-(1&lt;&lt;ans)+1][ans]; &#125;&#125;inline void __Pre_lmin_rmin()&#123; for(int i=1;i&lt;=n;++i)&#123; while(top&amp;&amp;a[stack[top]]&gt;a[i]) rmin[stack[top--]]=i; lmin[i]=stack[top],stack[++top]=i; &#125;while(top)lmin[stack[top]]=stack[top-1],rmin[stack[top--]]=n+1;&#125;inline ll left(int l,int r)&#123; int p=ST::query(l-1,r); return (ll)a[p]*(r-p+1)+fl[l-1]-fl[p];&#125;inline ll right(int l,int r)&#123; int p=ST::query(l,r+1); return (ll)a[p]*(p-l+1)+fr[r+1]-fr[p];&#125; int main()&#123; IN(n),IN(m);block=sqrt(n); a[0]=a[n+1]=inf; for(int i=1;i&lt;=n;++i)IN(a[i]); __Pre_lmin_rmin(); ST::Make(); for(int i=1;i&lt;=n;++i)fr[i]=(ll)a[i]*(i-lmin[i])+fr[lmin[i]]; for(int i=n;i&gt;=1;--i)fl[i]=(ll)a[i]*(rmin[i]-i)+fl[rmin[i]]; for(int i=1;i&lt;=m;++i) IN(q[i].l),IN(q[i].r),q[i].id=i; std::sort(q+1,q+1+m,cmp); int L=q[1].l,R=L-1;res=0; for(int i=1;i&lt;=m;++i)&#123; int x=q[i].l,y=q[i].r; while(L&gt;x)res+=left(L,R),L--; while(R&lt;y)res+=right(L,R),R++; while(L&lt;x)res-=left(L+1,R),++L; while(R&gt;y)res-=right(L,R-1),--R; Ans[q[i].id]=res; &#125; for(int i=1;i&lt;=m;++i) printf("%lld\n",Ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>ST表</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [CQOI2015]网络吞吐量 网络流 luoguP3171]]></title>
    <url>%2F2019%2F03%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3171%2F</url>
    <content type="text"><![CDATA[题目要求你做什么就做什么呗。 我们先跑最短路，然后按照最短路的边连网络流的边就好了。 这里我选择跑堆优 $Dij$ ，然后我们枚举每一条边，判断着一条边是否为最短路的边，判断的方式很显然，就是看这条边的起点的 $dis$ 加上边权是否等于终点的 $dis$ 就好。 网络流要拆点，除了拆了的点之间连一条该点的权值的边之外，其余的边全部都是 $inf$ ，当然第一个点和第 $n$ 个点拆点后连边也是 $inf$ 而非点权。连完边之后跑最大流即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long long#define A printf("A")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e5+2;const ll inf=1e18+9;int n,m,s,t;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace Dinic&#123; std::queue&lt;int&gt; q; struct Edge&#123;int nxt,to;ll val;&#125;G[N&lt;&lt;1]; int cnt(1),dep[N],head[N]; inline void add(int u,int v,ll w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt; &#125; inline bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]||G[i].val&lt;=0)continue; dep[y]=dep[x]+1,q.push(y); &#125; &#125;return dep[t]; &#125; inline ll dfs(int x,ll flow)&#123; if(x==t||!flow)return flow; ll used=0,rlow; for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used; &#125; inline ll dinic()&#123; ll maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow; &#125;&#125;namespace Dijstra&#123; #define P std::pair&lt;int,int&gt; std::priority_queue&lt;P,std::vector&lt;P&gt;,std::greater&lt;P&gt; &gt; q; int vis[N],head[N],cnt; ll dis[N]; struct Edge&#123;int nxt,to;ll w;&#125;G[N&lt;&lt;1]; inline void add(int u,int v,ll w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].w=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].w=w,head[v]=cnt; &#125; inline void dijstra(int s)&#123; for(int i=1;i&lt;=n;++i)dis[i]=inf; memset(vis,false,sizeof(vis)); dis[s]=0; q.push(std::make_pair(dis[s],s)); while(!q.empty())&#123; int x=q.top().second; q.pop();if(vis[x])continue;vis[x]=true; for(int i=head[x];i;i=G[i].nxt) if(dis[G[i].to]&gt;dis[x]+G[i].w)&#123; dis[G[i].to]=dis[x]+G[i].w; if(!vis[G[i].to])q.push(std::make_pair(dis[G[i].to],G[i].to)); &#125; &#125; for(int x=1;x&lt;=n;++x) for(int i=head[x];i;i=G[i].nxt) if(dis[x]+G[i].w==dis[G[i].to]) Dinic::add(x+n,G[i].to,inf); return; &#125;&#125;int main()&#123; IN(n),IN(m),s=1,t=n&lt;&lt;1; for(int i=1;i&lt;=m;++i)&#123; int u,v,w;IN(u),IN(v),IN(w); Dijstra::add(u,v,w); &#125; Dijstra::dijstra(1); for(int i=1,x;i&lt;=n;++i) IN(x),Dinic::add(i,i+n,(i!=1&amp;&amp;i!=n)?x:inf); printf("%lld\n",Dinic::dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 货车运输 最大生成树+倍增Lca luoguP1967]]></title>
    <url>%2F2019%2F03%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1967%2F</url>
    <content type="text"><![CDATA[题目大意就是，有多组询问，每组询问包含两个整数 $x,y​$ ，求出 $x​$ 到 $y​$ 的一条路径，满足这条路径在所有的 $x​$ 到 $y​$ 的路径中，边权最小的边权值最大。 这个很显然我们可以先求出图的最大生成树，那么 $x$ 到 $y$ 的目标路径肯定在最大生成树上，也只能在最大生成树上。 那么我们需要在最大生成树上找到这条路径，最大生成树是一棵树，很显然的我们可以想到在这棵树上做 $Lca$ ，那么这样就超级简单了。 我们在求 $lca$ 的时候顺带维护一下 $sum$ 数组，$sum[x][i]$ 表示在最大生成树 $x$ 到 $fa[x][i]$ 这条路径上的所有边的边权最小值。转移的方法也很简单：$sum[x][i]=min(sum[x][i-1],sum[fa[x][i-1]][i-1])$ 。 对于不能到达的情况特判一下就好了。 于是这题就做完了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt; #define ll long long#define A printf("A")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define swap(x,y) ((x)^=(y)^=(x)^=(y))const int N=1e5+2;const int log=30;const int inf=1e9+9;int n,m,q,cnt,f[N];int dep[N],fa[N][log+2],sum[N][log+2];struct Edge&#123;int from,to,val;&#125;G[N&lt;&lt;1];std::vector&lt;int&gt; E[N],V[N];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;bool cmp(Edge a,Edge b)&#123;return a.val&gt;b.val;&#125;int find(int x)&#123;return f[x]==x?x:f[x]=find(f[x]);&#125;void dfs(int u,int f,int dis)&#123; dep[u]=dep[f]+1, fa[u][0]=f,sum[u][0]=dis; for(int i=1;i&lt;log;++i) fa[u][i]=fa[fa[u][i-1]][i-1], sum[u][i]=min(sum[u][i-1],sum[fa[u][i-1]][i-1]); int size=E[u].size(); for(int i=0;i&lt;size;++i)&#123; int v=E[u][i]; if(v!=f)dfs(v,u,V[u][i]); &#125;return;&#125;inline int solve(int x,int y)&#123; int ans=inf; if(dep[x]&lt;dep[y])swap(x,y); for(int i=log-1;i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) ans=min(ans,sum[x][i]),x=fa[x][i]; if(x==y)return ans; for(int i=log-1;i&gt;=0;--i) if(fa[x][i]!=fa[y][i])&#123; ans=min(ans,min(sum[x][i],sum[y][i])); x=fa[x][i],y=fa[y][i]; &#125; ans=min(ans,min(sum[x][0],sum[y][0])); if(fa[x][0]==0)return -1; else return ans;&#125;int main()&#123; IN(n),IN(m); for(int i=1;i&lt;=n;++i)f[i]=i; for(int i=1;i&lt;=m;++i) IN(G[i].from),IN(G[i].to),IN(G[i].val); std::sort(G+1,G+1+m,cmp); for(int i=1;i&lt;=m;++i)&#123; int fx=find(G[i].from),fy=find(G[i].to); if(fx!=fy)&#123; f[fy]=fx;++cnt; E[G[i].from].push_back(G[i].to),V[G[i].from].push_back(G[i].val); E[G[i].to].push_back(G[i].from),V[G[i].to].push_back(G[i].val); if(cnt==n-1)break; &#125; &#125; for(int i=1;i&lt;=n;++i) if(!dep[i])dfs(i,0,0); IN(q); for(int i=1;i&lt;=q;++i)&#123; int x,y;IN(x),IN(y); printf("%d\n",solve(x,y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>lca</tag>
        <tag>倍增</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [ZJOI2009]狼和羊的故事 网络流 luoguP2598]]></title>
    <url>%2F2019%2F03%2F11%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2598%2F</url>
    <content type="text"><![CDATA[这题真的是裸的网络流……连我这种制杖都可以立刻想到正解。 如果不考虑领地问题的话，这显然是一道很裸的最小割———割断最少的边使 $S$ 和 $T​$ 不连通。 但是现在有了领地的问题……就是说限制了有些格子是一起的，不能被割开。 既然不能被割开，就连一条 $inf$ 的边啊，这样就割不开了啊。 于是我们可以让 $S$ 向所有的狼的领地连一条边权为 $inf$ 的边，然后所有的羊的领地向 $T$ 连一条边权为 $inf$ 的边。然后就是网格边连边了…… Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define A printf("A")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define id(x,y) (((x)-1)*m+(y))const int N=1e5+2;const int inf=1e9+9;const int dx[4]=&#123;0,0,-1,1&#125;;const int dy[4]=&#123;-1,1,0,0&#125;;int n,m,s,t;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;namespace Dinic&#123; std::queue&lt;int&gt; q; struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;1]; int cnt(1),dep[N],head[N]; inline void add(int u,int v,int w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt; &#125; inline bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]||G[i].val&lt;=0)continue; dep[y]=dep[x]+1,q.push(y); &#125; &#125;return dep[t]; &#125; inline int dfs(int x,int flow)&#123; if(x==t||!flow)return flow; int used=0,rlow; for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used; &#125; inline int dinic()&#123; int maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow; &#125;&#125;int main()&#123; IN(n),IN(m);s=n*m+1,t=n*m+2; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; int a;IN(a); if(a==1)Dinic::add(s,id(i,j),inf); if(a==2)Dinic::add(id(i,j),t,inf); &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) for(int k=0;k&lt;4;++k)&#123; int tx=i+dx[k],ty=j+dy[k]; if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;m)continue; Dinic::add(id(i,j),id(tx,ty),1); &#125; printf("%d\n",Dinic::dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 Willem, Chtholly and Seniorious 珂朵莉树 luoguCF896C]]></title>
    <url>%2F2019%2F03%2F11%2F%5B%E9%A2%98%E8%A7%A3%5DluoguCF896C%2F</url>
    <content type="text"><![CDATA[神奇的珂朵莉树，优雅的暴力。 珂朵莉树的主要思想就是对于一段连续的值相同的区间，将其缩为一个结点，然后丢到 $set$ 里面，主要的操作有拆分区间操作…….这货很强大，码量不短但极好写，而且一般不会出什么问题，调试也很方便。 但是珂朵莉树的思想很暴力，比如说区间第 $K$ 大，珂朵莉树的做法就是直接将区间拿出来排一波序！当然，这样暴力的东西只能在随机数据的情况下食用，或者数据水的情况下，不然分分钟给你 $T$ 飞！ 好吧来看看这道题的操作该怎么办： 第一个操作的话属于傻逼操作，珂朵莉树，先 $split$ 提取 $l,r$ 区间，然后直接暴力访问，加上 $x$ 即可。 第二个操作完全就是珂朵莉树的基本操作，跟上面一样，暴力访问然后直接将权值改为 $x$ 即可，更简单的方法就是删除 $l,r$ 区间，然后把权值统一为 $x$ 后再插入 $l,r$ 。 第三个操作第 $K$ 大，上面说了，直接拿出来排个序就好了，炒鸡暴力。 第四个操作……仍然是暴力，可以参考第一二个操作，注意 $longlong$ 的问题，不要爆 $long long$ 了。 对于初始的序列，我们先用题目要求的随机化函数得到序列中每一个位置的值，然后插入到 $set$ 中，这个时候第 $i$ 个元素区间是 $i,i$ 。 还有一个需要注意的地方，就是在插入完整个序列后还要在最后面插入一个边界的哨兵结点，当然哨兵结点的权值为 $0$ 。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;set&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))typedef long long ll;const int N=1e5+7;const int inf=1e9+9;ll seed,vmax;inline ll rnd()&#123; ll ret=seed; seed=(seed*7+13)%1000000007; return ret;&#125;struct ODT&#123; struct Node&#123; int l,r; mutable ll v; Node(int L,int R=-1,ll V=0):l(L),r(R),v(V) &#123;&#125; bool operator &lt; (const Node&amp;x) const &#123;return l&lt;x.l;&#125; &#125;; std::set&lt;Node&gt; s; #define IT std::set&lt;Node&gt;::iterator inline IT split(int pos)&#123; IT it=s.lower_bound(Node(pos)); if(it!=s.end()&amp;&amp;it-&gt;l==pos)return it; else --it; int L=it-&gt;l,R=it-&gt;r;ll V=it-&gt;v; s.erase(it); return s.insert(Node(L,pos-1,V)),s.insert(Node(pos,R,V)).first; &#125; inline void assign(int l,int r,ll val)&#123; IT itr=split(r+1),itl=split(l); s.erase(itl,itr); s.insert(Node(l,r,val)); &#125; inline void add(int l,int r,ll val)&#123; IT itr=split(r+1),itl=split(l); for(;itl!=itr;++itl)itl-&gt;v+=val; &#125; inline ll rank(int l,int r,int k)&#123; std::vector&lt;std::pair&lt;ll,int&gt; &gt; hep; IT itr=split(r+1),itl=split(l); for(;itl!=itr;++itl) hep.push_back(std::make_pair(itl-&gt;v,itl-&gt;r-itl-&gt;l+1)); std::sort(hep.begin(),hep.end()); for(std::vector&lt;std::pair&lt;ll,int&gt; &gt;::iterator it=hep.begin();it!=hep.end();++it)&#123; k-=it-&gt;second; if(k&lt;=0)return it-&gt;first; &#125; &#125; inline ll pow(ll x,ll y,ll mod)&#123; ll res=1ll;x%=mod; for(;y;y&gt;&gt;=1,x=x*x%mod)if(y&amp;1)res=res*x%mod; return res%mod; &#125; inline ll sum(int l,int r,int ex,int mod)&#123; IT itr=split(r+1),itl=split(l); ll res=0; for(;itl!=itr;++itl) res=(res+(ll)(itl-&gt;r-itl-&gt;l+1)*pow(itl-&gt;v,ll(ex),ll(mod)))%mod; return res; &#125; inline void pre(int n)&#123; int a; for(int i=1;i&lt;=n;++i) a=(rnd()%vmax)+1,s.insert(Node(i,i,a)); s.insert(Node(n+1,n+1,0)); return; &#125;&#125;T;int main()&#123; int n,m; scanf("%d%d%lld%lld",&amp;n,&amp;m,&amp;seed,&amp;vmax); T.pre(n); for(int i=1;i&lt;=m;++i)&#123; int op=(rnd()%4)+1,l=(rnd()%n)+1,r=(rnd()%n)+1,x,y; if(l&gt;r)std::swap(l,r); if(op==3)x=(rnd()%(r-l+1))+1; else x=(rnd()%vmax)+1; if(op==4)y=(rnd()%vmax)+1; if(op==1)T.add(l,r,ll(x)); else if(op==2)T.assign(l,r,ll(x)); else if(op==3)printf("%lld\n",T.rank(l,r,x)); else if(op==4)printf("%lld\n",T.sum(l,r,x,y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [国家集训队]聪聪可可 树形DP luoguP2634]]></title>
    <url>%2F2019%2F03%2F10%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2634%2F</url>
    <content type="text"><![CDATA[别人都说，什么淀粉质啊之类的轻松水过，然而我有码量恐惧症，不适合如此数据结构(主要也是太弱了QvQ) 那就上树形DP吧！$f[i][j]$表示点i为根的子树中到i路径权值和%3=j的点数.状态转移：Dfs，直接从子树转移即可，具体看代码。 真是炒鸡简单的啦~~ CODE:1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int#define A printf("A")using namespace std;const int N=2e4+2;inline ll gcd(int x,int y)&#123;return y?gcd(y,x%y):x;&#125;struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;2];int n,cnt,head[N];ll f[N][3],ans;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline void add(int x,int y,int v)&#123; G[++cnt].nxt=head[x],G[cnt].to=y,G[cnt].val=v,head[x]=cnt; G[++cnt].nxt=head[y],G[cnt].to=x,G[cnt].val=v,head[y]=cnt;&#125;inline void Dfs(int x,int fa)&#123; f[x][0]=1; for(register int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to;if(y==fa)continue;Dfs(y,x); for(int j=0;j&lt;3;++j)ans+=(ll)(f[y][j]*f[x][(((3-j-G[i].val)%3)+3)%3]*2); //从子树转移过来，注意取模，看不懂的同学画图秒懂 for(int j=0;j&lt;3;++j)f[x][(G[i].val+j)%3]+=f[y][j]; //跟新 f[x] &#125;return;&#125;int main()&#123; IN(n);ll s=(ll)n*n,g; for(register int x,y,v,i=1;i&lt;n;++i) IN(x),IN(y),IN(v),add(x,y,v); Dfs(1,0);ans+=n,g=gcd(ans,s);//一定要是最简分数 printf("%lld/%lld\n",ans/g,s/g);//输出答案 return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 「网络流24题」餐巾计划问题 网络流 luoguP1251]]></title>
    <url>%2F2019%2F03%2F09%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1251%2F</url>
    <content type="text"><![CDATA[实际上这道题可以用贪心解的……但是码量惊人 $QwQ$ 。 于是上网络流吧……这题显然是费用流。 对于每一天，我们将其拆成两个点，一个表示这天的早晨，一个表示这天的晚上。 我们从源点向每一天的晚上连一条边权为 $x$ 费用为 $0​$ 的边，表示这一天我们需要处理的餐巾数，就是白天用掉的餐巾。 每一天的早晨，这些餐巾来自题目给出的地方，并且最终连向汇点，边权为 $x$ 费用为 $0$ 。 然后考虑每天早上餐巾的来源，现在题目给了四个操作： 买新的 丢到快洗店 丢到慢洗店 弃疗 对于买新的，我们只需要从源点连一条边权为 $inf$ 费用为 $p$ 的边到这一天的白天，我们餐巾的获取都来自源点。 丢到快洗店，也就是说第 $i$ 天晚上这些没有处理的毛巾丢到快洗店，那么第 $i+m$ 天将洗完，这个时候可以在早晨收到餐巾，于是从 $i$ 的晚上连一条边权为 $inf$ 费用为 $f$ 的边连向 $i+m$ 的白天。 丢到慢洗店，这个跟快洗店是一个道理。 关于弃疗，就是说放着不管了，可以理解为第 $i$ 天晚上的餐巾留到了第 $i+1$ 天，并且这些餐巾是不能用的，那么不会连向 $i+1$ 的早晨，于是从 $i$ 的晚上连一条边权为 $inf$ 费用为 $f$ 的边连向 $i+1$ 的晚上。 然后跑一边费用流板子就好了，注意要开 $long long$ 。 至于上面四个选项为什么边的容量都设为 $inf$ ，我们就拿买新的来说吧，题目又没有限制你最多买多少，所以就是允许你可以一直买，买无限条，就当成 $inf$ 啦。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define id(type,x) ((type)*n+x)#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y)) const int N=1e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int s,t,r[N],tot(1),head[N],vis[N],dist[N];struct Edge&#123;int nxt,to,val,cot;&#125;G[N&lt;&lt;8];struct Pre&#123;int last,edge;&#125;pre[N];inline void add(int u,int v,int val,int cot)&#123; G[++tot].nxt=head[u],G[tot].to=v,G[tot].val=val,G[tot].cot=cot,head[u]=tot; G[++tot].nxt=head[v],G[tot].to=u,G[tot].val=0,G[tot].cot=-cot,head[v]=tot;&#125; inline bool Spfa()&#123; memset(pre,0,sizeof(pre)); memset(dist,0x3f,sizeof(dist)); memset(vis,0,sizeof(vis)); std::queue&lt;int&gt; q; q.push(s),vis[s]=1,dist[s]=0; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i;i=G[i].nxt)&#123; int v=G[i].to; if(G[i].val&gt;0&amp;&amp;dist[v]&gt;dist[u]+G[i].cot)&#123; dist[v]=dist[u]+G[i].cot; pre[v].last=u,pre[v].edge=i; if(!vis[v])&#123;q.push(v),vis[v]=1;&#125; &#125; &#125;vis[u]=0; &#125;return dist[t]!=0x3f3f3f3f;&#125;inline ll EK()&#123; ll maxflow=0; ll cost=0; int min_flow; while(Spfa())&#123; min_flow=inf; for(int i=t;i!=s;i=pre[i].last) min_flow=min(min_flow,G[pre[i].edge].val); for(int i=t;i!=s;i=pre[i].last)&#123; G[pre[i].edge].val-=min_flow; G[pre[i].edge^1].val+=min_flow; &#125; maxflow+=min_flow; cost+=min_flow*dist[t]; &#125;return cost; &#125;int main()&#123; int n,_n,_p,_m,_f,_s; IN(n);s=0,t=n*2+1; for(int i=1;i&lt;=n;++i)&#123; int x;IN(x); add(s,id(1,i),x,0),add(id(0,i),t,x,0); &#125; IN(_p),IN(_m),IN(_f),IN(_n),IN(_s); for(int i=1;i&lt;=n;++i)&#123; if(i+1&lt;=n)add(id(1,i),id(1,i+1),inf,0); if(i+_m&lt;=n)add(id(1,i),id(0,i+_m),inf,_f); if(i+_n&lt;=n)add(id(1,i),id(0,i+_n),inf,_s); add(s,id(0,i),inf,_p); &#125; printf("%lld\n",EK()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈4种莫队及例题]]></title>
    <url>%2F2019%2F03%2F08%2F%5B%E7%AE%97%E6%B3%95%5D%E8%8E%AB%E9%98%9F%26%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[在此输入你的密码以便阅读全文 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [WC2013]糖果公园 树上带修改莫队 luoguP4074/Uoj58]]></title>
    <url>%2F2019%2F03%2F08%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4074%2F</url>
    <content type="text"><![CDATA[毒瘤题目，树上带修改莫队板子题。 关于树上莫队和带修改莫队的文章戳这 $QwQ​$ :[算法]莫队&amp;树上莫队 然后就是将其结合在一起了，结合的话炒鸡简单，就是码量增大… 可以算作一个树上莫队/树上带修改莫队的板子来看。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cctype&gt;#include&lt;bitset&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define swap(x,y) ((x)^=(y)^=(x)^=(y))const int N=1e5+24;const int LogN=20;const int inf=1e9+9;inline int IN()&#123; int x=0;char ch;bool flag=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return flag?-x:x;&#125;int n,m,q,v[N],w[N],c[N];/*test*/int id[N&lt;&lt;1],in[N],out[N],dep[N],f[N][LogN],sequencelong;/*dfs&amp;lca*/int head[N],cnt;/*Tree Edge*/struct Edge&#123;int nxt,to;&#125;G[N&lt;&lt;1];/*Tree Edge*/int c0,c1,block,tot[N],cl[N],cr[N],vis[N],modify[N];/*MO*/struct MO&#123;int l,r,lbe,rbe,time,id,lca,ans;&#125;Q[N];/*MO*/ll now,Ans[N];bool cmp(MO a,MO b)&#123; if(a.lbe^b.lbe)return a.lbe&lt;b.lbe; if(a.rbe^b.rbe)return a.rbe&lt;b.rbe; if(a.time^b.time)return a.time&lt;b.time;&#125;inline void add(int u,int v)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,head[v]=cnt;&#125;void Get_Lca_and_sequence(int u,int fa)&#123; dep[u]=dep[fa]+1,f[u][0]=fa; for(int i=1;i&lt;20;++i)f[u][i]=f[f[u][i-1]][i-1]; id[in[u]=++sequencelong]=u; for(int i=head[u];i;i=G[i].nxt) if(G[i].to!=fa)Get_Lca_and_sequence(G[i].to,u); id[out[u]=++sequencelong]=u; return;&#125;int Lca(int u,int v)&#123; if(dep[u]&lt;dep[v])swap(u,v); for(int i=19;~i;--i) if(dep[u]-(1&lt;&lt;i)&gt;=dep[v])u=f[u][i]; for(int i=19;~i;--i) if(f[u][i]!=f[v][i])u=f[u][i],v=f[v][i]; return u==v?u:f[u][0];&#125;inline void _Main_input()&#123; n=IN(),m=IN(),q=IN();/*line 1*/ for(int i=1;i&lt;=m;++i)v[i]=IN();/*line 2*/ for(int i=1;i&lt;=n;++i)w[i]=IN();/*line 3*/ for(int i=1;i&lt;n;++i)add(IN(),IN());/*line 4 to n+2*/ for(int i=1;i&lt;=n;++i)c[i]=IN();/*line n+3*/ Get_Lca_and_sequence(1,0); block=std::ceil(std::pow(sequencelong,0.66666)); for(int i=1;i&lt;=q;++i)&#123;/*line n+4 to n+4+q*/ int Type=IN(),x=IN(),y=IN(); if(Type==1)&#123; Q[++c1].id=c1,Q[c1].time=c0; if(x==y)&#123; Q[c1].lbe=(Q[c1].l=in[x])/block; Q[c1].rbe=(Q[c1].r=in[x])/block; &#125;else&#123; if(in[x]&lt;in[y]&amp;&amp;out[y]&lt;out[x])&#123; Q[c1].lbe=(Q[c1].l=in[x])/block; Q[c1].rbe=(Q[c1].r=in[y])/block; &#125; else if(in[y]&lt;in[x]&amp;&amp;out[x]&lt;out[y])&#123; Q[c1].lbe=(Q[c1].l=in[y])/block; Q[c1].rbe=(Q[c1].r=in[x])/block; &#125; else&#123; if(out[x]&lt;in[y])&#123; Q[c1].lbe=(Q[c1].l=out[x])/block; Q[c1].rbe=(Q[c1].r=in[y])/block; Q[c1].lca=Lca(x,y); &#125; else if(out[y]&lt;in[x])&#123; Q[c1].lbe=(Q[c1].l=out[y])/block; Q[c1].rbe=(Q[c1].r=in[x])/block; Q[c1].lca=Lca(x,y); &#125; &#125; &#125; &#125;else modify[++c0]=x,cl[c0]=c[x],cr[c0]=y,c[x]=y; &#125;return;&#125;inline void work(int x)&#123; if(vis[x])now-=1ll*v[c[x]]*w[tot[c[x]]--]; else now+=1ll*v[c[x]]*w[++tot[c[x]]]; vis[x]^=1;return;&#125;inline void add(int x)&#123; if(vis[modify[x]])&#123;work(modify[x]);c[modify[x]]=cr[x];work(modify[x]);&#125; else c[modify[x]]=cr[x];&#125;inline void del(int x)&#123; if(vis[modify[x]])&#123;work(modify[x]);c[modify[x]]=cl[x];work(modify[x]);&#125; else c[modify[x]]=cl[x];&#125;inline void _Main_Mo_Solve()&#123; std::sort(Q+1,Q+c1+1,cmp); int l=1,r=0,nowtime=c0; for(int i=1;i&lt;=c1;++i)&#123; while(nowtime&gt;Q[i].time)del(nowtime--); while(nowtime&lt;Q[i].time)add(++nowtime); while(l&lt;Q[i].l)work(id[l++]); while(l&gt;Q[i].l)work(id[--l]); while(r&lt;Q[i].r)work(id[++r]); while(r&gt;Q[i].r)work(id[r--]); if(Q[i].lca)work(Q[i].lca); Ans[Q[i].id]=now; if(Q[i].lca)work(Q[i].lca); &#125;&#125;inline void _Main_output()&#123; for(int i=1;i&lt;=c1;++i) printf("%lld\n",Ans[i]);&#125;int main()&#123; _Main_input(); _Main_Mo_Solve(); _Main_output(); return 0;&#125; 当然，尽管再毒瘤，这个也只是入门的树上带修改莫队的题目。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SCOI2007]蜥蜴 网络流 luogu2472]]></title>
    <url>%2F2019%2F03%2F06%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2472%2F</url>
    <content type="text"><![CDATA[网络流……..题目要求我们求出能逃离的蜥蜴数量的最大值，不就是最大流吗？ 然后考虑怎么建模。 首先来看看蜥蜴，我们将这些蜥蜴的点跟 $s$ 连边，边权是多少呢？想一想，由于一个位置只有一只蜥蜴，那么边权就当然是 $1$ 了。 然后考虑逃离的这些柱子，题目说什么石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减 $1$ ，看似很不好办，但是这恰恰就是网络流。对于柱子间的一条边，从 $s$ 经过蜥蜴的点的时候，流量就只有 $1$ 了，这个 $1$ 的流量流过柱子中的边的时候就会让这条边的边权减 $1$ ，减到 $0$ 当然就不能流了。 那么柱子之间怎么连边呢？ 对于一个柱子，我们将它拆成两个点，一个入点，一个出点。其中入点向出点连一条边，边权为这个柱子的高度。如果一个柱子，判断一下，发现从它这里可以跳出去，那么就将这个柱子的出点向 $t$ 连一条边，这条边仅仅是代表找到了答案，对答案没有影响，边权为 $inf$ 。 然后我们再看一下，这个柱子能到达的柱子有哪些，这里直接算曼哈顿距离就好了。然后由这条柱子的出点向能到达的柱子的入点连一条边，边权呢？还是为 $inf$ 。因为我们对一个柱子的影响就是入点到出点的那一条边，那一条边的边权已经限制了这个柱子的使用量，所以中间的边权为 $inf$ 。 注意数组大小，要开大一点。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/*---[SCOI2007]蜥蜴.网络流-最大流 毒瘤题目*/#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define ID(ty,x,y) ((ty)*r*c+id[(x)][(y)])const int N=55;const int S=1e5+2;const int inf=1e9+9;std::queue&lt;int&gt; q;std::vector&lt;std::pair&lt;int,int&gt; &gt; lizard;std::vector&lt;std::pair&lt;int,int&gt; &gt; Pillar;int r,c,d,s,t;int dep[S],head[S],cnt=1;int val[N][N],id[N][N],tot=0,total=0;char str;struct Edge&#123;int nxt,to,val;&#125;G[N*N*8];inline void add(int u,int v,int w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int bfs()&#123; std::memset(dep,0,sizeof(dep)); dep[s]=1;q.push(s); while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i;i=G[i].nxt)&#123; int v=G[i].to; if(!dep[v]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,q.push(v); &#125; &#125;return dep[t];&#125;int dfs(int u,int flow)&#123; if(u==t||!flow)return flow; int used=0,rlow; for(int i=head[u];i;i=G[i].nxt)&#123; int v=G[i].to; if(dep[v]==dep[u]+1&amp;&amp;G[i].val&gt;0)&#123; used+=(rlow=dfs(v,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[u]=-1; return used;&#125;int dinic()&#123; int maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow;&#125;void _pre_in()&#123; IN(r),IN(c),IN(d); s=0,t=r*c*2+1; Pillar.clear();//柱子 lizard.clear();//蜥蜴 for(int i=1;i&lt;=r;++i) for(int j=1;j&lt;=c;++j)&#123; std::cin&gt;&gt;str; id[i][j]=++tot,val[i][j]=str-'0'; if(val[i][j]&gt;0)Pillar.push_back(std::make_pair(i,j)); &#125; for(int i=1;i&lt;=r;++i) for(int j=1;j&lt;=c;++j)&#123; std::cin&gt;&gt;str; if(str=='L')++total,lizard.push_back(std::make_pair(i,j)); &#125; return;&#125;void _pre_add_line()&#123;//连边 for(int i=0;i&lt;Pillar.size();++i)&#123; int x=Pillar[i].first,y=Pillar[i].second; add(ID(0,x,y),ID(1,x,y),val[x][y]); if(x&lt;=d||y&lt;=d||x+d&gt;r||y+d&gt;c)add(ID(1,x,y),t,inf);//可以逃出去 &#125; for(int i=0;i&lt;Pillar.size();++i) for(int j=0;j&lt;Pillar.size();++j)&#123; if(i==j)continue; int xi=Pillar[i].first,yi=Pillar[i].second; int xj=Pillar[j].first,yj=Pillar[j].second; if((xi-xj)*(xi-xj)+(yi-yj)*(yi-yj)&lt;=d*d) add(ID(1,xi,yi),ID(0,xj,yj),inf);//柱子之间可以互相到达 &#125; for(int i=0;i&lt;lizard.size();++i)&#123; int x=lizard[i].first,y=lizard[i].second; add(s,ID(0,x,y),1);//源点向蜥蜴连边 &#125;return;&#125;int main()&#123; _pre_in(); _pre_add_line(); printf("%d\n",total-dinic()); /*注意最终要算的是最少的未逃离的数，不是逃离的最大数*/ return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [HNOI2013]切糕 网络流 bzoj3144]]></title>
    <url>%2F2019%2F03%2F04%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj3144%2F</url>
    <content type="text"><![CDATA[话说切糕有很多细菌，并且高价，现在不让买了，也不让卖了…….. 好吧我们来解决一下这题吧。 额……感觉题意有点不可读，实际上题目就是说给你一个立方体，然后立方体中的每一个点都有一个权值，表示如果要切这个点的话所花费的代价，那么这时需要让你横着切，将这个立方体切成两半，求最小代价。 这就是很明显的最小割了，切成两半使得 $s$ 和 $t$不连通嘛。 于是我们可以考虑这样建边：对于这个立方体，我们建一个虚拟层—第 $0$ 层，对于第 $0$ 层的每一个点，我们用 $s$ 与其相连，这个连接的边是不能被割掉的，所以边权为 $inf$ 。然后对于第 $R$ 层的所有点，我们都将其与 $t$ 相连，同样的道理，边权为 $inf$ 。然后中间的点的话，考虑一个点 $(x,y,z)$ ，我们连一条 $(x−1,y,z)$ 到 $(x,y,z)$ 的边，权值为 $v(x,y,z)$ (即点 $(x,y,z)$ 的权值) 。 这个就是基本的了，如果没有第二个光滑性的限制，直接跑 $Dinic$ 就好了。 但是现在有了这个限制，怎么办呢？ 对于一个竖轴，假设这个竖轴的横竖坐标为 $(x,y)$ ，现在在这个竖轴上有一个高度为 $z$ 的点，这个点的坐标显然为 $(x,y,z)$ ，那么现在的情况就是，如果选了 $z$ ，那么相邻竖轴上的 $z−d,z+d$ 都必须选。 于是我们考虑，从 $(x,y,z)$ 向相邻数轴的 $z−d,z+d$ 连一条 $inf$ 的边，这样就可以保证正确性了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define A printf("A")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int dx[5]=&#123;0,0,0,-1,1&#125;;const int dy[5]=&#123;0,-1,1,0,0&#125;;const int N=8e4+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int P,Q,R,D,s,t,pointval[42][42][42];inline int point(int x,int y,int z)&#123;return x*P*Q+y*Q+z;&#125;namespace Dinic&#123; std::queue&lt;int&gt; q; struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;2]; int cnt(1),dep[N],head[N]; inline void add(int u,int v,int w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt; &#125; inline bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]||G[i].val&lt;=0)continue; dep[y]=dep[x]+1,q.push(y); &#125; &#125;return dep[t]; &#125; inline int dfs(int x,int flow)&#123; if(x==t||!flow)return flow; int used=0,rlow; for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used; &#125; inline int dinic()&#123; int maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow; &#125;&#125;int main()&#123; IN(P),IN(Q),IN(R),IN(D);s=0,t=N-1; for(int i=1;i&lt;=R;++i) for(int j=1;j&lt;=P;++j) for(int k=1;k&lt;=Q;++k) IN(pointval[i][j][k]); for(int j=1;j&lt;=P;++j) for(int k=1;k&lt;=Q;++k) Dinic::add(s,point(0,j,k),inf); for(int i=1;i&lt;=R;++i) for(int j=1;j&lt;=P;++j) for(int k=1;k&lt;=Q;++k) Dinic::add(point(i-1,j,k),point(i,j,k),pointval[i][j][k]); for(int j=1;j&lt;=P;++j) for(int k=1;k&lt;=Q;++k) Dinic::add(point(R,j,k),t,inf); for(int i=D;i&lt;=R;++i) for(int j=1;j&lt;=P;++j) for(int k=1;k&lt;=Q;++k) for(int l=0;l&lt;5;++l)&#123; int tx=dx[l]+j,ty=dy[l]+k; if(tx&lt;1||tx&gt;P||ty&lt;1||ty&gt;Q)continue; Dinic::add(point(i,j,k),point(i-D,tx,ty),inf); &#125; printf("%d\n",Dinic::dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 士兵占领 网络流 luogu4311]]></title>
    <url>%2F2019%2F03%2F01%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4311%2F</url>
    <content type="text"><![CDATA[讨厌死权限题了，然而这题又是 $bzoj$ 的权限题。 $QwQ$ 只好去洛谷上做了，幸好洛谷收的题目比较多。 这题就是网络流，我们先假设棋盘上摆满了士兵，这个时候需要拿走一些士兵，使得棋盘仍然是合法的，求拿走的最多数。 额……最多数让我想起了最大流，不过现在还是先来考虑怎么建图。 我们建两排点，第一排表示行，一共 $M$ 个点，第二排表示列，一共 $N$ 个点。对于一个点 $(x,y)$ ，就像从第一排的第 $x$ 号点向第二排的第 $y$ 号点连一条边权为 $1$ 的边。 这个显然是没有问题的。 然后就是限制，对于第 $k$ 行，至少要有 $L_k$ 个士兵，于是我们从 $s$ 连一条边权为 $L_k$ 的边，连向第一排的第 $k$ 号点。同样的道理，对于第二排的点，我们也像这样连边，连向 $t$ 。 然后就是跑 $dinic$ 了，别忘了跑出来的不是答案，而是最多拿走的士兵数，这个时候用整个棋盘的空位置的个数减去跑出来的 $maxflow$ 才是答案。 需要注意几个点： 当我们在看到了一个行/列的时候，需要判断一下。假设这个是行，那么这行的位置显然有 $n$ 个，如果 $n$ 减去这行障碍的个数，再减去最少要放的士兵数后为负数，那么显然就怎么也不可能有合法的方案，于是直接输出 “JIONG” 就好了。 注意整个棋盘的空位置不是 $N\cdot M$ ，而是 $N\cdot M-K$! 数组大小的话只需要开到 $2n$ ，并不需要开到 $n^2$ ，因为只有两排点。但是边的数组大小需要开到 $n^2$ ，因为我们对于棋盘上的一个点就要连一条边表示它！ Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define A printf("A")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=2e2+5;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;std::queue&lt;int&gt; q;struct Edge&#123;int nxt,to,val;&#125;G[N*N];int n,m,k,s,t,cnt(1),dep[N],head[N];int map[N][N],Li[N],Ci[N],Lm[N],Cm[N];inline void add(int u,int v,int w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt; &#125;inline bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]||G[i].val&lt;=0)continue; dep[y]=dep[x]+1,q.push(y); &#125; &#125;return dep[t];&#125; inline int dfs(int x,int flow)&#123; if(x==t||!flow)return flow; int used=0,rlow; for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow;&#125;int main()&#123; IN(m),IN(n),IN(k); s=1,t=n+m+1; int atot=n*m-k; for(int i=1;i&lt;=m;++i)IN(Li[i]); for(int i=1;i&lt;=n;++i)IN(Ci[i]); for(int i=1;i&lt;=k;++i)&#123; int x,y;IN(x),IN(y); map[x][y]=1,Lm[x]++,Cm[y]++; &#125; for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=n;++j) if(!map[i][j])add(i,j+m,1); for(int i=1;i&lt;=m;++i)&#123; int flow=n-Li[i]-Lm[i]; if(flow&lt;0)&#123;printf("JIONG!");exit(0);&#125; else add(s,i,flow); &#125; for(int i=1;i&lt;=n;++i)&#123; int flow=m-Ci[i]-Cm[i]; if(flow&lt;0)&#123;printf("JIONG!");exit(0);&#125; else add(i+m,t,flow); &#125; printf("%d\n",atot-dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2015]约数个数和 莫比乌斯反演 luoguP3327]]></title>
    <url>%2F2019%2F03%2F01%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3327%2F</url>
    <content type="text"><![CDATA[又是一道神奇的题目。 一句话题意：给定 $n,m$ 求 $\sum_{i=1}^{n}\sum_{j=1}^{m}d(ij)$ 于是开始推式子： 有这么一条公式： d(ij)=\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]这个非常重要，至于证明的话，本人太弱，留个坑，到时候再填，请大家谅解 $QwQ$ 。 然后呢？发现题目求的式子后面正好是 $d(ij)$ ，于是美滋滋的套进去。 \sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x|i}\sum_{y|j}[gcd(i,j)=1]$x$ 和 $y$ 我们扔到前面去枚举，后面来计算它们对它们的倍数做出的贡献。 可以知道前面的 $x$ 在 $n$ 以内的倍数有 $\lfloor\frac{n}{x}\rfloor$ 个，$y$ 在 $m$ 以内的倍数有 $\lfloor\frac{m}{y}\rfloor$，于是： \sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x|i}\sum_{y|j}[gcd(i,j)=1]=\sum_{x=1}^{n}\sum_{y=1}^{m}\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor\cdot[gcd(i,j)=1]按照套路，我们设： f(x)=\sum_{x=1}^{n}\sum_{y=1}^{m}\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor\cdot[gcd(i,j)=k]g(k)=\sum_{x=1}^{n}\sum_{y=1}^{m}\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor\cdot[k|gcd(i,j)]那么显然有： g(k)=\sum_{k|d} f(d)这个式子很有熟悉的味道，显然是反演常见的第二种形式。 所以就有： f(k)=\sum_{k|d}\mu(\frac{d}{k})g(d)我们的答案是$f(1)$，那么就是： f(1)=\sum_{d=1}^{n}\mu(d)g(d)现在来考虑怎么计算 $g$ 。 g(k)=\sum_{x=1}^{n}\sum_{y=1}^{m}\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor\cdot[k|gcd(i,j)]后面的 $k$ 很碍眼，消掉他。 g(k)=\sum_{x=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{y=1}^{\lfloor\frac{m}{k}\rfloor}\lfloor\frac{n}{xk}\rfloor\lfloor\frac{m}{yk}\rfloor于是我们预处理一个函数 $s$ ： s(k)=\sum_{i=1}^{k}\lfloor\frac{k}{i}\rfloor那么 $g(k)$ 就很好算了： g(k)=s(n/k) \cdot s(m/k)复杂度的话还好，预处理 $s$ 时可以整出分块，$O(\sqrt{n})$ 爽歪歪。然后的话，发现统计答案的时候 $g$ 函数也可以整出分块，$O(\sqrt{n})$ 。最后总时间复杂度 $O(T\sqrt{n})$ (???)反正过了就行，我也不会算 $QwQ$ 。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=5e4+2;const int inf=1e9+9;int T,n,m,cnt;int mui[N],vis[N],prime[N];ll s[N]; inline void _pre_mui()&#123; mui[1]=1; for(int i=2;i&lt;=N;++i)&#123; if(!vis[i])prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;5e4)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;mui[i*prime[j]]=0;break;&#125; mui[i*prime[j]]=-mui[i]; &#125; &#125; for(int i=1;i&lt;=N;++i)mui[i]+=mui[i-1]; for(int x=1;x&lt;=N;++x)&#123;//实际上这里是O(n sqrt(n))，不过影响不大。 ll res=0; for(int l=1,r=0;l&lt;=x;l=r+1) r=(x/(x/l)),res+=1ll*(r-l+1)*(x/l); s[x]=res; &#125;return;&#125;inline ll solve(int n,int m)&#123; ll ans=0; if(n&gt;m)n^=m^=n^=m; for(int l=1,r=0;l&lt;=n;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); ans+=1ll*(mui[r]-mui[l-1])*s[n/l]*s[m/l]; &#125;return ans;&#125;int main()&#123; _pre_mui(); scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",solve(n,m)); &#125;return 0;&#125; =\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]ij]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [国家集训队]Crash的数字表格 莫比乌斯反演 luoguP1829]]></title>
    <url>%2F2019%2F03%2F01%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1829%2F</url>
    <content type="text"><![CDATA[吐槽一下Typora这个编辑器：码了一上午的题解，居然突然卡机，并且自动关掉了，然后重新打开，发现保存的也没了。然后弹出一个“Typora意外关闭”的窗口，真想一拳上去。 只好重新自己码了……。(以上是吐槽，请不要在意) 算了算了，重新写吧。所以你看到的这是第二份稿子。 仍然上莫比乌斯反演。 众所周知： lcm(i,j)=\frac{ij}{gcd(i,j)}​那么我们将这个带进原式： \sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j) = \sum_{i=1}^{n}\sum_{j=1}^{m}\frac{ij}{gcd(i,j)}​我们枚举 $gcd(i,j)$ 的值： \sum_{d=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]\frac{ij}{d}=\sum_{d=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]ijd=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]ij设： f(x)=\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=x]ijg(x)=\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[x|gcd(i,j)]ij可得： g(x)=\sum_{x|d}f(d)考虑怎么计算 $g(x)$ ： g(x)=\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[x|gcd(i,j)]ijg(x)=\sum_{i=1}^{\lfloor\frac{n}{dx}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{dx}\rfloor}ij \cdot x^2g(x)=x^2\sum_{i=1}^{\lfloor\frac{n}{dx}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{dx}\rfloor}ij这个显然是可以 $O(1)$ 算出的。 继续： ans=\sum_{d=1}^{n}d\cdot f(1)f(1)=\sum_{d=1}^{\lfloor\frac{n}{}\rfloor}\mu(d)g(d)这个时候的复杂度只是 $O(n^2)$ ，继续优化。 将 $ans$ 写出： ans=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]ij发现后面可以整除分块！ 继续，将 $f(1)$ 写出： f(1)=\sum_{i=1}^{n}\mu(i)g(i)f(1)=\sum_{i=1}^{n}\mu(i)i^2\sum_{a=1}^{\lfloor\frac{n}{di}\rfloor}\sum_{b=1}^{\lfloor\frac{m}{di}\rfloor}ab将 $g$ 拆开后，我们可以发现后面又可以整除分块！ 那么现在就是 $O(n)$ 了，可以过。 Code-$O(n)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define MOD 20101009#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e7+2;const int inf=1e9+9;int mui[N],sum[N];int vis[N],prime[N],cnt;inline void _pre_mui(int n)&#123; mui[1]=1; for(int i=2;i&lt;=n;++i)&#123; if(!vis[i])prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;n)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;mui[i*prime[j]]=0;break;&#125; mui[id*prime[j]]=-mui[i]; &#125; &#125;return;&#125;inline int solve(int n,int m)&#123; ll ans=0; for(int l=1,r=0;l&lt;=n;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); int res=1ll*(1ll*(n/l)*(n/l+1)/2%MOD)*(1ll*(m/l)*(m/l+1)/2%MOD)%MOD; ans+=1ll*(sum[r]-sum[l-1])%MOD*res%MOD; ans%=MOD; &#125;return (ans+MOD)%MOD;&#125;int main()&#123; int n,m,ans=0; scanf("%d%d",&amp;n,&amp;m); if(n&gt;m)n^=m^=n^=m; _pre_mui(n); for(int i=1;i&lt;=n;++i) sum[i]=(sum[i-1]+1ll*i*i%MOD*mui[i]%MOD+MOD)%MOD; for(int l=1,r=0;l&lt;=n;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); int res=1ll*(l+r)*(r-l+1)/2%MOD; ans=(ans+1ll*solve(n/l,m/l)*res%MOD)%MOD; &#125; printf("%d\n",ans); return 0;&#125; 毒瘤出题人不会放过我们，这个毒瘤更改了数据： $n,m \leq 10^{10}$ 。 “哇咔咔咔卡掉你们的 O(n) !” 真想一拳上去这个智障。 $O(\sqrt{n})$ 是过的了的，故考虑向着这个方向前进。 继续推式子： ans=\sum_{d=1}^{n}d\sum_{i=1}^{n}\mu(i)i^2\sum_{a=1}^{\lfloor\frac{n}{di}\rfloor}\sum_{b=1}^{\lfloor\frac{m}{di}\rfloor}ab看见这个 $di$ 了吗？我们令 $T=di$ ，然后将 $T$ 扔到前面去枚举一下。 然后就是后面的两个 $\sum$ ，这玩意跟 $i,d$ 没关系，一起扔到前面去。 于是就变成了： ans=\sum_{T=1}^{n}\sum_{a=1}^{\lfloor\frac{n}{T}\rfloor}\sum_{b=1}^{\lfloor\frac{m}{T}\rfloor}ab\sum_{i|T}i^2\frac{T}{i}\mu(i)？？？？？？？ 首先前面的这段是没有问题的对吧，那么后面的呢？ 后面的原来是不是： \sum_{d=1}^{n}d\sum_{i=1}^{n}\mu(i)i^2那么……现在我们枚举的 $T$ 是 $i \cdot d$ ，我们枚举了一下可能的 $i$ ，成为 $i$ 的必备条件肯定是能被 $T$ 整除对吧？那么这个时候的 $d$ 呢？很显然是 $\frac{T}{i}$ 对吧？ 所以啊……就是这么写了。 但是这样写有什么用啊 $QwQ$ 首先，我们来看，$i^2$ 是个什么鬼？我们设一个函数 $Q(i)=i^2$ ，于是我们可以发现，这个东西是个完全积性函数，然后看 $\frac{T}{i}$ ，显然是 $id(\frac{T}{i})$ ，也是完全积性函数。于是两个完全积性函数用狄利克雷卷积卷起来，它们的狄利克雷卷积是一定可以筛出来的。后面的 $\mu$ 是积性函数，然后呢？后面的那一坨都可以筛出来！ 于是美滋滋。 我们设 $sum[k]$ 表示当 $T$ 为 $k$ 的时候后面那一坨的值。 那么现在分三种情况： $k$ 是质数，这下子后面的 $i$ 只能是 $1$ 和 $k$ ，$1$ 的时候的值就是 $k$ ，$k$ 的时候的值是 $k^2\cdot \frac{k}{k}\cdot \mu(k)$ ，很显然这个时候的 $\mu(k)$ 的值是 $-1$ ，于是这个时候的值是 $-k^2$ ，那么这个时候 $sum[k]$ 的值是 $k-k^2$ 。 $\mu(k)$ 为 $0$ ，这下子的话就肯定有一个 $j$ ，使得 $k$ 可以整除 $j^2$ ，这个时候假设就只能整除 $j^2$ ，也就是说 $\mu(k/j)$ 的值非 $0$ 。那么我们看看，在 $sum$ 所计算的式子中，只有 $T$ 的因子对 $T$ 产生贡献。考虑 $k/j$ 到 $k$ 多了什么因子。这个时候多的因子有两类，一类是包含了 $j^2$ 的，一类是只包含了 $j$ 的。第二类的可以先不管，因为之前 $k/j$ 中有了一个 $j$ ，这类因子的贡献已经算过了。那么对于第一类因子，因为包含了 $j^2$ ，所以 $\mu$ 值为 $0$ ，对答案没有任何贡献。 那么这个时候对答案有贡献的还是 $k/j$ 的因子，乘上一个 $j$ 后没有更多的对答案造成贡献的因子。 但是我们发现上限 $T$ 变了，增大了 $j$ 倍，对于原来的每份贡献的值也增大了 $j$ 倍。由于没有其他的贡献，$k$ 的所有的贡献都来自 $k/j$ ，那么直接转移就好。 所以是$sum[k]=sum[k/j]\cdot j$ 对于剩下的情况，我们发现，这个可以直接转移了。当我们枚举 $k$ 的时候，考虑怎么用 $k$ 来转移 $k\cdot j$ ，这个时候 $j$ 是质数，并且 $k$ 中不包含 $j$ ，也就是说 $k$ 与 $j$ 互质。于是根据积性函数的性质，$sum[k]=sum[k/j]\cdot sum[j]$ 就好。 于是这个时候前面再整出分块一下，复杂度 $O(\sqrt{n})$ 。 听说有人被卡住 $O(n)$ 后没有推式子了，直接上了个杜教筛，这人一看就是杜教士了，并且也说明不珂学的上杜教筛是布星的 Code-$O(\sqrt{n})$123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; #define ll long long#define MOD 20101009#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y)) const int N=1e7+3;const int inf=1e9+9; int sum[N],vis[N],prime[N],cnt; inline void _pre_mui_sum()&#123; vis[1]=sum[1]=1; for(int i=2;i&lt;=N;++i)&#123; if(!vis[i])prime[++cnt]=i,sum[i]=(i-1ll*i*i%MOD+MOD)%MOD; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;=N)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;sum[i*prime[j]]=1ll*sum[i]*prime[j]%MOD;break;&#125; else sum[i*prime[j]]=1ll*sum[i]*sum[prime[j]]%MOD; &#125; &#125; for(int i=1;i&lt;=N;++i) sum[i]=(sum[i-1]+sum[i])%MOD;&#125; int main()&#123; int n,m; _pre_mui_sum(); scanf("%d%d",&amp;n,&amp;m); if(n&gt;m)std::swap(n,m); long long ans=0; for(int l=1,r=0;l&lt;=n;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); int res=(1ll*(1+n/l)*(n/l)/2%MOD)*(1ll*(1+m/l)*(m/l)/2%MOD)%MOD; ans+=1ll*(sum[r]-sum[l-1]+MOD)%MOD*res%MOD; ans%=MOD; &#125; printf("%lld\n",(ans+MOD)%MOD); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 YY的GCD 莫比乌斯反演 luogu2257]]></title>
    <url>%2F2019%2F02%2F28%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2257%2F</url>
    <content type="text"><![CDATA[又是一道反演题，显然，题目要求我们求出下式： \sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)\in prime]​这个不好求，我们来推式子。 设 $n \leq m$ \sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)\in prime]=\sum_{k=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=k] \cdot[k \in prime]​=\sum_{k=1}^{n}\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{k} \rfloor}[gcd(i,j)=1]\cdot[k \in prime]我们知道 $\mu$ 函数的一个性质： [n=1]=\sum_{d|n} \mu(d)将 $n$ 换为 $gcd(i,j)$ ，然后扔回原式。 [n=1]=\sum_{d|n} \mu(d) \ \Rightarrow \ [gcd(i,j)=1]=\sum_{d|gcd(i,j)} \mu(d)\sum_{k=1}^{n}\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{k} \rfloor}\sum_{d|gcd(i,j)}\mu(d) \ \ \ (k \in prime)​=\sum_{k=1}^{n}\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{k} \rfloor}[d|gcd(i,j)]\cdot \mu(d) \ \ \ (k \in prime)=\sum_{k=1}^{n}\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{kd} \rfloor}[1|gcd(i,j)]\cdot \mu(d) \ \ \ (k \in prime)=\sum_{k=1}^{n}\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{kd} \rfloor}\mu(d) \ \ \ (k \in prime)我们知道，这里的 $\sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{kd} \rfloor}​$ 可以变成 $\lfloor \frac{n}{kd} \rfloor \lfloor \frac{m}{kd} \rfloor​$ 的，这是等价的。于是： =\sum_{k=1}^{n}\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor}\mu(d)\cdot \lfloor \frac{n}{kd} \rfloor \lfloor \frac{m}{kd} \rfloor \ \ \ (k \in prime)​这个式子依旧不可做，因为会超时，考虑如何再一步优化。 设 $T=kd$ ，那么我们枚举 $T$ ： =\sum_{T=1}^{n}\sum_{k|T,k\in prime}\mu(\frac{T}{k})\cdot \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$QvQ​$ 我们将 $\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor​$ 扔到前面去。 =\sum_{T=1}^{n}\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor\sum_{k|T,k\in prime}\mu(\frac{T}{k}) ​显然后面的可以预处理，预处理好了后，我们所需要计算的就是这一块： \sum_{T=1}^{n}\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T}\rfloor这个特别好处理，整除分块优化一波，复杂度 $O(\sqrt(n))$ 。 开始居然感觉这题不可做，然后想要不要用毒教筛来筛 $\mu$ 的前缀和，不过显然我是不会这种黑科技的 $QwQ$ Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e7+2;const int inf=1e9+9;int vis[N],sum[N],mui[N],f[N],prime[N],cnt;inline void _pre_mui()&#123; mui[1]=1; for(int i=2;i&lt;=N;++i)&#123; if(!vis[i])prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;N)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;mui[i*prime[j]]=0;break;&#125; else mui[i*prime[j]]=-mui[i]; &#125; &#125; for(int i=1;i&lt;=cnt;++i) for(int j=1;prime[i]*j&lt;=N;++j) f[j*prime[i]]+=mui[j]; for(int i=1;i&lt;=N;++i)sum[i]=sum[i-1]+f[i]; return;&#125;inline ll solve(int n,int m)&#123; ll ans=0; for(int l=1,r=0;l&lt;=n;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); ans+=(ll)(sum[r]-sum[l-1])*(ll)(n/l)*(ll)(m/l); &#125;return ans;&#125;int main()&#123; _pre_mui(); int n,m,T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); if(n&gt;m)std::swap(n,m); printf("%lld\n",solve(n,m)); &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [POI2007]ZAP-Queries 莫比乌斯反演 luogu3455]]></title>
    <url>%2F2019%2F02%2F27%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3455%2F</url>
    <content type="text"><![CDATA[很显然是让我们求出下式： ans=\sum_{i=1}^{A}\sum_{j=1}^{B}[gcd(i,j)=K]根据性质可以得到： ans=\sum_{i=1}^{\lfloor\frac{A}{K}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{K}\rfloor}[gcd(i,j)=1]我们设两个函数： 函数 $f$，$f(x)$ 表示 $\sum_{i=1}^{\lfloor\frac{A}{K}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{K}\rfloor}[gcd(i,j)=x]$ 函数 $g$ ，$g(x)$ 表示 $\sum_{i=1}^{\lfloor\frac{A}{K}\rfloor}\sum_{j=1}^{\lfloor\frac{B}{K}\rfloor}[x|gcd(i,j)]$ 我们可以得到： g(x)=\sum_{x|d} f(x)这是莫比乌斯反演的第二个形式： g(n)=\sum_{n|d} f(n) \ \Rightarrow \ f(n)=\sum_{n|d}g(d) \cdot \mu(\frac{d}{n})于是： g(x)=\sum_{x|d} f(x) \ \Rightarrow \ f(x)=\sum_{x|d}g(x) \cdot \mu(\frac{d}{x})=g(x)=\sum_{x|d} f(x) \ \Rightarrow \ f(x)=\sum_{x|d}g(\frac{d}{x}) \cdot \mu(x)设 $n=\lfloor\frac{A}{K}\rfloor\ ,\ m=\lfloor\frac{B}{K}\rfloor$ 那么： g(x)=\sum_{i=1}^{n}\sum_{i=1}^{m} [x|gcd(i,j)]=\sum_{i=1}^{\lfloor\frac{n}{K}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{K}\rfloor}[1|gcd(i,j)]=\sum_{i=1}^{\lfloor\frac{n}{K}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{K}\rfloor}[1|gcd(i,j)]=\lfloor\frac{A}{K}\rfloor \times\lfloor\frac{B}{K}\rfloorans=f(1)f(1)=\sum_{i=1}^{n}\mu(i)*g(i)=\sum_{i=1}^{n}\mu(i)*\lfloor\frac{A}{K}\rfloor *\lfloor\frac{B}{K}\rfloor这个式子是 $O(n)$ 的。 发现 $\lfloor\frac{A}{K}\rfloor \times\lfloor\frac{B}{K}\rfloor$ 可以整除分块，于是我们便可以做到 $O(\sqrt{x})$ Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int N=1e5+2;const int inf=1e9+9;int T,cnt;int prime[N],mui[N],vis[N];long long sum[N];inline int _Pre_mui()&#123; mui[1]=1; for(int i=2;i&lt;=N;++i)&#123; if(!vis[i])prime[++cnt]=i,mui[i]=-1; for(int j=1;j&lt;=cnt;++j)&#123; if(i*prime[j]&gt;=N)break; vis[i*prime[j]]=1; if(!(i%prime[j]))&#123;mui[i*prime[j]]=0;break;&#125; else mui[i*prime[j]]=-mui[i]; &#125; &#125;for(int i=1;i&lt;=N;++i)sum[i]=sum[i-1]+mui[i]; return 0;&#125;#define min(x,y) ((x)&lt;(y)?(x):(y))inline void solve(int n,int m,int k)&#123; long long ans=0; n/=k,m/=k; int lim=min(n,m); for(int i=1;i&lt;=lim;)&#123; long long j=min(n/(n/i),m/(m/i)); ans+=1ll*(sum[j]-sum[i-1])*(n/i)*(m/i); i=j+1; &#125;printf("%lld\n",ans); return;&#125;int main()&#123; _Pre_mui(); scanf("%d",&amp;T); while(T--)&#123; int n,m,k; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); solve(n,m,k); &#125;return 0; &#125; 所以就没了。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数论】 从狄利克雷卷积到莫比乌斯反演]]></title>
    <url>%2F2019%2F02%2F27%2F%5B%E6%95%B0%E8%AE%BA%5DDirichley%E5%88%B0Mobius%2F</url>
    <content type="text"><![CDATA[在此输入你的密码以便阅读全文 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>总结</tag>
        <tag>莫比乌斯反演</tag>
        <tag>狄利克雷卷积</tag>
        <tag>莫比乌斯函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 tower 网络流 bzoj4657]]></title>
    <url>%2F2019%2F02%2F26%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj4657%2F</url>
    <content type="text"><![CDATA[考试的时候正好考了这道题，全场仅有 $lys$ 大佬 $AC$ 。 都 $GG$ 了（当然我最惨，暴力分居然被卡了，只有 $10$ 分 $QwQ$）。 我们来看一下题目： 题目的阶梯数据真良心！ 20分做法很显然，$n,m \le 5$ ，分明是摆着让我们爆搜，那么直接暴力枚举打那个，处理一下路线的交叉问题就好了。 然而我菜爆了，这个居然打挂了，然后就只剩下 $10$ 分了 $QvQ$。 40分做法可以加一个剪枝，怎么剪呢？ 对于一个炮塔，假设我们之前在其打击范围内已经找到了一个点，该点跟该炮塔的曼哈顿距离是 $x$ ，其权值为 $a$ ,然后现在我们继续 $dfs$ ，发现又找到了一个点也在打击范围内，该点的与该炮的曼哈顿距离是 $y$ ，其权值是 $b$ 。 那么现在我们假设 $xb$ ，那么显然，对于最优的方案，该炮塔肯定不会打 $b$ 权值的点。也就是说，$b$ 权值的点没有 $a$ 权值的点优，因为权值少了，收益没那么大，并且风险(距离)(指容易被打断的风险)增加了。这时我们便可以放弃 $b$ 点，这就是一个小小的剪枝优化。 100分做法考虑最小割。 对于每一个炮塔，我们将其能打出去的范围的所有点连成一条链，这条链的两端分别连着 $s$ 和 $t$ 。 这个时候的 “割” 就是说你这个炮打到哪里结束。 如下图： 那么网络流的图中，这条链中 $3-4$ 的这条边被切断了。 所以我们每一个炮有一个打到的地方(当然可以不打)，这个时候每一条链都断了，所以图就断了。 但是关系并没有那么简单，假设现在又有一个炮塔，其轨迹跟现在的炮相交了，如果相交的点的编号 $&lt;3$，显然这个红炮是不可以打到小蓝点( $3$ 号点)的，我们该如何表示这种关系呢？ 现在所表示的状况： 现在的状况就是，相交点上面的点都打不到了(红炮)，相交点右边的点都打不到了(蓝炮)。 但是我们一定要保证 $S$ 到 $T$ 的联通。 那么就可以确定，如果红炮所在的点连接 $S$ ，那么蓝炮就连 $T$，这样才可以使 $S$ 和 $T$ 连通。 然后来解决怎么处理相交点的连边问题。 但是，如果按照上面的 “红炮连 $S$ ，蓝炮连 $T$” 的话，直接这样连不就好了吗？ 仔细想一想，这其实是布星的，因为我们要保证这个相交点的关系不会被割掉，那么就因该将边值设为 $inf$，但是设哪条边呢？这里所有的边的值都是这个点的权值，我们不可能直接改点的权值吧？ 那么很显然，我们将相交点拆成两个点，这两个点中间连有一条边权为 $inf$ 的边，这时无论如何都割不掉这个点了。 最后就是，既然要求最小割，对于如果炮不启动的话边权是 $0$ ，那么就达成了 “最小” 的效果，这是错的。所以我们设一个常量 $T$ ，将每条边的边权都设为 $T-v_i$ 就好。 然后就是板子 $Dinic$。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; #define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))#define id(i,j,type) type*n*m+(i-1)*m+j const int N=5e1+6;const int inf=1e9+9;const int dx[4]=&#123;-1,1,0,0&#125;;const int dy[4]=&#123;0,0,-1,1&#125;; int map[N][N],ans,n,m,s,t;int cnt(1),head[N*N*2],dep[N*N*2];struct Edge&#123;int nxt,to,val;&#125;G[N*N&lt;&lt;2];std::queue&lt;int&gt; q; bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i;i=G[i].nxt)&#123; int v=G[i].to; if(!dep[v]&amp;&amp;G[i].val&gt;0) dep[v]=dep[u]+1,q.push(v); &#125; &#125;return dep[t];&#125;int dfs(int u,int flow)&#123; if(u==t||!flow)return flow; int used=0,rlow; for(int i=head[u];i;i=G[i].nxt)&#123; int v=G[i].to; if(dep[v]==dep[u]+1&amp;&amp;G[i].val&gt;0)&#123; used+=(rlow=dfs(v,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[u]=-1; return used;&#125; int Dinic()&#123; int maxflow=0; while(bfs())maxflow+=dfs(s,inf); return maxflow;&#125; void add(int u,int v,int w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) scanf("%d",&amp;map[i][j]); s=0,t=n*m*2+1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; if(map[i][j]&lt;0)&#123; int direction=-map[i][j]-1; int x=i,y=j,Mx_val=0; while(true)&#123; x+=dx[direction],y+=dy[direction]; if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)break; Mx_val=max(Mx_val,map[x][y]); &#125;ans+=Mx_val; if(direction&lt;2)add(s,id(i,j,0),inf); else add(id(i,j,1),t,inf); x=i,y=j; while(true)&#123; int tx=x,ty=y; x+=dx[direction],y+=dy[direction]; if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)break; if(direction&lt;2)add(id(tx,ty,0),id(x,y,0),Mx_val-max(0,map[tx][ty])); else add(id(x,y,1),id(tx,ty,1),Mx_val-max(0,map[tx][ty])); &#125; &#125;else add(id(i,j,0),id(i,j,1),inf); &#125; printf("%d\n",ans-Dinic()); return 0;&#125; 为什么之前没想出来呢？]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2009]诗人小G 四边形不等式/决策单调性优化DP luoguP1912]]></title>
    <url>%2F2019%2F02%2F25%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1912%2F</url>
    <content type="text"><![CDATA[神奇的题目 $QvQ$ ，卡了我好久。 哎，主要是细节要处理到位，否则就会 WA 声满片。 记录一下我壮观的提交记录： 太杯具了 $QvQ$ (扯谈扯不下去了…….) 进入正题吧。 路人甲：$bzoj$ 上居然没有这道题？导演：赶紧走开，不管你的事 这题明显是 $DP$，我们可以很简单的得到 $DP$ 方程： 设 $f[i]$ 表示对前 $i$ 句诗排版后的最小不协调度，那么很显然，对于一个现在我们需要转移的 $i$，我们会找到一个最优的 $j$ ，使得第 $j+1$ 句到第 $i$ 句组成一个新的行。那么之前的行的总共的最小不协调度显然是 $f[j]$，现在我们就来计算一下 $f[i]$ 的最小不协调度。 显然，是下式(其中 $sum$ 是句子长度的前缀和)： f[i]=f[j]+{|sum[i]-sum[j]-L-1|}^P这就是状态转移方程，的确很好理解。但是……这样子做是 $O(N^2)$ 的复杂度，只能拿 $30$ 分。 而按照题目的数据范围，正解的复杂度因该是 $O(n log n)$ 左右。接下来考虑怎么优化。 经打表观察发现，如果我们将每次用作转移 $i$ 的最优的 $j$ 存起来，输出时会发现，$j$ 是单调递增的。 证明的话的确不好证，可以看看 $lyd$ 的书。但是按照实际理解一下是可以的，我们将 $j$ 后面的一直到 $i$ 的句子组成了新的一行，那么如果 $j$ 不单调上升的话，新的一句将会变的很长很长很长，那么这时这句造成的不协调度将会以几何数的形式疯狂增长，那么唯一的方法就是将这句长句断句，这样子 $j$ 就会变大，可以感性理解一下 $QvQ$。 但是我们知道了 $j$ 是单调上升的这条性质有什么用呢？ 很显然，每一次转移的时候不必往前找了，直接往后找。 我们维护一个队列，队列里的每一个元素有三个变量：$l,r,c$ ，其中 $l$ 和 $r$ 表示 $c$ 这个决策的适用范围，并且在这个范围中 $c$ 是最优的 $j$。 那么现在有了一个新的 $i$，考虑怎么维护这个队列。 我们可以先找到 $i$ 所在的范围的最优的 $j$，那么这时我们检查队头，如果队头的范围已经不包括 $i$ 了，那么直接弹出，因为既然队头的范围不包括 $i$ 了，那么这个队头对 $i+1$ 及后面的元素都不能产生贡献，故直接弹出。 弹出无用的队头后，转移的话就是 $O(1)$ 了：直接取队头转移不就好了吗？ 那么现在考虑怎么将 $i$ 加入这个队列，或许这个 $i$ 也会对后面的元素产生贡献。 我们检查当前的队尾，怎么判断这个队尾是否比 $i$ 更优呢？现在队尾的范围是 $l,r$ ，如果 $i$ 更新 $l$ 比 $c$ 更新 $l$ 更优，显然 $i$ 会比当前 $l,r$ 范围类的所有的 $c$ 更优，故弹出队尾。 那么，假设现在我们碰到了一个队尾，其中 $i$ 更新 $r$ 更优， $c$ 更新 $l$ 更优，怎么办呢？也就是说这个元素的范围中分成两半，前一半 $c$ 更新更优，后一半 $i$ 更新更优，显然要拆成两个队列元素。那么我们怎么知道这个位置呢？二分！ 那么这个时候我们可以得到答案了，只是输出怎么办呢？ 很简单，每次转移的时候记录一下转移自哪里，这就是分行，然后输出即可。 最后就是精度问题。 题目要求，如果 $f[n]$ (即所有句子排版后的最小不协调度) 还是大于了 $1e18$ ，那么输出 “$Too \ hard\ to\ arrange$”，但是如果在 $DP$ 的过程中就炸了 $long \ long$，那就 $GG$ 了。所以我们使用 $long \ double$ ，精度更高，(不会 $int$ 的，这辈子也不会用 $int$ 的)。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll;typedef long double ld;const int NS=1e5+2;const int inf=1e9+9;int T,N,L,P;int head,tail;int last[NS],ans[NS],Next[NS];struct Node&#123;int c,l,r;&#125;q[NS];char s[NS][35];ld sum[NS],f[NS];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;void clear()&#123; memset(last,0,sizeof(last)); memset(sum,0,sizeof(sum)); memset(q,0,sizeof(q)); memset(s,0,sizeof(s)); memset(f,0,sizeof(f));&#125;ld pows(ld x,int y)&#123;//快速幂 ld ans=1; for(;y;y&gt;&gt;=1,x*=x)if(y&amp;1)ans*=x; return ans;&#125;ld val(int j,int i)&#123;//转移函数 return f[j]+pows(abs(sum[i]-sum[j]-L-1),P);&#125;void half(int i)&#123;//二分过程 int now=q[tail].c,ls=q[tail].l,rs=q[tail].r;//当前队尾范围 int ret=q[tail].r+1; while(ls&lt;=rs)&#123; int mid=(ls+rs)&gt;&gt;1; if(val(i,mid)&lt;=val(now,mid))rs=mid-1,ret=mid;//i更优 else ls=mid+1;//c更优 &#125; if(ret!=q[tail].l)q[tail].r=ret-1;//分成了两半 else --tail;//整个元素都比不过i if(ret&lt;=N)q[++tail]=(Node)&#123;i,ret,N&#125;;//i分了一个区间时，加入新元素&#125;void output()&#123;//值得拥有的鬼畜输出 if(f[N]&gt;1e18)puts("Too hard to arrange");//无解，放心判1e18 else&#123; printf("%lld\n",(ll)(f[N]+0.5));//注意精度问题 for(int i=N;i;i=last[i])Next[last[i]]=i;//输出 int now=0; for(int i=1;i&lt;=N;++i)&#123; now=Next[now]; for(int j=i;j&lt;now;++j)printf("%s ",s[j]); printf("%s\n",s[now]); i=now; &#125; &#125; puts("--------------------");//注意 return;&#125;int main()&#123; IN(T); while(T--)&#123; clear(); IN(N),IN(L),IN(P); for(int i=1;i&lt;=N;++i)&#123; scanf("%s",s[i]); sum[i]=sum[i-1]+strlen(s[i])+1;//做前缀和 /*因为输出是有空格的，所以加上一个1*/ &#125; q[head=tail=1]=(Node)&#123;0,1,N&#125;;//初始元素 for(int i=1;i&lt;=N;++i)&#123; while(head&lt;tail&amp;&amp;q[head].r&lt;i)++head;//淘汰无用队头 ++q[head].l; f[i]=val(q[head].c,i);//O(1) 转移 last[i]=q[head].c;//记录“转移自哪里” while(head&lt;tail&amp;&amp;val(i,q[tail].l)&lt;=val(q[tail].c,q[tail].l))tail--;//弹出劣质队尾 half(i);//二分 &#125; output();//鬼畜输出 &#125; return 0;//终于结束&#125; 最后，我有个问题。 这是写的什么文章啊 $QvQ$ ，让我们来猜测一下。 白日依山尽，黄河入海流，欲穷千里目，更上一层楼。 这是 小 $G$ 写的？作者明明不是小 $G$ 好不好。 $QvQ$ 有毒啊……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
        <tag>决策单调性</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [USACO4.4]Pollutant Control 网络流 luoguP1344]]></title>
    <url>%2F2019%2F02%2F24%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1344%2F</url>
    <content type="text"><![CDATA[有必要么……直接打个电话给零售商：”我的牛奶不对，不要收牛奶！”不久可以了吗…… (好了好了这是扯淡) 显然这个运输图的 $1$ 号点就是公司发送牛奶的地方，$n$ 号点就是零售商，然后每一条边就是这个货车的出发点与到达点，边权即为拦截这个货车的代价。 然后呢？ 最小的损失……使 $1$ 到不了 $n$ ，这显然就是最小割啊 $QwQ$ 那么这样损失数就很容易得到了，那么最少要停的卡车数怎么求呢？很显然，我们任然跑最小割，那么这个图我们将所有边都设为 $1$ ，显然现在的最小割就是最少要停的卡车数。 很显然，时间爆炸，满屏惊喜！ 这里有一种方法！我们设一个常数 $T$ ，假设当前边的边权是 $w$ ，那么我们实际连一条边权为 $w \times T+1$ 的边，其中最小损失数显然为 $maxflow/T$ ，那么最少要停的卡车数呢？显然就是 $maxflow\ \%\ T$。 这里的 $T$ 要足够大，否则如果每条边后面的 $+1$ 乘上割的边数大于了 $T$ ，然后 $\%$ 一下，恭喜你！你 $GG$ 了。实际上 “足够大” 只要大于边数就好了，显然这样子建边是要开 $long long$ 的，否则会炸。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define A printf("A")#define ll long long#define RI register int#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const ll N=1e5+5;const ll inf=1e9+9;const ll T=2019;//2019新年快乐(尽管现在不是时候了)template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;std::queue&lt;int&gt; q;struct Edge&#123;ll nxt,to,val;&#125;G[N];ll n,m,s,t,cnt(1),dep[N],head[N];inline void add(ll u,ll v,ll w)&#123; G[++cnt].nxt=head[u],G[cnt].to=v,G[cnt].val=w,head[u]=cnt; G[++cnt].nxt=head[v],G[cnt].to=u,G[cnt].val=0,head[v]=cnt; &#125;inline bool bfs()&#123; memset(dep,0,sizeof(dep)); q.push(s);dep[s]=1; while(!q.empty())&#123; ll x=q.front();q.pop(); for(ll i=head[x];i;i=G[i].nxt)&#123; ll y=G[i].to; if(dep[y]||G[i].val&lt;=0)continue; dep[y]=dep[x]+1,q.push(y); &#125; &#125;return dep[t];&#125; inline ll dfs(ll x,ll flow)&#123; if(x==t||!flow)return flow; ll used=0,rlow; for(ll i=head[x];i;i=G[i].nxt)&#123; ll y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used;&#125;int main()&#123; IN(n),IN(m);s=1,t=n; for(ll i=1;i&lt;=m;++i)&#123; ll u,v,w;IN(u),IN(v),IN(w); add(u,v,w*T+1); &#125; ll maxflow=0; while(bfs())maxflow+=dfs(s,inf); printf("%lld %lld\n",maxflow/T,maxflow%T); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [BOI2007]Mokia CDQ分治 luogu4390]]></title>
    <url>%2F2019%2F02%2F22%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4390%2F</url>
    <content type="text"><![CDATA[BBQ烤翅，CDQ分治。 一道很裸的三位偏序，允许离线的话，就上CDQ分治，当然想当码农可以敲树套树。 很显然，三维就是 $x$ 轴，$y$ 轴，和时间。 然后将一个矩阵的询问拆成四个询问，按照容斥的方式搞，这显然是可以且简单的，但是询问数将会爆炸 $QvQ$ (但是没有炸，不舒服) $long long$ 也要开，不然会炸。 然后就这样了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const ll N=2e6+2;const ll inf=1e9+9;ll s,w,tot,c[N];struct Node&#123; ll x,y,ans,pos,type;&#125;q[N],hep[N];bool cmp(const Node&amp;x,const Node&amp;y)&#123;return x.pos&lt;y.pos;&#125;;struct BIT&#123; void add(ll x,ll v)&#123;for(;x&lt;=w;x+=(x&amp;-x))c[x]+=v;&#125;; ll sum(ll x)&#123;ll res=0;for(;x;x-=(x&amp;-x))res+=c[x];return res;&#125;; void clr(ll x)&#123;for(;x&lt;=w;x+=(x&amp;-x))c[x]=0;&#125;;&#125;T;void CDQ(ll l,ll r)&#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; CDQ(l,mid);CDQ(mid+1,r); ll i=l,j=mid+1,cnt=l; /*CDQ的主要流程*/ while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(q[i].x&lt;=q[j].x)&#123; /*注意这一题询问和修改是不一样的，不像陌上花开那题，每个元素即使修改对答案做贡献，也是询问*/ if(!q[i].type)T.add(q[i].y,q[i].ans);/*这是修改，树状数组标记一下*/ hep[cnt++]=q[i++];/*归并排序*/ &#125;else&#123; if(q[j].type)q[j].ans+=T.sum(q[j].y);/*询问，更新答案*/ hep[cnt++]=q[j++]; &#125; &#125; /*将剩下的元素排序好，更新好答案*/ while(i&lt;=mid)&#123; if(!q[i].type)T.add(q[i].y,q[i].ans); hep[cnt++]=q[i++]; &#125; while(j&lt;=r)&#123; if(q[j].type)q[j].ans+=T.sum(q[j].y); hep[cnt++]=q[j++]; &#125; for(ll o=l;o&lt;=mid;++o)/*清除本次操作在树状数组上留下的痕迹*/ if(!q[o].type)T.clr(q[o].y); for(ll o=l;o&lt;=r;++o)q[o]=hep[o];/*更新原数组*/&#125;int main()&#123; ll op; scanf("%lld%lld",&amp;s,&amp;w); while(scanf("%lld",&amp;op),op^3)&#123; ll x,y,z,x1,x2,y1,y2; if(op==1)&#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); q[++tot]=(Node)&#123;x,y,z,tot,0&#125;; &#125;else&#123; scanf("%lld%lld%lld%lld",&amp;x1,&amp;y1,&amp;x2,&amp;y2); /*四个询问*/ q[++tot]=(Node)&#123;x2,y2,0,tot,1&#125;; q[++tot]=(Node)&#123;x1-1,y2,0,tot,1&#125;; q[++tot]=(Node)&#123;x2,y1-1,0,tot,1&#125;; q[++tot]=(Node)&#123;x1-1,y1-1,0,tot,1&#125;; &#125; &#125; CDQ(1,tot); std::sort(q+1,q+tot+1,cmp); for(ll i=1;i&lt;=tot;++i) if(q[i].type)&#123; printf("%lld\n",q[i].ans-q[i+1].ans-q[i+2].ans+q[i+3].ans+s*(q[i].y-q[i+3].y)*(q[i].x-q[i+3].x)); i+=3; //printf("%lld\n",q[i].ans); &#125; return 0;&#125; 然而我还是太弱了，调半个小时的原因既然是 树状数组打错了$QvQ$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2001]食物链 并查集 luoguP2024]]></title>
    <url>%2F2019%2F02%2F22%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2024%2F</url>
    <content type="text"><![CDATA[并不是很难。 首先，我们将一个点 $x$ 拆分成三个点：$x_{eat},x_{sim},x_{emy}$， $x_{eat}$ 表示 $x$ 的食物，$x_{sim}$ 表示 $x$ 的同类，$x_{emy}$ 表示 $x$ 的天敌。 然后，对于一句真话： 如果是表示 $x​$ 是 $y​$ 的同类，那么很显然，$x​$ 的食物就是 $y​$ 的食物， $x​$ 的天敌就是 $y​$ 的天敌，于是讲 $x_{sim}​$ 和 $y_{sim}​$ 所在的并查集合并，将 $x_{eat}​$ 和 $y_{eat}​$ 所在的并查集合并，最后将 $x_{emy}​$ 和 $y_{emy}​$ 所在的并查集合并即可。 如果这句表示 $x$ 吃 $y$ ，那么很显然，$x$ 的食物就是 $y$ 的同类，$x$ 的天敌就是 $y$ 的食物(因为是环形)，$x$ 的同类都是 $y$ 的天敌，故将这些关系的并查集一次合并即可。 怎么判断一句话的真假呢？ 显然，如果 $x&gt;n||y&gt;n$ 就是假话，对于两个操作： 如果表示 $x​$ 是 $y​$ 的同类，那么 $x_{eat}​$ 不能和 $y_{sim}​$ 在同一个并查集中，$x_{sim}​$ 不能和 $y_{eat}​$ 在同一个并查集中，否则就与前面的话冲突了。 如果表示 $x$ 吃 $y$ ，首先 $x$ 和 $y$ 不能是同类(即 $x_{sim}$ 不能和 $y_{sim}$ 在一个并查集中)，然后 $y_{eat}$ 不能和 $x_{sim}$ 在一个并查集中，显然违反了以上的就是假话。 然后码量极小： Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int N=5e4+2;const int inf=1e9+9;const int K=1e5+2;int fa[N*3],ans,n,k;inline int sim(int x)&#123;return x;&#125;;inline int eat(int x)&#123;return x+n;&#125;;inline int emy(int x)&#123;return x+n+n;&#125;;int find(int x)&#123;return x==fa[x]?x:fa[x]=find(fa[x]);&#125;;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n*3;++i)fa[i]=i; for(int i=1;i&lt;=k;++i)&#123; int op,x,y; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if(x&gt;n||y&gt;n)&#123;++ans;continue;&#125; if(op==1)&#123; if(find(eat(x))==find(sim(y))||find(sim(x))==find(eat(y)))&#123;++ans;&#125; else&#123; fa[find(sim(x))]=find(sim(y)); fa[find(eat(x))]=find(eat(y)); fa[find(emy(x))]=find(emy(y)); &#125; &#125;else&#123; if(find(sim(x))==find(sim(y))||find(sim(x))==find(eat(y)))&#123;++ans;&#125; else&#123; fa[find(eat(x))]=find(sim(y)); fa[find(emy(x))]=find(eat(y)); fa[find(sim(x))]=find(emy(y)); &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; 我绝对不会告诉你们，我有一处地方 $sim$ 写成了 $sin$ 而调了半个小时]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 陌上花开 CDQ分治 bzoj3262]]></title>
    <url>%2F2019%2F02%2F22%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj3262%2F</url>
    <content type="text"><![CDATA[陌上花开，可缓缓归矣 ——吴越王 每日一学语文[滑稽]。 当然这题 $KDT​$ 是可以做的，但是不费，所以用 $CDQ​$ 算了吧。 很显然这道题是 $CDQ$ 三维偏序的板子题(luogu上它本来就是板子题) $CDQ$ 分治的三维偏序怎么做？ 对于其中的第一维，$CDQ$之前直接 $sort$ 排好序，那么这就可以保证对于一个 $i&lt;j$ ，位置 $j$ 的元素一定是对位置 $i$ 的元素做不出贡献的，因为 $x_i &lt;x_j$ 。 然后第二维，进入 $CDQ$ ，很显然当前的区间 $l - r$ 是会分成两个子区间分别做 $CDQ$ 的，那么当两个子区间合并的时候，左子区间是可能会对右子区间做出贡献的，但是右子区间对左子区间做不出任何贡献，原因是我们在之前已经按 $x$ 排好了序，那么显然左子区间的元素的 $x$ 始终小于右子区间的元素的 $x$。 外面排好了第一维，那么我们就在 $CDQ$ 中排第二维，由于我们是分成了两个子区间递归处理，往上面合并的时候，正好可以归并排序。第三位只需要在树状数组中记录一下，然后统计答案的时候调用树状数组的查询，看看比当前元素小的有多少个即可。 1234567891011121314151617181920void CDQ(int l,int r)&#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; CDQ(l,mid);CDQ(mid+1,r);/*分成两个子区间*/ int i=l,j=mid+1,cnt=l; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;/*归并+统计答案*/ if(v[i].b&lt;=v[j].b)add(v[i].c,size[v[i].id]),hep[cnt++]=v[i++]; /*左子区间的当前元素可能会有贡献，记录一下*/ else ans[v[j].id]+=sum(v[j].c),hep[cnt++]=v[j++]; /*接下来的左子区间的b是比当前的j.b要大的了，没有贡献了*/ /*因为在子区间中使用了归并，所以两个子区间中b肯定是升序的*/ &#125; while(j&lt;=r)ans[v[j].id]+=sum(v[j].c),hep[cnt++]=v[j++]; /*将剩下的归并排序完*/ for(int h=l;h&lt;i;++h)add(v[h].c,-size[v[h].id]); /*清除树状数组留下的痕迹*/ while(i&lt;=mid)hep[cnt++]=v[i++]; for(int i=l;i&lt;=r;++i)v[i]=hep[i]; /*更新原数组*/&#125; $QvQ$ 就这样了，只是这题需要离散化一下，$Code$ 中的 $size$ 就是元素出现的个数。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longconst int N=1e5+2;const int K=2e5+2;int n,k;struct Node&#123;int a,b,c,id;&#125;v[N],hep[N];int tre[K],ans[N],num[N],size[N];inline void add(int x,int v)&#123;for(;x&lt;=k;x+=(x&amp;-x))tre[x]+=v;&#125;;inline ll sum(int x)&#123;ll res=0;for(;x;x-=(x&amp;-x))res+=tre[x];return res;&#125;;template&lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;bool cmp(Node x,Node y)&#123; if(x.a!=y.a)return x.a&lt;y.a; if(x.b!=y.b)return x.b&lt;y.b; return x.c&lt;y.c;&#125;void CDQ(int l,int r)&#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; CDQ(l,mid);CDQ(mid+1,r); int i=l,j=mid+1,cnt=l; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(v[i].b&lt;=v[j].b)add(v[i].c,size[v[i].id]),hep[cnt++]=v[i++]; else ans[v[j].id]+=sum(v[j].c),hep[cnt++]=v[j++]; &#125; while(j&lt;=r)ans[v[j].id]+=sum(v[j].c),hep[cnt++]=v[j++]; for(int h=l;h&lt;i;++h)add(v[h].c,-size[v[h].id]); while(i&lt;=mid)hep[cnt++]=v[i++]; for(int i=l;i&lt;=r;++i)v[i]=hep[i];&#125;int main()&#123; IN(n),IN(k); for(int i=1;i&lt;=n;++i) scanf("%d%d%d",&amp;v[i].a,&amp;v[i].b,&amp;v[i].c); std::sort(v+1,v+n+1,cmp); int tot=0; for(int i=1;i&lt;=n;++i)&#123; if(v[i].a!=v[i-1].a||v[i].b!=v[i-1].b||v[i].c!=v[i-1].c)hep[++tot]=v[i]; ++size[tot]; &#125; for(int i=1;i&lt;=tot;++i)v[i]=hep[i],v[i].id=i; CDQ(1,tot); for(int i=1;i&lt;=tot;++i) num[ans[v[i].id]+size[v[i].id]-1]+=size[v[i].id]; for(int i=0;i&lt;n;++i) printf("%d\n",num[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数论】 乘法逆元]]></title>
    <url>%2F2019%2F02%2F20%2F%5B%E6%95%B0%E8%AE%BA%5D%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[真的我也不知道标题怎么起 $QvQ……$ 本文将介绍两种求乘法逆元的方式。 0XFF 乘法逆元是什么？ 乘法逆元，一般用于求 \frac{a}{b} \ \ (mod \ p)的值 ($p$ 通常为质数) 。 对于加、减、乘法的取模直接取就好了，但是对于除法(上面的分数形式)取模的话，显然直接取模是错的，那么这个时候就需要用到乘法逆元。 如果 $a \times x \equiv 1 \ \ (mod \ p) $，且 $a$ 与 $p$ 互质，那么就可以定义 $p$ 为 $x$ 的逆元，记为 $a^{-1}$，所以我们也可以称 $x$ 为 $a$ 在 $mod \ p$ 意义下的倒数。 对于 $\frac{a}{b} \ \ (mod \ p)​$，这个分数的值就是 $(b^{-1} \times a) \ mod \ p​$，即 $b​$ 在 $mod \ p​$ 意义下的逆元乘上 $a​$ ，最后对 $p​$ 取模。 0X1F 求乘法逆元的两种方法(我只会这两种)…… 0X1F-1 费马小定理求乘法逆元费马小定理： 若 $p​$ 为质数，$a​$ 为正整数，且 $a​$ 与 $p​$ 互质。 那么 $a^{p-1} \equiv 1 \ \ (mod \ p)$。 我们将 $a^{p-1} \equiv 1 \ \ (mod \ p)$ 代入原式： a \times x \equiv 1 \ \ (mod \ p)a \times x\equiv a^{p-1} \ \ (mod \ p)x\equiv a^{p-2} \ \ (mod \ p)那么直接跑一遍快速幂即可。 Code:1234567891011#define ll long longll pow(ll x,ll y,ll p) &#123; x%=p; ll ans=1; for(;y;y&gt;&gt;=1,x=x*x%mod) if(power&amp;1)ans=ans*x%mod; return ans;&#125;int main()&#123; ll x=pow(a,p-2,p);&#125; 0X1F-2 线性求乘法逆元这个算法的时间复杂度是线性的：$O(n)$ 设 $p=s \times i + r$ ，$(1&lt;r&lt;i&lt;p)$. 将此式套入 $(mod \ p)​$ 意义下的式子就可以得到： s \times i +r \equiv 0 \ \ (mod \ p)​两边同时乘上 $i^{-1}$： s + r \times i^{-1} \equiv 0 \ \ (mod \ p)​然后再同时乘上 $r^{-1}​$： s \times r^{-1} + i^{-1} \equiv 0 \ \ (mod \ p)​移项得到： i^{-1} \equiv -s \times r^{-1} \ \ (mod \ p)很显然 $s$ 等于 $[\frac{p}{i}]$，$r$ 等于 $p \ mod \ i$，那么 $r^{-1}$ 就等于 $inv[p \ mod \ i]$ ($inv[i]$ 表示 $i$ 在 $mod \ p$ 意义下的乘法逆元) 然后代入公式： inv[i] \equiv - [\frac{p}{i}] \times inv[p \ mod \ i] \ \ (mod \ p)于是代码就很短了： 123inv[0]=0,inv[1]=1;for(int i=2;i&lt;=n;++i) inv[i]=(long long)(p-p/i)*inv[p%i]%p; 一般来说线性的或许会优秀些，建议使用线性的算法，而且代码也比较短，容易写，处理组乘法逆元的时候，第一种的复杂度为 $O(nlogn)$，第二种只需 $O(n)$。但是在处理单组乘法逆元的时候，第一种复杂度为 $O(logn)$，但是第二种因为要讲 $p \ mod \ i$ 求出来，复杂度…..或许还是 $O(n)$。(实际上我也不会证 $QvQ…$)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>乘法逆元</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [国家集训队]Tree LCT luogu1501/bzoj2631]]></title>
    <url>%2F2019%2F02%2F17%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1501%2F</url>
    <content type="text"><![CDATA[Link-Cut-Tree 的懒标记下传正确食用方法。 1：+ u v c：将$u$到$v$的路径上的点的权值都加上自然数$c$; 解决方法： 很显然，我们可以$split(u,v)$来提取u,v这一段区间,提取完了将$Splay(v)$,然后直接在v上打加法标记$add$即可。 代码： 1234567891011121314inline void pushadd(ll x,ll val)&#123;//打标记 s[x]+=sz[x]*val,v[x]+=val,add[x]+=val; s[x]%=MOD,v[x]%=MOD,add[x]%=MOD;&#125;inline void split(ll x,ll y)&#123;//LCT基本操作split,不再赘述 makeroot(x);Access(y);Splay(y);&#125;//(main函数中)：if(op[0]=='+')&#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;v);//输入信息 split(x,y);pushadd(y,v);//提取链条&amp;打标记&#125; 2：- u1 v1 u2 v2：将树中原有的边$(u1,v1)$删除，加入一条新边$(u2,v2)$，保证操作完之后仍然是一棵树； 解决方法： 删除边即$cut$操作，加边即$link$操作。 代码： 1234567891011121314inline void link(ll x,ll y)&#123; makeroot(x);if(findroot(x)!=y)f[x]=y;&#125;inline void cut(ll x,ll y)&#123; makeroot(x);split(x,y); if(findroot(y)==x&amp;&amp;f[x]==y&amp;&amp;!ch[x][1]) f[x]=ch[y][0]=0;return;&#125;//LCT基本操作link&amp;cut，不再赘述//(main函数中)：if(op[0]=='-')&#123; scanf("%lld%lld",&amp;x,&amp;y);cut(x,y);//删边 scanf("%lld%lld",&amp;x,&amp;y);link(x,y);//加边&#125; 3：* u v c：将$u$到$v$的路径上的点的权值都乘上自然数$c$； 解决方法： 很显然，我们可以$split(u,v)$来提取u,v这一段区间,提取完了将$Splay(v)$,然后直接在v上打乘法标记$mul$即可。(跟第一个操作基本同理) 代码： 12345678910inline void pushmul(ll x,ll val)&#123;//打标记 s[x]*=val,v[x]*=val,mul[x]*=val,add[x]*=val; s[x]%=MOD,v[x]%=MOD,mul[x]%=MOD,add[x]%=MOD;&#125;//(main函数中)：if(op[0]=='*')&#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;v); split(x,y);pushmul(y,v);&#125; 4：/ u v：询问$u$到$v$的路径上的点的权值和，求出答案对于51061的余数。 解决方法： $Splay(v)$时已经将所有节点更新过了(懒标记下传过了)，所以最后只需输出$s[v]$即可。 代码： 12345//(main函数中)：if(op[0]=='/')&#123; scanf("%lld%lld",&amp;x,&amp;y); split(x,y);printf("%lld\n",s[y]);&#125; Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register ll#define A printf("A")#define C printf(" ") #define MOD 51061using namespace std;const ll N=1e5+2;template&lt;typename _Tp&gt; inline void IN(_Tp&amp; dig)&#123; char c;bool flag=0;dig=0; while(c=getchar(),!isdigit(c))if(c=='-')flag=1; while(isdigit(c))dig=dig*10+c-'0',c=getchar(); if(flag)dig=-dig;&#125;ll f[N],s[N],v[N],sz[N],rev[N],mul[N],add[N],hep[N],ch[N][2];inline ll get(ll x)&#123;return ch[f[x]][0]==x||ch[f[x]][1]==x;&#125;inline ll chk(ll x)&#123;return ch[f[x]][1]==x;&#125;inline void pushfilp(ll x)&#123; swap(ch[x][0],ch[x][1]);rev[x]^=1;&#125;inline void pushup(ll x)&#123; s[x]=(s[ch[x][0]]+s[ch[x][1]]+v[x])%MOD; sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1;&#125;inline void pushmul(ll x,ll val)&#123; s[x]*=val,v[x]*=val,mul[x]*=val,add[x]*=val; s[x]%=MOD,v[x]%=MOD,mul[x]%=MOD,add[x]%=MOD;&#125;inline void pushadd(ll x,ll val)&#123; s[x]+=sz[x]*val,v[x]+=val,add[x]+=val; s[x]%=MOD,v[x]%=MOD,add[x]%=MOD;&#125;inline void pushdown(ll x)&#123; if(mul[x]!=1)pushmul(ch[x][0],mul[x]),pushmul(ch[x][1],mul[x]); if(add[x])pushadd(ch[x][0],add[x]),pushadd(ch[x][1],add[x]); if(rev[x])&#123; if(ch[x][0])pushfilp(ch[x][0]); if(ch[x][1])pushfilp(ch[x][1]); &#125;rev[x]=0,add[x]=0,mul[x]=1;return;&#125;inline void rotate(ll x)&#123; ll y=f[x],z=f[y],k=chk(x),v=ch[x][!k]; if(get(y))ch[z][chk(y)]=x;ch[x][!k]=y,ch[y][k]=v; if(v)f[v]=y;f[y]=x,f[x]=z;pushup(y),pushup(x);&#125;inline void Splay(ll x)&#123; ll y=x,top=0;hep[++top]=y; while(get(y))hep[++top]=y=f[y]; while(top)pushdown(hep[top--]); while(get(x))&#123; y=f[x],top=f[y]; if(get(y))rotate((ch[y][0]==x)^(ch[top][0]==y)?y:x); rotate(x); &#125;pushup(x);return;&#125;inline void Access(ll x)&#123; for(register ll y=0;x;x=f[y=x]) Splay(x),ch[x][1]=y,pushup(x);&#125;inline ll findroot(ll x)&#123; Access(x);Splay(x); while(ch[x][0])pushdown(x),x=ch[x][0]; return x;&#125;inline void makeroot(ll x)&#123; Access(x);Splay(x);pushfilp(x);&#125;inline void split(ll x,ll y)&#123; makeroot(x);Access(y);Splay(y);&#125;inline void link(ll x,ll y)&#123; makeroot(x);if(findroot(x)!=y)f[x]=y;&#125;inline void cut(ll x,ll y)&#123; makeroot(x);split(x,y); if(findroot(y)==x&amp;&amp;f[x]==y&amp;&amp;!ch[x][1]) f[x]=ch[y][0]=0;return;&#125;char op[2];int main()&#123; ll n,m,x,y;scanf("%lld%lld",&amp;n,&amp;m); for(register int i=1;i&lt;=n;++i) mul[i]=sz[i]=v[i]=1;ll v; for(register int i=1;i&lt;n;++i) scanf("%lld%lld",&amp;x,&amp;y),link(x,y); for(register int i=1;i&lt;=m;++i)&#123; scanf("%s",op); if(op[0]=='+')&#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;v); split(x,y);pushadd(y,v); &#125;else if(op[0]=='-')&#123; scanf("%lld%lld",&amp;x,&amp;y);cut(x,y); scanf("%lld%lld",&amp;x,&amp;y);link(x,y); &#125;else if(op[0]=='*')&#123; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;v); split(x,y);pushmul(y,v); &#125;else if(op[0]=='/')&#123; scanf("%lld%lld",&amp;x,&amp;y); split(x,y);printf("%lld\n",s[y]); &#125; &#125;return 0;&#125; 因为$51061 * 51061$是会越过$int$界限的，所以我开的$longlong$(当然也可以开无符号$int$)所以就没了。。。。。。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈后缀数组(SA)&学习笔记]]></title>
    <url>%2F2019%2F02%2F16%2F%5B%E7%AE%97%E6%B3%95%5D%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84SA%2F</url>
    <content type="text"><![CDATA[在此输入你的密码以便阅读全文 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>后缀数组.SA</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈后缀自动机(SAM)&学习笔记]]></title>
    <url>%2F2019%2F02%2F16%2F%5B%E7%AE%97%E6%B3%95%5D%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BASAM%2F</url>
    <content type="text"><![CDATA[在此输入你的密码以便阅读全文 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>后缀自动机.SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 Qtree3 LCT luoguP4116]]></title>
    <url>%2F2019%2F02%2F15%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4116%2F</url>
    <content type="text"><![CDATA[第一个操作显然是不要考虑的…… 考虑第二个操作怎么办(实际上是超级easy的) 每个节点维护一个值sum，表示 $Splay$ 中它子树的和，每个点的权值为1(黑)0(白)。 对于这个操作，我们可以先 $split(1,x)$ ，现在x是这个 $Splay$ 的根。我们将要找的就是这颗 $Splay$ 中深度最小且为黑点的节点。 找Answer之前先特判一下s[x]是否大于0，如果为0，直接跳过即可。 不然进入循环，分三种情况： 1.如果s[ch[x][0]]大于0，说明有更优的答案(左子树深度小于x)，x=ch[x][0]。 2.否则，如果x本身就是黑点，那么x就是答案了，直接break。 3.不然，如果x到1的节点都是白色，那就只能去x的右子树找了，x=ch[x][1]。 退出循环时x即为答案，输出即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int#define A printf("A") using namespace std;const int N=1e5+2;int n,m,f[N],s[N],v[N],r[N],ch[N][2];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline int chk(int x)&#123;return ch[f[x]][1]==x;&#125;inline int isroot(int x)&#123;return ch[f[x]][0]==x||ch[f[x]][1]==x;&#125;inline void pushup(int x)&#123;s[x]=s[ch[x][0]]+s[ch[x][1]]+v[x];&#125;inline void pushdown(int x)&#123; if(!r[x])return;r[x]=0; r[ch[x][0]]^=1,r[ch[x][1]]^=1,swap(ch[x][0],ch[x][1]);&#125;inline void Splay_push(int x)&#123;if(isroot(x))Splay_push(f[x]);pushdown(x);&#125;inline void rotate(int x)&#123; int y=f[x],z=f[y],k=chk(x),v=ch[x][!k]; if(isroot(y))ch[z][chk(y)]=x;ch[x][!k]=y,ch[y][k]=v; if(v)f[v]=y;f[y]=x,f[x]=z;pushup(y);&#125;inline void Splay(int x)&#123; int y=x;Splay_push(x); while(isroot(x))&#123; if(isroot(y=f[x])) rotate((ch[y][0]==x)^(ch[f[y]][0]==y)?x:y); rotate(x); &#125;pushup(x);return;&#125;inline void Access(int x)&#123; for(register int y=0;x;x=f[y=x]) Splay(x),ch[x][1]=y,pushup(x); &#125;inline int findroot(int x)&#123; Access(x);Splay(x); while(ch[x][0])pushdown(x),x=ch[x][0]; Splay(x);return x;&#125;inline void makeroot(int x)&#123;Access(x);Splay(x);r[x]^=1;&#125;inline void split(int x,int y)&#123;makeroot(x);Access(y);Splay(y);&#125;inline void link(int x,int y)&#123;makeroot(x);if(findroot(x)!=findroot(y))f[x]=y;&#125;inline void cut(int x,int y)&#123;split(x,y);if(findroot(y)==x&amp;&amp;f[x]==y&amp;&amp;!ch[x][1])f[x]=ch[y][0]=0;&#125;int main()&#123; IN(n),IN(m); for(register int x,y,i=1;i&lt;n;++i) &#123;IN(x),IN(y);link(x,y);&#125; for(register int op,x,i=1;i&lt;=m;++i)&#123; IN(op),IN(x); if(op==0)&#123; makeroot(x);v[x]^=1;pushup(x); &#125;else if(op==1)&#123; split(1,x); if(!s[x])&#123;printf("-1\n");continue;&#125; while(s[x])&#123; pushdown(x); if(s[ch[x][0]])x=ch[x][0]; else if(v[x])break; else x=ch[x][1]; &#125;printf("%d\n",x); &#125; &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2010]地精部落 线性DP luogu2467]]></title>
    <url>%2F2019%2F02%2F15%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2467%2F</url>
    <content type="text"><![CDATA[好巧的一道思维题啊！ 思维量极大但是码量极小，真的好巧妙啊！(好了不废话进入主题) 在下文，因为为了方便代码的理解同步，所以应用了百度翻译： summit: 顶点 valley: 流域; 山谷，溪谷，峡谷，谷地，深谷; 这显然是道 $DP$ 题(又是废话) 可以知道题目要求的合法山脉其实是一个波动数列。 很容易的可以想到，设 $summit[i][j]$ 表示长度为 $j$ 的波动数列，此波动数列的第一个数为 $i$，且在题目中，$i$ 为山峰，这样状态下的方案总数。 同样的，我们同时设 $valley[i][j]$ 表示长度为 $j$ 的波动数列，此波动数列的第一个数为 $i$，且在题目中，$i$ 为山谷，这样状态下的方案总数。 那么答案是多少呢？由于数列中的每一个元素都可以做第一个元素，且都有可能做”山峰”或者是”山脉”，所以我们的答案应该是： \sum_{i=1}^{n} summit[i][n]+valley[i][n]现在来考虑怎么转移。 以 $summit$ 的转移为例子，假设现在需要转移 $summit[i][n]$. 那么这个波动数列的第二项肯定严格小于 $i$ ，而第三项又严格大于第二项，所以如果不看第一项的话，这个数列就变成了由第二项起头，并且第二项是”山谷”，设第二项的数为 $j$ ，那么其方案数可以用 $valley[j][n-1]$ 来表示。 由于第二项可以是数列中严格小于 $i$ 的任何数，因此我们可以列出转移式： summit[i][n] = \sum_{k=1}^{i-1} valley[k][n-1]因为题目说了是严格小于，所以可以这样子统计。 同样的，$valley[i][j]$ 也是这样转移： valley[i][n] = \sum_{k=i}^{n-1} summit[k][n-1]我们现在可以很轻易的打出正解了，但是想象一下，我们有那么大的空间吗？$2\cdot 4200\cdot 4200$？貌似很紧诶(虽然我是踩线没有 $MLE$) 那就使用滚动数组！还有，这样子统计，复杂度将会是 $O(n^3)$ ！怎么优化呢？ 前缀和就好了呀！然后……然后就没有然后了…… Code:12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define ll long long#define RI register int #define A printf("A")using namespace std;const int N=4205;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int summit[N][2],valley[N][2],ans,sum,p;int main()&#123; scanf("%d%d",&amp;sum,&amp;p); summit[2][0]=1,valley[1][0]=1,valley[2][0]=1; for(int n=3;n&lt;=sum;++n) for(int i=1;i&lt;=n;++i)&#123; int sum_val,sum_sum; sum_val=(summit[n-1][(n-1)&amp;1]-summit[i-1][(n-1)&amp;1]+p)%p; valley[i][n&amp;1]=(valley[i-1][n&amp;1]+sum_val)%p; sum_sum=valley[i-1][(n-1)&amp;1]%p; summit[i][n&amp;1]=(summit[i-1][n&amp;1]+sum_sum)%p; &#125; ans=(valley[sum][sum&amp;1]+summit[sum][sum&amp;1])%p; printf("%d\n",ans); return 0; &#125; 注意取模，不然会出锅!]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈FFT&学习笔记]]></title>
    <url>%2F2019%2F02%2F15%2F%5B%E7%AE%97%E6%B3%95%5DFFT%2F</url>
    <content type="text"><![CDATA[$QvQ$ 之前就对这个东西感兴趣，然后被一堆公式踩爆，这样高逼格的名字简直让人无法靠近。终于在 $1$ 月的时候，教练扯着我搞这个，没想到一天左右就会了。 我们进入正题。 0XFF—-FFT是啥? FFT是一种DFT的高效算法，称为快速傅立叶变换（fast Fourier transform），它根据离散傅氏变换的奇、偶、虚、实等 特性，对离散傅立叶变换的算法进行改进获得的。 —-百度百科 对于两个多项式 $F(x)$ 和 $G(x)$ ，要求你将他们乘起来。 那还不简单？直接暴力相乘啊： 设 $F(x)$ 的系数数列为 $C$。 $F(x) \times G(x) = C_nx^nG(x) + C_{n-1}x^{n-1}G(x) + C_{n-2}x^{n-2}G(x) \cdots C_2x^2G(x) + C_1x^1G(x) + C_0G(x)$ 这样下来需要做做 $n$ 次单项式乘多项式，每次的时间复杂度 $O(n)$ ，则总复杂度高达 $O(n^2)$ 基本上 $n$ 上了$4000$ 就会被卡吧……那怎么提速呢？ 这就需要我们伟大而又神奇的神器：$FFT$ (快速博立叶变换) 复杂度就只有 $O(nlogn)$ 了。 0X1F—-FFT的前置知识. 1.复数是什么? 我们把形如 $z=a+bi$（ $a,b$ 均为实数）的数称为复数，其中 $a$ 称为实部， $b$ 称为虚部， $i$ 称为虚数单位。当虚部等于零时，这个复数可以视为实数；当z的虚部不等于零时，实部等于零时，常称z为纯虚数。复数域是实数域的代数闭包，即任何复系数多项式在复数域中总有根。 复数是由意大利米兰学者卡当在十六世纪首次引入，经过达朗贝尔、棣莫弗、欧拉、高斯等人 的工作，此概念逐渐为数学家所接受。 —-百度百科 想必大家都知道实数是啥(不知道重读幼儿园吧……)，实数位于数轴上，就像下图这样： 我们稍微观察一下，$1$ 是怎么变到 $-1$ 的呢？ 在数轴上转了 180°。 如果，是 90° 的话，会发生什么呢？ 这个时候，会转到 $0$ 上面的位置，但是那里，好像没有数啊! 不对，其实是有的，只不过这个数不在实数轴上，而是在虚数轴上！ 虚数轴的单位是 $i$ ，我们可以这么表示： 嗯，对。这显然是一个平面坐标系。现在我们的数仅限于数轴上，如果是这个平面坐标系上的一个点怎么表达呢？ 对于下面的红色点： 这个点的坐标很容易的可以得到：$(2,i)$ ，也可以表示成 $2+i$ . 你没猜错！这个就叫复数！ 一个很重要的结论：复数相乘时，模长相乘，幅角相加！ 2.点值表示法是什么?我们用一个二维平面坐标系，在上面画 $N+1$ 个点，最终可以解出一个 $n$ 元的函数。证明略。 同样，我们可以用 $N-1$ 个点来表达一个多项式。 因为点值相乘的复杂度只有 $O(n)$ 显然优秀许多。 3.单位根是什么?*n次单位根(n为正整数)是n次幂为1的复数!*n次单位根(n为正整数)是n次幂为1的复数!*n次单位根(n为正整数)是n次幂为1的复数! 我们先在复平面上画个点，就像这样： Ta叫做单位圆。 圆边上的任意一点的模长都是 $1$. 只有单位圆上的点表示的复数才有可能成为$n$次单位根! 单位根的基本符号：$ω$ 一个单位圆，我们将它切成 $n$ 份，从 $(1,0)$ 开始旋转，每次旋转 $\frac{1}{n} \times 360$ 度，每次旋转后的点都记为 $ω_{n}^{k}$，特别的，$ω_{n}^{0}$ 和 $ω_{n}^{n}$ 都是 $(1,0)$ 点。 还有，当 $k&gt;=n$ 或者 $k&lt;0$ 时，$ω_{n}^{k}$ 也是合法的。 单位根的性质：$1.$ 对于任意的 $n$ , $ω_{n}^{0}$ 都为 $(1,0)$ 点。$2.$ $ω_{n}^{a} \times ω_{n}^{b} = ω_{n}^{a+b} $$3.$ $ω_{an}^{ak} = ω_{n}^{k} $$4.$ $(ω_{n}^{x})^y = (ω_{n}^{y})^x $$5.$ $ω_{n}^{k+n/2} = -ω_{n}^{k} $ if(n%2==0) 0X2F—-FFT的求解过程. 分治思想很重要！ 我们将多项式 $F(x)$ 按位置分成两块。 那么变成了(保证n是2的正整数次幂)： $F(x) = (C_0+C_2x^2+C_4x^4+ \cdots +C_{n-2}x^{n-2}) + (C_1x+C_3x^3+C_5x^5+ \cdots +C_{n-1}x^{n-1})$ 设两个多项式 $F1(x),F2(x)$。 $F1(x) = C_0+C_2x+C_4x^2+ \cdots +C_{n-2}x^{n/2-1}$$F2(x) = C_1x+C_3x+C_5x^2+ \cdots +C_{n-1}x^{n/2-1}$ 则我们可以得出： $F(x) = F1(x^2) + F2(x^2) \times x$ 设 $k&lt;n/2$ ， 将 $ω_{n}^{k}$ 带入多项式 $F(x)$. $F(ω_{n}^{k}) = F1((ω_{n}^{k})2) + F2((ω_{n}^{k})^2) \times ω_{n}^{k}$ 简化得： $F(ω_{n}^{k}) = F1(ω_{n/2}^{k}) + F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ 再假设 $k&lt;n/2$ ，将 $ω_{n}^{k+n/2}$ 带入多项式 $F(x)$. $F(ω_{n}^{k+n/2}) = F1((ω_{n}^{k+n/2})2) + F2((ω_{n}^{k+n/2})^2) \times ω_{n}^{k}$$F(ω_{n}^{k+n/2}) = F1(ω_{n}^{2k+n}) + F2(ω_{n}^{2k+n}) \times ω_{n}^{k+n/2}$$F(ω_{n}^{k+n/2}) = F1(ω_{n}^{2k}) + F2(ω_{n}^{2k}) \times ω_{n}^{k+n/2}$$F(ω_{n}^{k+n/2}) = F1(ω_{n/2}^{k}) + F2(ω_{n/2}^{k}) \times ω_{n}^{k+n/2}$$F(ω_{n}^{k+n/2}) = F1(ω_{n/2}^{k}) - F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ 比较一下两个式子： $F(ω_{n}^{k}) = F1(ω_{n/2}^{k}) + F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ $F(ω_{n}^{k+n/2}) = F1(ω_{n/2}^{k}) - F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ 等式右边只有一个负号的差别! 这两个式子很关键！ 0X3F—-FFT的代码实现.对于复数的使用虽然 $C++ STL$ 里面有复数 $(complex)$ 但是太慢不建议大家使用。 你可以自己手打 $complex$ 手打的 $complex$ : 1234struct complex&#123;complex(double a=0,double b=0)&#123;x=a,y=b;&#125;double x,y;&#125;;complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125;complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125;complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125; FFT: 123456789101112131415complex a[N],b[N];inline void FFT(complex *f,int len,short inv)&#123; if(!len)return;complex f1[len+1],f2[len+2]; for(int k=0;k&lt;len;++k)f1[k]=f[k&lt;&lt;1],f2[k]=f[k&lt;&lt;1|1];//按位置分 FFT(f1,len&gt;&gt;1,inv);FFT(f2,len&gt;&gt;1,inv);//递归处理子问题 complex tmp=complex(cos(PI/len),inv*sin(PI/len)),buf=complex(1,0); /*tmp:做一次平方后坐标的变换*/ /*buf:初始位置*/ for(RI k=0;k&lt;len;++k)&#123; complex t=buf*f2[k]; f[k]=f1[k]+t,f[k+len]=f1[k]-t;buf=buf*tmp;//按照公式还原 &#125;return;&#125;//注意，inv的作用是判断是 "系数转点值" 还是 "点值转系数" $Code$ 中提到的公式是这两项： $F(ω_{n}^{k}) = F1(ω_{n/2}^{k}) + F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ $F(ω_{n}^{k+n/2}) = F1(ω_{n/2}^{k}) - F2(ω_{n/2}^{k}) \times ω_{n}^{k}$ 对于文中的”坐标的变换”：我们依旧来看单位圆： 实际上，这个坐标的变换，直接用园中的三角形，运用三角函数就可以得出解了。 过程略. 最后我们得到的结果是：$ω_{n}^{1} = (cos(\frac{2π}{n}),sin(\frac{2π}{n}))$ 求出 $ω_{n}^{1}$ 后将它乘 $n$ 次，可以得到：$ {ω_{n}^{0},ω_{n}^{1},ω_{n}^{2},ω_{n}^{3},ω_{n}^{4},ω_{n}^{5} \cdots ω_{n}^{n-1}} $ 贴出最终的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define ll long long#define RI register int #define inf 0x3f3f3f3f#define PI 3.1415926535898using namespace std;const int N=6e4+2;template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; struct complex&#123;complex(double a=0,double b=0)&#123;x=a,y=b;&#125;double x,y;&#125;;complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125;complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125;complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;complex a[N],b[N];inline void FFT(complex *f,int len,short inv)&#123; if(!len)return;complex f1[len+1],f2[len+2]; for(int k=0;k&lt;len;++k)f1[k]=f[k&lt;&lt;1],f2[k]=f[k&lt;&lt;1|1]; FFT(f1,len&gt;&gt;1,inv);FFT(f2,len&gt;&gt;1,inv); complex tmp=complex(cos(PI/len),inv*sin(PI/len)),buf=complex(1,0); for(RI k=0;k&lt;len;++k)&#123; complex t=buf*f2[k]; f[k]=f1[k]+t,f[k+len]=f1[k]-t;buf=buf*tmp; &#125;return;&#125;int n,m;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(RI i=0;i&lt;=n;++i)scanf("%lf",&amp;a[i].x); for(RI i=0;i&lt;=m;++i)scanf("%lf",&amp;b[i].x); for(m+=n,n=1;n&lt;=m;n&lt;&lt;=1); FFT(a,n&gt;&gt;1,1);FFT(b,n&gt;&gt;1,1); for(int i=0;i&lt;n;++i)a[i]=a[i]*b[i]; FFT(a,n&gt;&gt;1,-1); for(int i=0;i&lt;=m;++i)printf("%.0f ",fabs(a[i].x)/n); putchar('\n'); return 0;&#125; 听说可以优化，那啥的我还不会，就到这吧. 过了一会儿…… “原来FFT小优化这么简单啊!” 0X4F—-FFT的一些小优化. 不用递归：12345递归版(数组下标，先偶后奇，从0开始)：0 1 2 3 4 5 6 7 --第1层0 2 4 6 |1 3 5 7 --第2层0 4 |2 6 |1 5 |3 7 --第3层0 |4 |2 |6 |1 |5 |3| 7 --第4层 发现了什么吗？ 最后的序列是原序列的二进制反转! 比如： $6 = (110)_2$ 反过来变成了 $(011)_2 = 3$ ！ 如何得到二进制翻转后的数列？递推即可! 12for(RI i=0;i&lt;n;++i)filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); //filp[i] 即为 i 的二进制位翻转 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define ll long long#define RI register int #define inf 0x3f3f3f3f#define PI 3.1415926535898using namespace std;const int N=3e6+2;int n,m,filp[N]; template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125; struct complex&#123;complex(double a=0,double b=0)&#123;x=a,y=b;&#125;double x,y;&#125;;complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125;complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125;complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;complex a[N],b[N];inline void FFT(complex *f,short inv)&#123; for(RI i=0;i&lt;n;++i)if(i&lt;filp[i])&#123;complex tmp=f[i];f[i]=f[filp[i]];f[filp[i]]=tmp;&#125; /*换位置*/ for(RI p=2;p&lt;=n;p&lt;&lt;=1)&#123;//每局区间长度 RI len=p/2;//合并子区间的长度(所以是p/2) complex tmp=complex(cos(PI/len),inv*sin(PI/len)); for(RI k=0;k&lt;n;k+=p)&#123;//每局左端点 complex buf=complex(1,0); for(RI l=k;l&lt;k+len;++l)&#123;//遍历区间 complex t=buf*f[len+l]; f[len+l]=f[l]-t,f[l]=f[l]+t,buf=buf*tmp;//赋值有微小的变化，注意顺序！ &#125; &#125; &#125;return;&#125;/*主程序不变*/int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(RI i=0;i&lt;=n;++i)scanf("%lf",&amp;a[i].x); for(RI i=0;i&lt;=m;++i)scanf("%lf",&amp;b[i].x); for(m+=n,n=1;n&lt;=m;n&lt;&lt;=1); for(RI i=0;i&lt;n;++i)filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); FFT(a,1);FFT(b,1); for(RI i=0;i&lt;n;++i)a[i]=a[i]*b[i]; FFT(a,-1); for(RI i=0;i&lt;=m;++i)printf("%.0f ",fabs(a[i].x)/n); putchar('\n'); return 0;&#125; luogu上的题，递归的总是T最后一个点，改成非递归版的就A了？emmmmmmmmmmmmmm 所有优化全开：很作死，建议不要轻易尝试[滑稽] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma GCC optimize(2)#pragma GCC optimize(3)#pragma GCC optimize("Ofast")#pragma GCC optimize("inline")#pragma GCC optimize("-fgcse")#pragma GCC optimize("-fgcse-lm")#pragma GCC optimize("-fipa-sra")#pragma GCC optimize("-ftree-pre")#pragma GCC optimize("-ftree-vrp")#pragma GCC optimize("-fpeephole2")#pragma GCC optimize("-ffast-math")#pragma GCC optimize("-fsched-spec")#pragma GCC optimize("unroll-loops")#pragma GCC optimize("-falign-jumps")#pragma GCC optimize("-falign-loops")#pragma GCC optimize("-falign-labels")#pragma GCC optimize("-fdevirtualize")#pragma GCC optimize("-fcaller-saves")#pragma GCC optimize("-fcrossjumping")#pragma GCC optimize("-fthread-jumps")#pragma GCC optimize("-funroll-loops")#pragma GCC optimize("-fwhole-program")#pragma GCC optimize("-freorder-blocks")#pragma GCC optimize("-fschedule-insns")#pragma GCC optimize("inline-functions")#pragma GCC optimize("-ftree-tail-merge")#pragma GCC optimize("-fschedule-insns2")#pragma GCC optimize("-fstrict-aliasing")#pragma GCC optimize("-fstrict-overflow")#pragma GCC optimize("-falign-functions")#pragma GCC optimize("-fcse-skip-blocks")#pragma GCC optimize("-fcse-follow-jumps")#pragma GCC optimize("-fsched-interblock")#pragma GCC optimize("-fpartial-inlining")#pragma GCC optimize("no-stack-protector")#pragma GCC optimize("-freorder-functions")#pragma GCC optimize("-findirect-inlining")#pragma GCC optimize("-fhoist-adjacent-loads")#pragma GCC optimize("-frerun-cse-after-loop")#pragma GCC optimize("inline-small-functions")#pragma GCC optimize("-finline-small-functions")#pragma GCC optimize("-ftree-switch-conversion")#pragma GCC optimize("-foptimize-sibling-calls")#pragma GCC optimize("-fexpensive-optimizations")#pragma GCC optimize("-funsafe-loop-optimizations")#pragma GCC optimize("inline-functions-called-once")#pragma GCC optimize("-fdelete-null-pointer-checks") [滑稽][滑稽][滑稽][滑稽][滑稽][滑稽][滑稽][滑稽][滑稽][滑稽][滑稽] NNT———学习笔记———关于FFT兄弟的那些事 0X5F—-NTT是啥? NTT(快速数论变换)一种快速数论变换算法，这种算法是以数论为基础，对样本点为的数论变换，按时间抽取的方法，得到一组等价的迭代方程，有效高速简化了方程中的计算公式·与直接计算相比，大大减少了运算次数。（见快速傅里叶变换）。在计算机实现多项式乘法中，我们所熟知的快速傅里叶变换(FFT)是基于n次单位根$ω_{n}$ $(omega)$ 的优秀性质实现的，而由于其计算时会使用正弦函数和余弦函数，在不断运算时无法避免地会产生精度误差。而多项式乘法有些时候会建立在模域中，在对一些特殊的大质数取模时，便可以考虑用原根g来代替$ω_{n}$，而这些特殊的大质数的原根恰好满足$ω_{n}$的某些性质，这使得多项式乘法在模域中也可以快速的分治合并。 ———百度百科 实际上，$NTT$ 跟 $FFT$ 没啥差别，优缺点各有。优点，就是省掉了大精度的操作，常数较小。 贴出我在luogu的P3803测评记录： O2—-FFT: 无优化—NTT: (速度不在一个服务器……) 当然，什么东西都是有缺点的，$NTT$ 的缺点就是多项式的系数只能是整数 ，而且普通的 $NTT$ 并不能做到任意模数，比较有限制(但是像XZY这样的奆佬随手可以水过任意模数NTT)，不过对于一般的像998244353这样的模数可以跑。 实现的基础———原根 原根是一种数学符号，设 $m$ 是正整数，$a$ 是整数，若 $a$ 模 $m$ 的阶等于 $φ(m)$ ，则称 $a$ 为模 $m$ 的一个原根。（其中 $φ(m)$ 表示 $m$ 的欧拉函数）———百度百科 为什么 $FFT$ 可以如此优秀？那是因为单位根有着神奇的性质。原根也是如此！ 合并的时候，$p=2len$ . 单位根：$cos\frac{2π}{P}+i sin\frac{2π}{P} = cos\frac{π}{len} + i sin\frac{π}{len}$ 原根：$g^{\frac{MOD-1}{P}} = g^{\frac{MOD-1}{2len}}$ $NTT$ 的学习是建立在 $FFT$ 上的，建议大家先理解 $FFT$ 再来看 $NTT$ 多说无益，贴板子吧…… 1234567891011121314151617181920212223#define MOD 998244353#define G 3inline int pow(int x,int y)//快速幂&#123;ll z=1ll*x,ans=1ll;for(;y;y/=2,z=z*z%MOD)if(y&amp;1)ans=ans*z%MOD;return (int)ans%MOD;&#125;inline void NTT(int *f,short inv)&#123;//NTT板子 int bit=0;while((1&lt;&lt;bit)&lt;n)bit++; for(RI i=0;i&lt;n;++i)&#123; filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); if(i&lt;filp[i])swap(f[i],f[filp[i]]); &#125; for(RI len=1;len&lt;n;len&lt;&lt;=1)&#123; RI tmp=pow(G,(MOD-1)/(len&lt;&lt;1)); if(inv==-1)tmp=pow(tmp,MOD-2);//是逆运算的话就套逆元 for(RI k=0;k&lt;n;k+=len*2)&#123; int buf=1; for(RI l=0;l&lt;len;++l,buf=1ll*buf*tmp%MOD)&#123; int t=f[l+k],d=1ll*buf*f[l+k+len]%MOD; f[l+k]=t+d,f[l+k+len]=t-d,//注意差别 f[l+k]=(f[l+k]%MOD+MOD)%MOD,f[l+k+len]=(f[l+k+len]%MOD+MOD)%MOD; &#125; &#125; &#125;&#125; 那一题的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define ll long long#define RI register int #define inf 0x3f3f3f3f#define MOD 998244353#define G 3using namespace std;const int N=3e6+2;int n=1,len1,len2,filp[N],a[N],b[N];template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline int pow(int x,int y)&#123;ll z=1ll*x,ans=1ll;for(;y;y/=2,z=z*z%MOD)if(y&amp;1)ans=ans*z%MOD;return (int)ans%MOD;&#125;inline void NTT(int *f,short inv)&#123; int bit=0;while((1&lt;&lt;bit)&lt;n)bit++; for(RI i=0;i&lt;n;++i)&#123; filp[i]=(filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); if(i&lt;filp[i])swap(f[i],f[filp[i]]); &#125; for(RI len=1;len&lt;n;len&lt;&lt;=1)&#123; RI tmp=pow(G,(MOD-1)/(len&lt;&lt;1)); if(inv==-1)tmp=pow(tmp,MOD-2); for(RI k=0;k&lt;n;k+=len*2)&#123; int buf=1; for(RI l=0;l&lt;len;++l,buf=1ll*buf*tmp%MOD)&#123; int t=f[l+k],d=1ll*buf*f[l+k+len]%MOD; f[l+k]=t+d,f[l+k+len]=t-d, f[l+k]=(f[l+k]%MOD+MOD)%MOD,f[l+k+len]=(f[l+k+len]%MOD+MOD)%MOD; &#125; &#125; &#125;&#125;int main()&#123; IN(len1),IN(len2);len1++,len2++; while(n&lt;len1+len2)n&lt;&lt;=1; for(RI i=0;i&lt;=len1-1;++i)IN(a[i]); for(RI i=0;i&lt;=len2-1;++i)IN(b[i]); NTT(a,1);NTT(b,1); for(RI i=0;i&lt;n;++i)a[i]=1ll*a[i]*b[i]%MOD; NTT(a,-1); for(RI i=0;i&lt;=len1+len2-2;++i)printf("%d ",1ll*a[i]*pow(n,MOD-2)%MOD); putchar('\n'); return 0;&#125; 0X3f3f3f3f 附记来一张表吧： 模数 G的值 3 2 5 2 17 3 97 5 193 5 257 3 7681 17 12289 11 40961 3 65537 3 786433 10 5767169 3 7340033 3 23068673 3 104857601 3 167772161 3 469762049 3 998244353 3 1004535809 3 2013265921 31 2281701377 3 3221225473 5 75161927681 3 77309411329 7 最后，因为本人实在太弱了，太蒟了，所以实在写不出啥了。 $by Qiuly$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 「网络流24题」骑士共存问题 网络流 luoguP3355]]></title>
    <url>%2F2019%2F02%2F15%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3355%2F</url>
    <content type="text"><![CDATA[最大流于最小割的转换。 假设现在棋盘上非障碍的位置全部摆满了骑士，我们拿走 $x$ 个的骑士可以使棋盘上的所有骑士互不冲突，求最小的 $x$. 可以跑匈牙利，也可以跑最大流算法，我选择跑 $Dinic$。 所有编号为奇数的点向源点 $s$ 连边，所有编号为偶数的点向汇点 $t$ ，连边，边权为 $1$.可以知道，同奇偶编号的点是无法互相攻击的，我们将在奇数和偶数之间可以攻击到彼此的点连一条边权无限大的边。 然后跑一遍 $Dinic$ 。 然后就没了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int #define ID(i,j) ((i-1)*n+j)#define A printf("A")using namespace std;const int M=5e5+2;const short dx[8]=&#123;1,1,-1,-1,2,2,-2,-2&#125;;const short dy[8]=&#123;2,-2,2,-2,1,-1,1,-1&#125;;int n,m,s,t,sum,cnt,dep[M],head[M];short ok[202][202];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct Edge&#123;int nxt,to,val;&#125;G[M];inline void add(int x,int y,int v)&#123; G[cnt].to=y,G[cnt].val=v,G[cnt].nxt=head[x],head[x]=cnt++; G[cnt].to=x,G[cnt].val=0,G[cnt].nxt=head[y],head[y]=cnt++;&#125; inline bool bfs()&#123; memset(dep,-1,sizeof(dep)); queue&lt;int&gt;q;q.push(s);dep[s]=0; while(q.size())&#123; int x=q.front();q.pop(); for(int i=head[x];i!=-1;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]!=-1||!G[i].val)continue; else&#123;dep[y]=dep[x]+1,q.push(y);if(y==t)return true;&#125; &#125; &#125;return false;&#125; inline int dfs(int x,int flow)&#123; if(x==t||!flow)return flow; int used=0,rlow; for(int i=head[x];i!=-1;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]==dep[x]+1&amp;&amp;G[i].val)&#123; used+=(rlow=dfs(y,min(G[i].val,flow-used))); G[i].val-=rlow,G[i^1].val+=rlow; &#125; &#125;if(!used)dep[x]=-1; return used;&#125;inline int dinic()&#123; int maxlow=0; while(bfs())maxlow+=dfs(s,1e9); return maxlow; &#125;int main()&#123; memset(head,-1,sizeof(head)); IN(n),IN(m);s=0,t=n*n+1;sum=n*n-m; for(int x,y,i=1;i&lt;=m;++i)IN(x),IN(y),ok[x][y]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j)&#123; if(ok[i][j])continue; if((i+j)&amp;1)&#123; add(s,ID(i,j),1); for(int k=0;k&lt;8;++k)&#123; int nx=i+dx[k],ny=j+dy[k]; if(nx&lt;1||ny&lt;1||nx&gt;n||ny&gt;n||ok[nx][ny])continue; add(ID(i,j),ID(nx,ny),1e9); &#125; &#125;else add(ID(i,j),t,1); &#125;printf("%d\n",sum-dinic()); return 0; &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 跳楼机 同余最短路 luogu3403]]></title>
    <url>%2F2019%2F02%2F15%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3403%2F</url>
    <content type="text"><![CDATA[对于 $x,y,z$ 三个操作，我们先考虑 $y,z$ 两个操作的情况。 $f[i]$ 表示通过 $y,z$ 两个操作可以到达的 $mod x=i$ 最小的楼层。 可以得知：$f[i+y]=f[i]+y,f[i+z]=f[i]+z.$ 对于最短路，我们可以用一下形式建边： 1add(i,(i+y)%x,y); add(i,(i+z)%x,z); 没问题吧？%x是必须要做的操作，上文讲了。 那如何统计答案呢？ 首先，如果这个 “最小的楼层” 超出了 $H$ ，那么显然是不用统计的。否则，我们将这样统计：ans+=(H-f[i])/x+1; 为什么要这样写呢？想想，现在我们知道了这个最小楼层，我们可以到达这个最小楼层，对吧？如果现在以这个最小楼层为起点，我们可以选择在往上跳 $x$ 层，或者是 $2x$ 层….知道 $nx$ 层，$(n+1)x$就会超出 $H$，这时上面的式子就好理解多了。 Code:(可以不用 堆优$Dijstra$，没必要，用 $Spfa$ 就行了)12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register intusing namespace std;const int N=1e5+3;ll H,x,y,z,ans,f[N];int vis[N],head[N],cnt;struct Edge&#123;int nxt,to,val;&#125;G[N&lt;&lt;1]; inline void add(int x,int y,int v)&#123;G[++cnt].nxt=head[x],G[cnt].to=y,G[cnt].val=v,head[x]=cnt;&#125;inline void spfa()&#123; memset(f,127,sizeof(f)); queue&lt;int&gt; q;f[1]=1,vis[1]=1,q.push(1); while(q.size())&#123; int x=q.front();q.pop();vis[x]=0; for(RI i=head[x];i;i=G[i].nxt)&#123; if(f[G[i].to]&gt;f[x]+G[i].val)&#123; f[G[i].to]=f[x]+G[i].val; if(!vis[G[i].to])q.push(G[i].to),vis[G[i].to]=1; &#125; &#125; &#125;return;&#125;int main()&#123; scanf("%lld%lld%lld%lld",&amp;H,&amp;x,&amp;y,&amp;z); if(x==1||y==1||z==1)&#123;printf("%lld\n",H);return 0;&#125; for(int i=0;i&lt;x;++i)&#123;add(i,(i+y)%x,y);add(i,(i+z)%x,z);&#125; spfa(); for(int i=0;i&lt;x;++i) if(f[i]&lt;=H)ans+=(H-f[i])/x+1; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>同余最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [ZJOI2014]力 FFT bzoj3527/luogu3338]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3338%2F</url>
    <content type="text"><![CDATA[这个式子有点……乱。 嗯，我们来推一推式子……推一推式子。 原式推一推，那么就是： E_i = \frac{F_i}{q_i} = \sum_{j=1}^{i} \frac{q_j}{(i-j)^2} - \sum_{j=i+1}^{n} \frac{q_j}{(i-j)^2}​ 令 $x = \frac{1}{y^2}​$ ， 那么： E_i = \frac{F_i}{q_i} = \sum_{j=1}^{i} q_j x_{i-j} - \sum_{j=i+1}^{n} q_j x_{j-i}​还可以写成： E_i = \sum_{j=1}^{i} q_j x_{i-j} - \sum_{j=i+1}^{n} q_j x_{j-i}​令 $S_i = q_{n-i+1} ​$，那么式子变成了： E_i = \sum_{j=1}^{i} q_j x_{i-j} - \sum_{j=i+1}^{n} p_{n-j+1} x_{j-i}这个时候我们可以发现，$\sum_{j=1}^{i} q_j x_{i-j}​$ 和 $\sum_{j=i+1}^{n} p_{n-j} x_{j-i}​$ 都是卷积，那么我们可以跑两遍 $FFT​$，分别求出上面的两个式子，记录为 $A,B​$ 。最后的答案就是 $A[i].x - B[n+1-i].x​$ 了。 FFT不用做太多修改，套模板跑就行(本来就是模板)。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt; #include&lt;cmath&gt;#include&lt;string&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int #define PI 3.1415926535898using namespace std;const int N=4e5+2;int n,limit=1,filp[N];template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct complex&#123;complex(double a=0,double b=0)&#123;x=a,y=b;&#125;double x,y;&#125;;complex operator + (complex a,complex b)&#123;return complex(a.x+b.x,a.y+b.y);&#125;;complex operator - (complex a,complex b)&#123;return complex(a.x-b.x,a.y-b.y);&#125;;complex operator * (complex a,complex b)&#123;return complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;;complex A[N],B[N],C[N];inline void FFT(complex *f,short inv)&#123; for(RI i=0;i&lt;limit;++i)if(i&lt;filp[i])&#123;complex t=f[i];f[i]=f[filp[i]],f[filp[i]]=t;&#125; for(RI p=2;p&lt;=limit;p&lt;&lt;=1)&#123; RI len=p/2; complex tmp=complex(cos(PI/len),inv*sin(PI/len)); for(RI k=0;k&lt;limit;k+=p)&#123; complex buf=complex(1,0); for(RI l=k;l&lt;k+len;++l)&#123; complex t=buf*f[l+len]; f[l+len]=f[l]-t,f[l]=f[l]+t,buf=buf*tmp; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n);int cnt=0; for(RI i=1;i&lt;=n;++i)&#123;scanf("%lf",&amp;A[i].x),B[n+1-i].x=A[i].x;&#125; for(RI i=1;i&lt;=n;++i)C[i].x=(1.0/double(i))/double(i); while(limit&lt;=(n&lt;&lt;1))limit&lt;&lt;=1,cnt++; for(RI i=0;i&lt;limit;++i)filp[i]=((filp[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(cnt-1))); FFT(A,1);FFT(B,1);FFT(C,1); for(RI i=0;i&lt;=limit;++i)A[i]=A[i]*C[i],B[i]=B[i]*C[i]; FFT(A,-1);FFT(B,-1); for(RI i=0;i&lt;=limit;++i)A[i].x/=limit,B[i].x/=limit; for(RI i=1;i&lt;=n;++i)printf("%.3lf\n",-B[n+1-i].x+A[i].x); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [USACO18DEC]Balance Beam 期望+凸包 洛谷P5155]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP5155%2F</url>
    <content type="text"><![CDATA[被概率冲昏的头脑~~~ 我们先将样例在图上画下来： 会发现，最大收益是： ) 看出什么了吗？ 这不就是凸包吗？ 跑一遍凸包就好了呀，这些点中，如果i号点是凸包上的点，那么它的ans就是自己(第二个点)，不然的话，从上图来看，i的ans肯定和他相邻的两个是凸包边界的点有关(0节点和2节点)，那么怎么求这个ans呢？(第x号点为横坐标为x的点) 实际上我也不知道就是个期望公式啊! l[i]记录i号点往左走第一个为凸包边界的点(如果i为1号，那么l[i]为0，特殊的，如果i为2号，那么l[i]就是本身)，r[i]同理。当l[x]==r[x]时，x时边界。 就是这个方程： (f[l[i]])*(r[i]-i)+f[r[i]]*(i-l[i])))/(r[i]-l[i]);基础的期望方程，在此不再赘述(实际上是不会证) 关于凸包，在这贴一波yyb大神的博客：传送门戳我QwQ(顺便膜一波yyb大神%%%) 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int#define F 100000using namespace std;const int NS=1e5+5;ll f[NS],l[NS],r[NS],hep[NS];//f如题,l[i]/r[i]如上文,hep为凸包 template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int main()&#123; int n,top=0;IN(n);hep[++top]=0;//注意先加入0! for(int i=1;i&lt;=n;++i)IN(f[i]); for(int i=1;i&lt;=n+1;++i)&#123;//凸包 while(top&gt;=2)&#123; int a=hep[top],b=hep[top-1]; if(((f[a]-f[b])*(i-a))&lt;((f[i]-f[a])*(a-b)))--top; else break; &#125;hep[++top]=i; &#125; for(int i=1;i&lt;top;++i)&#123; //中间的节点的l,r值都为hep[i]/hep[i+1] for(int j=hep[i]+1;j&lt;hep[i+1];++j)&#123; l[j]=hep[i],r[j]=hep[i+1]; &#125;l[hep[i]]=hep[i],r[hep[i]]=hep[i]; &#125; for(int i=1;i&lt;=n;++i)&#123; ll ans=0;//记得LL! if(l[i]==r[i])ans=f[i]*F;//为边界，直接跳下最优 else ans=(F*(f[l[i]]*(r[i]-i)+f[r[i]]*(i-l[i])))/(r[i]-l[i]);//否则用方程算 printf("%lld\n",ans); &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>概率</tag>
        <tag>期望</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 浅谈树套树(线段树套平衡树)&学习笔记]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E7%AE%97%E6%B3%95%5D%E6%A0%91%E5%A5%97%E6%A0%91(%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E5%B9%B3%E8%A1%A1%E6%A0%91)%2F</url>
    <content type="text"><![CDATA[唉还是太弱了，毕竟只会初级的线段树套平衡树，码量巨大，超级不适合我这种天生码量恐惧症的人……那么我们开始正文 码量巨大，超级不适合我这种天生码量恐惧症的人…… 那么我们开始正文 0XFF 前言 *如果本文有不好的地方，请在下方评论区提出，Monlights感激不尽！ 0X1F 这个东西有啥用? 树套树———线段树套平衡树，可以用于解决待修改区间$K$大的问题，当然也可以用 树套树———树状数组套可持久化线段树，但是 线段树套平衡树 更加容易理解，更加便于新手理解，所以一般也作为树套树的入门类别。对于静态区间$K$大，我们可以用小巧精悍的主席树来做，也可以用强大无比的$Splay$来做。如果带修改，主席树就无能为力了，$Splay$也会变得很棘手难打。如果用普通线段树，每个节点都有着一课包含子节点的$Splay$，对于一个区间，直接调用线段树上的$Splay$就迎刃而解了。这时的$Splay$不是对全局，而是只对这个线段树节点代表的区间。 当然，树套树———线段树套平衡树并不是那么的好打，还是要动纸笔 and 动脑筋。缺点也是有的：因为要打$Splay$和线段树，模板的码量就有 $150$ 行！因为线段树本来就是易手滑的数据结构，稍不留神可能会让你调上好久！另外，因为$Splay$的常数极大，再这么通过线段树一罩，效率就下来了许多，常数巨大无比……总之 树套树 是一个很强的数据结构，但是如果题目不是强制在线的话，$CDQ$分治和整体二分会将树套树吊起来打！ ——————Qiuly 0X2F 这个东西怎么实现?首先，线段树套平衡树可以解决的一般问题如下： 查询 $k$ 在区间 $l,r$ 内的排名 查询区间 $l,r$ 内排名为 $k$ 的值 修改某一位置上的数值 查询 $k$ 在区间 $l,r$ 内的前驱 查询 $k$ 在区间 $l,r$ 内的后继 修改区间 $l,r$ 的值(集体加减)(不会) ………… 我们今天来讲讲前五个基础操作怎么实现(我只会前五个操作) 0X2f-1 查询 $k$ 在区间 $l,r$ 内的排名我们先将一个外面的线段树画下来： (叶子节点中的数字是序列各个元素的权值) 假设我们现在要查询区间 $3,8$ 中 $5$ 的排名。 查询一个数的排名，很显然，就是查询这个区间内有多少个数比 Ta 小，然后在+1(即自己)。 那怎么查询 $3,8$ 区间内有多少个数比他小呢？$3,8$ 不是整个线段树节点啊。 我们可以将它分成若干个线段树节点来处理。 Code:123456789101112131415161718inline int Splay_rank(int i,int k)&#123;//i表示以线段树的i号节点为根的Splay int x=rt[i],cal=0;//板子就不再赘述了 while(x)&#123; if(v[x]==k)return cal+((ch[x][0])?s[ch[x][0]]:0); else if(v[x]&lt;k)&#123; cal+=((ch[x][0])?s[ch[x][0]]:0)+c[x];x=ch[x][1]; &#125;else x=ch[x][0]; &#125;return cal;&#125;;inline void Seg_rank(int x,int l,int r,int L,int R,int Kth)&#123; if(l==L&amp;&amp;r==R)&#123;ans+=Splay_rank(x,Kth);return;&#125;//是整个线段树节点 if(R&lt;=mid)Seg_rank(lc,l,mid,L,R,Kth);//情况1：完全属于左子树 else if(L&gt;mid)Seg_rank(rc,mid+1,r,L,R,Kth);//情况2：完全属于右子树 else Seg_rank(lc,l,mid,L,mid,Kth),Seg_rank(rc,mid+1,r,mid+1,R,Kth);//情况3：横跨两子树区间&#125;;//Main 函数中case 1:&#123;IN(v);ans=0;Seg_rank(1,1,n,x,y,v);printf("%d\n",ans+1);&#125;break; 没看懂？我们来一步一步解读。 首先，进入线段树。 不是整个线段树节点，跳过第一条语句。发现 $3,8$ 横跨了两个子树，拆开询问区间，先询问左子树。这个时候往左子树递归，目标询问区间 $3,4$ ，右子树目标询问区间 $5,8$ 。分别处理。 进入左子树： 然后，发现询问区间完全属于右子树(当前区间：$1,4$ , 询问区间：$3~4$)，所以直接递归右子树： 这个时候，发现当前区间和询问区间合并了(当前区间：$3,4$ , 询问区间：$3~4$)，$Splay$ 询问小于 $5$ 的数的个数。 区间：$3,4$ 的 $Splay$ : 至于 $Splay$ 里面的操作不在模拟，因为 $(4,6)$ 中比 $5$ 小的只有一个数，所以 $ans+=1$ ，现在 $ans=1$ 左子树的任务完成，现在处理在右子树的询问区间 $(5,8)$ ，发现一下去 当前区间：$5,8$ , 询问区间：$5,8$ 合并了！直接跳进 $Splay$。 跑完 $Splay$ 后，发现有两个数小于 $5$ ($=$的不算)，$ans+=2$ ，现在 $ans=3$ 。 所以询问区间全部处理完了，退出函数。main函数输出：$ans(3)+1=4$ 即答案为 $4$ . 0X2f-2 查询区间 $l,r$ 内排名为 $k$ 的值这个我们需要用到二分来实现，我们不能讲询问区间拆成两个区间(像第一个操作那样)，因为合并不了答案啊。 所以我们依靠二分来实现。 Code: 1234567891011inline int Get_Kth(int x,int y,int k)&#123; int L=0,R=MX+1,M;//MX为序列权值的最大值，上图中MX为9. while(L&lt;R)&#123; M=(L+R)&gt;&gt;1; ans=0;Seg_rank(1,1,n,x,y,M);//询问M的排名 if(ans&lt;k)L=M+1;else R=M;//二分 &#125;return L-1;//return&#125;;//Main函数中case 2:&#123;IN(v);printf("%d\n",Get_Kth(x,y,v));&#125;break; 这个我就不贴图了，不好画图解释。理解不难，多读几遍代码就好了。 0X2f-3 修改某一位置上的数值这个很简单，跟普通的线段树单点修改几乎一模一样，只是要同时更新 $Splay$。 123456789inline void Seg_change(int x,int l,int r,int pos,int val)&#123; Splay_Delete(x,a[pos]);Splay_Insert(x,val);//更新 Splay if(l==r)&#123;a[pos]=val;return;&#125;;//修改序列的值 if(pos&lt;=mid)Seg_change(lc,l,mid,pos,val);//普通的线段树 else Seg_change(rc,mid+1,r,pos,val);&#125;;//Main函数中case 3:&#123;Seg_change(1,1,n,x,y);&#125;break; 0X2f-4 查询 $k$ 在区间 $l,r$ 内的前驱对于这个操作，我们依旧可以拆开来操作，合并的时候对于每个拆分后的询问区间的答案取个最大值，因为是求前驱，肯定是越接近 $k$ 越好。 123456789inline void Seg_pre(int x,int l,int r,int L,int R,int val)&#123; if(l==L&amp;&amp;r==R)&#123;ans=max(ans,Splay_Get_pre(x,val));return;&#125; if(R&lt;=mid)Seg_pre(lc,l,mid,L,R,val); else if(L&gt;mid)Seg_pre(rc,mid+1,r,L,R,val); else Seg_pre(lc,l,mid,L,mid,val),Seg_pre(rc,mid+1,r,mid+1,R,val);&#125;;//Main函数中case 4:&#123;IN(v);ans=-inf;Seg_pre(1,1,n,x,y,v);printf("%d\n",ans);&#125;break; 0X2f-4 查询 $k$ 在区间 $l,r$ 内的后继 跟 $4$ 操作同理. 0X3F 一些题目 BZOJ3196: Tyvj 1730 二逼平衡树LUOGU P3380【模板】二逼平衡树(树套树) 这道题就是上面讲的那道啊! Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define RI register int #define A printf("A")#define C printf(" ")#define inf 2147483647#define PI 3.1415926535898using namespace std;const int N=4e6+2;//template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; //template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int n,m,a[N],ans,MX;/*----------------------------------Splay-------------------------------------*/int f[N],c[N],s[N],v[N],ch[N][2],rt[N],tot;inline int chk(int x)&#123;return ch[f[x]][1]==x;&#125;;inline void Splay_del_node(int x)&#123;f[x]=s[x]=c[x]=v[x]=ch[x][0]=ch[x][1]=0;&#125;;inline void Splay_pushup(int x)&#123;s[x]=(ch[x][0]?s[ch[x][0]]:0)+(ch[x][1]?s[ch[x][1]]:0)+c[x];&#125;;inline void Splay_rotate(int x)&#123; int y=f[x],z=f[y],k=chk(x),v=ch[x][k^1]; ch[y][k]=v;if(v)f[v]=y;f[x]=z;if(z)ch[z][chk(y)]=x; f[y]=x,ch[x][k^1]=y;Splay_pushup(y),Splay_pushup(x);&#125;;inline void Splay(int i,int x,int top=0)&#123; while(f[x]!=top)&#123; int y=f[x],z=f[y]; if(z!=top)Splay_rotate((ch[z][0]==y)==(ch[y][0]==x)?y:x); Splay_rotate(x); &#125;if(!top)rt[i]=x;&#125;;inline void Splay_Insert(int i,int x)&#123; int pos=rt[i]; if(!rt[i])&#123; rt[i]=pos=++tot;v[pos]=x;s[pos]=c[pos]=1; f[pos]=ch[pos][0]=ch[pos][1]=0;return; &#125;int last=0; while(1)&#123; if(v[pos]==x)&#123;++c[pos];Splay_pushup(last);break;&#125; last=pos;pos=ch[pos][x&gt;v[pos]]; if(!pos)&#123; pos=++tot;v[pos]=x;s[pos]=c[pos]=1; ch[last][x&gt;v[last]]=pos; f[pos]=last;ch[pos][0]=ch[pos][1]=0; Splay_pushup(last);break; &#125; &#125;Splay(i,pos);return;&#125;;inline int Splay_rank(int i,int k)&#123; int x=rt[i],cal=0; while(x)&#123; if(v[x]==k)return cal+((ch[x][0])?s[ch[x][0]]:0); else if(v[x]&lt;k)&#123; cal+=((ch[x][0])?s[ch[x][0]]:0)+c[x];x=ch[x][1]; &#125;else x=ch[x][0]; &#125;return cal;&#125;;inline int Splay_find(int i,int x)&#123; int pos=rt[i];while(x)&#123; if(v[pos]==x)&#123;Splay(i,pos);return pos;&#125;; pos=ch[pos][x&gt;v[pos]]; &#125;return 0;&#125;;inline int Splay_pre(int i)&#123;int x=ch[rt[i]][0];while(ch[x][1])x=ch[x][1];return x;&#125;inline int Splay_suc(int i)&#123;int x=ch[rt[i]][1];while(ch[x][0])x=ch[x][0];return x;&#125;inline int Splay_Get_pre(int i,int x)&#123; int pos=rt[i];while(pos)&#123; if(v[pos]&lt;x)&#123;if(ans&lt;v[pos])ans=v[pos];pos=ch[pos][1];&#125; else pos=ch[pos][0]; &#125;return ans;&#125;;inline int Splay_Get_suc(int i,int x)&#123; int pos=rt[i];while(pos)&#123; if(v[pos]&gt;x)&#123;if(ans&gt;v[pos])ans=v[pos];pos=ch[pos][0];&#125; else pos=ch[pos][1]; &#125;return ans;&#125;;inline void Splay_Delete(int i,int key)&#123; int x=Splay_find(i,key); if(c[x]&gt;1)&#123;--c[x];Splay_pushup(x);return;&#125; if(!ch[x][0]&amp;&amp;!ch[x][1])&#123;Splay_del_node(rt[i]);rt[i]=0;return;&#125; if(!ch[x][0])&#123;int y=ch[x][1];rt[i]=y;f[y]=0;return;&#125; if(!ch[x][1])&#123;int y=ch[x][0];rt[i]=y;f[y]=0;return;&#125; int p=Splay_pre(i);int lastrt=rt[i]; Splay(i,p,0);ch[rt[i]][1]=ch[lastrt][1];f[ch[lastrt][1]]=rt[i]; Splay_del_node(lastrt);Splay_pushup(rt[i]);&#125;;/*------------------------------Seg_Tree--------------------------------------*/ #define lc ((x)&lt;&lt;1)#define rc ((x)&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)inline void Seg_Insert(int x,int l,int r,int pos,int val)&#123; Splay_Insert(x,val);if(l==r)return; if(pos&lt;=mid)Seg_Insert(lc,l,mid,pos,val); else Seg_Insert(rc,mid+1,r,pos,val);&#125;;inline void Seg_rank(int x,int l,int r,int L,int R,int Kth)&#123; if(l==L&amp;&amp;r==R)&#123;ans+=Splay_rank(x,Kth);return;&#125; if(R&lt;=mid)Seg_rank(lc,l,mid,L,R,Kth); else if(L&gt;mid)Seg_rank(rc,mid+1,r,L,R,Kth); else Seg_rank(lc,l,mid,L,mid,Kth),Seg_rank(rc,mid+1,r,mid+1,R,Kth);&#125;;inline void Seg_change(int x,int l,int r,int pos,int val)&#123; // printf("QvQ:: %d %d %d %d %d\n",x,l,r,pos,val); Splay_Delete(x,a[pos]);Splay_Insert(x,val); if(l==r)&#123;a[pos]=val;return;&#125;; if(pos&lt;=mid)Seg_change(lc,l,mid,pos,val); else Seg_change(rc,mid+1,r,pos,val);&#125;;inline void Seg_pre(int x,int l,int r,int L,int R,int val)&#123; if(l==L&amp;&amp;r==R)&#123;ans=max(ans,Splay_Get_pre(x,val));return;&#125; if(R&lt;=mid)Seg_pre(lc,l,mid,L,R,val); else if(L&gt;mid)Seg_pre(rc,mid+1,r,L,R,val); else Seg_pre(lc,l,mid,L,mid,val),Seg_pre(rc,mid+1,r,mid+1,R,val);&#125;;inline void Seg_suc(int x,int l,int r,int L,int R,int val)&#123; if(l==L&amp;&amp;r==R)&#123;ans=min(ans,Splay_Get_suc(x,val));return;&#125; if(R&lt;=mid)Seg_suc(lc,l,mid,L,R,val); else if(L&gt;mid)Seg_suc(rc,mid+1,r,L,R,val); else Seg_suc(lc,l,mid,L,mid,val),Seg_suc(rc,mid+1,r,mid+1,R,val);&#125;;/*---------------------------------ask----------------------------------------*/inline int Get_Kth(int x,int y,int k)&#123; int L=0,R=MX+1,M; while(L&lt;R)&#123; M=(L+R)&gt;&gt;1; ans=0;Seg_rank(1,1,n,x,y,M); if(ans&lt;k)L=M+1;else R=M; &#125;return L-1;&#125;;/*-------------------------------main-------------------------------------*/int main(int argc,char const* argv[])&#123; IN(n),IN(m); for(RI i=1;i&lt;=n;++i)&#123;IN(a[i]);Seg_Insert(1,1,n,i,a[i]);MX=max(MX,a[i]);&#125; while(m--)&#123; int op,x,y,v;IN(op),IN(x),IN(y); switch(op)&#123; case 1:&#123;IN(v);ans=0;Seg_rank(1,1,n,x,y,v);printf("%d\n",ans+1);&#125;break; case 2:&#123;IN(v);printf("%d\n",Get_Kth(x,y,v));&#125;break; case 3:&#123;Seg_change(1,1,n,x,y);&#125;break; case 4:&#123;IN(v);ans=-inf;Seg_pre(1,1,n,x,y,v);printf("%d\n",ans);&#125;break; case 5:&#123;IN(v);ans=inf;Seg_suc(1,1,n,x,y,v);printf("%d\n",ans);&#125;break; &#125; &#125;return 0;&#125; 然后就是这道题，跟上面的那道题差不多，大家可以拿来练练手： BZOJ3196: 1901 Dynamic RankingsLUOGU P2617 Dynamic Rankings 不贴代码了。 一道不错的细节题： LUOGU P3332 [ZJOI2013]K大数查询 $———by Qiuly$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2016]生成魔咒 后缀自动机.SAM bzoj4516/luogu4070]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4070%2F</url>
    <content type="text"><![CDATA[一眼题目。 题目简述如下： 任务一：支持询问当前本质不同的子串的个数 任务二：支持插入 很显然后缀自动机可以解决胜任，正好今天刚学了后缀自动机，那么就将它定为练手题了。 插入是很简单的，至于询问本质不同的字串的个数，我们知道新插入一个节点 $now$ 对答案的贡献是: $ |max(now)| - |min(now)| + 1$ 。我们建后缀自动机的时候只保存了 $max(now)$ ，难道还要保存一个 $min(now)$ 吗？其实不需要，根据其性质可以得到：$|max(now)| - |max(fa[now])|$，直接计算即可。 注意数据范围较大，记得开 $longlong​$ ！ *注：文中的 $|S|​$ 指的是字符串 $S​$ 的长度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=2e5+2;const int inf=1e9+9;template&lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;struct SAM&#123; ll ans; std::map&lt;int,int&gt; ch[N]; int last,cnt,len[N],fa[N]; inline void Insert(int c)&#123; int p=last,now=last=++cnt; len[now]=len[p]+1; while(p&amp;&amp;!ch[p][c])ch[p][c]=now,p=fa[p]; if(!p)fa[now]=1; else&#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[now]=q; else&#123; int copy=++cnt; len[copy]=len[p]+1,ch[copy]=ch[q]; fa[copy]=fa[q],fa[q]=fa[now]=copy; while(p&amp;&amp;ch[p][c]==q)ch[p][c]=copy,p=fa[p]; &#125; &#125; ans+=len[now]-len[fa[now]]; return; &#125;&#125;sam;int main()&#123; int n;IN(n); sam.last=sam.cnt=1; for(int i=1;i&lt;=n;++i)&#123; int c;IN(c); sam.Insert(c); printf("%lld\n",sam.ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>后缀自动机.SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [JSOI2008]球形空间产生器 高斯消元 洛谷P4035]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4035%2F</url>
    <content type="text"><![CDATA[“你要求出这个n维球体的球心坐标“，这使我想到的解方程…… 先假设n=2，这是一个二维平面。设圆心的坐标为$(x,y)$，有两个坐标$(a_1,b_1)$和$(a_2,b_2)$，显然两个坐标的关系为： (x-a_1)^2+(y-b_1)^2=(x-a_2)^2+(y-b_2)^2考虑如何化简上面的式子。 (x-a_1)^2-(x-a_2)^2+(y-b_1)^2-(y-b_2)^2=0根据完全平方公式： (x-a_1)^2=x^2+a_1^2-2 \times x \times a_1(x-a_1)^2-(x-a_2)^2=x^2+a_1^2-2 \times x \times a_1-x^2-a_2^2+2 \times x \times a_2(x-a_1)^2-(x-a_2)^2=a_1^2-2 \times x \times a_1-a_2^2+2 \times x \times a_2(x-a_1)^2-(x-a_2)^2=a_1^2-a_2^2-2(a_1-a_2)x同理 (y-b_1)^2-(y-b_2)^2=b_1^2-b_2^2-2(b_1-b_2)y整理后： a_1^2-a_2^2-2(a_1-a_2)x+b_1^2-b_2^2-2(b_1-b_2)y=0移项后： a_1^2-a_2^2+b_1^2-b_2^2=2(a_1-a_2)x+2(b_1-b_2)y这个式子最终为： 2(a_1-a_2)x+2(b_1-b_2)y=a_1^2-a_2^2+b_1^2-b_2^2由于 $a_1^2-a_2^2+b_1^2-b_2^2​$ 是已知的，我们将 $a_1^2-a_2^2+b_1^2-b_2^2​$ 设为$Sum​$. $2(a_1-a_2)​$ 和 $2(b_1-b_2)​$都是已知的项，分别设为 $a​$ 和 $b​$ . 所以它又变成了我们亲切的小学奥数之解方程：$ax+by=Sum$ 对于二维的答案是 $(x,y)​$ ，$x​$ 和 $y​$ 都可以通过高斯消元的模板来解出。 对于更高的维数，跟二维同理，只不过”元”多了几个而已。 所以就这样愉快的A掉了这道大水题。Code:1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register intusing namespace std;const int N=25;const double eps=1e-8;double v[N][N],f[N][N],s[N],del;int n;inline bool Gauss()&#123; for(RI k=1,i=1;i&lt;=n;++i,k=i)&#123; for(RI j=i+1;j&lt;=n;++j)if(abs(f[j][i])&gt;abs(f[k][i]))k=j; if(fabs(del=f[k][i])&lt;eps)return false;//不判就出BUG，不知道为啥 swap(f[i],f[k]);swap(s[i],s[k]); for(RI j=i;j&lt;=n;++j)f[i][j]/=del;s[i]/=del; for(k=1;k&lt;=n;++k)if(k!=i)&#123; del=f[k][i]; for(RI j=i;j&lt;=n;++j)f[k][j]-=f[i][j]*del; s[k]-=s[i]*del; &#125; &#125;return true;&#125;int main()&#123; scanf("%d",&amp;n); for(RI i=1;i&lt;=n+1;++i)for(RI j=1;j&lt;=n;++j)scanf("%lf",&amp;v[i][j]); for(RI i=1;i&lt;=n;++i) for(RI j=1;j&lt;=n;++j)&#123; s[i]+=(v[i][j]*v[i][j]-v[i+1][j]*v[i+1][j]);//求上面的 "Sum" f[i][j]=2*(v[i][j]-v[i+1][j]);//求上面的 "a"、"b"等 &#125; Gauss(); for(RI i=1;i&lt;n;++i)printf("%.3lf ",s[i]);//注意输出格式! printf("%.3lf",s[n]); return 0;&#125; 这题啥都好，就是输出格式有点制杖……请各位小心……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [ICPC-Beijing 2006]狼抓兔子 网络流 bzoj1001/洛谷P4001]]></title>
    <url>%2F2019%2F02%2F14%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP4001%2F</url>
    <content type="text"><![CDATA[网络流水题。 既然要抓到所有的兔子，又要用最少的狼，很容易想到，这是在让我们求最小割。 那么如何求最小割呢？ 有一条定理是这样的：最大流=最小割 所以我们只要用 $Dinic$ 跑出最大流，然后直接输出就行了。 不过，为什么最大流=最小割呢？ 网上的一名 $Dalao$ 给出了答案： $Q:$ 如何凭直觉解释最大流等于最小割? $A:$ $1.$ 最大流不可能大于最小割, 因为最大流所有的水流都一定经过最小割那些割边, 流过的水流怎么可能比水管容量还大呢? $2.$ 最大流不可能小于最小割, 如果小, 那么说明水管容量没有物尽其用, 可以继续加大水流. $Q:$ 如何严谨证明最大流等于最小割? $A:$ $1.$ 证明任意的 $s-t$ 流量小于 $s-t$ 割容量, 证明方法: 根据定义即可; $2.$ 根据 $Ford-Fulkerson$ 算法求出的流来选出一个 $s-t$ 割, $S$ 为残余网络中 $s$ 可达的顶点集合, 这样就可以证出算法求出的流$=$这个割的容量, 再根据已经证明的 $1$ 来得出算法求出的流是最大流, 对应的割是最小割. $Dalao——Jecvay Notes$ 现在要注意的一点就是，直接跑朴素的 $Dinic$ 是会 T 的，这个时候或许会要一些优化，比如说用当前弧优化，或者可以跑$ISAP$，如果还过不了，吸氧算了[滑稽]。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define RI register int#define ll long longconst int N=1e6+2;const int inf=1e9+9;struct Edge&#123; int nxt,to,val;&#125;G[N*6];int n,m,s,t,cnt=1,dep[N],head[N];#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y)) template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;inline int id(int x,int y)&#123;return (x-1)*m+y;&#125;inline void add(int x,int y,int v)&#123; G[++cnt].nxt=head[x],G[cnt].to=y,G[cnt].val=v,head[x]=cnt; G[++cnt].nxt=head[y],G[cnt].to=x,G[cnt].val=v,head[y]=cnt;&#125;inline bool bfs()&#123; std::memset(dep,0,sizeof(dep)); std::queue&lt;int&gt;q;q.push(s),dep[s]=1; while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]||!G[i].val)continue; dep[y]=dep[x]+1;q.push(y); if(y==t)return true; &#125; &#125;return false;&#125;inline int dfs(int x,int flow)&#123; if(x==t)return flow; int used=0; for(int i=head[x];i&amp;&amp;used&lt;flow;i=G[i].nxt)&#123; int y=G[i].to; if(dep[y]!=dep[x]+1||!G[i].val)continue; else&#123; int rlow=dfs(y,min(G[i].val,flow-used)); if(!rlow)&#123;dep[y]=-1;continue;&#125; G[i].val-=rlow,G[i^1].val+=rlow,used+=rlow; &#125; &#125;return used;&#125;inline int Dinic()&#123; int ans=0; while(bfs())ans+=dfs(s,inf); return ans;&#125;int main()&#123; int v; IN(n),IN(m);s=1,t=n*m; for(int i=1;i&lt;=n;++i) for(int j=2;j&lt;=m;++j) IN(v),add(id(i,j-1),id(i,j),v); for(int i=2;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) IN(v),add(id(i-1,j),id(i,j),v); for(int i=2;i&lt;=n;++i) for(int j=2;j&lt;=m;++j) IN(v),add(id(i-1,j-1),id(i,j),v); printf("%d\n",Dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 小清新人渣的本愿 莫队+bitset luoguP3674]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP3674%2F</url>
    <content type="text"><![CDATA[莫队 $+$ $bitset$. 我们可以用 $bitset$ 维护当前 $l,r$ 区间数的出现的状态，莫对依旧按照套路搞，然后来考虑怎么回答每一个询问。 对于操做 $1$ ，要求回答我们从当前区间能否找出 $a,b$ 使得其差为 $x$。 很显然，$a-b=x$ 等价于 $a=b+x$。 我们维护的是数的出现的状态，于是可以将当前的 $bitset$ 左移 $x$ 位，也就是让所有数都加上 $x$，然后与原 $bitset$ 做与运算，看看是否有一个 $a$ 出现，如果与的结果非 $0$ ，那么显然是有的，否则没有。 第二个操作有些不好办，我们再开一个 $bitset$ 集，对于一个出现过的数 $i$，在第二个 $bitset$ 集中记为 $N-i$。然后再来看操作要求，这次是让 $a+b=x$。 那么可以得到：a=x-b 于是设一个数 $z$ ，表示 $N-a$ 。 然后：z=N-x+b 移项得：z-b=N-x 于是我们将第二个 $bitset$ 右移 $N-x$ 为，显然第二个 $bitset$ 集上的第 $i$ 位代表的就是第一个 $bitset$ 上的 $x-i$ 位。 然后，将两个 $bitset$ 与一下，看看是否同时存在 $a$ 和 $x-a$ 即可。 最后对于第三个操作，貌似bitset也不太好搞，那么直接暴力枚举因子就好了，复杂度 $O(\sqrt{n})$，放心不会炸。具体怎么暴力枚举呢？在 $1 - \sqrt{x}$ 的范围类枚举一个 $j$ ，如果 $x$ % $j==0$ 并且同时存在 $j$ 和 $x/j$，显然就有答案了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cmath&gt;#include&lt;bitset&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long long#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=1e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;std::bitset&lt;N&gt; now1,now2; int n,m,l,r,s,a[N],c[N],Be[N],ans[N];struct MO&#123;int opt,l,r,x,id;&#125;q[N];inline bool cmp(MO a,MO b)&#123;return Be[a.l]==Be[b.l]?a.r&lt;b.r:a.l&lt;b.l;&#125; inline void input()&#123; IN(n),IN(m);s=sqrt(n); for(int i=1;i&lt;=n;++i)IN(a[i]),Be[i]=(i-1)/s+1; for(int i=1;i&lt;=m;++i) IN(q[i].opt),IN(q[i].l),IN(q[i].r),IN(q[i].x),q[i].id=i; std::sort(q+1,q+1+m,cmp); l=1,r=0;now1.reset(),now2.reset();&#125;inline void Add(int x)&#123;if(c[x]++==0)now1[x]=1,now2[N-x]=1;&#125;inline void Del(int x)&#123;if(--c[x]==0)now1[x]=0,now2[N-x]=0;&#125;int main()&#123; input(); for(int i=1;i&lt;=m;++i)&#123; while(l&lt;q[i].l)Del(a[l++]); while(l&gt;q[i].l)Add(a[--l]); while(r&gt;q[i].r)Del(a[r--]); while(r&lt;q[i].r)Add(a[++r]); if(q[i].opt==1)&#123; if((now1&amp;(now1&lt;&lt;q[i].x)).any())ans[q[i].id]=true; &#125;else if(q[i].opt==2)&#123; if((now1&amp;(now2&gt;&gt;(N-q[i].x))).any())ans[q[i].id]=true; &#125;else if(q[i].opt==3)&#123; for(int j=1;j*j&lt;=q[i].x;++j) if(!(q[i].x%j)&amp;&amp;now1[j]&amp;&amp;now1[q[i].x/j]) &#123;ans[q[i].id]=true;break;&#125; &#125; &#125; for(int i=1;i&lt;=m;++i) if(ans[i])printf("hana\n"); else printf("bi\n"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】 点分治总结&学习笔记]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E7%AE%97%E6%B3%95%5D%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[其实很短的啦，感觉……感觉淀粉质这种东西好像没什么可以总结的……只会有一些简单的板子题而已……(实际上是砍不动难的题目)(淀粉质吗？味道真是不错呢嘿嘿嘿) 0XFF—-点分治是啥？ 点分治，是处理树上路径的一个极好的工具。 一般如果需要大规模处理树上路径，点分治是一个不错的选择。 ———一位网上的Dalao 现在有一个问题，给你一颗树，树上的每一条边都有权值，现在给一个 $k$ ，要求你求出树上所有路径中路径权值小于 $k$ 的路径总数，你怎么办？ 暴力？$O(N^3)$ 的复杂度分分钟让你 T 飞！ 当然，你可以用分治来求，复杂度仅有 $O(nlogn)$。 对于树上做分治，不仅有基于点的分治方式，还有基于边的以及基于链的，但是这不在我们的讨论范围类(作者太蒟了不会QvQ)。 0X1F 点分治的流程0X1F—-1 怎么分治？对于所有的路径，很显然我们可以将它们分成两部分： $1.$ 这条路径经过了它所在的子树的根节点 $2.$ 这条路径没经过它所在的子树的根节点 假设现在有一颗树，Ta的根节点是 $1$： 对于路径 $2 -&gt; 1 -&gt; 3 -&gt; 6$ ，它是经过了根节点的，属于 $1$ 类路径。 对于路径 $4 -&gt; 2 -&gt; 5 -&gt; 8$ ，它没有经过根节点 $1$，属于 $2$ 类路径。 对于第一类路径我们直接处理，对于第二类路径，递归处理当前根的儿子，在儿子里面处理，也就是说现在我们只需要处理第一类路径。 怎么确定这个根呢？显然根的好坏可以决定算法的复杂度。 因为每次是递归儿子，显然递归层数越少越好，什么情况下递归层数越少？当前根是当前树的重心时！ 那么，整个算法的框架如下： 12345678910void solve(int u)&#123;//当前节点u 当前树的当前根节点为u，统计第一类路径; 做标记，当前点已经当过根了(总不可能一直是一个点当吧=。=) for(u的所有儿子)&#123; if(儿子当过根节点了)continue; 去掉满足在一个子树条件的不合法答案; 在儿子的子树中得到一个新的根节点; solve(新的根节点); &#125;return;&#125; 其中，在儿子的子树中得到一个新的根节点如下： 现在在 $Solva(1)$ 函数中，并且现在循环到了 $1$ 的儿子 $3$ ，那么 $3$ 的子树就是灰色三角形中的三个节点，我们的新 $root$ 就是灰色三角形这棵树的重心，现在刚开始的时候可以将 $3$ 看成根节点，然后再往下计算。 0X1F—-2 获取树的重心很简单，只需要一个 $DP$ 就行了。 123456789101112void getroot(int u,int fa)&#123; size[u]=1;mxss[u]=0; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; getroot(v,u); size[u]+=size[v]; mxss[u]=max(mxss[u],size[v]); &#125; mxss[u]=max(mxss[u],sum-size[u]); if(mxss[u]&lt;mxss[root])root=u; //mxss[u]为u的子树中size最大的size，size就是u下面的子树大小。&#125; 那么这一句是什么意思呢：mxss[u]=max(mxss[u],sum-size[u]); 我们再举个栗子，假如现在的 $u$ 是 $1$ ：($Qiuly$懒所以用的前面的那个图) 但是 $size[1]$ 统计的只是Ta下面的 ${2,3,4,5,6,7,8}$ 号节点，万一当前树不止这些呢？也就是说上面还有一坨节点，如果计算的时候显然也是要考虑进去的。 0X1F—-怎么统计1类路径？Code:123456789101112131415161718void getdist(int u,int fa)&#123; use[++cnt]=dist[u]; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; dist[v]=dist[u]+G[i].val;getdist(v,u); &#125;return;&#125;int calc(int u,int dist0)&#123; cnt=0;dist[u]=dist0; getdist(u,0); std::sort(use+1,use+1+cnt); int l=1,r=cnt,res=0; while(l&lt;r) if(use[l]+use[r]&lt;=k)res+=r-l,++l; else --r; return res; &#125; 确定了当前树的 $root$ 后，我们可以定义 $dist[root]$ 为 $0$ ，其余的当前树的节点的 $dist$ 为Ta到 $root$ 的距离(路上所有边的权值和)。 显然，这个问题很容易搞定($getdist$)。 想象一下，现在有一条路径 $l -&gt; \cdots -&gt; root -&gt; \cdots -&gt; r$，显然这条路径的权值就是 $dist[l] + dist[r]$。 可是，如果一一去枚举 $l,r$ 并且统计的话复杂度是报表的啊！这没关系，我们依旧可以用线性的时间复杂度解决问题。 得到了所有的 $dist$ 后，我们排个序。 然后就是统计的流程。 假设现在排好序的数列为 {$1,1,2,3,4,4,5,6,7,7,8$}，$l$ 为 $1$ ，$r$ 为 $cnt$。 现在计算 $1+8$ ，显然如果 $1+8$ 小于 $k$ ，那么 $1 + (1/2/3/4/4/5/6/7/7)$ 都会小于 $k$，这个时候直接统计即可。否则 --r ，因为我们还需要统计的是 $l+1,l+2,\cdots$，既然这个 $r$ 不行了，对后面的答案是肯定不会有影响的。 最后 $return;$ 0X2F 总体代码 Test:Luogu P4178 TreeCode:如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))//为了格式不鬼畜这两个宏定义我只能放着了QvQ#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt; const int N=4e4+2;const int inf=1e9+9;int n,m,k,cnt,sum,ans,root,head[N];int vis[N],use[N],dist[N],size[N],mxss[N];struct Edge&#123; int nxt,to,val; &#125;G[N&lt;&lt;1];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;void getroot(int u,int fa)&#123; size[u]=1;mxss[u]=0; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; getroot(v,u); size[u]+=size[v]; mxss[u]=max(mxss[u],size[v]); &#125; mxss[u]=max(mxss[u],sum-size[u]); if(mxss[u]&lt;mxss[root])root=u; &#125;void getdist(int u,int fa)&#123; use[++cnt]=dist[u]; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; dist[v]=dist[u]+G[i].val;getdist(v,u); &#125;return;&#125;int calc(int u,int dist0)&#123; cnt=0;dist[u]=dist0; getdist(u,0); std::sort(use+1,use+1+cnt); int l=1,r=cnt,res=0; while(l&lt;r) if(use[l]+use[r]&lt;=k)res+=r-l,++l; else --r; return res; &#125;void solve(int u)&#123; ans+=calc(u,0); vis[u]=1; for(int v,i=head[u];i;i=G[i].nxt)&#123; if(vis[(v=G[i].to)])continue; ans-=calc(v,G[i].val); sum=size[v];root=0; getroot(v,0); solve(root); &#125;return;&#125;int main()&#123; IN(n),sum=mxss[0]=n; for(int i=1,u,v,w;i&lt;n;++i)&#123; IN(u),IN(v),IN(w); G[++cnt]=(Edge)&#123;head[u],v,w&#125;;head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,w&#125;;head[v]=cnt; &#125; IN(k); getroot(1,0); solve(root); printf("%d\n",ans); return 0; &#125; Test:Luogu P3806 【模板】点分治1Analysis:很显然我们不能像上面那样傻乎乎的While了，那样不能算出路径的权值，只能统计。干脆统计时来个双重循环暴力吧！然后搞个桶。复杂度很高但是能过得了(至少这一题是这样的)Code:如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))//Q.v.Q........................#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long long#define RI register int const int N=1e4+2;const int inf=1e9+9;int ans[10000005];int n,m,k,cnt,sum,root,head[N];int vis[N],use[N],dist[N],size[N],mxss[N];struct Edge&#123; int nxt,to,val; &#125;G[N&lt;&lt;1];template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;void getroot(int u,int fa)&#123; size[u]=1;mxss[u]=0; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; getroot(v,u); size[u]+=size[v]; mxss[u]=max(mxss[u],size[v]); &#125; mxss[u]=max(mxss[u],sum-size[u]); if(mxss[u]&lt;mxss[root])root=u; &#125;void getdist(int u,int fa)&#123; use[++cnt]=dist[u]; for(int v,i=head[u];i;i=G[i].nxt)&#123; if((v=G[i].to)==fa||vis[v])continue; dist[v]=dist[u]+G[i].val;getdist(v,u); &#125;return;&#125;void calc(int u,int dist0,int add)&#123; cnt=0;dist[u]=dist0; getdist(u,0); for(int i=1;i&lt;=cnt;++i) for(int j=1;j&lt;=cnt;++j) ans[use[i]+use[j]]+=add; &#125;void solve(int u)&#123; calc(u,0,1);vis[u]=1; for(int v,i=head[u];i;i=G[i].nxt)&#123; if(vis[(v=G[i].to)])continue; calc(v,G[i].val,-1); sum=size[v];root=0; getroot(v,0); solve(root); &#125;return;&#125;int main()&#123; IN(n),IN(m),sum=mxss[0]=n; for(int i=1,u,v,w;i&lt;n;++i)&#123; IN(u),IN(v),IN(w); G[++cnt]=(Edge)&#123;head[u],v,w&#125;;head[u]=cnt; G[++cnt]=(Edge)&#123;head[v],u,w&#125;;head[v]=cnt; &#125; getroot(1,0); solve(root); for(int i=1;i&lt;=m;++i) IN(k),printf(ans[k]?"AYE\n":"NAY\n"); return 0; &#125; ~~(还是背板子最重要嘿嘿嘿)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2014]魔法森林 动态加边Spfa bzoj3669/luogu2387]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2387%2F</url>
    <content type="text"><![CDATA[膜法森林2333…… 显然是一道 $LCT$ 动态加边的题目。 然而并不需要这么高深的数据结构来动态加边(实际上是不会)，我们只需要 $Spfa$ 动态加边即可切掉此题。 怎么 $Spfa$?又是个怎么的动态加边法呢？ 在下面我先给出代码，然后再来一步一步剖析(跟 $Spfa$ 板子差不多)。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long long#define RI register intconst int N=5e4+2,M=1e5+2;const int inf=1e9+9;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; bool flag=0;char ch;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;bool vis[N];std::queue&lt;int&gt; q;int head[N],dis[N],tot,cnt,ans,n,m;struct Edge_Spfa&#123;int nxt,to,v1,v2;&#125;G[M];struct Edge_Main&#123; int x,y,v1,v2; bool operator &lt; (Edge_Main a)const&#123; return v1&lt;a.v1; &#125;&#125;L[M];inline void make_line(int x,int y,int v1,int v2)&#123; G[++tot].nxt=head[x],head[x]=tot,G[tot].to=y,G[tot].v1=v1,G[tot].v2=v2; G[++tot].nxt=head[y],head[y]=tot,G[tot].to=x,G[tot].v1=v1,G[tot].v2=v2;&#125; #define A printf("A")#define C printf("\n")#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y)) inline void spfa(int star_1,int star_2)&#123; vis[star_1]=true,vis[star_2]=true; q.push(star_1),q.push(star_2); while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i;i=G[i].nxt)&#123; int to=G[i].to; if(max(dis[u],G[i].v2)&lt;dis[to])&#123; dis[to]=max(dis[u],G[i].v2); if(!vis[to])q.push(to),vis[to]=true; &#125; &#125;vis[u]=false; &#125;return;&#125;int main()&#123; IN(n),IN(m); memset(dis,127,sizeof(dis)); dis[1]=0,q.push(1),ans=inf; for(int i=1;i&lt;=m;++i) IN(L[i].x),IN(L[i].y),IN(L[i].v1),IN(L[i].v2); std::sort(L+1,L+1+m); for(int i=1;i&lt;=m;++i)&#123; make_line(L[i].x,L[i].y,L[i].v1,L[i].v2); spfa(L[i].x,L[i].y); ans=min(ans,dis[n]+L[i].v1); &#125;printf("%d\n",ans==inf?-1:ans); return 0;&#125; 动态加边，顾名思义，就是按最优顺序依次将边插入，对于每次插完边的图做一次答案统计($Spfa$)，然后每次在 $main$ 函数里统计答案，最后输出即可。 我们固定 $v1$ ，用 $v2$ 跑 $Spfa$，边的插入顺序是按照 $v1$ 的大小来的，小的先插。 之所以上面要用到 $sort$，是因为我们要达到”按最优顺序依次将边插入”。 $Spfa$ 的板子就不解释了，不懂的同学左转搜素 $Spfa$ ，先刷几道黄牌去吧…… 我们来看看动态加边的过程: 12345for(int i=1;i&lt;=m;++i)&#123; make_line(L[i].x,L[i].y,L[i].v1,L[i].v2); spfa(L[i].x,L[i].y); ans=min(ans,dis[n]+L[i].v1); &#125; make_line(L[i].x,L[i].y,L[i].v1,L[i].v2); : 加边，不解释 spfa(L[i].x,L[i].y); : $Spfa$ 过程。 $Q$ :为什么要定义两个起点 $L[i].x$ 和 $L[i].y$ 呢？ $A$ :显然加进来了这条边后，对当前图中一些点的 $dis$ 值可能会有影响，所以以这个边的两端的点为起点，依次更新旁边的点，直到不能再更新。 ans=min(ans,dis[n]+L[i].v1); : 更新 $ans$ 值 $Q$ :为什么使用 $dis[n]+L[i].v1$ 对 $ans$ 进行更新，有可能这条最短路上并不包含这个边啊，为什么要将 $L[i].v1$ 算进去呢？可能会更新错答案啊。 $A$ :对于当前图的最短路，我们分两种情况来讨论： $1.$ 这条最短路上没包含这条新加上的边 $2.$ 这条最短路上包含了这条新加上的边 对于第一种情况，显然这条最短路在加上这条边之前就已经有了，因为这条边的存在跟这条最短路没任何关系，既然之前有了，那么就肯定已经更新过 $ans$ 了。而那个时候的 $v1$ 是肯定比这个时候的 $v1$ 小的，也就是说 $ans$ 在之前已经被比现在的答案更小的答案更新过了，所以 $ans$ 也不会被当前答案更新。 对于第二种情况，因为这条最短路上包含了这条边，而这条边肯定是这条最短路上 $v1$ 最大的边(当然也是当前图上 $v1$ 最大的边)，所以直接更新没错。 每一次循环后数组不要重置吗？ 显然队列是不要的，因为 $Spfa$ 的退出条件是是队列为空，所以每次做完 $Spfa$ 时队列也就空了。 $vis$ 数组也不需要，跟队列是一个道理，只有 $vis$ 数组里面还有 $true$ 的元素，说明还有元素在队列里，队列空了，$vis$ 数组也自然空了。 $dis$ 数组不需要，因为循环中每次跑 $Spfa$ 是为了更新 $dis$ 数组而非做最短路。 然后……然后就没有然后了……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LCT</tag>
        <tag>Spfa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [SDOI2008]Cave洞穴勘测 LCT bzoj2049/洛谷P2147]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2147%2F</url>
    <content type="text"><![CDATA[Link-Cut-Tree的模板题啊……(听说还可以用其他的方法做，不管了，直接上LCT) 没有要求维护点权，只需要维护点的连通性即可。 就是朴素的LCT，居然还不要pushup。 感觉有些不适应啊…….不得不说LCT是个神器。 简单分析一下。 对于每种命令: 如果是Connect x y (链接 x y):直接 link(x,y)即可。 如果是Destroy x y (切断 x y):直接 cut(x,y)即可。 如果是Query x y (询问 x y 的连通性):判断findroot(x)和findroot(y)是否一致，一致输出Yes，否则输出No。 然后就A了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define RI register int#define A printf("A")#define C printf(" ") using namespace std;const int N=2e5+2;template &lt;typename Tp&gt; inline void IN(Tp &amp;x)&#123; int f=1;x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')if(ch=='-')f=-1,ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10+ch-'0',ch=getchar();x*=f;&#125;int n,m,f[N],r[N],hep[N],ch[N][2];inline int chk(int x)&#123;return ch[f[x]][1]==x;&#125;inline int get(int x)&#123;return ch[f[x]][0]==x||ch[f[x]][1]==x;&#125;inline void filp(int x)&#123;swap(ch[x][0],ch[x][1]);r[x]^=1;&#125; inline void pushdown(int x)&#123; if(!r[x])return;r[x]=0; if(ch[x][0])filp(ch[x][0]); if(ch[x][1])filp(ch[x][1]);&#125;inline void rotate(int x)&#123; int y=f[x],z=f[y],k=chk(x),&amp;v=ch[x][!k]; if(get(y))ch[z][chk(y)]=x;v=y,ch[y][k]=v; if(v)f[v]=y;f[y]=x,f[x]=z;return;&#125;inline void Splay(int x)&#123; int y=x,top=0;hep[++top]=y; while(get(y))hep[++top]=y=f[y]; while(top)pushdown(hep[top--]); while(get(x))&#123; y=f[x],top=f[y]; if(get(y))rotate((ch[y][0]==x)^(ch[top][0]==y)?x:y); rotate(x); &#125;return;&#125; inline void Access(int x)&#123; for(register int y=0;x;x=f[y=x]) Splay(x),ch[x][1]=y;&#125;inline void makeroot(int x)&#123; Access(x);Splay(x);filp(x);&#125;inline int findroot(int x)&#123; Access(x);Splay(x); while(ch[x][0])pushdown(x),x=ch[x][0]; return x;&#125;inline void split(int x,int y)&#123; makeroot(x);Access(y);Splay(y);&#125; inline void link(int x,int y)&#123; makeroot(x);if(findroot(y)!=x)f[x]=y;&#125;inline void cut(int x,int y)&#123; makeroot(x); if(findroot(y)==x&amp;&amp;f[x]==y&amp;&amp;!ch[x][1])&#123; f[x]=ch[y][0]=0; &#125;return;&#125;char op[10];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(register int x,y,i=1;i&lt;=m;++i)&#123; scanf("%s%d%d",op,&amp;x,&amp;y); if(op[0]=='C')link(x,y); else if(op[0]=='D')cut(x,y); else if(op[0]=='Q')&#123; if(findroot(x)==findroot(y))printf("Yes\n"); else printf("No\n"); &#125; &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 [NOI2010]超级钢琴 RMQ+优先队列 bzoj2006/洛谷P2048]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP2048%2F</url>
    <content type="text"><![CDATA[这一道题显然是一道 $RMQ$ 的题目，用一个三元素组$（o，l，r）​$表示：左端点为o，右端点在l到r的区间内的最大子段，元素组用堆维护。 对于每个和弦的值，用前缀和在$O(1)$的时间复杂度求出。 $ans$累加这个三元组的贡献。由于$t$已经被选中，对于这个$o$，$t$已经不能重复选中，但最优解还可能存在于 $t$左右的两端区间中，所以提取出$(o, l, r)$之后，为了避免重复且不丧失其他较优解，我们仍然要把$(o, l, t - 1),(o, t + 1, r)$扔回堆里面去。还要避免重复或错误，即$l = t$或$r = t$的情况要进行特判。 对于$t$的位置，我们直接用ST表预处理出即可。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define Macth#define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y))const int N=500005,Log=20;ll f[N][Log],sum[N];template &lt;typename Tp&gt; inline void read(Tp &amp;x)&#123; x=0;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar();&#125;namespace RMQ&#123;//ST表求区间最优位置(貌似在本题中是这样) inline void make(int n)&#123; for(register int i=1;i&lt;=n;++i)f[i][0]=i; for(register int j=1;(1&lt;&lt;j)&lt;=n;++j) for(register int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)&#123; int x=f[i][j-1],y=f[i+(1&lt;&lt;(j-1))][j-1]; f[i][j]=sum[x]&gt;sum[y]?x:y;//取更优的位置 &#125;return; &#125; inline int query(int l,int r)&#123; int k=log2(r-l+1); int x=f[l][k],y=f[r-(1&lt;&lt;k)+1][k]; return sum[x]&gt;sum[y]?x:y; &#125;&#125;int n,k,L,R;struct Queue&#123; int l,r,o,t;//t就是最优的位置 Queue()&#123;&#125; Queue(int o,int l,int r):o(o),l(l),r(r),t(RMQ::query(l,r))&#123;&#125;//t:取个l至r区间的最优值 bool operator &lt; (Queue a)const&#123;//重载运算符 return sum[a.t]-sum[a.o-1]&lt;sum[t]-sum[o-1]; &#125;&#125;A;std::priority_queue&lt;Queue&gt; q;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;k,&amp;L,&amp;R); for(register int i=1;i&lt;=n;++i)&#123; scanf("%lld",&amp;sum[i]);sum[i]+=sum[i-1]; &#125;RMQ::make(n);ll ans=0; for(register int i=1;i&lt;=n;++i)&#123; if(i+L-1&lt;=n)q.push(Queue(i,i+L-1,min(i+R-1,n))); &#125;while(k--)&#123; A=q.top();q.pop(); ans+=sum[A.t]-sum[A.o-1];//更新ans if(A.l!=A.t)q.push(Queue(A.o,A.l,A.t-1)); if(A.r!=A.t)q.push(Queue(A.o,A.t+1,A.r)); &#125;printf("%lld\n",ans); return 0;&#125; 差不多就是这样了……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>RMQ</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 Tyvj1730二逼平衡树 树套树 luogu3380/bzoj3196]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5DluoguP1730%2F</url>
    <content type="text"><![CDATA[树套树，直接线段树套 $Splay$ . 因为有区间的$k$大，不能直接用$Splay$(大佬忽视这句话)，显然可以用树套树(废话)。对于每一个线段树的节点都建一棵 $Splay$ ，需要查询这个节点所代表的区间第 $k$ 大等操作时直接用 $Splay$ 来完成即可…… 但是，如果不是正好的区间呢？假如询问区间横跨了两个子树区间怎么办呢？ 这就需要技巧了. 下面，对于第一个操作，先贴出代码: 123456789inline void Seg_rank(int x,int l,int r,int L,int R,int Kth)&#123; if(l==L&amp;&amp;r==R)&#123;ans+=Splay_rank(x,Kth);return;&#125;//必须判断啊，一定要相等 if(R&lt;=mid)Seg_rank(lc,l,mid,L,R,Kth);//完全属于左子树 else if(L&gt;mid)Seg_rank(rc,mid+1,r,L,R,Kth);//完全属于左子树 else Seg_rank(lc,l,mid,L,mid,Kth),Seg_rank(rc,mid+1,r,mid+1,R,Kth); //因为 ans 是 += ，所以直接拆开即可，因为有些抽象，可以画图模拟&#125;;case 1:&#123;IN(v);ans=0;Seg_rank(1,1,n,x,y,v);printf("%d\n",ans+1);&#125;break; 基本上，所有有关的操作都可以参考上面的代码段…… 多说无益，直接看代码吧. 哦，对了，其实理解只需纸笔和一份正确的代码，并不要太多的讲解(感觉网上没找到很优秀的文章……) Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long long#define RI register int #define A printf("A")#define C printf(" ")#define inf 2147483647#define PI 3.1415926535898using namespace std;const int N=4e6+2;//template &lt;typename _Tp&gt; inline _Tp max(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&gt;y?x:y;&#125; //template &lt;typename _Tp&gt; inline _Tp min(const _Tp&amp;x,const _Tp&amp;y)&#123;return x&lt;y?x:y;&#125;template &lt;typename _Tp&gt; inline void IN(_Tp&amp;x)&#123; char ch;bool flag=0;x=0; while(ch=getchar(),!isdigit(ch))if(ch=='-')flag=1; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); if(flag)x=-x;&#125;int n,m,a[N],ans,MX;/*----------------------------------Splay-------------------------------------*/int f[N],c[N],s[N],v[N],ch[N][2],rt[N],tot;// rt[i] 表示线段树编号为i的节点的Splay的根节点inline int chk(int x)&#123;return ch[f[x]][1]==x;&#125;;inline void Splay_del_node(int x)&#123;f[x]=s[x]=c[x]=v[x]=ch[x][0]=ch[x][1]=0;&#125;;inline void Splay_pushup(int x)&#123;s[x]=(ch[x][0]?s[ch[x][0]]:0)+(ch[x][1]?s[ch[x][1]]:0)+c[x];&#125;;inline void Splay_rotate(int x)&#123; int y=f[x],z=f[y],k=chk(x),v=ch[x][k^1]; ch[y][k]=v;if(v)f[v]=y;f[x]=z;if(z)ch[z][chk(y)]=x; f[y]=x,ch[x][k^1]=y;Splay_pushup(y),Splay_pushup(x);&#125;;inline void Splay(int i,int x,int top=0)&#123; while(f[x]!=top)&#123; int y=f[x],z=f[y]; if(z!=top)Splay_rotate((ch[z][0]==y)==(ch[y][0]==x)?y:x); Splay_rotate(x); &#125;if(!top)rt[i]=x;&#125;;inline void Splay_Insert(int i,int x)&#123; int pos=rt[i]; if(!rt[i])&#123; rt[i]=pos=++tot;v[pos]=x;s[pos]=c[pos]=1; f[pos]=ch[pos][0]=ch[pos][1]=0;return; &#125;int last=0; while(1)&#123; if(v[pos]==x)&#123;++c[pos];Splay_pushup(last);break;&#125; last=pos;pos=ch[pos][x&gt;v[pos]]; if(!pos)&#123; pos=++tot;v[pos]=x;s[pos]=c[pos]=1; ch[last][x&gt;v[last]]=pos; f[pos]=last;ch[pos][0]=ch[pos][1]=0; Splay_pushup(last);break; &#125; &#125;Splay(i,pos);return;&#125;;inline int Splay_rank(int i,int k)&#123; int x=rt[i],cal=0; while(x)&#123; if(v[x]==k)return cal+((ch[x][0])?s[ch[x][0]]:0); else if(v[x]&lt;k)&#123; cal+=((ch[x][0])?s[ch[x][0]]:0)+c[x];x=ch[x][1]; &#125;else x=ch[x][0]; &#125;return cal;&#125;;inline int Splay_find(int i,int x)&#123; int pos=rt[i];while(x)&#123; if(v[pos]==x)&#123;Splay(i,pos);return pos;&#125;; pos=ch[pos][x&gt;v[pos]]; &#125;return 0;&#125;;inline int Splay_pre(int i)&#123;int x=ch[rt[i]][0];while(ch[x][1])x=ch[x][1];return x;&#125;inline int Splay_suc(int i)&#123;int x=ch[rt[i]][1];while(ch[x][0])x=ch[x][0];return x;&#125;inline int Splay_Get_pre(int i,int x)&#123; int pos=rt[i];while(pos)&#123; if(v[pos]&lt;x)&#123;if(ans&lt;v[pos])ans=v[pos];pos=ch[pos][1];&#125; else pos=ch[pos][0]; &#125;return ans;&#125;;inline int Splay_Get_suc(int i,int x)&#123; int pos=rt[i];while(pos)&#123; if(v[pos]&gt;x)&#123;if(ans&gt;v[pos])ans=v[pos];pos=ch[pos][0];&#125; else pos=ch[pos][1]; &#125;return ans;&#125;;inline void Splay_Delete(int i,int key)&#123; int x=Splay_find(i,key); if(c[x]&gt;1)&#123;--c[x];Splay_pushup(x);return;&#125; if(!ch[x][0]&amp;&amp;!ch[x][1])&#123;Splay_del_node(rt[i]);rt[i]=0;return;&#125; if(!ch[x][0])&#123;int y=ch[x][1];rt[i]=y;f[y]=0;return;&#125; if(!ch[x][1])&#123;int y=ch[x][0];rt[i]=y;f[y]=0;return;&#125; int p=Splay_pre(i);int lastrt=rt[i]; Splay(i,p,0);ch[rt[i]][1]=ch[lastrt][1];f[ch[lastrt][1]]=rt[i]; Splay_del_node(lastrt);Splay_pushup(rt[i]);&#125;;/*------------------------------Seg_Tree--------------------------------------*/ #define lc ((x)&lt;&lt;1)#define rc ((x)&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)inline void Seg_Insert(int x,int l,int r,int pos,int val)&#123; Splay_Insert(x,val);if(l==r)return; if(pos&lt;=mid)Seg_Insert(lc,l,mid,pos,val); else Seg_Insert(rc,mid+1,r,pos,val);&#125;;inline void Seg_rank(int x,int l,int r,int L,int R,int Kth)&#123; if(l==L&amp;&amp;r==R)&#123;ans+=Splay_rank(x,Kth);return;&#125; if(R&lt;=mid)Seg_rank(lc,l,mid,L,R,Kth); else if(L&gt;mid)Seg_rank(rc,mid+1,r,L,R,Kth); else Seg_rank(lc,l,mid,L,mid,Kth),Seg_rank(rc,mid+1,r,mid+1,R,Kth);&#125;;inline void Seg_change(int x,int l,int r,int pos,int val)&#123;// printf("QvQ:: %d %d %d %d %d\n",x,l,r,pos,val); Splay_Delete(x,a[pos]);Splay_Insert(x,val); if(l==r)&#123;a[pos]=val;return;&#125;; if(pos&lt;=mid)Seg_change(lc,l,mid,pos,val); else Seg_change(rc,mid+1,r,pos,val);&#125;;inline void Seg_pre(int x,int l,int r,int L,int R,int val)&#123; if(l==L&amp;&amp;r==R)&#123;ans=max(ans,Splay_Get_pre(x,val));return;&#125; if(R&lt;=mid)Seg_pre(lc,l,mid,L,R,val); else if(L&gt;mid)Seg_pre(rc,mid+1,r,L,R,val); else Seg_pre(lc,l,mid,L,mid,val),Seg_pre(rc,mid+1,r,mid+1,R,val);&#125;;inline void Seg_suc(int x,int l,int r,int L,int R,int val)&#123; if(l==L&amp;&amp;r==R)&#123;ans=min(ans,Splay_Get_suc(x,val));return;&#125; if(R&lt;=mid)Seg_suc(lc,l,mid,L,R,val); else if(L&gt;mid)Seg_suc(rc,mid+1,r,L,R,val); else Seg_suc(lc,l,mid,L,mid,val),Seg_suc(rc,mid+1,r,mid+1,R,val);&#125;;/*---------------------------------ask----------------------------------------*/inline int Get_Kth(int x,int y,int k)&#123; int L=0,R=MX+1,M; while(L&lt;R)&#123; M=(L+R)&gt;&gt;1; ans=0;Seg_rank(1,1,n,x,y,M); if(ans&lt;k)L=M+1;else R=M; &#125;return L-1;&#125;;/*-------------------------------main-------------------------------------*/int main(int argc,char const* argv[])&#123; IN(n),IN(m); for(RI i=1;i&lt;=n;++i)&#123;IN(a[i]);Seg_Insert(1,1,n,i,a[i]);MX=max(MX,a[i]);&#125; while(m--)&#123; int op,x,y,v;IN(op),IN(x),IN(y); switch(op)&#123; case 1:&#123;IN(v);ans=0;Seg_rank(1,1,n,x,y,v);printf("%d\n",ans+1);&#125;break; case 2:&#123;IN(v);printf("%d\n",Get_Kth(x,y,v));&#125;break; case 3:&#123;Seg_change(1,1,n,x,y);&#125;break; case 4:&#123;IN(v);ans=-inf;Seg_pre(1,1,n,x,y,v);printf("%d\n",ans);&#125;break; case 5:&#123;IN(v);ans=inf;Seg_suc(1,1,n,x,y,v);printf("%d\n",ans);&#125;break; &#125; &#125;return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 楼房重建 线段树 bzoj2957]]></title>
    <url>%2F2019%2F02%2F13%2F%5B%E9%A2%98%E8%A7%A3%5Dbzoj2957%2F</url>
    <content type="text"><![CDATA[每个楼房，还有单点修改操作。简单的想到用线段树来维护信息。 显然线段树只需要维护y/x即可，对于每一个楼房，能看见的条件就是前面楼房的y/x的严格小于当前楼房的y/x。 线段树的区间修改不再赘述。 那么怎么维护可以看到的楼房数呢？ 考虑在线段树的每一个节点上用一个变量sum来表示从这个节点的左端点向右端点看时能看到多少楼房。 假设现在有一区间：1,5,8,0,7,9。维护这个区间信息的节点编号为x。 x的左儿子维护的区间是1,5,8，从1往8看可以看到三个楼房，故x的左儿子的sum的值为3。 x的右儿子维护的区间是0,7,9，从0往9看也可以看到三个楼房，故x的右儿子的sum的值也为3。 难道x的sum值也为3+3=6？错!这显然是不能加在一起的，x的sum的值为4。 为什么会错呢？因为x的右儿子的观察视角不是从1开始的，是从0开始的。 显然0被前面的楼房挡住了。 首先考虑每个线段树节点在维护一个mx，mx代表这个节点所代表的区间中所有的楼房中最高的高度。 上传时，由于两个儿子的sum值是已经处理好的，而左儿子的视角是跟x的视角一样的(对于上面的例子来说都是1)，可以直接上传，即sum(x)+=sum(l(x))。 对于右儿子，考虑递归处理右儿子的区间，递归时带一个Mx变量表示x的左儿子mx(右儿子再左儿子后面，原因下面解释)，递归函数的返回值是当前处理区间可以被看到的楼房数(从x的视角看) 对于现在处理的每一个区间： 如果这个区间的最高的楼房的高度都Mx(可以看到)，那么return 当前区间维护的sum值。 如果这个区间只代表一个楼房，直接判断其能否被看到即可。 对于剩下的情况，递归儿子，分两种情况讨论： 如果左儿子的最高的楼房小于Mx(不能对答案有任何贡献)，直接递归右儿子。 否则，递归左儿子，右儿子能看到的楼房个数为当前区间sum-左儿子sum即可，(应为下面已经更新好了，只需要直接调用就好了。) Code(文中的sum用l代替):12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f#define lson x&lt;&lt;1#define rson x&lt;&lt;1|1using namespace std;const int N=1e5+2;struct Node &#123; double mx;int l; #define m(x) tree[x].mx #define l(x) tree[x].l&#125; tree[N&lt;&lt;2];int n,m;double val[N];inline void pushup_max(int x) &#123; m(x)=max(m(x&lt;&lt;1),m(x&lt;&lt;1|1));&#125;inline int pushup_sum(double Mx,int x,int l,int r) &#123; if(m(x)&lt;Mx)return 0; if(val[l]&gt;Mx)return l(x); if(l==r)return val[l]&gt;Mx; int mid=(l+r)&gt;&gt;1; if(m(lson)&lt;=Mx)return pushup_sum(Mx,rson,mid+1,r); else return pushup_sum(Mx,lson,l,mid)+l(x)-l(lson);&#125;inline void change(int x,int l,int r,int pos,int value) &#123; if(l==r&amp;&amp;l==pos)&#123;m(x)=(double)value/pos;l(x)=1;return;&#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)change(lson,l,mid,pos,value); else if(pos&gt;mid)change(rson,mid+1,r,pos,value); pushup_max(x); l(x)=l(lson)+pushup_sum(m(lson),rson,mid+1,r);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;m); for(register int x,y,i=1; i&lt;=m; ++i) &#123; scanf("%d%d",&amp;x,&amp;y); val[x]=(double)y/x; change(1,1,n,x,y); printf("%d\n",l(1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome,new visitors! Here is Qiuly's blog!]]></title>
    <url>%2F2019%2F02%2F12%2FWelcome%2F</url>
    <content type="text"><![CDATA[预测未来的最好方法是创造未来 ——艾伦·凯 欢迎！这里是 $Qiuly’s\ blog$ ！在翻阅文章之前，$Qiuly$ 有几个小小的要求： 如果需要复制原文的话可以加 $Qiuly$ $QQ:2641450959$ ，请不要擅自复制却不跟 $Qiuly$ 说一声，谢谢理解。$Qiuly$ 目前还只是一个可爱的小学森，更博勤快的确不容易。 如果有图片挂了的，或者是代码缩进变成了 $8$ 的代码，还有就是格式问题爆炸的话(就是字之间突然有若干个空格之类的)也请加 $QQ$ ，$Qiuly’s \ blog$ 没有邮箱提醒的功能，所以如果只的是评论的话 $Qiuly$ 根本不知道。$QQ$ 的验证就填六年级好了，说明的话就填博客问题。 作为一个个人博客，当然欢迎加友链啦！想要加友链的朋友可以再下方评论区提出哦。 或许是使用的 $Latex$ 比较多，有些公式/ $Latex$ 的句子或许会加载的比较慢，需要等待片刻后再食用。 好啦，现在开始你的 $Qiuly’s \ blog$ 之旅吧！]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>公告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello new blog!]]></title>
    <url>%2F2019%2F02%2F12%2FHello%20new%20blog!%2F</url>
    <content type="text"><![CDATA[曾经尝试过用 $Wordpress$ 搭过博客，虽说操作简单，却因为我不想花钱而使用不了 $Makedown$ 格式，对于超级依赖 $Makedown$ 的我，找遍了方法都没法解决…… 于是蠢蠢欲动的想要用 $Hexo$ 搭个博客，虽然听学长说，$Hexo$ 只是静态页面，不是那么好。但是却可以免费，还可以用自己喜欢的编辑器学文章。这个计划就这么开始了。 两天时间，一共搭建了四次，前三次在机房搭的，均未成功。一到家用自己的笔记本电脑，却出奇的顺利，看到页面成功的弹出来时，我真的是激动得不能言语！ 然后，对这个也挺满意的。但是由于本人实在太弱，没有实力与精力去优化博客界面，只是草草的搞了一下 $LATEX$(打错了？) ，不知道能不能用。 之前我的 $Wordpress$ 的第一篇文章叫新的开始，现在看来那还不是，希望这才是一个崭新的开始吧！ （实际上原来叫 $Qiuly$，这个 $“monlights”$ 只是小号而已，$QvQ!$） （逃]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>公告</tag>
      </tags>
  </entry>
</search>
